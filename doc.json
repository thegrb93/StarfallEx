{"hooks":{"1":"EndEntityDriving","2":"EntityRemoved","3":"EntityTakeDamage","4":"GravGunOnDropped","5":"GravGunOnPickedUp","6":"GravGunPunt","7":"Initialize","8":"KeyPress","9":"KeyRelease","10":"OnEntityCreated","11":"OnPhysgunFreeze","12":"OnPhysgunReload","13":"PhysgunDrop","14":"PhysgunPickup","15":"PlayerCanPickupWeapon","16":"PlayerDeath","17":"PlayerDisconnected","18":"PlayerEnteredVehicle","19":"PlayerHurt","20":"PlayerLeaveVehicle","21":"PlayerNoClip","22":"PlayerSay","23":"PlayerSpawn","24":"PlayerSpray","25":"PlayerSwitchFlashlight","26":"PlayerSwitchWeapon","27":"PlayerUse","28":"PropBreak","29":"Removed","30":"StartEntityDriving","31":"input","32":"inputPressed","33":"inputReleased","34":"net","35":"readcell","36":"remote","37":"render","38":"starfallUsed","39":"think","40":"writecell","render":{"description":"\nCalled when a frame is requested to be drawn. You may want to unhook from this if you don't need \nto render anything for a bit","code":[""],"class":"hook","classForced":true,"name":"render","summary":"\nCalled when a frame is requested to be drawn.","client":true,"comment":["--- Called when a frame is requested to be drawn. You may want to unhook from this if you don't need","-- to render anything for a bit","-- @name render","-- @class hook","-- @client"],"param":[]},"PhysgunPickup":{"description":"\nCalled when an entity gets picked up by a physgun","code":[""],"class":"hook","classForced":true,"name":"PhysgunPickup","summary":"\nCalled when an entity gets picked up by a physgun ","server":true,"client":true,"comment":["--- Called when an entity gets picked up by a physgun","-- @name PhysgunPickup","-- @class hook","-- @shared","-- @param ply Player picking up the entity","-- @param ent Entity being picked up"],"param":{"1":"ply","2":"ent","ply":"Player picking up the entity","ent":"Entity being picked up"}},"GravGunOnPickedUp":{"description":"\nCalled when an entity is being picked up by a gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunOnPickedUp","summary":"\nCalled when an entity is being picked up by a gravity gun ","server":true,"comment":["--- Called when an entity is being picked up by a gravity gun","-- @name GravGunOnPickedUp","-- @class hook","-- @server","-- @param ply Player picking up an object","-- @param ent Entity being picked up"],"param":{"1":"ply","2":"ent","ply":"Player picking up an object","ent":"Entity being picked up"}},"PlayerCanPickupWeapon":{"description":"\nCalled when a wants to pick up a weapon","code":[""],"class":"hook","classForced":true,"name":"PlayerCanPickupWeapon","summary":"\nCalled when a wants to pick up a weapon ","server":true,"comment":["--- Called when a wants to pick up a weapon","-- @name PlayerCanPickupWeapon","-- @class hook","-- @server","-- @param ply Player","-- @param wep Weapon"],"param":{"1":"ply","2":"wep","ply":"Player","wep":"Weapon"}},"PlayerEnteredVehicle":{"description":"\nCalled when a players enters a vehicle","code":[""],"class":"hook","classForced":true,"name":"PlayerEnteredVehicle","summary":"\nCalled when a players enters a vehicle ","server":true,"comment":["--- Called when a players enters a vehicle","-- @name PlayerEnteredVehicle","-- @class hook","-- @server","-- @param ply Player who entered a vehicle","-- @param vehicle Vehicle that was entered","-- @param num Role"],"param":{"1":"ply","2":"vehicle","3":"num","vehicle":"Vehicle that was entered","ply":"Player who entered a vehicle","num":"Role"}},"PlayerSpray":{"description":"\nCalled when a players sprays his logo","code":[""],"class":"hook","classForced":true,"name":"PlayerSpray","summary":"\nCalled when a players sprays his logo ","server":true,"comment":["--- Called when a players sprays his logo","-- @name PlayerSpray","-- @class hook","-- @server","-- @param ply Player that sprayed"],"param":{"1":"ply","ply":"Player that sprayed"}},"KeyRelease":{"description":"\nCalled when a player releases a key","code":[""],"class":"hook","classForced":true,"name":"KeyRelease","summary":"\nCalled when a player releases a key ","server":true,"client":true,"comment":["--- Called when a player releases a key","-- @name KeyRelease","-- @class hook","-- @shared","-- @param ply Player releasing the key","-- @param key The key being released"],"param":{"1":"ply","2":"key","ply":"Player releasing the key","key":"The key being released"}},"KeyPress":{"description":"\nCalled when a player presses a key","code":[""],"class":"hook","classForced":true,"name":"KeyPress","summary":"\nCalled when a player presses a key ","server":true,"client":true,"comment":["--- Called when a player presses a key","-- @name KeyPress","-- @class hook","-- @shared","-- @param ply Player pressing the key","-- @param key The key being pressed"],"param":{"1":"ply","2":"key","ply":"Player pressing the key","key":"The key being pressed"}},"EntityTakeDamage":{"description":"\nCalled when an entity is damaged","code":[""],"class":"hook","classForced":true,"name":"EntityTakeDamage","summary":"\nCalled when an entity is damaged ","server":true,"comment":["--- Called when an entity is damaged","-- @name EntityTakeDamage","-- @class hook","-- @server","-- @param target Entity that is hurt","-- @param attacker Entity that attacked","-- @param inflictor Entity that inflicted the damage","-- @param amount How much damage","-- @param type Type of the damage","-- @param position Position of the damage","-- @param force Force of the damage"],"param":{"1":"target","2":"attacker","3":"inflictor","4":"amount","5":"type","6":"position","7":"force","inflictor":"Entity that inflicted the damage","position":"Position of the damage","amount":"How much damage","target":"Entity that is hurt","force":"Force of the damage","attacker":"Entity that attacked","type":"Type of the damage"}},"PlayerSpawn":{"description":"\nCalled when a player spawns","code":[""],"class":"hook","classForced":true,"name":"PlayerSpawn","summary":"\nCalled when a player spawns ","server":true,"comment":["--- Called when a player spawns","-- @name PlayerSpawn","-- @class hook","-- @server","-- @param player Player who spawned"],"param":{"1":"player","player":"Player who spawned"}},"OnPhysgunFreeze":{"description":"\nCalled when an entity is being frozen","code":[""],"class":"hook","classForced":true,"name":"OnPhysgunFreeze","summary":"\nCalled when an entity is being frozen ","server":true,"comment":["--- Called when an entity is being frozen","-- @name OnPhysgunFreeze","-- @class hook","-- @server","-- @param physgun Entity of the physgun","-- @param physobj PhysObj of the entity","-- @param ent Entity being frozen","-- @param ply Player freezing the entity"],"param":{"1":"physgun","2":"physobj","3":"ent","4":"ply","physobj":"PhysObj of the entity","ply":"Player freezing the entity","physgun":"Entity of the physgun","ent":"Entity being frozen"}},"remote":{"description":"\nRemote hook. \nThis hook can be called from other instances","code":[""],"class":"hook","classForced":true,"name":"remote","summary":"\nRemote hook.","server":true,"client":true,"comment":["--- Remote hook.","-- This hook can be called from other instances","-- @name remote","-- @class hook","-- @shared","-- @param sender The entity that caused the hook to run","-- @param owner The owner of the sender","-- @param ... The payload that was supplied when calling the hook"],"param":{"1":"sender","2":"owner","3":"...","sender":"The entity that caused the hook to run","...":"The payload that was supplied when calling the hook","owner":"The owner of the sender"}},"PlayerDisconnected":{"description":"\nCalled when a player disconnects","code":[""],"class":"hook","classForced":true,"name":"PlayerDisconnected","summary":"\nCalled when a player disconnects ","server":true,"comment":["--- Called when a player disconnects","-- @name PlayerDisconnected","-- @class hook","-- @server","-- @param ply Player that disconnected"],"param":{"1":"ply","ply":"Player that disconnected"}},"PlayerSwitchWeapon":{"description":"\nCalled when a player switches their weapon","code":[""],"class":"hook","classForced":true,"name":"PlayerSwitchWeapon","summary":"\nCalled when a player switches their weapon ","server":true,"client":true,"comment":["--- Called when a player switches their weapon","-- @name PlayerSwitchWeapon","-- @class hook","-- @shared","-- @param ply Player droppig the entity","-- @param oldwep Old weapon","-- @param newweapon New weapon"],"param":{"1":"ply","2":"oldwep","3":"newweapon","oldwep":"Old weapon","ply":"Player droppig the entity","newweapon":"New weapon"}},"PlayerLeaveVehicle":{"description":"\nCalled when a players leaves a vehicle","code":[""],"class":"hook","classForced":true,"name":"PlayerLeaveVehicle","summary":"\nCalled when a players leaves a vehicle ","server":true,"comment":["--- Called when a players leaves a vehicle","-- @name PlayerLeaveVehicle","-- @class hook","-- @server","-- @param ply Player who left a vehicle","-- @param vehicle Vehicle that was left"],"param":{"1":"ply","2":"vehicle","ply":"Player who left a vehicle","vehicle":"Vehicle that was left"}},"PlayerSwitchFlashlight":{"description":"\nCalled when a players turns their flashlight on or off","code":[""],"class":"hook","classForced":true,"name":"PlayerSwitchFlashlight","summary":"\nCalled when a players turns their flashlight on or off ","server":true,"comment":["--- Called when a players turns their flashlight on or off","-- @name PlayerSwitchFlashlight","-- @class hook","-- @server","-- @param ply Player switching flashlight","-- @param state New flashlight state. True if on."],"param":{"1":"ply","2":"state","ply":"Player switching flashlight","state":"New flashlight state. True if on."}},"PlayerUse":{"description":"\nCalled when a player holds their use key and looks at an entity. \nWill continuously run.","code":[""],"class":"hook","classForced":true,"name":"PlayerUse","summary":"\nCalled when a player holds their use key and looks at an entity.","param":{"1":"ply","2":"ent","ply":"Player using the entity","ent":"Entity being used"},"comment":["--- Called when a player holds their use key and looks at an entity.","-- Will continuously run.","-- @name PlayerUse","-- @server","-- @class hook","-- @param ply Player using the entity","-- @param ent Entity being used"],"server":true},"GravGunPunt":{"description":"\nCalled when a player punts with the gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunPunt","summary":"\nCalled when a player punts with the gravity gun ","server":true,"client":true,"comment":["--- Called when a player punts with the gravity gun","-- @name GravGunPunt","-- @class hook","-- @shared","-- @param ply Player punting the gravgun","-- @param ent Entity being punted"],"param":{"1":"ply","2":"ent","ply":"Player punting the gravgun","ent":"Entity being punted"}},"EndEntityDriving":{"description":"\nCalled when a player stops driving an entity","code":[""],"class":"hook","classForced":true,"name":"EndEntityDriving","summary":"\nCalled when a player stops driving an entity ","server":true,"client":true,"comment":["--- Called when a player stops driving an entity","-- @name EndEntityDriving","-- @class hook","-- @shared","-- @param ent Entity that had been driven","-- @param ply Player that drove the entity"],"param":{"1":"ent","2":"ply","ent":"Entity that had been driven","ply":"Player that drove the entity"}},"OnEntityCreated":{"description":"\nCalled when an entity gets created","code":[""],"class":"hook","classForced":true,"name":"OnEntityCreated","summary":"\nCalled when an entity gets created ","server":true,"client":true,"comment":["--- Called when an entity gets created","-- @name OnEntityCreated","-- @class hook","-- @shared","-- @param ent New entity"],"param":{"1":"ent","ent":"New entity"}},"GravGunOnDropped":{"description":"\nCalled when an entity is being dropped by a gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunOnDropped","summary":"\nCalled when an entity is being dropped by a gravity gun ","server":true,"comment":["--- Called when an entity is being dropped by a gravity gun","-- @name GravGunOnDropped","-- @class hook","-- @server","-- @param ply Player dropping the object","-- @param ent Entity being dropped"],"param":{"1":"ply","2":"ent","ply":"Player dropping the object","ent":"Entity being dropped"}},"PlayerHurt":{"description":"\nCalled when a player gets hurt","code":[""],"class":"hook","classForced":true,"name":"PlayerHurt","summary":"\nCalled when a player gets hurt ","server":true,"client":true,"comment":["--- Called when a player gets hurt","-- @name PlayerHurt","-- @class hook","-- @shared","-- @param ply Player being hurt","-- @param attacker Entity causing damage to the player","-- @param newHealth New health of the player","-- @param damageTaken Amount of damage the player has taken"],"param":{"1":"ply","2":"attacker","3":"newHealth","4":"damageTaken","damageTaken":"Amount of damage the player has taken","attacker":"Entity causing damage to the player","ply":"Player being hurt","newHealth":"New health of the player"}},"PropBreak":{"description":"\nCalled when an entity is broken","code":[""],"class":"hook","classForced":true,"name":"PropBreak","summary":"\nCalled when an entity is broken ","server":true,"client":true,"comment":["--- Called when an entity is broken","-- @name PropBreak","-- @class hook","-- @shared","-- @param ply Player who broke it","-- @param ent Entity broken"],"param":{"1":"ply","2":"ent","ply":"Player who broke it","ent":"Entity broken"}},"PlayerNoClip":{"description":"\nCalled when a player toggles noclip","code":[""],"class":"hook","classForced":true,"name":"PlayerNoClip","summary":"\nCalled when a player toggles noclip ","server":true,"client":true,"comment":["--- Called when a player toggles noclip","-- @name PlayerNoClip","-- @class hook","-- @shared","-- @param ply Player toggling noclip","-- @param newState New noclip state. True if on."],"param":{"1":"ply","2":"newState","ply":"Player toggling noclip","newState":"New noclip state. True if on."}},"writecell":{"classForced":true,"summary":"\nCalled when a high speed device writes to a wired SF chip ","comment":["--- Called when a high speed device writes to a wired SF chip","-- @name writecell","-- @class hook","-- @param address The address written to","-- @param data The data being written"],"code":[],"description":"\nCalled when a high speed device writes to a wired SF chip","class":"hook","name":"writecell","param":{"1":"address","2":"data","data":"The data being written","address":"The address written to"}},"readcell":{"ret":"The value read","description":"\nCalled when a high speed device reads from a wired SF chip","code":[""],"class":"hook","classForced":true,"name":"readcell","summary":"\nCalled when a high speed device reads from a wired SF chip ","server":true,"comment":["--- Called when a high speed device reads from a wired SF chip","-- @name readcell","-- @class hook","-- @server","-- @param address The address requested","-- @return The value read"],"param":{"1":"address","address":"The address requested"}},"EntityRemoved":{"description":"\nCalled when an entity is removed","code":[""],"class":"hook","classForced":true,"name":"EntityRemoved","summary":"\nCalled when an entity is removed ","server":true,"client":true,"comment":["--- Called when an entity is removed","-- @name EntityRemoved","-- @class hook","-- @shared","-- @param ent Entity being removed"],"param":{"1":"ent","ent":"Entity being removed"}},"net":{"classForced":true,"summary":"\nCalled when a net message arrives ","comment":["--- Called when a net message arrives","-- @name net","-- @class hook","-- @param name Name of the arriving net message","-- @param len Length of the arriving net message in bytes","-- @param ply On server, the player that sent the message. Nil on client."],"code":[],"description":"\nCalled when a net message arrives","class":"hook","name":"net","param":{"1":"name","2":"len","3":"ply","len":"Length of the arriving net message in bytes","name":"Name of the arriving net message","ply":"On server, the player that sent the message. Nil on client."}},"Initialize":{"description":"\nCalled after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","code":[],"class":"hook","classForced":true,"name":"Initialize","summary":"\nCalled after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","server":true,"comment":["--- Called after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","-- @name Initialize","-- @class hook","-- @server"],"param":[]},"Removed":{"description":"\nCalled when the starfall chip is removed","code":[""],"class":"hook","classForced":true,"name":"Removed","summary":"\nCalled when the starfall chip is removed ","server":true,"comment":["--- Called when the starfall chip is removed","-- @name Removed","-- @class hook","-- @server"],"param":[]},"think":{"description":"\nThink hook. Called each game tick","code":[""],"class":"hook","classForced":true,"name":"think","summary":"\nThink hook.","server":true,"client":true,"comment":["--- Think hook. Called each game tick","-- @name think","-- @class hook","-- @shared"],"param":[]},"StartEntityDriving":{"description":"\nCalled when a player starts driving an entity","code":[""],"class":"hook","classForced":true,"name":"StartEntityDriving","summary":"\nCalled when a player starts driving an entity ","server":true,"client":true,"comment":["--- Called when a player starts driving an entity","-- @name StartEntityDriving","-- @class hook","-- @shared","-- @param ent Entity being driven","-- @param ply Player that is driving the entity"],"param":{"1":"ent","2":"ply","ent":"Entity being driven","ply":"Player that is driving the entity"}},"PlayerSay":{"ret":"New text. \"\" to stop from displaying. Nil to keep original.","description":"\nCalled when a player sends a chat message","code":[""],"class":"hook","classForced":true,"name":"PlayerSay","summary":"\nCalled when a player sends a chat message ","server":true,"comment":["--- Called when a player sends a chat message","-- @name PlayerSay","-- @class hook","-- @server","-- @param ply Player that sent the message","-- @param text Content of the message","-- @param teamChat True if team chat","-- @return New text. \"\" to stop from displaying. Nil to keep original."],"param":{"1":"ply","2":"text","3":"teamChat","text":"Content of the message","ply":"Player that sent the message","teamChat":"True if team chat"}},"inputReleased":{"classForced":true,"summary":"\nCalled when a button is released ","comment":["--- Called when a button is released","-- @name inputReleased","-- @class hook","-- @param name Name of the key"],"code":[""],"description":"\nCalled when a button is released","class":"hook","name":"inputReleased","param":{"1":"name","name":"Name of the key"}},"inputPressed":{"classForced":true,"summary":"\nCalled when a button is pressed ","comment":["--- Called when a button is pressed","-- @name inputPressed","-- @class hook","-- @param name Name of the key"],"code":[""],"description":"\nCalled when a button is pressed","class":"hook","name":"inputPressed","param":{"1":"name","name":"Name of the key"}},"PhysgunDrop":{"description":"\nCalled when an entity being held by a physgun gets dropped","code":[""],"class":"hook","classForced":true,"name":"PhysgunDrop","summary":"\nCalled when an entity being held by a physgun gets dropped ","server":true,"client":true,"comment":["--- Called when an entity being held by a physgun gets dropped","-- @name PhysgunDrop","-- @class hook","-- @shared","-- @param ply Player droppig the entity","-- @param ent Entity being dropped"],"param":{"1":"ply","2":"ent","ply":"Player droppig the entity","ent":"Entity being dropped"}},"input":{"classForced":true,"summary":"\nCalled when an input on a wired SF chip is written to ","comment":["--- Called when an input on a wired SF chip is written to","-- @name input","-- @class hook","-- @param input The input name","-- @param value The value of the input"],"code":[""],"description":"\nCalled when an input on a wired SF chip is written to","class":"hook","name":"input","param":{"1":"input","2":"value","input":"The input name","value":"The value of the input"}},"starfallUsed":{"classForced":true,"summary":"\nCalled when a player uses the screen ","comment":["--- Called when a player uses the screen","-- @name starfallUsed","-- @class hook","-- @param activator Player using the screen"],"code":[""],"description":"\nCalled when a player uses the screen","class":"hook","name":"starfallUsed","param":{"1":"activator","activator":"Player using the screen"}},"PlayerDeath":{"description":"\nCalled when a player dies","code":[""],"class":"hook","classForced":true,"name":"PlayerDeath","summary":"\nCalled when a player dies ","server":true,"comment":["--- Called when a player dies","-- @name PlayerDeath","-- @class hook","-- @server","-- @param ply Player who died","-- @param inflictor Entity used to kill the player","-- @param attacker Entity that killed the player"],"param":{"1":"ply","2":"inflictor","3":"attacker","inflictor":"Entity used to kill the player","ply":"Player who died","attacker":"Entity that killed the player"}},"OnPhysgunReload":{"description":"\nCalled when a player reloads his physgun","code":[""],"class":"hook","classForced":true,"name":"OnPhysgunReload","summary":"\nCalled when a player reloads his physgun ","server":true,"comment":["--- Called when a player reloads his physgun","-- @name OnPhysgunReload","-- @class hook","-- @server","-- @param physgun Entity of the physgun","-- @param ply Player reloading the physgun"],"param":{"1":"physgun","2":"ply","physgun":"Entity of the physgun","ply":"Player reloading the physgun"}}},"libraries":{"1":"bass","2":"bit","3":"builtin","4":"constraint","5":"coroutine","6":"entities","7":"fastlz","8":"file","9":"find","10":"game","11":"globaltables","12":"holograms","13":"hook","14":"http","15":"input","16":"joystick","17":"json","18":"net","19":"physenv","20":"prop","21":"quaternion","22":"render","23":"sounds","24":"timer","25":"trace","26":"von","27":"wire","render":{"comment":["--- Render library. Screens are 512x512 units. Most functions require","-- that you be in the rendering hook to call, otherwise an error is","-- thrown. +x is right, +y is down","-- @entity starfall_screen","-- @field TEXT_ALIGN_LEFT","-- @field TEXT_ALIGN_CENTER","-- @field TEXT_ALIGN_RIGHT","-- @field TEXT_ALIGN_TOP","-- @field TEXT_ALIGN_BOTTOM"],"functions":{"1":"capturePixels","2":"clear","3":"createFont","4":"createPoly","5":"createRenderTarget","6":"cursorPos","7":"drawCircle","8":"drawLine","9":"drawPoly","10":"drawRect","11":"drawRectOutline","12":"drawText","13":"drawTexturedRect","14":"drawTexturedRectRotated","15":"drawTexturedRectUV","16":"getDefaultFont","17":"getScreenInfo","18":"getScreenPos","19":"getTextSize","20":"getTextureID","21":"popMatrix","22":"pushMatrix","23":"readPixel","24":"selectRenderTarget","25":"setColor","26":"setFont","27":"setRenderTargetTexture","28":"setTexture","drawTexturedRectUV":{"comment":["--- Draws a textured rectangle with UV coordinates","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param startU Texture mapping at rectangle origin","-- @param startV Texture mapping at rectangle origin","-- @param endV Texture mapping at rectangle end","-- @param endV Texture mapping at rectangle end"],"code":["function render_library.drawTexturedRectUV ( x, y, w, h, startU, startV, endU, endV )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( startU, \"number\" )","\tSF.CheckType( startV, \"number\" )","\tSF.CheckType( endU, \"number\" )","\tSF.CheckType( endV, \"number\" )","\tsurface.DrawTexturedRectUV( x, y, w, h, startU, startV, endU, endV )","end",""],"class":"function","name":"render_library.drawTexturedRectUV","summary":"\nDraws a textured rectangle with UV coordinates ","private":false,"library":"render","description":"\nDraws a textured rectangle with UV coordinates","param":{"1":"x","2":"y","3":"w","4":"h","5":"startU","6":"startV","7":"endU","8":"endV","y":"Top left corner y coordinate","h":"Height","endV":"Texture mapping at rectangle end","startU":"Texture mapping at rectangle origin","startV":"Texture mapping at rectangle origin","w":"Width","x":"Top left corner x coordinate"}},"drawTexturedRect":{"comment":["--- Draws a textured rectangle.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawTexturedRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawTexturedRect ( x, y, w, h )","end",""],"class":"function","name":"render_library.drawTexturedRect","summary":"\nDraws a textured rectangle.","private":false,"library":"render","description":"\nDraws a textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"drawRect":{"comment":["--- Draws a rectangle using the current color. ","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRect","summary":"\nDraws a rectangle using the current color.","private":false,"library":"render","description":"\nDraws a rectangle using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"drawCircle":{"comment":["--- Draws a circle outline","-- @param x Center x coordinate","-- @param y Center y coordinate","-- @param r Radius"],"code":["function render_library.drawCircle ( x, y, r )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( r, \"number\" )","\tsurface.DrawCircle( x, y, r, currentcolor )","end",""],"class":"function","name":"render_library.drawCircle","summary":"\nDraws a circle outline ","private":false,"library":"render","description":"\nDraws a circle outline","param":{"1":"x","2":"y","3":"r","y":"Center y coordinate","x":"Center x coordinate","r":"Radius"}},"readPixel":{"ret":"Color object with ( r, g, b, 255 ) from the specified pixel.","comment":["--- Reads the color of the specified pixel.","-- @param x Pixel x-coordinate.","-- @param y Pixel y-coordinate.","-- @return Color object with ( r, g, b, 255 ) from the specified pixel."],"code":["function render_library.readPixel ( x, y )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\t","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","","\tlocal r, g, b = render.ReadPixel( x, y )","\treturn SF.Color.Wrap( Color( r, g, b, 255 ) )","end",""],"class":"function","name":"render_library.readPixel","summary":"\nReads the color of the specified pixel.","private":false,"library":"render","description":"\nReads the color of the specified pixel.","param":{"1":"x","2":"y","y":"Pixel y-coordinate.","x":"Pixel x-coordinate."}},"pushMatrix":{"comment":["--- Pushes a matrix onto the matrix stack.","-- @param m The matrix"],"code":["function render_library.pushMatrix(m)","\tSF.CheckType(m,matrix_meta)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tlocal id = #matrix_stack","\tif id + 1 > MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tlocal newmatrix","\tif matrix_stack[id] then","\t\tnewmatrix = matrix_stack[id] * v_unwrap(m)","\telse","\t\tnewmatrix = v_unwrap(m)","\tend","\tmatrix_stack[id+1] = newmatrix","\tcam.PushModelMatrix(newmatrix)","end",""],"class":"function","name":"render_library.pushMatrix","summary":"\nPushes a matrix onto the matrix stack.","private":false,"library":"render","description":"\nPushes a matrix onto the matrix stack.","param":{"1":"m","m":"The matrix"}},"getScreenPos":{"ret":["The screen position","The screen angle"],"comment":["--- Returns the screen surface's world position and angle","-- @return The screen position","-- @return The screen angle"],"code":["function render_library.getScreenPos()","\tlocal gpu = SF.instance.data.render.gpu","\tif not gpu then return end","\tlocal _, pos, rot = gpu:GetInfo()","\treturn SF.WrapObject( pos ), SF.WrapObject( rot )","end","","local function findAvailableRT ()","\tfor k, v in pairs( globalRTs ) do","\t\tif v[ 2 ] then","\t\t\treturn k, v","\t\tend","\tend","\treturn nil","end",""],"class":"function","name":"render_library.getScreenPos","summary":"\nReturns the screen surface's world position and angle ","private":false,"library":"render","description":"\nReturns the screen surface's world position and angle","param":[]},"createFont":{"comment":["--- Creates a font. Does not require rendering hook","-- @param font Base font to use","-- @param size Font size","-- @param weight Font weight (default: 400)","-- @param antialias Antialias font?","-- @param additive If true, adds brightness to pixels behind it rather than drawing over them.","-- @param shadow Enable drop shadow?","-- @param outline Enable outline?","-- @param blue Enable blur?","-- @usage","-- Base font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall):","-- \\- DebugFixed","-- \\- DebugFixedSmall","-- \\- DefaultFixedOutline","-- \\- MenuItem","-- \\- Default","-- \\- TabLarge","-- \\- DefaultBold","-- \\- DefaultUnderline","-- \\- DefaultSmall","-- \\- DefaultSmallDropShadow","-- \\- DefaultVerySmall","-- \\- DefaultLarge","-- \\- UiBold","-- \\- MenuLarge","-- \\- ConsoleText","-- \\- Marlett","-- \\- Trebuchet18","-- \\- Trebuchet19","-- \\- Trebuchet20","-- \\- Trebuchet22","-- \\- Trebuchet24","-- \\- HUDNumber","-- \\- HUDNumber1","-- \\- HUDNumber2","-- \\- HUDNumber3","-- \\- HUDNumber4","-- \\- HUDNumber5","-- \\- HudHintTextLarge","-- \\- HudHintTextSmall","-- \\- CenterPrintText","-- \\- HudSelectionText","-- \\- DefaultFixed","-- \\- DefaultFixedDropShadow","-- \\- CloseCaption_Normal","-- \\- CloseCaption_Bold","-- \\- CloseCaption_BoldItalic","-- \\- TitleFont","-- \\- TitleFont2","-- \\- ChatFont","-- \\- TargetID","-- \\- TargetIDSmall","-- \\- HL2MPTypeDeath","-- \\- BudgetLabel","-- \\- DejaVu Sans Mono (shipped, monospaced)"],"code":["function render_library.createFont(font,size,weight,antialias,additive,shadow,outline,blur)","\tif not validfonts[font] then SF.throw( \"invalid font\", 2 ) end","\t","\tsize = tonumber(size) or 16","\tweight = tonumber(weight) or 400","\tblur = tonumber(blur) or 0","\tantialias = antialias and true or false","\tadditive = additive and true or false","\tshadow = shadow and true or false","\toutline = outline and true or false","\t","\tlocal name = string.format(\"sf_screen_font_%s_%d_%d_%d_%d%d%d%d\",","\t\tfont, size, weight, blur,","\t\tantialias and 1 or 0,","\t\tadditive and 1 or 0,","\t\tshadow and 1 or 0,","\t\toutline and 1 or 0)","\t","\tif not defined_fonts[name] then","\t\tsurface.CreateFont(name, {size = size, weight = weight,","\t\t\tantialias=antialias, additive = additive, font = font,","\t\t\tshadow = shadow, outline = outline, blur = blur})","\t\tdefined_fonts[name] = true","\tend","\treturn name","end",""],"class":"function","summary":"\nCreates a font.","name":"render_library.createFont","library":"render","private":false,"usage":"\nBase font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall): \n- DebugFixed \n- DebugFixedSmall \n- DefaultFixedOutline \n- MenuItem \n- Default \n- TabLarge \n- DefaultBold \n- DefaultUnderline \n- DefaultSmall \n- DefaultSmallDropShadow \n- DefaultVerySmall \n- DefaultLarge \n- UiBold \n- MenuLarge \n- ConsoleText \n- Marlett \n- Trebuchet18 \n- Trebuchet19 \n- Trebuchet20 \n- Trebuchet22 \n- Trebuchet24 \n- HUDNumber \n- HUDNumber1 \n- HUDNumber2 \n- HUDNumber3 \n- HUDNumber4 \n- HUDNumber5 \n- HudHintTextLarge \n- HudHintTextSmall \n- CenterPrintText \n- HudSelectionText \n- DefaultFixed \n- DefaultFixedDropShadow \n- CloseCaption_Normal \n- CloseCaption_Bold \n- CloseCaption_BoldItalic \n- TitleFont \n- TitleFont2 \n- ChatFont \n- TargetID \n- TargetIDSmall \n- HL2MPTypeDeath \n- BudgetLabel \n- DejaVu Sans Mono (shipped, monospaced)","description":"\nCreates a font. Does not require rendering hook","param":{"1":"font","2":"size","3":"weight","4":"antialias","5":"additive","6":"shadow","7":"outline","8":"blur","9":"blue","outline":"Enable outline?","shadow":"Enable drop shadow?","blue":"Enable blur?","weight":"Font weight (default: 400)","font":"Base font to use","additive":"If true, adds brightness to pixels behind it rather than drawing over them.","antialias":"Antialias font?","size":"Font size"}},"selectRenderTarget":{"comment":["--- Selects the render target to draw on.","-- Nil for the visible RT.","-- @param name Name of the render target to use"],"code":["function render_library.selectRenderTarget ( name )","\tlocal data = SF.instance.data.render","\tdata.oldRT = data.oldRT or render.GetRenderTarget()","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif not name then","\t\tif data.usingRT then","\t\t\tcam.End2D()","\t\t\trender.PopRenderTarget()","\t\t\tcam.Start2D()","\t\t\tdata.usingRT = false","\t\tend","\t\treturn","\tend","\tSF.CheckType( name, \"string\" )","\tlocal rt = globalRTs[ data.rendertargets[ name ] ][ 1 ]","\tif not rt then SF.Throw( \"Invalid Rendertarget\", 2 ) end","","\tcam.End2D()","\tif data.usingRT then","\t\trender.PopRenderTarget()","\tend","\trender.PushRenderTarget( rt, 0, 0, rt:Width(), rt:Height() )","\tcam.Start2D()","\tdata.usingRT = true","end",""],"class":"function","name":"render_library.selectRenderTarget","summary":"\nSelects the render target to draw on.","private":false,"library":"render","description":"\nSelects the render target to draw on. \nNil for the visible RT.","param":{"1":"name","name":"Name of the render target to use"}},"createRenderTarget":{"comment":["--- Creates a new render target to draw onto.","-- The dimensions will always be 1024x1024","-- @param name The name of the render target","-- @bug The drawing will be offset by 16 pixels to the left and 16 to the top and the resolution is actually 992x992. So drawing to 16,16 will draw in the top-left corner and 1007,1007 to the bottom-right."],"code":["function render_library.createRenderTarget ( name )","\tSF.CheckType( name, \"string\" )","","\tlocal data = SF.instance.data.render","\tdata.rendertargets = data.rendertargets or {}","\tdata.rendertargetcount = data.rendertargetcount or 0","","\tif data.rendertargetcount >= 2 then","\t\tSF.throw( \"Rendertarget limit reached\", 2 )","\tend","","\tdata.rendertargetcount = data.rendertargetcount + 1","\tlocal rtname, rt = findAvailableRT()","\tif not rt then","\t\tglobalRTcount = globalRTcount + 1","\t\trtname = \"Starfall_CustomRT_\" .. globalRTcount","\t\trt = { GetRenderTarget( rtname, 1024, 1024, false ) }","\t\tglobalRTs[ rtname ] = rt","\tend","\trt[ 2 ] = false","\tdata.rendertargets[ name ] = rtname","end",""],"class":"function","bug":"The drawing will be offset by 16 pixels to the left and 16 to the top and the resolution is actually 992x992. So drawing to 16,16 will draw in the top-left corner and 1007,1007 to the bottom-right.","name":"render_library.createRenderTarget","summary":"\nCreates a new render target to draw onto.","private":false,"library":"render","description":"\nCreates a new render target to draw onto. \nThe dimensions will always be 1024x1024","param":{"1":"name","name":"The name of the render target"}},"capturePixels":{"comment":["--- Dumps the current render target and allows the pixels to be accessed by render.readPixel."],"code":["function render_library.capturePixels ()","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\trender.CapturePixels()","end",""],"class":"function","name":"render_library.capturePixels","summary":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","private":false,"library":"render","description":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","param":[]},"setRenderTargetTexture":{"comment":["--- Sets the active texture to the render target with the specified name.","-- Nil to reset.","-- @param name Name of the render target to use"],"code":["function render_library.setRenderTargetTexture ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif not name then","\t\tdraw.NoTexture()","\telse","\t\tSF.CheckType( name, \"string\" )","\t\tlocal rtname = data.rendertargets[ name ]","\t\tlocal rt = globalRTs[ rtname ][ 1 ]","\t\tlocal mat = globalRTs[ rtname ][ 2 ] or CreateMaterial( rtname, \"UnlitGeneric\", {","\t\t\t[ \"$nolod\" ] = 1,","\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t[ \"$vertexalpha\" ] = 1","\t\t} )","\t\tmat:SetTexture( \"$basetexture\", rt )","\t\tsurface.SetMaterial( mat )","\tend","end",""],"class":"function","name":"render_library.setRenderTargetTexture","summary":"\nSets the active texture to the render target with the specified name.","private":false,"library":"render","description":"\nSets the active texture to the render target with the specified name. \nNil to reset.","param":{"1":"name","name":"Name of the render target to use"}},"clear":{"comment":["--- Clears the surface","-- @param clr Color type to clear with"],"code":["function render_library.clear ( clr )","    if clr == nil then","        if not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","        render.Clear( 0, 0, 0, 255 )","    else","        SF.CheckType( clr, SF.Types[ \"Color\" ] )","        if not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","        render.Clear( clr.r, clr.g, clr.b, clr.a )","    end","end",""],"class":"function","name":"render_library.clear","summary":"\nClears the surface ","private":false,"library":"render","description":"\nClears the surface","param":{"1":"clr","clr":"Color type to clear with"}},"getScreenInfo":{"ret":"A table describing the screen.","comment":["--- Returns information about the screen, such as dimentions and rotation.","-- Note: this does a table copy so move it out of your draw hook","-- @return A table describing the screen."],"code":["function render_library.getScreenInfo()","\tlocal gpu = SF.instance.data.render.gpu","\tif not gpu then return end","\tlocal info, _, _ = gpu:GetInfo()","\treturn table.Copy(info)","end",""],"class":"function","name":"render_library.getScreenInfo","summary":"\nReturns information about the screen, such as dimentions and rotation.","private":false,"library":"render","description":"\nReturns information about the screen, such as dimentions and rotation. \nNote: this does a table copy so move it out of your draw hook","param":[]},"drawLine":{"comment":["--- Draws a line","-- @param x1 X start coordinate","-- @param y1 Y start coordinate","-- @param x2 X end coordinate","-- @param y2 Y end coordinate"],"code":["function render_library.drawLine ( x1, y1, x2, y2 )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x1, \"number\" )","\tSF.CheckType( y1, \"number\" )","\tSF.CheckType( x2, \"number\" )","\tSF.CheckType( y2, \"number\" )","\tsurface.DrawLine( x1, y1, x2, y2 )","end",""],"class":"function","name":"render_library.drawLine","summary":"\nDraws a line ","private":false,"library":"render","description":"\nDraws a line","param":{"1":"x1","2":"y1","3":"x2","4":"y2","x2":"X end coordinate","y2":"Y end coordinate","y1":"Y start coordinate","x1":"X start coordinate"}},"getTextureID":{"comment":["--- Looks up a texture by file name. Use with render.setTexture to draw with it.","--- Make sure to store the texture to use it rather than calling this slow function repeatedly.","-- @param tx Texture file path, or a http url"],"code":["function render_library.getTextureID ( tx )","","\tif tx:sub(1,4)==\"http\" then","\t\ttx = string.gsub( tx, \"[^%w _~%.%-/:]\", function( str )","\t\t\treturn string.format( \"%%%02X\", string.byte( str ) )","\t\tend )","\t\t","\t\tlocal tbl = {}","\t\ttexturecache[ tbl ] = LoadURLMaterial( tx )","\t\treturn tbl","\telse","\t\tlocal id = surface.GetTextureID( tx )","\t\tif id then","\t\t\tlocal mat = Material( tx ) -- Hacky way to get ITexture, if there is a better way - do it!","\t\t\tlocal cacheentry = CreateMaterial( \"SF_TEXTURE_\" .. id, \"UnlitGeneric\", {","\t\t\t\t[ \"$nolod\" ] = 1,","\t\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t\t[ \"$vertexalpha\" ] = 1","\t\t\t} )","\t\t\tcacheentry:SetTexture( \"$basetexture\", mat:GetTexture( \"$basetexture\" ) )","\t\t\t","\t\t\tlocal tbl = {}","\t\t\ttexturecache[ tbl ] = cacheentry","\t\t\treturn tbl","\t\tend","\tend","\t","end",""],"class":"function","name":"render_library.getTextureID","summary":"\nLooks up a texture by file name.","private":false,"library":"render","description":"\nLooks up a texture by file name. Use with render.setTexture to draw with it. \nMake sure to store the texture to use it rather than calling this slow function repeatedly.","param":{"1":"tx","tx":"Texture file path, or a http url"}},"cursorPos":{"ret":["x position","y position"],"comment":["--- Gets a 2D cursor position where ply is aiming.","-- @param ply player to get cursor position from","-- @return x position","-- @return y position"],"code":["function render_library.cursorPos( ply )","\t-- Taken from EGPLib","\tlocal Normal, Pos, monitor, Ang","\tlocal screen = SF.instance.data.render.renderEnt","\tif not screen then return nil end","\t","\tply = SF.Entities.Unwrap( ply )","\tif not ply then SF.throw(\"Invalid Player\", 2) end","\t","\t-- Get monitor screen pos & size","\tmonitor = WireGPU_Monitors[ screen:GetModel() ]","\t\t","\t-- Monitor does not have a valid screen point","\tif not monitor then return nil end","\t\t","\tAng = screen:LocalToWorldAngles( monitor.rot )","\tPos = screen:LocalToWorld( monitor.offset )","\t\t","\tNormal = Ang:Up()","\t","\tlocal Start = ply:GetShootPos()","\tlocal Dir = ply:GetAimVector()","\t","\tlocal A = Normal:Dot(Dir)","\t","\t-- If ray is parallel or behind the screen","\tif A == 0 or A > 0 then return nil end","\t","\tlocal B = Normal:Dot(Pos-Start) / A","\t\tif (B >= 0) then","\t\tlocal HitPos = WorldToLocal( Start + Dir * B, Angle(), Pos, Ang )","\t\tlocal x = (0.5+HitPos.x/(monitor.RS*512/monitor.RatioX)) * 512","\t\tlocal y = (0.5-HitPos.y/(monitor.RS*512)) * 512\t","\t\tif x < 0 or x > 512 or y < 0 or y > 512 then return nil end -- Aiming off the screen ","\t\treturn x, y","\tend","\t","\treturn nil","end",""],"class":"function","name":"render_library.cursorPos","summary":"\nGets a 2D cursor position where ply is aiming.","private":false,"library":"render","description":"\nGets a 2D cursor position where ply is aiming.","param":{"1":"ply","ply":"player to get cursor position from"}},"setFont":{"comment":["--- Sets the font","-- @param font The font to use"],"code":["function render_library.setFont(font)","\tif not defined_fonts[font] then SF.throw( \"Font does not exist.\", 2 ) end","\tSF.instance.data.render.font = font","\t--surface.SetFont(font)","end",""],"class":"function","name":"render_library.setFont","summary":"\nSets the font ","private":false,"library":"render","description":"\nSets the font","param":{"1":"font","font":"The font to use"}},"drawPoly":{"comment":["--- Draws a polygon. Takes a compiled/uncompiled poly to draw.","-- Note that if you do use an uncompiled poly, you will use up ops","-- very quickly!","-- @param poly Compiled poly or array of vertexes"],"code":["function render_library.drawPoly(poly)","\tif dgetmeta(poly) ~= poly_metamethods then","\t\tSF.CheckType(poly,\"table\")","\t\tlocal verts = poly","\t\tpoly = {}","\t\tfor i=1,#verts do","\t\t\tlocal v = verts[i]","\t\t\tSF.CheckType(v,\"table\")","\t\t\tpoly[i] = checkvertex(v)","\t\tend","\telse","\t\tpoly = unwrappoly(poly)","\tend","\tsurface.DrawPoly(poly)","end",""],"class":"function","name":"render_library.drawPoly","summary":"\nDraws a polygon.","private":false,"library":"render","description":"\nDraws a polygon. Takes a compiled/uncompiled poly to draw. \nNote that if you do use an uncompiled poly, you will use up ops \nvery quickly!","param":{"1":"poly","poly":"Compiled poly or array of vertexes"}},"drawTexturedRectRotated":{"comment":["--- Draws a rotated, textured rectangle.","-- @param x X coordinate of center of rect","-- @param y Y coordinate of center of rect","-- @param w Width","-- @param h Height","-- @param rot Rotation in degrees"],"code":["function render_library.drawTexturedRectRotated ( x, y, w, h, rot )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( rot, \"number\" )","","\tsurface.DrawTexturedRectRotated( x, y, w, h, rot )","end",""],"class":"function","name":"render_library.drawTexturedRectRotated","summary":"\nDraws a rotated, textured rectangle.","private":false,"library":"render","description":"\nDraws a rotated, textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","5":"rot","y":"Y coordinate of center of rect","h":"Height","rot":"Rotation in degrees","w":"Width","x":"X coordinate of center of rect"}},"createPoly":{"ret":"compiled polygon","comment":["--- Compiles a 2D poly. This is needed so that poly don't have to be","-- type-checked each frame. Polys can be indexed by a number, in which","-- a copy of the vertex at that spot is returned. They can also be assigned","-- a new vertex at 1 <= i <= #poly+1. And the length of the poly can be taken.","-- @param verts Array of verticies to convert.","-- @return compiled polygon"],"code":["function render_library.createPoly(verts)","\tSF.CheckType(verts,\"table\")","\tlocal poly = {}","\tlocal wrappedpoly = wrappoly(poly)","\tfor i=1,#verts do","\t\tlocal v = verts[i]","\t\tSF.CheckType(v,\"table\")","\t\tpoly[i] = checkvertex(v)","\tend","\treturn wrappedpoly","end",""],"class":"function","name":"render_library.createPoly","summary":"\nCompiles a 2D poly.","private":false,"library":"render","description":"\nCompiles a 2D poly. This is needed so that poly don't have to be \ntype-checked each frame. Polys can be indexed by a number, in which \na copy of the vertex at that spot is returned. They can also be assigned \na new vertex at 1 <= i <= #poly+1. And the length of the poly can be taken.","param":{"1":"verts","verts":"Array of verticies to convert."}},"drawRectOutline":{"comment":["--- Draws a rectangle outline using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRectOutline ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawOutlinedRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRectOutline","summary":"\nDraws a rectangle outline using the current color.","private":false,"library":"render","description":"\nDraws a rectangle outline using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"getTextSize":{"ret":["width of the text","height of the text"],"comment":["--- Gets the size of the specified text. Don't forget to use setFont before calling this function","-- @param text Text to get the size of","-- @return width of the text","-- @return height of the text"],"code":["function render_library.getTextSize( text )","\tSF.CheckType(text,\"string\")","\t","\tsurface.SetFont(SF.instance.data.render.font or defaultFont)","\treturn surface.GetTextSize( text )","end",""],"class":"function","name":"render_library.getTextSize","summary":"\nGets the size of the specified text.","private":false,"library":"render","description":"\nGets the size of the specified text. Don't forget to use setFont before calling this function","param":{"1":"text","text":"Text to get the size of"}},"getDefaultFont":{"ret":"Default font","comment":["--- Gets the default font","-- @return Default font"],"code":["function render_library.getDefaultFont()","\treturn defaultFont","end",""],"class":"function","name":"render_library.getDefaultFont","summary":"\nGets the default font ","private":false,"library":"render","description":"\nGets the default font","param":[]},"popMatrix":{"comment":["--- Pops a matrix from the matrix stack."],"code":["function render_library.popMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif #matrix_stack <= 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tmatrix_stack[#matrix_stack] = nil","\tcam.PopModelMatrix()","end",""],"class":"function","name":"render_library.popMatrix","summary":"\nPops a matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a matrix from the matrix stack.","param":[]},"setTexture":{"comment":["--- Sets the texture","-- @param id Texture id or url to an online image."],"code":["function render_library.setTexture ( id )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif id and texturecache[ id ] then","\t\tsurface.SetMaterial( texturecache[ id ] )","\t\treturn","\tend","","\tdraw.NoTexture()","end",""],"class":"function","name":"render_library.setTexture","summary":"\nSets the texture ","private":false,"library":"render","description":"\nSets the texture","param":{"1":"id","id":"Texture id or url to an online image."}},"drawText":{"comment":["--- Draws text.","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param alignment Text alignment"],"code":["function render_library.drawText ( x, y, text, alignment )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif alignment then","\t\tSF.CheckType( alignment, \"number\" )","\tend","\t","\tlocal font = SF.instance.data.render.font or defaultFont","\t","\tdraw.DrawText( text, font, x, y, currentcolor, alignment or TEXT_ALIGN_LEFT )","end",""],"class":"function","name":"render_library.drawText","summary":"\nDraws text.","private":false,"library":"render","description":"\nDraws text.","param":{"1":"x","2":"y","3":"text","4":"alignment","y":"Y coordinate","x":"X coordinate","alignment":"Text alignment","text":"Text to draw"}},"setColor":{"comment":["--- Sets the draw color","-- @param clr Color type"],"code":["function render_library.setColor ( clr )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\tcurrentcolor = clr","\tsurface.SetDrawColor( clr )","\tsurface.SetTextColor( clr )","end",""],"class":"function","name":"render_library.setColor","summary":"\nSets the draw color ","private":false,"library":"render","description":"\nSets the draw color","param":{"1":"clr","clr":"Color type"}}},"class":"library","summary":"\nRender library.","code":["","local render_library, _ = SF.Libraries.RegisterLocal(\"render\")","","render_library.TEXT_ALIGN_LEFT = TEXT_ALIGN_LEFT","render_library.TEXT_ALIGN_CENTER = TEXT_ALIGN_CENTER","render_library.TEXT_ALIGN_RIGHT = TEXT_ALIGN_RIGHT","render_library.TEXT_ALIGN_TOP = TEXT_ALIGN_TOP","render_library.TEXT_ALIGN_BOTTOM = TEXT_ALIGN_BOTTOM",""],"fields":[],"name":"render","description":"\nRender library. Screens are 512x512 units. Most functions require \nthat you be in the rendering hook to call, otherwise an error is \nthrown. +x is right, +y is down","entity":"starfall_screen","libtbl":"render_library","tables":[],"field":{"1":"TEXT_ALIGN_LEFT","2":"TEXT_ALIGN_CENTER","3":"TEXT_ALIGN_RIGHT","4":"TEXT_ALIGN_TOP","5":"TEXT_ALIGN_BOTTOM","TEXT_ALIGN_CENTER":"","TEXT_ALIGN_TOP":"","TEXT_ALIGN_BOTTOM":"","TEXT_ALIGN_LEFT":"","TEXT_ALIGN_RIGHT":""}},"quaternion":{"comment":["--- Quaternion library","-- @shared"],"functions":{"1":"New","2":"abs","3":"conj","4":"exp","5":"inv","6":"log","7":"qMod","8":"qRotation","9":"qRotation","10":"qi","11":"qj","12":"qk","13":"rotationAngle","14":"rotationAxis","15":"rotationEulerAngle","16":"rotationVector","17":"slerp","18":"vec","conj":{"comment":["--- Returns the conjugate of <q>"],"code":["function quat_lib.conj(q)","\treturn quicknew(q[1], -q[2], -q[3], -q[4])","end",""],"class":"function","name":"quat_lib.conj","summary":"\nReturns the conjugate of <q> ","private":false,"library":"quaternion","description":"\nReturns the conjugate of <q>","param":["q"]},"log":{"comment":["--- Calculates natural logarithm of <q>"],"code":["function quat_lib.log(q)","\treturn qlog(q)","end",""],"class":"function","name":"quat_lib.log","summary":"\nCalculates natural logarithm of <q> ","private":false,"library":"quaternion","description":"\nCalculates natural logarithm of <q>","param":["q"]},"exp":{"comment":["--- Raises Euler's constant e to the power <q>"],"code":["function quat_lib.exp(q)","\treturn qexp(q)","end",""],"class":"function","name":"quat_lib.exp","summary":"\nRaises Euler's constant e to the power <q> ","private":false,"library":"quaternion","description":"\nRaises Euler's constant e to the power <q>","param":["q"]},"slerp":{"comment":["--- Performs spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1"],"code":["function quat_lib.slerp(q0, q1, t)","\tlocal dot = q0[1]*q1[1] + q0[2]*q1[2] + q0[3]*q1[3] + q0[4]*q1[4]","\tlocal q11","\tif dot<0 then","\t\tq11 = {-q1[1], -q1[2], -q1[3], -q1[4]}","\telse","\t\tq11 = { q1[1], q1[2], q1[3], q1[4] }  -- dunno if just q11 = q1 works","\tend","","\tlocal l = q0[1]*q0[1] + q0[2]*q0[2] + q0[3]*q0[3] + q0[4]*q0[4]","","\tif l==0 then return quicknew( 0, 0, 0, 0 ) end","","\tlocal invq0 = { q0[1]/l, -q0[2]/l, -q0[3]/l, -q0[4]/l }","\tlocal logq = qlog(qmul(invq0,q11))","\tlocal q = qexp( { logq[1]*t, logq[2]*t, logq[3]*t, logq[4]*t } )","","\treturn qmul(q0,q)","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.slerp","summary":"\nPerforms spherical linear interpolation between <q0> and <q1>.","private":false,"library":"quaternion","description":"\nPerforms spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1","param":["q0","q1","t"]},"qRotation":{"comment":["--- Construct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)"],"code":["function quat_lib.qRotation(rv1)","\tlocal angSquared = rv1.x * rv1.x + rv1.y * rv1.y + rv1.z * rv1.z","","\tif angSquared == 0 then return quicknew( 1, 0, 0, 0 ) end","","\tlocal len = sqrt(angSquared)","\tlocal ang = (len + 180) % 360 - 180","\tlocal ang2 = ang*deg2rad*0.5","\tlocal sang2len = sin(ang2) / len","","\treturn quicknew( cos(ang2), rv1.x * sang2len , rv1.y * sang2len, rv1.z * sang2len )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nConstruct a quaternion from the rotation vector <rv1>.","private":false,"library":"quaternion","description":"\nConstruct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)","param":["rv1"]},"qMod":{"comment":["--- Changes quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)"],"code":["function quat_lib.qMod(q)","\tif q[1]<0 then return quicknew(-q[1], -q[2], -q[3], -q[4]) else return quicknew(q[1], q[2], q[3], q[4]) end","end",""],"class":"function","name":"quat_lib.qMod","summary":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)","param":["q"]},"rotationEulerAngle":{"comment":["--- Returns the euler angle of rotation in degrees"],"code":["function quat_lib.rotationEulerAngle(q)","\tlocal l = sqrt(q[1]*q[1]+q[2]*q[2]+q[3]*q[3]+q[4]*q[4])","\tif l == 0 then return SF.WrapObject( Angle( 0, 0, 0) ) end","\tlocal q1, q2, q3, q4 = q[1]/l, q[2]/l, q[3]/l, q[4]/l","","\tlocal x = Vector(q1*q1 + q2*q2 - q3*q3 - q4*q4,","\t\t2*q3*q2 + 2*q4*q1,","\t\t2*q4*q2 - 2*q3*q1)","","\tlocal y = Vector(2*q2*q3 - 2*q4*q1,","\t\tq1*q1 - q2*q2 + q3*q3 - q4*q4,","\t\t2*q2*q1 + 2*q3*q4)","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tang.roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = q2*q1 + q3*q4","\tif dot < 0 then ang.roll = -ang.roll end","","\treturn SF.WrapObject( ang )","end",""],"class":"function","name":"quat_lib.rotationEulerAngle","summary":"\nReturns the euler angle of rotation in degrees ","private":false,"library":"quaternion","description":"\nReturns the euler angle of rotation in degrees","param":["q"]},"New":{"comment":["--- Creates a new Quaternion given a variety of inputs","-- @param ... A series of arguments which lead to valid generation of a quaternion.","-- See argTypesToQuat table for examples of acceptable inputs."],"code":["function quat_lib.New( self, ...)","\tlocal args = {...}","\t","\tlocal argtypes = \"\"","\tfor i=1,min(#args,4) do","\t\targtypes = argtypes .. SF.GetType( args[i] )","\tend","\t","\treturn argTypesToQuat[argtypes] and argTypesToQuat[argtypes](...) or quicknew(0,0,0,0)","end","","quat_lib_metamethods.__call = quat_lib.New","","","local function format(value)","\tlocal r,i,j,k,dbginfo","","\tr = \"\"","\ti = \"\"","\tj = \"\"","\tk = \"\"","","\tif abs(value[1]) > 0.0005 then","\t\tr = Round(value[1]*1000)/1000","\tend","","\tdbginfo = r","","\tif abs(value[2]) > 0.0005 then","\t\ti = tostring(Round(value[2]*1000)/1000)","","\t\tif string.sub(i,1,1) ~= \"-\" and dbginfo ~= \"\" then i = \"+\"..i end","","\t\ti = i .. \"i\"","\tend","","\tdbginfo = dbginfo .. i","","\tif abs(value[3]) > 0.0005 then","\t\tj = tostring(Round(value[3]*1000)/1000)","","\t\tif string.sub(j,1,1) ~= \"-\" and dbginfo ~= \"\" then j = \"+\"..j end","","\t\tj = j .. \"j\"","\tend","","\tdbginfo = dbginfo .. j","","\tif abs(value[4]) > 0.0005 then","\t\tk = tostring(Round(value[4]*1000)/1000)","","\t\tif string.sub(k,1,1) ~= \"-\" and dbginfo ~= \"\" then k = \"+\"..k end","","\t\tk = k .. \"k\"","\tend","","\tdbginfo = dbginfo .. k","","\tif dbginfo == \"\" then dbginfo = \"0 LAWL\" end","","\treturn dbginfo","end","","","quat_metamethods.__tostring = format","","","",""],"class":"function","name":"quat_lib.New","summary":"\nCreates a new Quaternion given a variety of inputs ","private":false,"library":"quaternion","description":"\nCreates a new Quaternion given a variety of inputs","param":{"1":"self","2":"...","...":"A series of arguments which lead to valid generation of a quaternion. \nSee argTypesToQuat table for examples of acceptable inputs."}},"qi":{"comment":["--- Returns Quaternion <n>*i"],"code":["function quat_lib.qi(n)","\treturn quicknew(0, n or 1, 0, 0)","end",""],"class":"function","name":"quat_lib.qi","summary":"\nReturns Quaternion <n>*i ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*i","param":["n"]},"qk":{"comment":["--- Returns Quaternion <n>*k"],"code":["function quat_lib.qk(n)","\treturn quicknew(0, 0, 0, n or 1)","end","","","","","quat_metamethods.__unm = function(q)","\treturn quicknew( -q[1], -q[2], -q[3], -q[4] )","end","","","quat_metamethods.__add = function(lhs, rhs)","","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3], lhs[4] + rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] + rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs + rhs[1], rhs[2], rhs[3], rhs[4] )","\tend","","\tError(\"Tried to add a \" .. ltype .. \" to a \" .. rtype .. \"not \")","end","","","quat_metamethods.__sub = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] - rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs - rhs[1], -rhs[2], -rhs[3], -rhs[4] )","\tend","","\tError(\"Tried to subtract a \" .. ltype .. \" from a \" .. rtype .. \"not \")","end","","","quat_metamethods.__mul = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] * rhs, lhs[2] * rhs, lhs[3] * rhs, lhs[4] * rhs )","\t\telseif rtype == \"Vector\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\treturn quicknew( lhs * rhs[1], lhs * rhs[2], lhs * rhs[3], lhs * rhs[4] )","\t\telseif ltype == \"Vector\" then","\t\t\tlocal lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\tend","","\tError(\"Tried to multiply a \" .. ltype .. \" with a \" .. rtype .. \"not \\n\")","end","","","quat_metamethods.__div = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs1 * rhs1 + lhs2 * rhs2 + lhs3 * rhs3 + lhs4 * rhs4)/l,","\t\t\t(-lhs1 * rhs2 + lhs2 * rhs1 - lhs3 * rhs4 + lhs4 * rhs3)/l,","\t\t\t(-lhs1 * rhs3 + lhs3 * rhs1 - lhs4 * rhs2 + lhs2 * rhs4)/l,","\t\t\t(-lhs1 * rhs4 + lhs4 * rhs1 - lhs2 * rhs3 + lhs3 * rhs2)/l","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1/rhs,","\t\t\tlhs2/rhs,","\t\t\tlhs3/rhs,","\t\t\tlhs4/rhs","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs * rhs1)/l,","\t\t\t(-lhs * rhs2)/l,","\t\t\t(-lhs * rhs3)/l,","\t\t\t(-lhs * rhs4)/l","\t\t\t)","\t\tend","\tend","","\terror(\"Tried to divide a \" .. ltype .. \" with a \" .. rtype)","end","","","quat_metamethods.__pow = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"number\" then","\t\tif lhs == 0 then return { 0, 0, 0, 0 } end","","\t\tlocal l = log(lhs)","\t\treturn qexp({ l*rhs[1], l*rhs[2], l*rhs[3], l*rhs[4] })","\telseif rtype == \"Quaternion\" and ltype == \"number\" then","\t\tlocal l = qlog(lhs)","\t\treturn qexp({ l[1]*rhs, l[2]*rhs, l[3]*rhs, l[4]*rhs })","\tend","","\tError(\"Tried to exponentiate a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end","","","--[[****************************************************************************]]","","quat_metamethods.__eq = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"Quaternion\" then","\t\tlocal rvd1, rvd2, rvd3, rvd4 = lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4]","\t\tif rvd1 <= delta and rvd1 >= -delta and","\t\t\trvd2 <= delta and rvd2 >= -delta and","\t\t\trvd3 <= delta and rvd3 >= -delta and","\t\t\trvd4 <= delta and rvd4 >= -delta","\t\tthen","\t\t\treturn 1","\t\telse","\t\t\treturn 0","\t\tend","\tend","","\tError(\"Tried to compare a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end",""],"class":"function","name":"quat_lib.qk","summary":"\nReturns Quaternion <n>*k ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*k","param":["n"]},"qj":{"comment":["--- Returns Quaternion <n>*j"],"code":["function quat_lib.qj(n)","\treturn quicknew(0, 0, n or 1, 0)","end",""],"class":"function","name":"quat_lib.qj","summary":"\nReturns Quaternion <n>*j ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*j","param":["n"]},"abs":{"comment":["--- Returns absolute value of <q>"],"code":["function quat_lib.abs(q)","\treturn sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","end",""],"class":"function","name":"quat_lib.abs","summary":"\nReturns absolute value of <q> ","private":false,"library":"quaternion","description":"\nReturns absolute value of <q>","param":["q"]},"rotationAxis":{"comment":["--- Returns the axis of rotation (by coder0xff)"],"code":["function quat_lib.rotationAxis(q)","\tlocal m2 = q[2] * q[2] + q[3] * q[3] + q[4] * q[4]","","\tif m2 == 0 then return vwrap( Vector( 0, 0, 1 ) ) end","","\tlocal m = sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] / m, q[ 3 ] / m, q[ 4 ] / m ) )","end",""],"class":"function","name":"quat_lib.rotationAxis","summary":"\nReturns the axis of rotation (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the axis of rotation (by coder0xff)","param":["q"]},"inv":{"comment":["--- Returns the inverse of <q>"],"code":["function quat_lib.inv(q)","\tlocal l = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\treturn quicknew( q[1]/l, -q[2]/l, -q[3]/l, -q[4]/l )","end",""],"class":"function","name":"quat_lib.inv","summary":"\nReturns the inverse of <q> ","private":false,"library":"quaternion","description":"\nReturns the inverse of <q>","param":["q"]},"rotationAngle":{"comment":["--- Returns the angle of rotation in degrees (by coder0xff)"],"code":["function quat_lib.rotationAngle(q)","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","","\tif l2 == 0 then return 0 end","","\tlocal l = sqrt(l2)","\tlocal ang = 2*acos(math.Clamp(q[1]/l, -1, 1))*rad2deg  --this returns angle from 0 to 360","","\tif ang > 180 then ang = ang - 360 end  -- make it -180 - 180","","\treturn ang","end",""],"class":"function","name":"quat_lib.rotationAngle","summary":"\nReturns the angle of rotation in degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the angle of rotation in degrees (by coder0xff)","param":["q"]},"vec":{"comment":["--- Converts <q> to a vector by dropping the real component"],"code":["function quat_lib.vec(q)","\treturn vwrap( Vector( q[ 2 ], q[ 3 ], q[ 4 ] ) )","end","","--[[****************************************************************************]]"],"class":"function","name":"quat_lib.vec","summary":"\nConverts <q> to a vector by dropping the real component ","private":false,"library":"quaternion","description":"\nConverts <q> to a vector by dropping the real component","param":["q"]},"rotationVector":{"comment":["--- Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)"],"code":["function quat_lib.rotationVector(q)","\tSF.CheckType( q, quat_metamethods )","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\tlocal m2 = math.max( q[2]*q[2] + q[3]*q[3] + q[4]*q[4], 0 )","","\tif l2 == 0 or m2 == 0 then return vwrap( Vector( 0, 0, 0 ) ) end","","\tlocal s = 2 * acos( math.Clamp( q[1] / sqrt(l2), -1, 1 ) ) * rad2deg","","\tif s > 180 then s = s - 360 end","","\ts = s / sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] * s, q[ 3 ] * s, q[ 4 ] * s ) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.rotationVector","summary":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)","param":["q"]}},"class":"library","summary":"\nQuaternion library ","code":["local quat_lib, quat_lib_metamethods = SF.Libraries.Register(\"quaternion\")","","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","--[[","-- Quaternion Support","-- Converted from Wiremod's E2 Quaternion library for general lua use","-- Original code for use by Bubbus","-- Permission received for use from Bubbus by Radon","-- http:\\\\wiki.wiremod.com/?title=Expression2#Quaternion","--","-- Credits to Radon for addition to Starfall","-- Credits to Divran for painful amounts of testing","]]","","-- faster access to some math library functions","local math = math -- Because global lookups suck","local setmetatable = setmetatable","local abs   = math.abs","local Round = math.Round","local sqrt  = math.sqrt","local exp   = math.exp","local log   = math.log","local sin   = math.sin","local cos   = math.cos","local sinh  = math.sinh","local cosh  = math.cosh","local acos  = math.acos","local min \t= math.min","","local delta = wire_expression2_delta or 0.0000001000000","","local isValid = SF.Entities.IsValid -- For checking shit","","local deg2rad = math.pi/180","local rad2deg = 180/math.pi",""],"fields":[],"name":"quaternion","client":true,"description":"\nQuaternion library","libtbl":"quat_lib","tables":[],"server":true},"bass":{"comment":["--- Bass library.","-- @client"],"functions":{"1":"loadFile","2":"loadURL","loadURL":{"comment":["--- Loads a sound object from a url","-- @param path url to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadURL ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tlocal instance = SF.instance","\t","\tsound.PlayURL( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadURL","summary":"\nLoads a sound object from a url ","private":false,"library":"bass","description":"\nLoads a sound object from a url","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"url to the sound file.","callback":"to run when the sound is loaded"}},"loadFile":{"comment":["--- Loads a sound object from a file","-- @param path Filepath to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadFile ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","\t","\tlocal instance = SF.instance","","\tsound.PlayFile( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadFile","summary":"\nLoads a sound object from a file ","private":false,"library":"bass","description":"\nLoads a sound object from a file","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"Filepath to the sound file.","callback":"to run when the sound is loaded"}}},"class":"library","summary":"\nBass library.","fields":[],"name":"bass","client":true,"description":"\nBass library.","libtbl":"bass_library","tables":[],"code":["local bass_library, _ = SF.Libraries.Register( \"bass\" )","","SF.Bass.Wrap = wrap","SF.Bass.Unwrap = unwrap","SF.Bass.Methods = bass_methods","SF.Bass.Metatable = bass_metamethods","","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.bass = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.bass.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tif s:IsValid() then","\t\t\ts:Stop()","\t\tend","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""]},"json":{"comment":["--- JSON library","-- @shared"],"functions":{"1":"decode","2":"encode","encode":{"ret":"JSON encoded string representation of the table","comment":["--- Convert table to JSON string","--@param tbl Table to encode","--@return JSON encoded string representation of the table"],"code":["function json_library.encode ( tbl )","\tSF.CheckType( tbl, \"table\" )","\treturn util.TableToJSON( tbl )","end",""],"class":"function","name":"json_library.encode","summary":"\nConvert table to JSON string ","private":false,"library":"json","description":"\nConvert table to JSON string","param":{"1":"tbl","tbl":"Table to encode"}},"decode":{"ret":"Table representing the JSON object","comment":["--- Convert JSON string to table","-- @param s String to decode","-- @return Table representing the JSON object"],"code":["function json_library.decode ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.JSONToTable( s )","end"],"class":"function","name":"json_library.decode","summary":"\nConvert JSON string to table ","private":false,"library":"json","description":"\nConvert JSON string to table","param":{"1":"s","s":"String to decode"}}},"class":"library","summary":"\nJSON library ","code":["local json_library, _ = SF.Libraries.Register( \"json\" )","local util = util",""],"fields":[],"name":"json","client":true,"description":"\nJSON library","libtbl":"json_library","tables":[],"server":true},"prop":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"createSent","4":"propsLeft","5":"spawnRate","canSpawn":{"ret":"True if user can spawn props, False if not.","comment":["--- Checks if a user can spawn anymore props.","-- @server","-- @return True if user can spawn props, False if not."],"code":["function props_library.canSpawn ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return false end","\t","\tlocal instance = SF.instance","\treturn not personal_max_reached( instance ) and not max_reached() and can_spawn( instance, true )","\t","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore props.","name":"props_library.canSpawn","library":"prop","private":false,"server":true,"description":"\nChecks if a user can spawn anymore props.","param":[]},"createSent":{"ret":"The sent object","comment":["--- Creates a sent.","-- @server","-- @return The sent object"],"code":["function props_library.createSent ( pos, ang, class, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( class, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not can_spawn( instance ) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 )","\telseif max_reached() then return SF.throw( \"Can't spawn props, maximum limit of \" .. SF.Props.defaultquota:GetInt() .. \" has been reached\", 2 ) end","\tif not IsValid( instance.player ) then return end","\t","","\tlocal swep = list.Get( \"Weapon\" )[ class ]","\tlocal sent = list.Get( \"SpawnableEntities\" )[ class ]","","\tlocal propdata = instance.data.props","\tlocal entity","\tlocal hookcall","\t","\tif swep then","\t","\t\tif ( ( !swep.Spawnable && !instance.player:IsAdmin() ) || ","\t\t      ( swep.AdminOnly && !instance.player:IsAdmin() ) ) then return end","\t\tif ( !gamemode.Call( \"PlayerSpawnSWEP\", instance.player, class, swep ) ) then return end","","","\t\tentity = ents.Create( swep.ClassName )","\t\t","\t\thookcall = \"PlayerSpawnedSWEP\"","\t","\telseif sent then","\t","\t\tif ( sent.AdminOnly && !instance.player:IsAdmin() ) then return false end","\t\tif ( !gamemode.Call( \"PlayerSpawnSENT\", instance.player, class ) ) then return end","\t","\t\tentity = ents.Create( sent.ClassName )","\t","\t\thookcall = \"PlayerSpawnedSENT\"","\t","\tend","\t","\tif ( IsValid( entity ) ) then","\t\t","\t\tentity:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\t\tentity:SetPos( pos )","\t\tentity:SetAngles( ang )","\t\t","\t\tentity:Spawn()","\t\tentity:Activate()","\t\t","\t\tlocal phys = entity:GetPhysicsObject()","\t\tif phys:IsValid() then","\t\t\tphys:EnableMotion(not frozen)","\t\tend","\t\t","\t\tinstance.player:AddCleanup( \"props\", entity )","\t\tgamemode.Call( hookcall, instance.player, entity )","\t","\t\tlocal wrapped = SF.Entities.Wrap( entity )","","\t\tpropdata.props[ wrapped ] = wrapped","","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\t\treturn wrapped","\tend","end",""],"class":"function","summary":"\nCreates a sent.","name":"props_library.createSent","library":"prop","private":false,"server":true,"description":"\nCreates a sent.","param":["pos","ang","class","frozen"]},"propsLeft":{"ret":"number of props able to be spawned","comment":["--- Checks how many props can be spawned","-- @server","-- @return number of props able to be spawned"],"code":["function props_library.propsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\treturn math.min( SF.Props.personalquota:GetInt() - plyCount[instance.player], instance.data.props.burst )","\t","end",""],"class":"function","summary":"\nChecks how many props can be spawned ","name":"props_library.propsLeft","library":"prop","private":false,"server":true,"description":"\nChecks how many props can be spawned","param":[]},"create":{"ret":"The prop object","comment":["--- Creates a prop.","-- @server","-- @return The prop object"],"code":["function props_library.create ( pos, ang, model, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( model, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not can_spawn( instance ) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 )","\telseif max_reached() then return SF.throw( \"Can't spawn props, maximum limit of \" .. SF.Props.defaultquota:GetInt() .. \" has been reached\", 2 ) end","\tif not IsValid( instance.player ) then return end","\tif not gamemode.Call( \"PlayerSpawnProp\", instance.player, model ) then return end","","\tlocal propdata = instance.data.props","\tlocal propent = ents.Create( \"prop_physics\" )","\t","\tpropent:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\tpropent:SetPos( pos )","\tpropent:SetAngles( ang )","\tpropent:SetModel( model )","\tpropent:Spawn()","\t","\tfor I = 0,  propent:GetPhysicsObjectCount() - 1 do","\t\tlocal obj = propent:GetPhysicsObjectNum( I )","\t\tif obj:IsValid() then","\t\t\tobj:EnableMotion(not frozen)","\t\tend","\tend","\t","\tinstance.player:AddCleanup( \"props\", propent )","\t","\tgamemode.Call( \"PlayerSpawnedProp\", instance.player, model, propent )","\tFixInvalidPhysicsObject( propent )","","\tlocal prop = SF.Entities.Wrap( propent )","","\tpropdata.props[ prop ] = prop","\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\treturn prop","end",""],"class":"function","summary":"\nCreates a prop.","name":"props_library.create","library":"prop","private":false,"server":true,"description":"\nCreates a prop.","param":["pos","ang","model","frozen"]},"spawnRate":{"ret":"Number of props per second the user can spawn","comment":["--- Returns how many props per second the user can spawn","-- @server","-- @return Number of props per second the user can spawn"],"code":["function props_library.spawnRate ()","","\treturn SF.Props.burstrate:GetFloat() or 4","\t","end"],"class":"function","summary":"\nReturns how many props per second the user can spawn ","name":"props_library.spawnRate","library":"prop","private":false,"server":true,"description":"\nReturns how many props per second the user can spawn","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","code":["local props_library, props_library_metamethods = SF.Libraries.Register(\"prop\")","","local vunwrap = SF.UnwrapObject","","SF.Props = {}","SF.Props.defaultquota = CreateConVar( \"sf_props_defaultquota\", \"200\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn via Starfall scripts across all instances\" )","","SF.Props.personalquota = CreateConVar( \"sf_props_personalquota\", \"100\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn via Starfall scripts for a single instance\" )","","SF.Props.burstmax = CreateConVar( \"sf_props_burstmax\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn in a short interval of time via Starfall scripts for a single instance ( burst )\" )","\t","SF.Props.burstrate = CreateConVar( \"sf_props_burstrate\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The rate at which the burst regenerates per second.\" )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"prop.create\", \"Create prop\", \"Allows the user to create props\" )","end","","local insts = {}","local plyCount = setmetatable({}, {__mode=\"k\"})","","SF.Libraries.AddHook(\"initialize\",function(inst)","\tinst.data.props = {","\t\tprops = {},","\t\tburst = SF.Props.burstmax:GetInt() or 4","\t}","","\tinsts[inst] = true","\tplyCount[inst.player] = plyCount[inst.player] or 0","end)","","SF.Libraries.AddHook(\"deinitialize\", function(inst)","\tlocal props = inst.data.props.props","\tlocal prop = next(props)","\twhile prop do","\t\tlocal propent = SF.Entities.Unwrap(prop)","\t\tif IsValid(propent) then","\t\t\tpropent:Remove()","\t\tend","\t\tprops[prop] = nil","\t\tprop = next(props)","\tend","","\tinsts[inst]= nil","end)","","local function propOnDestroy(propent, propdata, ply)","\tplyCount[ply] = plyCount[ply] - 1","\tif not propdata.props then return end","\tlocal prop = SF.Entities.Wrap(propent)","\tif propdata.props[prop] then","\t\tpropdata.props[prop] = nil","\tend","end","",""],"fields":[],"name":"prop","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"props_library","tables":[],"server":true},"sounds":{"comment":["--- Sounds library.","-- @shared"],"functions":{"1":"create","create":{"ret":"Sound Object","comment":["--- Creates a sound and attaches it to an entity","-- @param ent Entity to attach sound to.","-- @param path Filepath to the sound file.","-- @return Sound Object"],"code":["function sound_library.create ( ent, path )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tSF.CheckType( path, \"string\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","","\tlocal e = SF.UnwrapObject( ent )","\tif not ( e or e:IsValid() ) then","\t\tSF.throw( \"Invalid Entity\", 2 )","\tend","","\tlocal s = wrap( CreateSound( e, path ) )","\tlocal i = SF.instance.data.sounds.sounds","\ti[ s ] = s","","\treturn i[ s ]","end",""],"class":"function","name":"sound_library.create","summary":"\nCreates a sound and attaches it to an entity ","private":false,"library":"sounds","description":"\nCreates a sound and attaches it to an entity","param":{"1":"ent","2":"path","ent":"Entity to attach sound to.","path":"Filepath to the sound file."}}},"class":"library","summary":"\nSounds library.","code":["local sound_library, _ = SF.Libraries.Register( \"sounds\" )","","SF.Sounds.Wrap = wrap","SF.Sounds.Unwrap = unwrap","SF.Sounds.Methods = sound_methods","SF.Sounds.Metatable = sound_metamethods","","-- Register Privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"sound.create\", \"Sound\", \"Allows the user to create sounds\" )","\tP.registerPrivilege( \"sound.modify\", \"Sound\", \"Allows the user to modify created sounds\" )","end","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.sounds = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.sounds.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tunwrap( s ):Stop()","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""],"fields":[],"name":"sounds","client":true,"description":"\nSounds library.","libtbl":"sound_library","tables":[],"server":true},"holograms":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Holograms\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"hologramsLeft","4":"spawnRate","spawnRate":{"ret":"Number of holograms per second the user can spawn","comment":["--- Returns how many holograms per second the user can spawn","-- @server","-- @return Number of holograms per second the user can spawn"],"code":["function holograms_library.spawnRate ()","","\treturn SF.Holograms.burstrate:GetFloat() or 4","\t","end"],"class":"function","summary":"\nReturns how many holograms per second the user can spawn ","name":"holograms_library.spawnRate","library":"holograms","private":false,"server":true,"description":"\nReturns how many holograms per second the user can spawn","param":[]},"canSpawn":{"ret":"True if user can spawn holograms, False if not.","comment":["--- Checks if a user can spawn anymore holograms.","-- @server","-- @return True if user can spawn holograms, False if not."],"code":["function holograms_library.canSpawn()","    local instance = SF.instance","    return not personal_max_reached( instance ) and not max_reached() and can_spawn( instance, true )","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore holograms.","name":"holograms_library.canSpawn","library":"holograms","private":false,"server":true,"description":"\nChecks if a user can spawn anymore holograms.","param":[]},"create":{"ret":"The hologram object","comment":["--- Creates a hologram.","-- @server","-- @return The hologram object"],"code":["function holograms_library.create ( pos, ang, model, scale )","    SF.CheckType( pos, SF.Types[ \"Vector\" ] )","    SF.CheckType( ang, SF.Types[ \"Angle\" ] )","    SF.CheckType( model, \"string\" )","    if scale then","\t\tSF.CheckType( scale, SF.Types[ \"Vector\" ] )","\t\tscale = vunwrap( scale )","\tend","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","    local instance = SF.instance","    if not can_spawn( instance ) then return SF.throw( \"Can't spawn holograms that often\", 2 )","    elseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn holograms, maximum personal limit of \" .. SF.Holograms.personalquota:GetInt() .. \" has been reached\", 2 )","    elseif max_reached() then return SF.throw( \"Can't spawn holograms, maximum limit of \" .. SF.Holograms.defaultquota:GetInt() .. \" has been reached\", 2 ) end","","    local holodata = instance.data.holograms","    local holoent = ents.Create( \"starfall_hologram\" )","    if holoent and holoent:IsValid() then","        holoent:SetPos( pos )","        holoent:SetAngles( ang )","        holoent:SetModel( model )","        holoent:CallOnRemove( \"starfall_hologram_delete\", hologramOnDestroy, holodata, instance.player )","        holoent:Spawn()","","        if scale then","            holoent:SetScale( scale )","        end","","        local holo = SF.Entities.Wrap( holoent )","","        holodata.holos[ holo ] = holo","","        plyCount[ instance.player ] = plyCount[ instance.player ] + 1","        return holo","        -- TODO: Need to fire a umsg here to assign clientside ownership(?)","    end","end",""],"class":"function","summary":"\nCreates a hologram.","name":"holograms_library.create","library":"holograms","private":false,"server":true,"description":"\nCreates a hologram.","param":["pos","ang","model","scale"]},"hologramsLeft":{"ret":"number of holograms able to be spawned","comment":["--- Checks how many holograms can be spawned","-- @server","-- @return number of holograms able to be spawned"],"code":["function holograms_library.hologramsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\treturn math.min( SF.Holograms.personalquota:GetInt() - plyCount[instance.player], instance.data.holos.burst )","\t","end",""],"class":"function","summary":"\nChecks how many holograms can be spawned ","name":"holograms_library.hologramsLeft","library":"holograms","private":false,"server":true,"description":"\nChecks how many holograms can be spawned","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","code":["local holograms_library, holograms_library_metamethods = SF.Libraries.Register(\"holograms\")",""],"fields":[],"name":"holograms","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","libtbl":"holograms_library","tables":[],"server":true},"wire":{"comment":["--- Wire library. Handles wire inputs/outputs, wirelinks, etc."],"functions":{"1":"adjustInputs","2":"adjustOutputs","3":"create","4":"delete","5":"getInputs","6":"getOutputs","7":"getWirelink","8":"self","adjustOutputs":{"comment":["--- Creates/Modifies wire outputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of output names. May be modified by the function.","-- @param types An array of output types. May be modified by the function."],"code":["function wire_library.adjustOutputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setOutputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create outputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string output name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string output type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match(\"^[%u][%a%d]*$\") then SF.throw( \"Invalid output name: \" .. newname, 2 ) end","\t\tif not outputConverters[newtype] then SF.throw( \"Invalid/unsupported output type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._outputs = {names, types}\t","\tWireLib.AdjustSpecialOutputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustOutputs","summary":"\nCreates/Modifies wire outputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of output types. May be modified by the function.","names":"An array of output names. May be modified by the function."}},"delete":{"comment":["--- Unwires an entity's input","-- @param entI Entity with input","-- @param inputname Input to be un-wired"],"code":["function wire_library.delete ( entI, inputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\t","\tlocal entI = SF.Entities.Unwrap( entI )","\t","\tif not SF.Entities.IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.deleteWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs or not entI.Inputs[ inputname ] then SF.throw( \"Entity does not have input: \" .. inputname ) end","\tif not entI.Inputs[ inputname ].Src then SF.throw( \"Input \\\"\" .. inputname .. \"\\\" is not wired\" ) end","\t","\tWireLib.Link_Clear( entI, inputname )","end","","local function parseEntity( ent, io )","\t","\tif ent then","\t\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\t\tent = SF.Entities.Unwrap( ent )","\t\tif not SF.Permissions.check( SF.instance.player, ent, \"wire.get\" .. io ) then SF.throw( \"Insufficient permissions\", 2 ) end","\telse","\t\tent = SF.instance.data.entity or nil","\tend","\t","\tif not SF.Entities.IsValid( ent ) then SF.throw( \"Invalid source\" ) end","","\tlocal ret = {}","\tfor k, v in pairs( ent[ io ] ) do","\t\tif k ~= \"\" then","\t\t\ttable.insert( ret, k )","\t\tend","\tend\t","","\treturn ret","end",""],"class":"function","name":"wire_library.delete","summary":"\nUnwires an entity's input ","private":false,"library":"wire","description":"\nUnwires an entity's input","param":{"1":"entI","2":"inputname","entI":"Entity with input","inputname":"Input to be un-wired"}},"getWirelink":{"ret":"Wirelink of the entity","comment":["--- Returns a wirelink to a wire entity","-- @param ent Wire entity","-- @return Wirelink of the entity"],"code":["function wire_library.getWirelink ( ent )","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tent = SF.Entities.Unwrap( ent )","\tif not ent:IsValid() then return end","\t","\tif not ent.extended then","\t\tWireLib.CreateWirelinkOutput( SF.instance.player, ent, {true} )","\tend","\t","\treturn wlwrap(ent)","end","","-- ------------------------- Wirelink ------------------------- --",""],"class":"function","name":"wire_library.getWirelink","summary":"\nReturns a wirelink to a wire entity ","private":false,"library":"wire","description":"\nReturns a wirelink to a wire entity","param":{"1":"ent","ent":"Wire entity"}},"self":{"comment":["--- Returns the wirelink representing this entity."],"code":["function wire_library.self()","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","\treturn wlwrap(ent)","end",""],"class":"function","name":"wire_library.self","summary":"\nReturns the wirelink representing this entity.","private":false,"library":"wire","description":"\nReturns the wirelink representing this entity.","param":[]},"getInputs":{"ret":"Table of entity's inputs","comment":["--- Returns a table of entity's inputs","-- @param entI Entity with input(s)","-- @return Table of entity's inputs"],"code":["function wire_library.getInputs ( entI )","\treturn parseEntity( entI, \"Inputs\" )","end",""],"class":"function","name":"wire_library.getInputs","summary":"\nReturns a table of entity's inputs ","private":false,"library":"wire","description":"\nReturns a table of entity's inputs","param":{"1":"entI","entI":"Entity with input(s)"}},"getOutputs":{"ret":"Table of entity's outputs","comment":["--- Returns a table of entity's outputs","-- @param entO Entity with output(s)","-- @return Table of entity's outputs"],"code":["function wire_library.getOutputs ( entO )","\treturn parseEntity( entO, \"Outputs\" )","end",""],"class":"function","name":"wire_library.getOutputs","summary":"\nReturns a table of entity's outputs ","private":false,"library":"wire","description":"\nReturns a table of entity's outputs","param":{"1":"entO","entO":"Entity with output(s)"}},"create":{"comment":["--- Wires two entities together","-- @param entI Entity with input","-- @param entO Entity with output","-- @param inputname Input to be wired","-- @param outputname Output to be wired"],"code":["function wire_library.create ( entI, entO, inputname, outputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( entO, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\tSF.CheckType( outputname, \"string\" )","\t\t","\tlocal entI = SF.Entities.Unwrap( entI )","\tlocal entO = SF.Entities.Unwrap( entO )","\t","\tif not SF.Entities.IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\tif not SF.Entities.IsValid( entO ) then SF.throw( \"Invalid target\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.createWire\" ) or not SF.Permissions.check( SF.instance.player, entO, \"wire.createWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs then SF.throw( \"Source has no valid inputs\" ) end","\tif not entO.Outputs then SF.throw( \"Target has no valid outputs\" ) end","\t","\tif inputname == \"\" then SF.throw( \"Invalid input name\" ) end","\tif outputname == \"\" then SF.throw( \"Invalid output name\" ) end","\t","\tif not entI.Inputs[ inputname ] then SF.throw( \"Invalid source input: \" .. inputname ) end","\tif not entO.Outputs[ outputname ] then SF.throw( \"Invalid source output: \" .. outputname ) end","\tif entI.Inputs[ inputname ].Src then","\t\tlocal CheckInput = entI.Inputs[ inputname ]","\t\tif CheckInput.SrcId == outputname and CheckInput.Src == entO then SF.throw( \"Source \\\"\" .. inputname .. \"\\\" is already wired to target \\\"\" .. outputname .. \"\\\"\" ) end","\tend","\t\t","\tWireLib.Link_Start( SF.instance.player:UniqueID(), entI, entI:WorldToLocal( entI:GetPos() ), inputname, \"cable/rope\", Vector( 255, 255, 255 ), 0 )","\tWireLib.Link_End( SF.instance.player:UniqueID(), entO, entO:WorldToLocal( entO:GetPos() ), outputname, SF.instance.player )","end",""],"class":"function","name":"wire_library.create","summary":"\nWires two entities together ","private":false,"library":"wire","description":"\nWires two entities together","param":{"1":"entI","2":"entO","3":"inputname","4":"outputname","entI":"Entity with input","entO":"Entity with output","inputname":"Input to be wired","outputname":"Output to be wired"}},"adjustInputs":{"comment":["--- Creates/Modifies wire inputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of input names. May be modified by the function.","-- @param types An array of input types. May be modified by the function."],"code":["function wire_library.adjustInputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setInputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create inputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string input name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string input type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match( \"^[%u][%a%d]*$\" ) then SF.throw( \"Invalid input name: \" .. newname, 2 ) end","\t\tif not inputConverters[ newtype ] then SF.throw( \"Invalid/unsupported input type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._inputs = {names, types}","\tWireLib.AdjustSpecialInputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustInputs","summary":"\nCreates/Modifies wire inputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of input types. May be modified by the function.","names":"An array of input names. May be modified by the function."}}},"class":"library","fields":[],"name":"wire","summary":"\nWire library.","description":"\nWire library. Handles wire inputs/outputs, wirelinks, etc.","libtbl":"wire_library","tables":{"1":"ports","ports":{"description":"\nPorts table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.","code":["wire_library.ports = setmetatable({},wire_ports_metamethods)","","-- ------------------------- Hook Documentation ------------------------- --",""],"class":"table","classForced":true,"name":"wire_library.ports","summary":"\nPorts table.","library":"wire","comment":["--- Ports table. Reads from this table will read from the wire input","-- of the same name. Writes will write to the wire output of the same name.","-- @class table","-- @name wire_library.ports"],"param":[]}},"code":["local wire_library, wire_metamethods = SF.Libraries.Register( \"wire\" )","","function wire_metamethods.onLoad ( instance )","\tif not WireLib then return end","\tlocal ent = instance.data.entity","\tif ent.Inputs == nil then","\t\tWireLib.CreateInputs( ent, {} )","\tend","\tif ent.Outputs == nil then","\t\tWireLib.CreateOutputs( ent, {} )","\tend","","\tfunction ent:TriggerInput ( key, value )","\t\tlocal tmp = SF.instance","\t\tSF.instance = nil","\t\tself:runScriptHook( \"input\", key, SF.Wire.InputConverters[ self.Inputs[ key ].Type ]( value ) )","\t\tSF.instance = tmp","\tend","","\tfunction ent:ReadCell ( address )","\t\tlocal tmp = SF.instance","\t\tSF.instance = nil","\t\tlocal ret = tonumber( self:runScriptHookForResult( \"readcell\", address ) ) or 0","\t\tSF.instance = tmp","\t\treturn ret","\tend","","\tfunction ent:WriteCell ( address, data )","\t\tlocal tmp = SF.instance","\t\tSF.instance = nil","\t\tself:runScriptHook( \"writecell\", address, data )","\t\tSF.instance = tmp","\tend","","end","","SF.Wire = {}","SF.Wire.Library = wire_library",""]},"trace":{"comment":["--- Provides functions for doing line/AABB traces","-- @shared","-- @field MAT_ANTLION","-- @field MAT_BLOODYFLESH","-- @field MAT_CONCRETE","-- @field MAT_DIRT","-- @field MAT_FLESH","-- @field MAT_GRATE","-- @field MAT_ALIENFLESH","-- @field MAT_CLIP","-- @field MAT_PLASTIC","-- @field MAT_METAL","-- @field MAT_SAND","-- @field MAT_FOLIAGE","-- @field MAT_COMPUTER","-- @field MAT_SLOSH","-- @field MAT_TILE","-- @field MAT_VENT","-- @field MAT_WOOD","-- @field MAT_GLASS","-- @field HITGROUP_GENERIC","-- @field HITGROUP_HEAD","-- @field HITGROUP_CHEST","-- @field HITGROUP_STOMACH","-- @field HITGROUP_LEFTARM","-- @field HITGROUP_RIGHTARM","-- @field HITGROUP_LEFTLEG","-- @field HITGROUP_RIGHTLEG","-- @field HITGROUP_GEAR","-- @field MASK_SPLITAREAPORTAL","-- @field MASK_SOLID_BRUSHONLY","-- @field MASK_WATER","-- @field MASK_BLOCKLOS","-- @field MASK_OPAQUE","-- @field MASK_VISIBLE","-- @field MASK_DEADSOLID","-- @field MASK_PLAYERSOLID_BRUSHONLY","-- @field MASK_NPCWORLDSTATIC","-- @field MASK_NPCSOLID_BRUSHONLY","-- @field MASK_CURRENT","-- @field MASK_SHOT_PORTAL","-- @field MASK_SOLID","-- @field MASK_BLOCKLOS_AND_NPCS","-- @field MASK_OPAQUE_AND_NPCS","-- @field MASK_VISIBLE_AND_NPCS","-- @field MASK_PLAYERSOLID","-- @field MASK_NPCSOLID","-- @field MASK_SHOT_HULL","-- @field MASK_SHOT","-- @field MASK_ALL","-- @field CONTENTS_EMPTY","-- @field CONTENTS_SOLID","-- @field CONTENTS_WINDOW","-- @field CONTENTS_AUX","-- @field CONTENTS_GRATE","-- @field CONTENTS_SLIME","-- @field CONTENTS_WATER","-- @field CONTENTS_BLOCKLOS","-- @field CONTENTS_OPAQUE","-- @field CONTENTS_TESTFOGVOLUME","-- @field CONTENTS_TEAM4","-- @field CONTENTS_TEAM3","-- @field CONTENTS_TEAM1","-- @field CONTENTS_TEAM2","-- @field CONTENTS_IGNORE_NODRAW_OPAQUE","-- @field CONTENTS_MOVEABLE","-- @field CONTENTS_AREAPORTAL","-- @field CONTENTS_PLAYERCLIP","-- @field CONTENTS_MONSTERCLIP","-- @field CONTENTS_CURRENT_0","-- @field CONTENTS_CURRENT_90","-- @field CONTENTS_CURRENT_180","-- @field CONTENTS_CURRENT_270","-- @field CONTENTS_CURRENT_UP","-- @field CONTENTS_CURRENT_DOWN","-- @field CONTENTS_ORIGIN","-- @field CONTENTS_MONSTER","-- @field CONTENTS_DEBRIS","-- @field CONTENTS_DETAIL","-- @field CONTENTS_TRANSLUCENT","-- @field CONTENTS_LADDER","-- @field CONTENTS_HITBOX"],"functions":{"1":"trace","2":"traceHull","traceHull":{"ret":"Result of the trace","comment":["--- Does a swept-AABB trace","-- @param start Start position","-- @param endpos End position","-- @param minbox Lower box corner","-- @param maxbox Upper box corner","-- @param filter Entity/array of entities to filter","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.traceHull ( start, endpos, minbox, maxbox, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minbox, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxbox, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos, minbox, maxbox = vunwrap( start ), vunwrap( endpos ), vunwrap( minbox ), vunwrap( maxbox )","","\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask,","\t\tmins = minbox,","\t\tmaxs = maxbox","\t}","\t","\treturn SF.Sanitize( util.TraceHull( trace ) )","end"],"class":"function","name":"trace_library.traceHull","summary":"\nDoes a swept-AABB trace ","private":false,"library":"trace","description":"\nDoes a swept-AABB trace","param":{"1":"start","2":"endpos","3":"minbox","4":"maxbox","5":"filter","6":"mask","filter":"Entity/array of entities to filter","maxbox":"Upper box corner","start":"Start position","mask":"Trace mask","minbox":"Lower box corner","endpos":"End position"}},"trace":{"ret":"Result of the trace","comment":["--- Does a line trace","-- @param start Start position","-- @param endpos End position","-- @param filter Entity/array of entities to filter","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.trace ( start, endpos, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos = vunwrap( start ), vunwrap( endpos )","","\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask","\t}","\t","\treturn SF.Sanitize( util.TraceLine( trace ) )","end",""],"class":"function","name":"trace_library.trace","summary":"\nDoes a line trace ","private":false,"library":"trace","description":"\nDoes a line trace","param":{"1":"start","2":"endpos","3":"filter","4":"mask","start":"Start position","mask":"Trace mask","filter":"Entity/array of entities to filter","endpos":"End position"}}},"class":"library","summary":"\nProvides functions for doing line/AABB traces ","field":{"1":"MAT_ANTLION","2":"MAT_BLOODYFLESH","3":"MAT_CONCRETE","4":"MAT_DIRT","5":"MAT_FLESH","6":"MAT_GRATE","7":"MAT_ALIENFLESH","8":"MAT_CLIP","9":"MAT_PLASTIC","10":"MAT_METAL","11":"MAT_SAND","12":"MAT_FOLIAGE","13":"MAT_COMPUTER","14":"MAT_SLOSH","15":"MAT_TILE","16":"MAT_VENT","17":"MAT_WOOD","18":"MAT_GLASS","19":"HITGROUP_GENERIC","20":"HITGROUP_HEAD","21":"HITGROUP_CHEST","22":"HITGROUP_STOMACH","23":"HITGROUP_LEFTARM","24":"HITGROUP_RIGHTARM","25":"HITGROUP_LEFTLEG","26":"HITGROUP_RIGHTLEG","27":"HITGROUP_GEAR","28":"MASK_SPLITAREAPORTAL","29":"MASK_SOLID_BRUSHONLY","30":"MASK_WATER","31":"MASK_BLOCKLOS","32":"MASK_OPAQUE","33":"MASK_VISIBLE","34":"MASK_DEADSOLID","35":"MASK_PLAYERSOLID_BRUSHONLY","36":"MASK_NPCWORLDSTATIC","37":"MASK_NPCSOLID_BRUSHONLY","38":"MASK_CURRENT","39":"MASK_SHOT_PORTAL","40":"MASK_SOLID","41":"MASK_BLOCKLOS_AND_NPCS","42":"MASK_OPAQUE_AND_NPCS","43":"MASK_VISIBLE_AND_NPCS","44":"MASK_PLAYERSOLID","45":"MASK_NPCSOLID","46":"MASK_SHOT_HULL","47":"MASK_SHOT","48":"MASK_ALL","49":"CONTENTS_EMPTY","50":"CONTENTS_SOLID","51":"CONTENTS_WINDOW","52":"CONTENTS_AUX","53":"CONTENTS_GRATE","54":"CONTENTS_SLIME","55":"CONTENTS_WATER","56":"CONTENTS_BLOCKLOS","57":"CONTENTS_OPAQUE","58":"CONTENTS_TESTFOGVOLUME","59":"CONTENTS_TEAM4","60":"CONTENTS_TEAM3","61":"CONTENTS_TEAM1","62":"CONTENTS_TEAM2","63":"CONTENTS_IGNORE_NODRAW_OPAQUE","64":"CONTENTS_MOVEABLE","65":"CONTENTS_AREAPORTAL","66":"CONTENTS_PLAYERCLIP","67":"CONTENTS_MONSTERCLIP","68":"CONTENTS_CURRENT_0","69":"CONTENTS_CURRENT_90","70":"CONTENTS_CURRENT_180","71":"CONTENTS_CURRENT_270","72":"CONTENTS_CURRENT_UP","73":"CONTENTS_CURRENT_DOWN","74":"CONTENTS_ORIGIN","75":"CONTENTS_MONSTER","76":"CONTENTS_DEBRIS","77":"CONTENTS_DETAIL","78":"CONTENTS_TRANSLUCENT","79":"CONTENTS_LADDER","80":"CONTENTS_HITBOX","MASK_DEADSOLID":"","MASK_BLOCKLOS":"","CONTENTS_EMPTY":"","MASK_OPAQUE":"","CONTENTS_IGNORE_NODRAW_OPAQUE":"","MASK_VISIBLE":"","HITGROUP_LEFTLEG":"","MASK_PLAYERSOLID_BRUSHONLY":"","HITGROUP_RIGHTARM":"","CONTENTS_CURRENT_DOWN":"","CONTENTS_OPAQUE":"","MAT_TILE":"","MAT_FOLIAGE":"","HITGROUP_HEAD":"","MASK_SHOT":"","MAT_COMPUTER":"","CONTENTS_TEAM3":"","MASK_SPLITAREAPORTAL":"","CONTENTS_CURRENT_UP":"","MAT_CONCRETE":"","MAT_CLIP":"","MAT_WOOD":"","MAT_ANTLION":"","MASK_NPCSOLID_BRUSHONLY":"","CONTENTS_DEBRIS":"","MASK_SHOT_PORTAL":"","HITGROUP_STOMACH":"","MAT_SLOSH":"","CONTENTS_PLAYERCLIP":"","MASK_NPCWORLDSTATIC":"","MASK_OPAQUE_AND_NPCS":"","MAT_BLOODYFLESH":"","MASK_BLOCKLOS_AND_NPCS":"","CONTENTS_TEAM1":"","HITGROUP_CHEST":"","CONTENTS_AREAPORTAL":"","HITGROUP_GENERIC":"","MAT_METAL":"","HITGROUP_GEAR":"","MAT_VENT":"","MAT_PLASTIC":"","CONTENTS_CURRENT_180":"","MAT_ALIENFLESH":"","MAT_FLESH":"","MAT_GLASS":"","CONTENTS_HITBOX":"","CONTENTS_LADDER":"","CONTENTS_MONSTER":"","CONTENTS_ORIGIN":"","CONTENTS_TEAM2":"","CONTENTS_DETAIL":"","CONTENTS_GRATE":"","MASK_NPCSOLID":"","CONTENTS_MOVEABLE":"","CONTENTS_TRANSLUCENT":"","CONTENTS_CURRENT_270":"","MASK_VISIBLE_AND_NPCS":"","CONTENTS_SOLID":"","CONTENTS_MONSTERCLIP":"","MAT_SAND":"","CONTENTS_SLIME":"","CONTENTS_CURRENT_0":"","CONTENTS_WINDOW":"","MASK_PLAYERSOLID":"","MASK_ALL":"","CONTENTS_BLOCKLOS":"","MASK_WATER":"","MASK_SOLID_BRUSHONLY":"","HITGROUP_RIGHTLEG":"","CONTENTS_CURRENT_90":"","CONTENTS_AUX":"","MASK_CURRENT":"","MAT_DIRT":"","CONTENTS_TEAM4":"","CONTENTS_TESTFOGVOLUME":"","CONTENTS_WATER":"","MASK_SOLID":"","MASK_SHOT_HULL":"","HITGROUP_LEFTARM":"","MAT_GRATE":""},"code":["local trace_library, _ = SF.Libraries.Register(\"trace\")","","-- Material Enumeration","trace_library.MAT_ANTLION = MAT_ANTLION","trace_library.MAT_BLOODYFLESH = MAT_BLOODYFLESH","trace_library.MAT_CONCRETE = MAT_CONCRETE","trace_library.MAT_DIRT = MAT_DIRT","trace_library.MAT_FLESH = MAT_FLESH","trace_library.MAT_GRATE = MAT_GRATE","trace_library.MAT_ALIENFLESH = MAT_ALIENFLESH","trace_library.MAT_CLIP = MAT_CLIP","trace_library.MAT_PLASTIC = MAT_PLASTIC","trace_library.MAT_METAL = MAT_METAL","trace_library.MAT_SAND = MAT_SAND","trace_library.MAT_FOLIAGE = MAT_FOLIAGE","trace_library.MAT_COMPUTER = MAT_COMPUTER","trace_library.MAT_SLOSH = MAT_SLOSH","trace_library.MAT_TILE = MAT_TILE","trace_library.MAT_VENT = MAT_VENT","trace_library.MAT_WOOD = MAT_WOOD","trace_library.MAT_GLASS = MAT_GLASS","","-- Hithroup Enumeration","trace_library.HITGROUP_GENERIC = HITGROUP_GENERIC","trace_library.HITGROUP_HEAD = HITGROUP_HEAD","trace_library.HITGROUP_CHEST = HITGROUP_CHEST","trace_library.HITGROUP_STOMACH = HITGROUP_STOMACH","trace_library.HITGROUP_LEFTARM = HITGROUP_LEFTARM","trace_library.HITGROUP_RIGHTARM = HITGROUP_RIGHTARM","trace_library.HITGROUP_LEFTLEG = HITGROUP_LEFTLEG","trace_library.HITGROUP_RIGHTLEG = HITGROUP_RIGHTLEG","trace_library.HITGROUP_GEAR = HITGROUP_GEAR","","-- Mask Enumerations","trace_library.MASK_SPLITAREAPORTAL = MASK_SPLITAREAPORTAL","trace_library.MASK_SOLID_BRUSHONLY = MASK_SOLID_BRUSHONLY","trace_library.MASK_WATER = MASK_WATER","trace_library.MASK_BLOCKLOS = MASK_BLOCKLOS","trace_library.MASK_OPAQUE = MASK_OPAQUE","trace_library.MASK_VISIBLE = MASK_VISIBLE","trace_library.MASK_DEADSOLID = MASK_DEADSOLID","trace_library.MASK_PLAYERSOLID_BRUSHONLY = MASK_PLAYERSOLID_BRUSHONLY","trace_library.MASK_NPCWORLDSTATIC = MASK_NPCWORLDSTATIC","trace_library.MASK_NPCSOLID_BRUSHONLY = MASK_NPCSOLID_BRUSHONLY","trace_library.MASK_CURRENT = MASK_CURRENT","trace_library.MASK_SHOT_PORTAL = MASK_SHOT_PORTAL","trace_library.MASK_SOLID = MASK_SOLID","trace_library.MASK_BLOCKLOS_AND_NPCS = MASK_BLOCKLOS_AND_NPCS","trace_library.MASK_OPAQUE_AND_NPCS = MASK_OPAQUE_AND_NPCS","trace_library.MASK_VISIBLE_AND_NPCS = MASK_VISIBLE_AND_NPCS","trace_library.MASK_PLAYERSOLID = MASK_PLAYERSOLID","trace_library.MASK_NPCSOLID = MASK_NPCSOLID","trace_library.MASK_SHOT_HULL = MASK_SHOT_HULL","trace_library.MASK_SHOT = MASK_SHOT","trace_library.MASK_ALL = MASK_ALL","","-- Content Enumerations","trace_library.CONTENTS_EMPTY = CONTENTS_EMPTY","trace_library.CONTENTS_SOLID = CONTENTS_SOLID","trace_library.CONTENTS_WINDOW = CONTENTS_WINDOW","trace_library.CONTENTS_AUX = CONTENTS_AUX","trace_library.CONTENTS_GRATE = CONTENTS_GRATE","trace_library.CONTENTS_SLIME = CONTENTS_SLIME","trace_library.CONTENTS_WATER = CONTENTS_WATER","trace_library.CONTENTS_BLOCKLOS = CONTENTS_BLOCKLOS","trace_library.CONTENTS_OPAQUE = CONTENTS_OPAQUE","trace_library.CONTENTS_TESTFOGVOLUME = CONTENTS_TESTFOGVOLUME","trace_library.CONTENTS_TEAM4 = CONTENTS_TEAM4","trace_library.CONTENTS_TEAM3 = CONTENTS_TEAM3","trace_library.CONTENTS_TEAM1 = CONTENTS_TEAM1","trace_library.CONTENTS_TEAM2 = CONTENTS_TEAM2","trace_library.CONTENTS_IGNORE_NODRAW_OPAQUE = CONTENTS_IGNORE_NODRAW_OPAQUE","trace_library.CONTENTS_MOVEABLE = CONTENTS_MOVEABLE","trace_library.CONTENTS_AREAPORTAL = CONTENTS_AREAPORTAL","trace_library.CONTENTS_PLAYERCLIP = CONTENTS_PLAYERCLIP","trace_library.CONTENTS_MONSTERCLIP = CONTENTS_MONSTERCLIP","trace_library.CONTENTS_CURRENT_0 = CONTENTS_CURRENT_0","trace_library.CONTENTS_CURRENT_90 = CONTENTS_CURRENT_90","trace_library.CONTENTS_CURRENT_180 = CONTENTS_CURRENT_180","trace_library.CONTENTS_CURRENT_270 = CONTENTS_CURRENT_270","trace_library.CONTENTS_CURRENT_UP = CONTENTS_CURRENT_UP","trace_library.CONTENTS_CURRENT_DOWN = CONTENTS_CURRENT_DOWN","trace_library.CONTENTS_ORIGIN = CONTENTS_ORIGIN","trace_library.CONTENTS_MONSTER = CONTENTS_MONSTER","trace_library.CONTENTS_DEBRIS = CONTENTS_DEBRIS","trace_library.CONTENTS_DETAIL = CONTENTS_DETAIL","trace_library.CONTENTS_TRANSLUCENT = CONTENTS_TRANSLUCENT","trace_library.CONTENTS_LADDER = CONTENTS_LADDER","trace_library.CONTENTS_HITBOX = CONTENTS_HITBOX","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"trace\", \"Trace\", \"Allows the user to start traces\" )","end","","-- Local functions","","local wrap","local unwrap","","local function postload()","\twrap = SF.Entities.Wrap","\tunwrap = SF.Entities.Unwrap","end","SF.Libraries.AddHook(\"postload\",postload)","","local function convertFilter(filter)","\tif unwrap(filter) then","\t\treturn {filter}","\telse","\t\tlocal l = {}","\t\tlocal count = 1","\t\tfor i=1,#filter do","\t\t\tlocal unwrapped = unwrap(filter[i])","\t\t\tif unwrapped then","\t\t\t\tl[count] = unwrapped","\t\t\t\tcount = count + 1","\t\t\tend","\t\tend","\t\treturn l","\tend","end",""],"fields":[],"name":"trace","client":true,"description":"\nProvides functions for doing line/AABB traces","libtbl":"trace_library","tables":[],"server":true},"coroutine":{"comment":["--- Coroutine library","-- @shared"],"functions":{"1":"create","2":"resume","3":"running","4":"status","5":"wait","6":"wrap","7":"yield","resume":{"ret":"Any values the coroutine is returning to the main thread","comment":["--- Resumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","-- @param thread coroutine to resume","-- @param ... optional parameters that will be passed to the coroutine","-- @return Any values the coroutine is returning to the main thread"],"code":["function coroutine_library.resume ( thread, ... )","\tSF.CheckType( thread, thread_metamethods )","\tlocal func = unwrap( thread ).func","\treturn func( ... )","end",""],"class":"function","name":"coroutine_library.resume","summary":"\nResumes a suspended coroutine.","private":false,"library":"coroutine","description":"\nResumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","param":{"1":"thread","2":"...","...":"optional parameters that will be passed to the coroutine","thread":"coroutine to resume"}},"yield":{"ret":"Any values passed to the coroutine","comment":["--- Suspends the currently running coroutine. May not be called outside a coroutine.","-- @param ... optional parameters that will be returned to the main thread","-- @return Any values passed to the coroutine"],"code":["function coroutine_library.yield ( ... )","\treturn coroutine.yield( ... )","end",""],"class":"function","name":"coroutine_library.yield","summary":"\nSuspends the currently running coroutine.","private":false,"library":"coroutine","description":"\nSuspends the currently running coroutine. May not be called outside a coroutine.","param":{"1":"...","...":"optional parameters that will be returned to the main thread"}},"running":{"ret":"Currently running coroutine","comment":["--- Returns the coroutine that is currently running.","-- @return Currently running coroutine"],"code":["function coroutine_library.running ()","\tlocal thread = coroutine.running()","\treturn wrap( { thread = thread, func = coroutines[ thread ] } )","end",""],"class":"function","name":"coroutine_library.running","summary":"\nReturns the coroutine that is currently running.","private":false,"library":"coroutine","description":"\nReturns the coroutine that is currently running.","param":[]},"status":{"ret":"Either \"suspended\", \"running\", \"normal\" or \"dead\"","comment":["--- Returns the status of the coroutine.","-- @param thread The coroutine","-- @return Either \"suspended\", \"running\", \"normal\" or \"dead\""],"code":["function coroutine_library.status ( thread )","\tSF.CheckType( thread, thread_metamethods )","\tlocal thread = unwrap( thread ).thread","\treturn coroutine.status( thread )","end",""],"class":"function","name":"coroutine_library.status","summary":"\nReturns the status of the coroutine.","private":false,"library":"coroutine","description":"\nReturns the status of the coroutine.","param":{"1":"thread","thread":"The coroutine"}},"wrap":{"ret":"A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine.","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine."],"code":["function coroutine_library.wrap ( func )","\tSF.CheckType( func, \"function\" )","\t","\tlocal wrappedFunc, thread = createCoroutine( func )","","\treturn wrappedFunc","end",""],"class":"function","name":"coroutine_library.wrap","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"create":{"ret":"coroutine","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return coroutine"],"code":["function coroutine_library.create ( func )","\tSF.CheckType( func, \"function\" )","","\tlocal wrappedFunc, thread = createCoroutine( func )","","\tlocal ret = { func = wrappedFunc, thread = thread }","","\treturn wrap( ret )","end",""],"class":"function","name":"coroutine_library.create","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"wait":{"comment":["--- Suspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","-- @param time Time in seconds to suspend the coroutine"],"code":["function coroutine_library.wait ( time )","\tcoroutine.wait( time )","\tSF.CheckType( time, \"number\" )","end"],"class":"function","name":"coroutine_library.wait","summary":"\nSuspends the coroutine for a number of seconds.","private":false,"library":"coroutine","description":"\nSuspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","param":{"1":"time","time":"Time in seconds to suspend the coroutine"}}},"class":"library","summary":"\nCoroutine library ","code":["local coroutine_library, _ = SF.Libraries.Register( \"coroutine\" )","local coroutine = coroutine","","local _, thread_metamethods = SF.Typedef( \"thread\" )","local wrap, unwrap = SF.CreateWrapper( thread_metamethods, true, false )","","local coroutines = setmetatable( {}, { __mode = \"v\" } )","","local function createCoroutine ( func )","\t-- Can't use coroutine.create, because of a bug that prevents halting the program when it exceeds quota","","\t-- Hack to get the coroutine from a wrapped function. Necessary because coroutine.create is not available","\tlocal wrappedFunc = coroutine.wrap( function() return func( coroutine.yield( coroutine.running() ) ) end ) ","\t","\tlocal thread = wrappedFunc()","","\tcoroutines[ thread ] = wrappedFunc","\t","\treturn wrappedFunc, thread","end",""],"fields":[],"name":"coroutine","client":true,"description":"\nCoroutine library","libtbl":"coroutine_library","tables":[],"server":true},"file":{"comment":["--- File functions. Allows modification of files.","-- @shared"],"functions":{"1":"append","2":"createDir","3":"delete","4":"exists","5":"read","6":"write","read":{"ret":["Contents, or nil if error","Error message if applicable"],"comment":["--- Reads a file from path","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return Contents, or nil if error","-- @return Error message if applicable"],"code":["function file_library.read ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tlocal contents = file.Read( \"sf_filedata/\" .. path, \"DATA\" )","\tif contents then return contents else SF.throw( \"file not found\", 2 ) return end","end",""],"class":"function","name":"file_library.read","summary":"\nReads a file from path ","private":false,"library":"file","description":"\nReads a file from path","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"write":{"ret":["True if OK, nil if error","Error message if applicable"],"comment":["--- Writes to a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if OK, nil if error","-- @return Error message if applicable"],"code":["function file_library.write ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.Write( \"sf_filedata/\" .. path, data )","\treturn true","end",""],"class":"function","name":"file_library.write","summary":"\nWrites to a file ","private":false,"library":"file","description":"\nWrites to a file","param":{"1":"path","2":"data","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"append":{"ret":"Error message if applicable","comment":["--- Appends a string to the end of a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @param data String that will be appended to the file.","-- @return Error message if applicable"],"code":["function file_library.append ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.Append( \"sf_filedata/\" .. path, data )","\treturn true","end",""],"class":"function","name":"file_library.append","summary":"\nAppends a string to the end of a file ","private":false,"library":"file","description":"\nAppends a string to the end of a file","param":{"1":"path","2":"data","data":"String that will be appended to the file.","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"createDir":{"comment":["--- Creates a directory","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'"],"code":["function file_library.createDir ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.CreateDir( \"sf_filedata/\" .. path )","end"],"class":"function","name":"file_library.createDir","summary":"\nCreates a directory ","private":false,"library":"file","description":"\nCreates a directory","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"delete":{"ret":["True if successful, nil if error","Error message if applicable"],"comment":["--- Deletes a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if successful, nil if error","-- @return Error message if applicable"],"code":["function file_library.delete ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tif not file.Exists( \"sf_filedata/\" .. path, \"DATA\" ) then SF.throw( \"file not found\", 2 ) return end","\tfile.Delete( path )","\treturn true","end",""],"class":"function","name":"file_library.delete","summary":"\nDeletes a file ","private":false,"library":"file","description":"\nDeletes a file","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"exists":{"ret":["True if exists, false if not, nil if error","Error message if applicable"],"comment":["--- Checks if a file exists","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if exists, false if not, nil if error","-- @return Error message if applicable"],"code":["function file_library.exists ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Exists( \"sf_filedata/\" .. path, \"DATA\" )","end",""],"class":"function","name":"file_library.exists","summary":"\nChecks if a file exists ","private":false,"library":"file","description":"\nChecks if a file exists","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}}},"class":"library","summary":"\nFile functions.","code":["local file_library, _ = SF.Libraries.Register( \"file\" )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"file.read\", \"Read files\", \"Allows the user to read files from data/sf_scriptdata directory\" )","\tP.registerPrivilege( \"file.write\", \"Write files\", \"Allows the user to write files to data/sf_scriptdata directory\" )","\tP.registerPrivilege( \"file.exists\", \"File existence check\", \"Allows the user to determine whether a file in data/sf_scriptdata exists\" )","end","","file.CreateDir( \"sf_filedata/\" )",""],"fields":[],"name":"file","client":true,"description":"\nFile functions. Allows modification of files.","libtbl":"file_library","tables":[],"server":true},"joystick":{"comment":["--- Joystick library.","-- @client"],"functions":{"1":"getAxis","2":"getButton","3":"getName","4":"getPov","5":"numAxes","6":"numButtons","7":"numJoysticks","8":"numPovs","numJoysticks":{"ret":"Number of joysticks","comment":["--- Gets the number of detected joysticks.","-- @return Number of joysticks"],"code":["function joystick_library.numJoysticks( )","\tif joystick then","\t\treturn joystick.count( )","\tend","end",""],"class":"function","name":"joystick_library.numJoysticks","summary":"\nGets the number of detected joysticks.","private":false,"library":"joystick","description":"\nGets the number of detected joysticks.","param":[]},"getButton":{"ret":"0 or 1","comment":["--- Returns if the button is pushed or not","-- @param enum Joystick number. Starts at 0","-- @param button Joystick button number. Starts at 0","-- @return 0 or 1"],"code":["function joystick_library.getButton( enum, button )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.button( enum, button )","\tend","end",""],"class":"function","name":"joystick_library.getButton","summary":"\nReturns if the button is pushed or not ","private":false,"library":"joystick","description":"\nReturns if the button is pushed or not","param":{"1":"enum","2":"button","button":"Joystick button number. Starts at 0","enum":"Joystick number. Starts at 0"}},"getAxis":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the axis data value.","-- @param enum Joystick number. Starts at 0","-- @param axis Joystick axis number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getAxis( enum, axis )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.axis( enum, axis )","\tend","end",""],"class":"function","name":"joystick_library.getAxis","summary":"\nGets the axis data value.","private":false,"library":"joystick","description":"\nGets the axis data value.","param":{"1":"enum","2":"axis","axis":"Joystick axis number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"numButtons":{"ret":"Number of buttons","comment":["--- Gets the number of detected buttons on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of buttons"],"code":["function joystick_library.numButtons( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 3 )","\tend","end",""],"class":"function","name":"joystick_library.numButtons","summary":"\nGets the number of detected buttons on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected buttons on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numAxes":{"ret":"Number of axes","comment":["--- Gets the number of detected axes on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of axes"],"code":["function joystick_library.numAxes( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 1 )","\tend","end",""],"class":"function","name":"joystick_library.numAxes","summary":"\nGets the number of detected axes on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected axes on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numPovs":{"ret":"Number of povs","comment":["--- Gets the number of detected povs on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of povs"],"code":["function joystick_library.numPovs( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 2 )","\tend","end",""],"class":"function","name":"joystick_library.numPovs","summary":"\nGets the number of detected povs on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected povs on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"getPov":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the pov data value.","-- @param enum Joystick number. Starts at 0","-- @param pov Joystick pov number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getPov( enum, pov )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.pov( enum, pov )","\tend","end",""],"class":"function","name":"joystick_library.getPov","summary":"\nGets the pov data value.","private":false,"library":"joystick","description":"\nGets the pov data value.","param":{"1":"enum","2":"pov","pov":"Joystick pov number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"getName":{"ret":"Name of the device","comment":["--- Gets the hardware name of the joystick","-- @param enum Joystick number. Starts at 0","-- @return Name of the device"],"code":["function joystick_library.getName( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.name( enum )","\tend","end",""],"class":"function","name":"joystick_library.getName","summary":"\nGets the hardware name of the joystick ","private":false,"library":"joystick","description":"\nGets the hardware name of the joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}}},"class":"library","summary":"\nJoystick library.","fields":[],"name":"joystick","client":true,"description":"\nJoystick library.","libtbl":"joystick_library","tables":[],"code":["local joystick_library, _ = SF.Libraries.Register(\"joystick\")","","","if file.Exists(\"lua/bin/gmcl_joystick_win32.dll\", \"GAME\") then","\trequire(\"joystick\")","end","","local next_updates = {}","","local function refresh( enum )","\tenum = math.Clamp( enum, 0, 12 )","\tlocal next_update = next_updates[ enum ] or 0","\tif CurTime()>next_update then","\t\tnext_updates[ enum ] = CurTime() + 0.0303","\t\tjoystick.refresh( enum )","\tend","end",""]},"fastlz":{"comment":["--- FastLZ library","-- @shared"],"functions":{"1":"compress","2":"decompress","decompress":{"ret":"Decompressed string","comment":["--- Decompress using FastLZ","-- @param s FastLZ compressed string to decode","-- @return Decompressed string"],"code":["function fastlz_library.decompress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Decompress( s )","end"],"class":"function","name":"fastlz_library.decompress","summary":"\nDecompress using FastLZ ","private":false,"library":"fastlz","description":"\nDecompress using FastLZ","param":{"1":"s","s":"FastLZ compressed string to decode"}},"compress":{"ret":"FastLZ compressed string","comment":["--- Compress string using FastLZ","--@param s String to compress","--@return FastLZ compressed string"],"code":["function fastlz_library.compress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Compress( s )","end",""],"class":"function","name":"fastlz_library.compress","summary":"\nCompress string using FastLZ ","private":false,"library":"fastlz","description":"\nCompress string using FastLZ","param":{"1":"s","s":"String to compress"}}},"class":"library","summary":"\nFastLZ library ","code":["local fastlz_library, _ = SF.Libraries.Register( \"fastlz\" )","local util = util",""],"fields":[],"name":"fastlz","client":true,"description":"\nFastLZ library","libtbl":"fastlz_library","tables":[],"server":true},"von":{"comment":["--- vON Library","-- @shared"],"functions":{"1":"deserialize","2":"serialize","serialize":{"ret":"String","description":"\nSerialize a table","code":["von.serialize = setmetatable(_serialize,_s_meta)"],"class":"function","classForced":true,"summary":"\nSerialize a table ","name":"von.serialize","library":"von","comment":["--- Serialize a table","-- @shared","-- @class function","-- @name von.serialize","-- @param tbl Table to serialize","-- @return String"],"client":true,"server":true,"param":{"1":"tbl","tbl":"Table to serialize"}},"deserialize":{"ret":"Table","description":"\nDeserialize a string","code":["von.deserialize = setmetatable(_deserialize,_d_meta)",""],"class":"function","classForced":true,"summary":"\nDeserialize a string ","name":"von.deserialize","library":"von","comment":["--- Deserialize a string","-- @shared","-- @class function","-- @name von.deserialize","-- @param str String to deserialize","-- @return Table"],"client":true,"server":true,"param":{"1":"str","str":"String to deserialize"}}},"class":"library","summary":"\nvON Library ","code":["local von, _ = SF.Libraries.Register(\"von\")","","local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable","local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next","","--\tThis is kept away from the table for speed.","function d_findVariable(s, i, len, lastType)","\tlocal i, c, typeRead, val = i or 1","","\t--\tKeep looping through the string.","\twhile true do","\t\t--\tStop at the end. Throw an error. This function MUST NOT meet the end!","\t\tif i > len then","\t\t\tSF.throw( \"vON: Reached end of string, cannot form proper variable.\", 3 )","\t\tend","","\t\t--\tCache the character. Nobody wants to look for the same character ten times.","\t\tc = sub(s, i, i)","","\t\t--\tIf it just read a type definition, then a variable HAS to come after it.","\t\tif typeRead then","\t\t\t--\tAttempt to deserialize a variable of the freshly read type.","\t\t\tval, i = _deserialize[lastType](s, i, len)","\t\t\t--\tReturn the value read, the index of the last processed character, and the type of the last read variable.","\t\t\treturn val, i, lastType","","\t\t\t--\t@ means nil. It should not even appear in the output string of the serializer. Nils are useless to store.","\t\telseif c == \"@\" then","\t\t\treturn nil, i, lastType","","\t\t\t--\tn means a number will follow. Base 10... :C","\t\telseif c == \"n\" then","\t\t\tlastType = \"number\"","\t\t\ttypeRead = true","","\t\t\t--\tb means boolean flags.","\t\telseif c == \"b\" then","\t\t\tlastType = \"boolean\"","\t\t\ttypeRead = true","","\t\t\t--\t\" means the start of a string.","\t\telseif c == \"\\\"\" then","\t\t\tlastType = \"string\"","\t\t\ttypeRead = true","","\t\t\t--\t{ means the start of a table!","\t\telseif c == \"{\" then","\t\t\tlastType = \"table\"","\t\t\ttypeRead = true","","\t\t\t--\tIf no type has been found, attempt to deserialize the last type read.","\t\telseif lastType then","\t\t\tval, i = _deserialize[lastType](s, i, len)","\t\t\treturn val, i, lastType","","\t\t\t--\tThis will occur if the very first character in the vON code is wrong.","\t\telse","\t\t\tSF.throw( \"vON: Malformed data... Can't find a proper type definition. Char#\" .. i .. \":\" .. c, 3 )","\t\tend","","\t\t--\tMove the pointer one step forward.","\t\ti = i + 1","\tend","end","","--\tThis is kept away from the table for speed.","--\tYeah, crapload of parameters.","function s_anyVariable(data, lastType, isNumeric, isKey, isLast, nice, indent)","","\t--\tBasically, if the type changes.","\tif lastType ~= type(data) then","\t\t--\tRemember the new type. Caching the type is useless.","\t\tlastType = type(data)","","\t\t--\tReturn the serialized data and the (new) last type.","\t\t--\tThe second argument, which is true now, means that the data type was just changed.","\t\treturn _serialize[lastType](data, true, isNumeric, isKey, isLast, nice, indent), lastType","\tend","","\t--\tOtherwise, simply serialize the data.","\treturn _serialize[lastType](data, false, isNumeric, isKey, isLast, nice, indent), lastType","end","","_deserialize = {","","\t--\tWell, tables are very loose...","\t--\tThe first table doesn't have to begin and end with { and }.","\t[\"table\"] = function(s, i, len, unnecessaryEnd)","\t\tlocal ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals and locals.","","\t\t--\tKeep looping.","\t\twhile true do","\t\t\t--\tUntil it meets the end.","\t\t\tif i > len then","\t\t\t\t--\tYeah, if the end is unnecessary, it won't spit an error. The main chunk doesn't require an end, for example.","\t\t\t\tif unnecessaryEnd then","\t\t\t\t\treturn ret, i","","\t\t\t\t\t--\tOtherwise, the data has to be damaged.","\t\t\t\telse","\t\t\t\t\tSF.throw( \"vON: Reached end of string, incomplete table definition.\", 2 )","\t\t\t\tend","\t\t\tend","","\t\t\t--\tCache the character.","\t\t\tc = sub(s,i,i)","\t\t\t--print(i, \"table char:\", c, tostring(unnecessaryEnd))","","\t\t\t--\tIf it's the end of a table definition, return.","\t\t\tif c == \"}\" then","\t\t\t\treturn ret, i","","\t\t\t\t--\tIf it's the component separator, switch to key:value pairs.","\t\t\telseif c == \"~\" then","\t\t\t\tnumeric = false","","\t\t\telseif c == \";\" then","\t\t\t\t--\tLol, nothing!","\t\t\t\t--\tRemenant from numbers, for faster parsing.","","\t\t\t\t--\tOK, now, if it's on the numeric component, simply add everything encountered.","\t\t\telseif numeric then","\t\t\t\t--\tFind a variable and it's value","\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType)","\t\t\t\t--\tAdd it to the table.","\t\t\t\tret[#ret + 1] = val","","\t\t\t\t--\tOtherwise, if it's the key:value component...","\t\t\telse","\t\t\t\t--\tIf a value is expected...","\t\t\t\tif expectValue then","\t\t\t\t\t--\tRead it.","\t\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType)","\t\t\t\t\t--\tAdd it?","\t\t\t\t\tret[key] = val","\t\t\t\t\t--\tClean up.","\t\t\t\t\texpectValue, key = false, nil","","\t\t\t\t\t--\tIf it's the separator...","\t\t\t\telseif c == \":\" then","\t\t\t\t\t--\tExpect a value next.","\t\t\t\t\texpectValue = true","","\t\t\t\t\t--\tBut, if there's a key read already...","\t\t\t\telseif key then","\t\t\t\t\t--\tThen this is malformed.","\t\t\t\t\tSF.throw( \"vON: Malformed table... Two keys declared successively? Char#\" .. i .. \":\" .. c, 2 )","","\t\t\t\t\t--\tOtherwise the key will be read.","\t\t\t\telse","\t\t\t\t\t--\tI love multi-return and multi-assignement.","\t\t\t\t\tkey, i, lastType = d_findVariable(s, i, len, lastType)","\t\t\t\tend","\t\t\tend","","\t\t\ti = i + 1","\t\tend","","\t\treturn nil, i","\tend,","","","\t--\tNumbers are weakly defined.","\t--\tThe declaration is not very explicit. It'll do it's best to parse the number.","\t--\tHas various endings: \\n, }, ~, : and ;, some of which will force the table deserializer to go one char backwards.","\t[\"number\"] = function(s, i, len)","\t\tlocal i, a = i or 1","\t\t--\tLocals, locals, locals, locals","","\t\ta = find(s, \"[;:}~]\", i)","","\t\tif a then","\t\t\treturn tonumber(sub(s, i, a - 1)), a - 1","\t\tend","","\t\tSF.throw( \"vON: Number definition started... Found no end.\", 3 )","\tend,","","","\t--\tA boolean is A SINGLE CHARACTER, either 1 for true or 0 for false.","\t--\tAny other attempt at boolean declaration will result in a failure.","\t[\"boolean\"] = function(s, i, len)","\t\tlocal c = sub(s,i,i)","\t\t--\tOnly one character is needed.","","\t\t--\tIf it's 1, then it's true","\t\tif c == \"1\" then","\t\t\treturn true, i","","\t\t\t--\tIf it's 0, then it's false.","\t\telseif c == \"0\" then","\t\t\treturn false, i","\t\tend","","\t\t--\tAny other supposely \"boolean\" is just a sign of malformed data.","\t\tSF.throw( \"vON: Invalid value on boolean type... Char#\" .. i .. \": \" .. c, 3 )","\tend,","","","\t--\tStrings are very easy to parse and also very explicit.","\t--\t\" simply marks the type of a string.","\t--\tThen it is parsed until an unescaped \" is countered.","\t[\"string\"] = function(s, i, len)","\t\tlocal res, i, a = \"\", i or 1","\t\t--\tLocals, locals, locals, locals","","\t\twhile true do","\t\t\ta = find(s, \"\\\"\", i, true)","","\t\t\tif a then","\t\t\t\tif sub(s, a - 1, a - 1) == \"\\\\\" then","\t\t\t\t\tres = res .. sub(s, i, a - 2) .. \"\\\"\"","\t\t\t\t\ti = a + 1","\t\t\t\telse","\t\t\t\t\treturn res .. sub(s, i, a - 2), a","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw( \"vON: String definition started... Found no end.\", 3 )","\t\t\tend","\t\tend","\tend","}","","","_serialize = {","","\t--\tUh. Nothing to comment.","\t--\tShitload of parameters.","\t--\tMakes shit faster than simply passing it around in locals.","\t--\ttable.concat works better than normal concatenations WITH LARGE-ISH STRINGS ONLY.","\t[\"table\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first)","\t--print(string.format(\"data: %s; mustInitiate: %s; isKey: %s; isLast: %s; nice: %s; indent: %s; first: %s\", tostring(data), tostring(mustInitiate), tostring(isKey), tostring(isLast), tostring(nice), tostring(indent), tostring(first)))","","\t\tlocal result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals, locals and locals.","","\t\t--\tFirst thing to be done is separate the numeric and key:value components of the given table in two tables.","\t\t--\tpairs(data) is slower than next, data as far as my tests tell me.","\t\tfor k, v in next, data do","\t\t\t--\tSkip the numeric keyz.","\t\t\tif type(k) ~= \"number\" or k < 1 or k > len then","\t\t\t\tkeyvals[#keyvals + 1] = k","\t\t\tend","\t\tend","","\t\tkeyvalsLen = #keyvals","","\t\t--\tMain chunk - no initial character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"{\"","\t\tend","","\t\t--\tAdd numeric values.","\t\tif len > 0 then","\t\t\tfor i = 1, len do","\t\t\t\tval, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, false, 0)","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tIf there are key:value pairs.","\t\tif keyvalsLen > 0 then","\t\t\t--\tInsert delimiter.","\t\t\tresult[#result + 1] = \"~\"","","\t\t\t--\tInsert key:value pairs.","\t\t\tfor _i = 1, keyvalsLen do","\t\t\t\tkeyvalsProgress = keyvalsProgress + 1","","\t\t\t\tval, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, false, 0)","","\t\t\t\tresult[#result + 1] = val..\":\"","","\t\t\t\tval, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, false, 0)","","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tMain chunk needs no ending character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"}\"","\t\tend","","\t\treturn concat(result)","\tend,","","","\t--\tNormal concatenations is a lot faster with small strings than table.concat","\t--\tAlso, not so branched-ish.","\t[\"number\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t--\tIf a number hasn't been written before, add the type prefix.","\t\tif mustInitiate then","\t\t\tif isKey or isLast then","\t\t\t\treturn \"n\"..data","\t\t\telse","\t\t\t\treturn \"n\"..data..\";\"","\t\t\tend","\t\tend","","\t\tif isKey or isLast then","\t\t\treturn \"n\"..data","\t\telse","\t\t\treturn \"n\"..data..\";\"","\t\tend","\tend,","","","\t--\tI hope gsub is fast enough.","\t[\"string\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t\treturn \"\\\"\" .. gsub(data, \"\\\"\", \"\\\\\\\"\") .. \"v\\\"\"","\tend,","","","\t--\tFastest.","\t[\"boolean\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t--\tPrefix if we must.","\t\tif mustInitiate then","\t\t\tif data then","\t\t\t\treturn \"b1\"","\t\t\telse","\t\t\t\treturn \"b0\"","\t\t\tend","\t\tend","","\t\tif data then","\t\t\treturn \"1\"","\t\telse","\t\t\treturn \"0\"","\t\tend","\tend,","","","\t--\tFastest.","\t[\"nil\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t\treturn \"@\"","\tend","}","","local _s_table = _serialize.table","local _d_table = _deserialize.table","","_d_meta = {","\t__call = function(self, str)","\t\tif type(str) == \"string\" then","\t\t\treturn _d_table(str, nil, #str, true)","\t\tend","\t\tSF.throw( \"vON: You must deserialize a string, not a \" .. type( str ), 2 )","\tend","}","_s_meta = {","\t__call = function(self, data)","\t\tif type(data) == \"table\" then","\t\t\treturn _s_table(data, nil, nil, nil, nil, true)","\t\tend","\t\tSF.throw( \"vON: You must serialize a table, not a \" .. type( data ), 2 )","\tend","}",""],"fields":[],"name":"von","client":true,"description":"\nvON Library","libtbl":"von","tables":[],"server":true},"timer":{"comment":["--- Deals with time and timers.","-- @shared"],"functions":{"1":"adjust","2":"create","3":"curtime","4":"exists","5":"frametime","6":"pause","7":"realtime","8":"remove","9":"simple","10":"start","11":"stop","12":"systime","13":"unpause","simple":{"comment":["--- Creates a simple timer, has no name, can't be stopped, paused, or destroyed.","-- @param delay the time, in second, to set the timer to","-- @param func the function to call when the timer is fired"],"code":["function timer_library.simple(delay, func)","\tSF.CheckType( delay, \"number\" )","\tSF.CheckType( func, \"function\" )","\t","\tlocal instance = SF.instance","\ttimer.Simple(delay, function()","\t\tif IsValid(instance.data.entity) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"simple timer errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend)","end","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.timers = {}","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tif instance.data.timers ~= nil then","\t\tfor name,_ in pairs(instance.data.timers) do","\t\t\tlocal realname = mangle_timer_name(instance,name)","\t\t\ttimer.Remove(realname)","\t\tend","\tend","\tinstance.data.timers = nil","end)"],"class":"function","name":"timer_library.simple","summary":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","private":false,"library":"timer","description":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","param":{"1":"delay","2":"func","delay":"the time, in second, to set the timer to","func":"the function to call when the timer is fired"}},"frametime":{"comment":["--- Returns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua"],"code":["function timer_library.frametime()","\treturn FrameTime()","end","","-- ------------------------- Timers ------------------------- --","","local function mangle_timer_name(instance, name)","\treturn string.format(\"sftimer_%s_%s\",tostring(instance),name)","end",""],"class":"function","name":"timer_library.frametime","summary":"\nReturns time between frames on client and ticks on server.","private":false,"library":"timer","description":"\nReturns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua","param":[]},"systime":{"comment":["--- Same as GLua's SysTime()"],"code":["function timer_library.systime()","\treturn SysTime()","end",""],"class":"function","name":"timer_library.systime","summary":"\nSame as GLua's SysTime() ","private":false,"library":"timer","description":"\nSame as GLua's SysTime()","param":[]},"adjust":{"comment":["--- Adjusts a timer","-- @param name The timer name"],"code":["function timer_library.adjust(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Adjust(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.adjust","summary":"\nAdjusts a timer ","private":false,"library":"timer","description":"\nAdjusts a timer","param":{"1":"name","name":"The timer name"}},"create":{"comment":["--- Creates (and starts) a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.create(name, delay, reps, func)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tSF.CheckType(func,\"function\")","\t","\tlocal instance = SF.instance","\tlocal timername = mangle_timer_name(instance,name)","\t","\tlocal function timercb()","\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\t\ttimer.Remove( timername )","\t\tend","\tend","\t","\ttimer.Create(timername, delay, reps, timercb )","\t","\tinstance.data.timers[name] = true","end",""],"class":"function","name":"timer_library.create","summary":"\nCreates (and starts) a timer ","private":false,"library":"timer","description":"\nCreates (and starts) a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"stop":{"comment":["--- Stops a timer","-- @param name The timer name"],"code":["function timer_library.stop(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Stop(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.stop","summary":"\nStops a timer ","private":false,"library":"timer","description":"\nStops a timer","param":{"1":"name","name":"The timer name"}},"remove":{"comment":["--- Removes a timer","-- @param name The timer name"],"code":["function timer_library.remove(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\ttimer.Stop(mangle_timer_name(instance,name))","\tinstance.data.timers[name] = nil","end",""],"class":"function","name":"timer_library.remove","summary":"\nRemoves a timer ","private":false,"library":"timer","description":"\nRemoves a timer","param":{"1":"name","name":"The timer name"}},"exists":{"ret":"bool if the timer exists","comment":["--- Checks if a timer exists","-- @param name The timer name","-- @return bool if the timer exists"],"code":["function timer_library.exists(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\treturn timer.Exists(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.exists","summary":"\nChecks if a timer exists ","private":false,"library":"timer","description":"\nChecks if a timer exists","param":{"1":"name","name":"The timer name"}},"unpause":{"comment":["--- Unpauses a timer","-- @param name The timer name"],"code":["function timer_library.unpause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.UnPause(mangle_timer_name(instance,name))","end","",""],"class":"function","name":"timer_library.unpause","summary":"\nUnpauses a timer ","private":false,"library":"timer","description":"\nUnpauses a timer","param":{"1":"name","name":"The timer name"}},"realtime":{"comment":["--- Same as GLua's RealTime()"],"code":["function timer_library.realtime()","\treturn RealTime()","end",""],"class":"function","name":"timer_library.realtime","summary":"\nSame as GLua's RealTime() ","private":false,"library":"timer","description":"\nSame as GLua's RealTime()","param":[]},"start":{"comment":["--- Starts a timer","-- @param name The timer name"],"code":["function timer_library.start(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Start(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.start","summary":"\nStarts a timer ","private":false,"library":"timer","description":"\nStarts a timer","param":{"1":"name","name":"The timer name"}},"pause":{"comment":["--- Pauses a timer","-- @param name The timer name"],"code":["function timer_library.pause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Pause(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.pause","summary":"\nPauses a timer ","private":false,"library":"timer","description":"\nPauses a timer","param":{"1":"name","name":"The timer name"}},"curtime":{"comment":["--- Same as GLua's CurTime()"],"code":["function timer_library.curtime()","\treturn CurTime()","end",""],"class":"function","name":"timer_library.curtime","summary":"\nSame as GLua's CurTime() ","private":false,"library":"timer","description":"\nSame as GLua's CurTime()","param":[]}},"class":"library","summary":"\nDeals with time and timers.","code":["local timer_library, _ = SF.Libraries.Register(\"timer\")","","-- ------------------------- Time ------------------------- --",""],"fields":[],"name":"timer","client":true,"description":"\nDeals with time and timers.","libtbl":"timer_library","tables":[],"server":true},"net":{"comment":["--- Net message library. Used for sending data from the server to the client and back"],"functions":{"1":"bytesWritten","2":"canSend","3":"readBit","4":"readDouble","5":"readFloat","6":"readInt","7":"readString","8":"readTable","9":"readUInt","10":"send","11":"start","12":"writeBit","13":"writeDouble","14":"writeFloat","15":"writeInt","16":"writeString","17":"writeTable","18":"writeUInt","readDouble":{"ret":"The double that was read","comment":["--- Reads a double from the net message","-- @shared","-- @return The double that was read"],"code":["","function net_library.readDouble()","\treturn net.ReadDouble()","end",""],"class":"function","summary":"\nReads a double from the net message ","library":"net","name":"net_library.readDouble","server":true,"private":false,"client":true,"description":"\nReads a double from the net message","param":[]},"send":{"comment":["--- Send a net message from client->server, or server->client.","--@shared","--@param target Optional target location to send the net message."],"code":["function net_library.send ( target )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tlocal data = instance.data.net.data","\tif #data == 0 then return false end","\tnet.Start( \"SF_netmessage\" )","\tnet.WriteEntity( SF.instance.data.entity )","\tfor i = 1, #data do","\t\tlocal writefunc = data[ i ][ 1 ]","\t\tlocal writevalue = data[ i ][ 2 ]","\t\tlocal writesetting = data[ i ][ 3 ]","","\t\tnet[ writefunc ]( writevalue, writesetting )","\tend","","\tinstance.data.net.burst = instance.data.net.burst - net.BytesWritten() / 1000","\t","\tif SERVER then","\t\tlocal sendfunc","\t\tlocal newtarget","","\t\tif target then","\t\t\tif SF.GetType( target ) == \"table\" then","\t\t\t\tlocal nt = { }","\t\t\t\tfor i = 1, #target do","\t\t\t\t\tSF.CheckType( SF.Entities.Unwrap( target[ i ] ), \"Player\", 1 )","\t\t\t\t\tnt[ i ] = SF.Entities.Unwrap( target[ i ] )","\t\t\t\tend","\t\t\t\tsendfunc, newtarget = net.Send, nt","\t\t\telse","\t\t\t\tSF.CheckType( SF.Entities.Unwrap( target ), \"Player\", 1 ) -- TODO: unhacky this","\t\t\t\tsendfunc, newtarget = net.Send, SF.Entities.Unwrap( target )","\t\t\tend","\t\telse","\t\t\tsendfunc = net.Broadcast","\t\tend","","\t\tsendfunc( newtarget )","\telse","\t\tnet.SendToServer()","\tend","end",""],"class":"function","summary":"\nSend a net message from client->server, or server->client.","library":"net","name":"net_library.send","server":true,"private":false,"client":true,"description":"\nSend a net message from client->server, or server->client.","param":{"1":"target","target":"Optional target location to send the net message."}},"writeTable":{"comment":["--- Writes a table to the net message","-- @shared","-- @param t The table to be written. This will be checked for blacklisted types. eg VMatrix."],"code":["function net_library.writeTable( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","\t","\tSF.CheckType( t, \"table\" )","","\tcheckTblForBlacklist( t )","","\twrite( instance, \"Table\", SF.Unsanitize(t) )","\treturn true","end",""],"class":"function","summary":"\nWrites a table to the net message ","library":"net","name":"net_library.writeTable","server":true,"private":false,"client":true,"description":"\nWrites a table to the net message","param":{"1":"t","t":"The table to be written. This will be checked for blacklisted types. eg VMatrix."}},"readFloat":{"ret":"The float that was read","comment":["--- Reads a float from the net message","-- @shared","-- @return The float that was read"],"code":["","function net_library.readFloat()","\treturn net.ReadFloat()","end",""],"class":"function","summary":"\nReads a float from the net message ","library":"net","name":"net_library.readFloat","server":true,"private":false,"client":true,"description":"\nReads a float from the net message","param":[]},"writeBit":{"comment":["--- Writes a bit to the net message","-- @shared","-- @param t The bit to be written. (boolean)"],"code":["","function net_library.writeBit( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"boolean\" )","","\twrite( instance, \"Bit\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a bit to the net message ","library":"net","name":"net_library.writeBit","server":true,"private":false,"client":true,"description":"\nWrites a bit to the net message","param":{"1":"t","t":"The bit to be written. (boolean)"}},"readUInt":{"ret":"The unsigned integer that was read","comment":["--- Reads an unsigned integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The unsigned integer that was read"],"code":["","function net_library.readUInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadUInt(n)","end",""],"class":"function","summary":"\nReads an unsigned integer from the net message ","library":"net","name":"net_library.readUInt","server":true,"private":false,"client":true,"description":"\nReads an unsigned integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"readBit":{"ret":"The bit that was read. (0 for false, 1 for true)","comment":["--- Reads a bit from the net message","-- @shared","-- @return The bit that was read. (0 for false, 1 for true)"],"code":["","function net_library.readBit()","\treturn net.ReadBit()","end",""],"class":"function","summary":"\nReads a bit from the net message ","library":"net","name":"net_library.readBit","server":true,"private":false,"client":true,"description":"\nReads a bit from the net message","param":[]},"readTable":{"ret":"The table that was read","comment":["--- Reads a table from the net message","-- @shared","-- @return The table that was read"],"code":["","function net_library.readTable()","\treturn SF.Sanitize(net.ReadTable())","end",""],"class":"function","summary":"\nReads a table from the net message ","library":"net","name":"net_library.readTable","server":true,"private":false,"client":true,"description":"\nReads a table from the net message","param":[]},"readString":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @return The string that was read"],"code":["","function net_library.readString()","\treturn net.ReadString()","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readString","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":[]},"readInt":{"ret":"The integer that was read","comment":["--- Reads an integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The integer that was read"],"code":["","function net_library.readInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadInt(n)","end",""],"class":"function","summary":"\nReads an integer from the net message ","library":"net","name":"net_library.readInt","server":true,"private":false,"client":true,"description":"\nReads an integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"writeInt":{"comment":["--- Writes an integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of"],"code":["","function net_library.writeInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Int\", t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an integer to the net message ","library":"net","name":"net_library.writeInt","server":true,"private":false,"client":true,"description":"\nWrites an integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of","t":"The integer to be written"}},"writeString":{"comment":["--- Writes a string to the net message","-- @shared","-- @param t The string to be written"],"code":["","function net_library.writeString( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","","\twrite( instance, \"String\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a string to the net message ","library":"net","name":"net_library.writeString","server":true,"private":false,"client":true,"description":"\nWrites a string to the net message","param":{"1":"t","t":"The string to be written"}},"writeUInt":{"comment":["--- Writes an unsigned integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of. Should not be greater than 32"],"code":["","function net_library.writeUInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"UInt\", t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an unsigned integer to the net message ","library":"net","name":"net_library.writeUInt","server":true,"private":false,"client":true,"description":"\nWrites an unsigned integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of. Should not be greater than 32","t":"The integer to be written"}},"canSend":{"ret":"A boolean that states whether or not you can currently send a net message","comment":["--- Checks whether you can currently send a net message","-- @return A boolean that states whether or not you can currently send a net message"],"code":["","function net_library.canSend()","\treturn SF.instance.data.net.burst > 0","end","","net.Receive( \"SF_netmessage\", function( len, ply )","\tlocal ent = net.ReadEntity()","\tif ent:IsValid() and ent.runScriptHook then","\t\tent:runScriptHook( \"net\", net.ReadString(), len, ply and SF.WrapObject( ply ) )","\tend","end)",""],"class":"function","name":"net_library.canSend","summary":"\nChecks whether you can currently send a net message ","private":false,"library":"net","description":"\nChecks whether you can currently send a net message","param":[]},"start":{"comment":["--- Starts the net message","-- @shared","-- @param name The message name"],"code":["function net_library.start( name )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\tif instance.data.net.burst <= 0 then return SF.throw( \"can't send that much data that often\", 2 ) end","\t","\tinstance.data.net.started = true","\tinstance.data.net.data = {}","\twrite( instance, \"String\", name )","end",""],"class":"function","summary":"\nStarts the net message ","library":"net","name":"net_library.start","server":true,"private":false,"client":true,"description":"\nStarts the net message","param":{"1":"name","name":"The message name"}},"bytesWritten":{"ret":"The amount of bytes written so far","comment":["--- Gets the amount of bytes written so far","-- @return The amount of bytes written so far"],"code":["","function net_library.bytesWritten()","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\treturn net.BytesWritten()","end",""],"class":"function","name":"net_library.bytesWritten","summary":"\nGets the amount of bytes written so far ","private":false,"library":"net","description":"\nGets the amount of bytes written so far","param":[]},"writeDouble":{"comment":["--- Writes a double to the net message","-- @shared","-- @param t The double to be written"],"code":["","function net_library.writeDouble( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Double\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a double to the net message ","library":"net","name":"net_library.writeDouble","server":true,"private":false,"client":true,"description":"\nWrites a double to the net message","param":{"1":"t","t":"The double to be written"}},"writeFloat":{"comment":["--- Writes a float to the net message","-- @shared","-- @param t The float to be written"],"code":["","function net_library.writeFloat( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Float\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a float to the net message ","library":"net","name":"net_library.writeFloat","server":true,"private":false,"client":true,"description":"\nWrites a float to the net message","param":{"1":"t","t":"The float to be written"}}},"class":"library","fields":[],"name":"net","summary":"\nNet message library.","description":"\nNet message library. Used for sending data from the server to the client and back","libtbl":"net_library","tables":[],"code":["local net_library, _ = SF.Libraries.Register(\"net\")","","local burst_limit = CreateConVar( \"sf_net_burst_limit\", \"10\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\"The net message burst limit in kB.\" )","","local burst_interval = CreateConVar( \"sf_net_burst_interval\", \"0.1\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\t\"The interval of the timer that adds 1kB more available net message. Requires a map reload to update.\" )","","","local function write( instance, type, value, setting )","\tinstance.data.net.data[#instance.data.net.data+1] = { \"Write\" .. type, value, setting }","end","","local instances = {}","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.net = {","\t\tstarted = false,","\t\tburst = burst_limit:GetInt(),","\t\tdata = {},","\t}","\t","\tinstances[instance] = true","end)","","SF.Libraries.AddHook( \"deinitialize\", function( instance )","\tif instance.data.net.started then","\t\tinstance.data.net.started = false","\tend","\t","\tinstances[instance] = nil","end)","","timer.Create( \"SF_Net_BurstCounter\", burst_interval:GetFloat(), 0, function()","\tfor instance, b in pairs( instances ) do","\t\tif instance.data.net.burst < burst_limit:GetInt() then","\t\t\tinstance.data.net.burst = instance.data.net.burst + 1","\t\tend","\tend","end)","","if SERVER then","\tutil.AddNetworkString( \"SF_netmessage\" )","end",""]},"physenv":{"comment":["--- Physenv functions","-- @shared"],"functions":{"1":"getAirDensity","2":"getGravity","3":"getPerformanceSettings","getAirDensity":{"ret":"number Air Density","comment":["--- Gets the air density.","-- @return number Air Density"],"code":["function physenv_lib.getAirDensity ()","\treturn physenv.GetAirDensity()","end",""],"class":"function","name":"physenv_lib.getAirDensity","summary":"\nGets the air density.","private":false,"library":"physenv","description":"\nGets the air density.","param":[]},"getPerformanceSettings":{"ret":"table Performance Settings Table.","comment":["--- Gets the performance settings.</br>","-- See <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","-- @return table Performance Settings Table."],"code":["function physenv_lib.getPerformanceSettings ()","\treturn SF.Sanitize( table.Copy( physenv.GetPerformanceSettings() ) )","end"],"class":"function","name":"physenv_lib.getPerformanceSettings","summary":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","private":false,"library":"physenv","description":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","param":[]},"getGravity":{"ret":"Vector Gravity Vector ( eg Vector(0,0,-600) )","comment":["--- Gets the gravity vector","-- @return Vector Gravity Vector ( eg Vector(0,0,-600) )"],"code":["function physenv_lib.getGravity ()","\treturn SF.WrapObject( physenv.GetGravity() )","end",""],"class":"function","name":"physenv_lib.getGravity","summary":"\nGets the gravity vector ","private":false,"library":"physenv","description":"\nGets the gravity vector","param":[]}},"class":"library","summary":"\nPhysenv functions ","code":["local physenv_lib, _ = SF.Libraries.Register( \"physenv\" )",""],"fields":[],"name":"physenv","client":true,"description":"\nPhysenv functions","libtbl":"physenv_lib","tables":[],"server":true},"builtin":{"description":"\nBuilt in values. These don't need to be loaded; they are in the default environment.","code":["","-- ------------------------- Lua Ports ------------------------- --","-- This part is messy because of LuaDoc stuff.","","local function pascalToCamel ( t, r )","\tlocal r = r or {}","\tfor k, v in pairs( t ) do","\t\tk = k:gsub( \"^%l\", string.lower )","\t\tr[ k ] = v","\tend","\treturn r","end",""],"summary":"\nBuilt in values.","class":"library","tables":{"1":"IN_KEY","2":"KEY","3":"MOUSE","4":"math","5":"os","6":"string","7":"table","string":{"description":"\nLua's (not glua's) string library","code":["SF.DefaultEnvironment.string = setmetatable( {}, string_metatable )","","-- Math library","local math_methods, math_metatable = SF.Typedef(\"Library: math\")","filterGmodLua(math,math_methods)","math_metatable.__newindex = function() end","math_methods.clamp = math.Clamp","math_methods.angnorm = math.NormalizeAngle","math_methods.sign = function(a) return a>0 and 1 or -1 end","math_methods.round = math.Round","math_methods.randfloat = math.Rand","math_methods.calcBSplineN = nil"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.string","summary":"\nLua's (not glua's) string library ","library":"builtin","comment":["--- Lua's (not glua's) string library","-- @name SF.DefaultEnvironment.string","-- @class table"],"param":[]},"os":{"description":"\nGLua's os library. http://wiki.garrysmod.com/page/Category:os, plus sortByKey, sortByMember","code":["SF.DefaultEnvironment.os = setmetatable( {}, os_metatable )","","local table_methods, table_metatable = SF.Typedef(\"Library: table\")","filterGmodLua(table,table_methods)","table_methods.sortByKey = table.SortByKey","table_methods.sortByMember = table.SortByMember","table_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.os","summary":"\nGLua's os library.","library":"builtin","comment":["--- GLua's os library. http://wiki.garrysmod.com/page/Category:os, plus sortByKey, sortByMember","-- @name SF.DefaultEnvironment.os","-- @class table"],"param":[]},"table":{"description":"\nLua's (not glua's) table library","code":["SF.DefaultEnvironment.table = setmetatable({},table_metatable)","","-- ------------------------- Functions ------------------------- --",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.table","summary":"\nLua's (not glua's) table library ","library":"builtin","comment":["--- Lua's (not glua's) table library","-- @name SF.DefaultEnvironment.table","-- @class table"],"param":[]},"math":{"description":"\nLua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN","code":["SF.DefaultEnvironment.math = setmetatable({},math_metatable)","","local os_methods, os_metatable = SF.Typedef( \"Library: os\" )","filterGmodLua( os, os_methods )","os_metatable.__newindex = function () end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.math","summary":"\nLua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN ","library":"builtin","comment":["--- Lua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN","-- @name SF.DefaultEnvironment.math","-- @class table"],"param":[]},"IN_KEY":{"description":"\nENUMs of in_keys for use with player:keyDown","code":["SF.DefaultEnvironment.IN_KEY = setmetatable( {}, {","\t__index = _INKEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.IN_KEY","summary":"\nENUMs of in_keys for use with player:keyDown ","library":"builtin","comment":["--- ENUMs of in_keys for use with player:keyDown","-- @name SF.DefaultEnvironment.IN_KEY","-- @class table"],"param":[]},"MOUSE":{"description":"\nENUMs of mouse buttons for use with input library","code":["SF.DefaultEnvironment.MOUSE = setmetatable( {}, {","\t__index = _MOUSE,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _INKEY = {","\t[ \"ALT1\" ] = IN_ALT1,","\t[ \"ALT2\" ] = IN_ALT2,","\t[ \"ATTACK\" ] = IN_ATTACK,","\t[ \"ATTACK2\" ] = IN_ATTACK2,","\t[ \"BACK\" ] = IN_BACK,","\t[ \"DUCK\" ] = IN_DUCK,","\t[ \"FORWARD\" ] = IN_FORWARD,","\t[ \"JUMP\" ] = IN_JUMP,","\t[ \"LEFT\" ] = IN_LEFT,","\t[ \"MOVELEFT\" ] = IN_MOVELEFT,","\t[ \"MOVERIGHT\" ] = IN_MOVERIGHT,","\t[ \"RELOAD\" ] = IN_RELOAD,","\t[ \"RIGHT\" ] = IN_RIGHT,","\t[ \"SCORE\" ] = IN_SCORE,","\t[ \"SPEED\" ] = IN_SPEED,","\t[ \"USE\" ] = IN_USE,","\t[ \"WALK\" ] = IN_WALK,","\t[ \"ZOOM\" ] = IN_ZOOM,","\t[ \"GRENADE1\" ] = IN_GRENADE1,","\t[ \"GRENADE2\" ] = IN_GRENADE2,","\t[ \"WEAPON1\" ] = IN_WEAPON1,","\t[ \"WEAPON2\" ] = IN_WEAPON2,","\t[ \"BULLRUSH\" ] = IN_BULLRUSH,","\t[ \"CANCEL\" ] = IN_CANCEL,","\t[ \"RUN\" ] = IN_RUN,","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.MOUSE","summary":"\nENUMs of mouse buttons for use with input library ","library":"builtin","comment":["--- ENUMs of mouse buttons for use with input library","-- @name SF.DefaultEnvironment.MOUSE","-- @class table"],"param":[]},"KEY":{"description":"\nENUMs of keyboard keys for use with input library","code":["SF.DefaultEnvironment.KEY = setmetatable( {}, {","\t__index = _KEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _MOUSE = {","\t[ \"MOUSE1\" ] = 107,","\t[ \"LEFT\" ] = 107,","\t[ \"MOUSE2\" ] = 108,","\t[ \"RIGHT\" ] = 108,","\t[ \"MOUSE3\" ] = 109,","\t[ \"MIDDLE\" ] = 109,","\t[ \"MOUSE4\" ] = 110,","\t[ \"4\" ] = 110,","\t[ \"MOUSE5\"] = 111,","\t[ \"5\" ] = 111,","\t[ \"MWHEELUP\" ] = 112,","\t[ \"WHEEL_UP\" ] = 112,","\t[ \"MWHEELDOWN\" ] = 113,","\t[ \"WHEEL_DOWN\" ] = 113,","\t[ \"COUNT\" ] = 7,","\t[ \"FIRST\" ] = 107,","\t[ \"LAST\" ] = 113","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.KEY","summary":"\nENUMs of keyboard keys for use with input library ","library":"builtin","comment":["--- ENUMs of keyboard keys for use with input library","-- @name SF.DefaultEnvironment.KEY","-- @class table"],"param":[]}},"functions":{"1":"assert","2":"concmd","3":"dodir","4":"dofile","5":"error","6":"getLibraries","7":"getfenv","8":"getmetatable","9":"ipairs","10":"loadstring","11":"next","12":"pairs","13":"print","14":"printTable","15":"quotaAverage","16":"quotaMax","17":"quotaUsed","18":"rawget","19":"rawset","20":"require","21":"requiredir","22":"setfenv","23":"setmetatable","24":"throw","25":"tonumber","26":"tostring","27":"try","28":"type","29":"unpack","getLibraries":{"ret":"Table containing the names of each available library","comment":["--- Gets a list of all libraries","-- @return Table containing the names of each available library"],"code":["function SF.DefaultEnvironment.getLibraries()","\tlocal ret = {}","\tfor k,v in pairs( SF.Libraries.libraries ) do","\t\tret[#ret+1] = k","\tend","\treturn ret","end","","","","if SERVER then"],"class":"function","name":"SF.DefaultEnvironment.getLibraries","summary":"\nGets a list of all libraries ","private":false,"library":"builtin","description":"\nGets a list of all libraries","param":[]},"printTable":{"comment":["--- Prints a table to player's chat","-- @param tbl Table to print"],"code":["function SF.DefaultEnvironment.printTable ( tbl )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tSF.CheckType( tbl, \"table\" )","","\tprintTableX( ( SERVER and SF.instance.player or LocalPlayer() ), tbl, 0, { t = true } )","end","",""],"class":"function","name":"SF.DefaultEnvironment.printTable","summary":"\nPrints a table to player's chat ","private":false,"library":"builtin","description":"\nPrints a table to player's chat","param":{"1":"tbl","tbl":"Table to print"}},"tostring":{"ret":"obj as string","description":"\nSame as Lua's tostring","code":["SF.DefaultEnvironment.tostring = tostring"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tostring","summary":"\nSame as Lua's tostring ","library":"builtin","comment":["--- Same as Lua's tostring","-- @name SF.DefaultEnvironment.tostring","-- @class function","-- @param obj","-- @return obj as string"],"param":{"1":"obj","obj":""}},"print":{"comment":["\t--- Prints a message to the player's chat.","\t-- @shared","\t-- @param ... Values to print"],"code":["\tfunction SF.DefaultEnvironment.print(...)","\t\tlocal str = \"\"","\t\tlocal tbl = {n=select('#', ...), ...}","\t\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t\tSF.instance.player:ChatPrint(str)","\tend","else","\t-- Prints a message to the player's chat.","\tfunction SF.DefaultEnvironment.print(...)","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tlocal str = \"\"","\t\tlocal tbl = {n=select('#', ...), ...}","\t\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t\tLocalPlayer():ChatPrint(str)","\tend","end","","local function printTableX ( target, t, indent, alreadyprinted )","\tfor k,v in SF.DefaultEnvironment.pairs( t ) do","\t\tif SF.GetType( v ) == \"table\" and not alreadyprinted[ v ] then","\t\t\talreadyprinted[ v ] = true","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \":\" )","\t\t\tprintTableX( target, v, indent + 1, alreadyprinted )","\t\telse","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \"\\t=\\t\" .. tostring( v ) )","\t\tend","\tend","end",""],"class":"function","summary":"\nPrints a message to the player's chat.","library":"builtin","name":"SF.DefaultEnvironment.print","server":true,"private":false,"client":true,"description":"\nPrints a message to the player's chat.","param":{"1":"...","...":"Values to print"}},"rawget":{"ret":"The value of the index","comment":["--- Gets the value of a table index without invoking a metamethod","--@param table The table to get the value from","--@param key The index of the table","--@return The value of the index"],"code":["function SF.DefaultEnvironment.rawget( table, key, value )","    SF.CheckType( table, \"table\" )","","    return rawget( table, key )","end","","-- ------------------------- Restrictions ------------------------- --","-- Restricts access to builtin type's metatables","","local _R = debug.getregistry()","local function restrict(instance, hook, name, ok, err)","\t_R.Vector.__metatable = \"Vector\"","\t_R.Angle.__metatable = \"Angle\"","\t_R.VMatrix.__metatable = \"VMatrix\"","end","","local function unrestrict(instance, hook, name, ok, err)","\t_R.Vector.__metatable = nil","\t_R.Angle.__metatable = nil","\t_R.VMatrix.__metatable = nil","end","","SF.Libraries.AddHook(\"prepare\", restrict)","SF.Libraries.AddHook(\"cleanup\", unrestrict)","",""],"class":"function","name":"SF.DefaultEnvironment.rawget","summary":"\nGets the value of a table index without invoking a metamethod ","private":false,"library":"builtin","description":"\nGets the value of a table index without invoking a metamethod","param":{"1":"table","2":"key","3":"value","key":"The index of the table","table":"The table to get the value from"}},"rawset":{"comment":["--- Set the value of a table index without invoking a metamethod","--@param table The table to modify","--@param key The index of the table","--@param value The value to set the index equal to"],"code":["function SF.DefaultEnvironment.rawset( table, key, value )","    SF.CheckType( table, \"table\" )","","    rawset( table, key, value )","end",""],"class":"function","name":"SF.DefaultEnvironment.rawset","summary":"\nSet the value of a table index without invoking a metamethod ","private":false,"library":"builtin","description":"\nSet the value of a table index without invoking a metamethod","param":{"1":"table","2":"key","3":"value","value":"The value to set the index equal to","key":"The index of the table","table":"The table to modify"}},"tonumber":{"ret":"obj as number","description":"\nSame as Lua's tonumber","code":["SF.DefaultEnvironment.tonumber = tonumber",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tonumber","summary":"\nSame as Lua's tonumber ","library":"builtin","comment":["--- Same as Lua's tonumber","-- @name SF.DefaultEnvironment.tonumber","-- @class function","-- @param obj","-- @return obj as number"],"param":{"1":"obj","obj":""}},"error":{"comment":["--- Throws a raw exception.","-- @param msg Exception message"],"code":["function SF.DefaultEnvironment.error ( msg )","\terror( msg or \"an unspecified error occured\", 2 )","end",""],"class":"function","name":"SF.DefaultEnvironment.error","summary":"\nThrows a raw exception.","private":false,"library":"builtin","description":"\nThrows a raw exception.","param":{"1":"msg","msg":"Exception message"}},"unpack":{"ret":"Elements of tbl","description":"\nSame as Lua's unpack","code":["SF.DefaultEnvironment.unpack = unpack",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.unpack","summary":"\nSame as Lua's unpack ","library":"builtin","comment":["--- Same as Lua's unpack","-- @name SF.DefaultEnvironment.unpack","-- @class function","-- @param tbl","-- @return Elements of tbl"],"param":{"1":"tbl","tbl":""}},"throw":{"comment":["--- Throws an exception","-- @param msg Message","-- @param level Which level in the stacktrace to blame. Defaults to one of invalid","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.DefaultEnvironment.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" )","\tif not filename then","\t\tinfo = debug.getinfo( 2, \"Sl\" )","\t\tfilename = info.short_src:match( \"^SF:(.*)$\" )","\tend","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"class":"function","name":"SF.DefaultEnvironment.throw","summary":"\nThrows an exception ","private":false,"library":"builtin","description":"\nThrows an exception","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame. Defaults to one of invalid"}},"try":{"comment":["--- Try to execute a function and catch possible exceptions","-- Similar to xpcall, but a bit more in-depth","-- @param func Function to execute","-- @param catch Optional function to execute in case func fails"],"code":["function SF.DefaultEnvironment.try ( func, catch )","\tlocal ok, err = pcall( func )","\tif ok then return end","","\tif type( err ) == \"table\" then","\t\tif err.uncatchable then","\t\t\terror( err )","\t\tend","\tend","\tif catch then catch( err ) end","end",""],"class":"function","name":"SF.DefaultEnvironment.try","summary":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth ","private":false,"library":"builtin","description":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth","param":{"1":"func","2":"catch","func":"Function to execute","catch":"Optional function to execute in case func fails"}},"require":{"ret":"Return value of the script","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.require(file)","\tSF.CheckType(file, \"string\")","\tlocal loaded = SF.instance.data.reqloaded","\tif not loaded then","\t\tloaded = {}","\t\tSF.instance.data.reqloaded = loaded","\tend","\t","\tif loaded[file] then","\t\treturn loaded[file]","\telse","\t\tlocal func = SF.instance.scripts[file]","\t\tif not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","\t\tloaded[file] = func() or true","\t\treturn loaded[file]","\tend","end",""],"class":"function","name":"SF.DefaultEnvironment.require","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"quotaUsed":{"ret":"Current quota used this Think","comment":["--- Returns the current count for this Think's CPU Time.","-- This value increases as more executions are done, may not be exactly as you want.","-- If used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","-- @return Current quota used this Think"],"code":["function SF.DefaultEnvironment.quotaUsed ()","\treturn SF.instance.cpu_total","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaUsed","summary":"\nReturns the current count for this Think's CPU Time.","private":false,"library":"builtin","description":"\nReturns the current count for this Think's CPU Time. \nThis value increases as more executions are done, may not be exactly as you want. \nIf used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","param":[]},"getfenv":{"ret":"Current environment","comment":["--- Simple version of Lua's getfenv","-- Returns the current environment","-- @return Current environment"],"code":["function SF.DefaultEnvironment.getfenv ()","\treturn getfenv()","end",""],"class":"function","name":"SF.DefaultEnvironment.getfenv","summary":"\nSimple version of Lua's getfenv \nReturns the current environment ","private":false,"library":"builtin","description":"\nSimple version of Lua's getfenv \nReturns the current environment","param":[]},"type":{"ret":"The name of the object's type.","comment":["--- Same as Lua's type","-- @name SF.DefaultEnvironment.type","-- @class function","-- @param obj Object to get type of","-- @return The name of the object's type."],"code":["SF.DefaultEnvironment.type = function( obj )","\tlocal tp = getmetatable( obj )","\treturn type(tp) == \"string\" and tp or type( obj )","end"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.type","summary":"\nSame as Lua's type ","private":false,"library":"builtin","description":"\nSame as Lua's type","param":{"1":"obj","obj":"Object to get type of"}},"pairs":{"ret":["Iterator function","Table tbl","nil as current index"],"description":"\nSame as Lua's pairs","code":["SF.DefaultEnvironment.pairs = pairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.pairs","summary":"\nSame as Lua's pairs ","library":"builtin","comment":["--- Same as Lua's pairs","-- @name SF.DefaultEnvironment.pairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return nil as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"next":{"ret":["Key or nil","Value or nil"],"description":"\nSame as Lua's next","code":["SF.DefaultEnvironment.next = next"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.next","summary":"\nSame as Lua's next ","library":"builtin","comment":["--- Same as Lua's next","-- @name SF.DefaultEnvironment.next","-- @class function","-- @param tbl Table to get the next key-value pair of","-- @param k Previous key (can be nil)","-- @return Key or nil","-- @return Value or nil"],"param":{"1":"tbl","2":"k","tbl":"Table to get the next key-value pair of","k":"Previous key (can be nil)"}},"setfenv":{"ret":"func with environment set to tbl","comment":["--- Lua's setfenv","-- Works like setfenv, but is restricted on functions","-- @param func Function to change environment of","-- @param tbl New environment","-- @return func with environment set to tbl"],"code":["function SF.DefaultEnvironment.setfenv ( func, tbl )","\tif type( func ) ~= \"function\" then SF.throw( \"Main Thread is protected!\", 2 ) end","\treturn setfenv( func, tbl )","end",""],"class":"function","name":"SF.DefaultEnvironment.setfenv","summary":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions ","private":false,"library":"builtin","description":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions","param":{"1":"func","2":"tbl","func":"Function to change environment of","tbl":"New environment"}},"assert":{"comment":["--- Same as Lua's assert.","-- @name SF.DefaultEnvironment.assert","-- @class function","-- @param condition","-- @param msg"],"code":["SF.DefaultEnvironment.assert = function ( condition, msg ) if not condition then SF.throw( msg or \"assertion failed!\", 2 ) end end"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.assert","summary":"\nSame as Lua's assert.","private":false,"library":"builtin","description":"\nSame as Lua's assert.","param":{"1":"condition","2":"msg","condition":"","msg":""}},"dodir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included directory, but does not cache the result.","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.dodir( dir, loadpriority )","    SF.CheckType( dir, \"string\" )","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","","    local returns = {}","","    if loadpriority then","        for i = 0, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.dofile( file )","                end","            end","        end","    end","","    for file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 then","\t\t\treturns[ file ] = SF.DefaultEnvironment.dofile( file )","\t\tend","    end","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.dodir","summary":"\nRuns an included directory, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included directory, but does not cache the result.","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"quotaAverage":{"ret":"Average CPU Time of the buffer.","comment":["--- Gets the Average CPU Time in the buffer","-- @return Average CPU Time of the buffer."],"code":["function SF.DefaultEnvironment.quotaAverage ()","\treturn SF.instance.cpu_average","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaAverage","summary":"\nGets the Average CPU Time in the buffer ","private":false,"library":"builtin","description":"\nGets the Average CPU Time in the buffer","param":[]},"loadstring":{"ret":"Function of str","comment":["--- GLua's loadstring","-- Works like loadstring, except that it executes by default in the main environment","-- @param str String to execute","-- @return Function of str"],"code":["function SF.DefaultEnvironment.loadstring ( str )","\tlocal func = CompileString( str, \"SF: \" .. tostring( SF.instance.env ), false )","\t","\t-- CompileString returns an error as a string, better check before setfenv","\tif type( func ) == \"function\" then","\t\treturn setfenv( func, SF.instance.env )","\tend","\t","\treturn func","end",""],"class":"function","name":"SF.DefaultEnvironment.loadstring","summary":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment ","private":false,"library":"builtin","description":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment","param":{"1":"str","str":"String to execute"}},"setmetatable":{"ret":"tbl with metatable set to meta","description":"\nSame as Lua's setmetatable. Doesn't work on most internal metatables","code":["SF.DefaultEnvironment.setmetatable = setmetatable",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.setmetatable","summary":"\nSame as Lua's setmetatable.","library":"builtin","comment":["--- Same as Lua's setmetatable. Doesn't work on most internal metatables","-- @name SF.DefaultEnvironment.setmetatable","-- @class function","-- @param tbl The table to set the metatable of","-- @param meta The metatable to use","-- @return tbl with metatable set to meta"],"param":{"1":"tbl","2":"meta","tbl":"The table to set the metatable of","meta":"The metatable to use"}},"requiredir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.requiredir( dir, loadpriority )","    SF.CheckType( dir, \"string\")","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","    ","    local returns = {}","","    if loadpriority then","        for i = 1, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.require( file )","                end","            end","        end","    end","","\tfor file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 and not returns[ file ] then","\t\t\treturns[ file ] = SF.DefaultEnvironment.require( file )","\t\tend","\tend","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.requiredir","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"dofile":{"ret":"Return value of the script","comment":["--- Runs an included script, but does not cache the result.","-- Pretty much like standard Lua dofile()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.dofile(file)","    SF.CheckType(file, \"string\")","    local func = SF.instance.scripts[file]","    if not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","    return func()","end",""],"class":"function","name":"SF.DefaultEnvironment.dofile","summary":"\nRuns an included script, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included script, but does not cache the result. \nPretty much like standard Lua dofile()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"ipairs":{"ret":["Iterator function","Table tbl","0 as current index"],"description":"\nSame as Lua's ipairs","code":["SF.DefaultEnvironment.ipairs = ipairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.ipairs","summary":"\nSame as Lua's ipairs ","library":"builtin","comment":["--- Same as Lua's ipairs","-- @name SF.DefaultEnvironment.ipairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return 0 as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"quotaMax":{"ret":"Max SysTime allowed to take for execution of the chip in a Think.","comment":["--- Gets the CPU Time max.","-- CPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","-- @return Max SysTime allowed to take for execution of the chip in a Think."],"code":["function SF.DefaultEnvironment.quotaMax ()","\treturn SF.instance.context.cpuTime.getMax()","end","","-- The below modules have the Gmod functions removed (the ones that begin with a capital letter),","-- as requested by Divran","","-- Filters Gmod Lua files based on Garry's naming convention.","local function filterGmodLua(lib, original, gm)","\toriginal = original or {}","\tgm = gm or {}","\tfor name, func in pairs(lib) do","\t\tif name:match(\"^[A-Z]\") then","\t\t\tgm[name] = func","\t\telse","\t\t\toriginal[name] = func","\t\tend","\tend","\treturn original, gm","end","","-- String library","local string_methods, string_metatable = SF.Typedef( \"Library: string\" )","filterGmodLua( string, string_methods )","string_metatable.__newindex = function () end",""],"class":"function","name":"SF.DefaultEnvironment.quotaMax","summary":"\nGets the CPU Time max.","private":false,"library":"builtin","description":"\nGets the CPU Time max. \nCPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","param":[]},"getmetatable":{"ret":"The metatable of tbl","comment":["--- Same as Lua's getmetatable. Doesn't work on most internal metatables","-- @param tbl Table to get metatable of","-- @return The metatable of tbl"],"code":["SF.DefaultEnvironment.getmetatable = function(tbl)","\tSF.CheckType(tbl,\"table\")","\treturn getmetatable(tbl)","end",""],"class":"function","name":"SF.DefaultEnvironment.getmetatable","summary":"\nSame as Lua's getmetatable.","private":false,"library":"builtin","description":"\nSame as Lua's getmetatable. Doesn't work on most internal metatables","param":{"1":"tbl","tbl":"Table to get metatable of"}},"concmd":{"comment":["--- Execute a console command","-- @param cmd Command to execute"],"code":["function SF.DefaultEnvironment.concmd ( cmd )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end -- only execute on owner of screen","\tSF.CheckType( cmd, \"string\" )","\tSF.instance.player:ConCommand( cmd )","end",""],"class":"function","name":"SF.DefaultEnvironment.concmd","summary":"\nExecute a console command ","private":false,"library":"builtin","description":"\nExecute a console command","param":{"1":"cmd","cmd":"Command to execute"}}},"classForced":true,"fields":{"1":"CLIENT","2":"SERVER","CLIENT":{"description":"\nConstant that denotes whether the code is executed on the client","code":["SF.DefaultEnvironment.CLIENT = CLIENT"],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.CLIENT","summary":"\nConstant that denotes whether the code is executed on the client ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the client","-- @name SF.DefaultEnvironment.CLIENT","-- @class field"],"param":[]},"SERVER":{"description":"\nConstant that denotes whether the code is executed on the server","code":["SF.DefaultEnvironment.SERVER = SERVER",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.SERVER","summary":"\nConstant that denotes whether the code is executed on the server ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the server","-- @name SF.DefaultEnvironment.SERVER","-- @class field"],"param":[]}},"name":"builtin","libtbl":"SF.DefaultEnvironment","server":true,"client":true,"comment":["--- Built in values. These don't need to be loaded; they are in the default environment.","-- @name builtin","-- @shared","-- @class library","-- @libtbl SF.DefaultEnvironment"],"param":[]},"hook":{"comment":["--- Deals with hooks","-- @shared"],"functions":{"1":"add","2":"remove","3":"run","4":"runRemote","runRemote":{"ret":"tbl A list of the resultset of each called hook","comment":["--- Run a hook remotely.","-- This will call the hook \"remote\" on either a specified entity or all instances on the server/client","-- @shared","-- @param recipient Starfall entity to call the hook on. Nil to run on every starfall entity","-- @param ... Payload. These parameters will be used to call the hook functions","-- @return tbl A list of the resultset of each called hook"],"code":["function hook_library.runRemote ( recipient, ... )","\tif recipient then SF.CheckType( recipient, SF.Entities.Metatable ) end","","\tlocal recipients","\tif recipient then","\t\tlocal ent = SF.Entities.Unwrap( recipient )","\t\tif not ent.instance then SF.throw( \"Entity has no starfall instance\", 2 ) end","\t\trecipients = {","\t\t\t[ ent.instance ] = true","\t\t}","\telse","\t\trecipients = registered_instances","\tend","","\tlocal instance = SF.instance","","\tlocal result = {}","\tfor k, _ in pairs( recipients ) do","\t\tSF.instance = nil","\t\tresult = { k:runScriptHookForResult( \"remote\", instance.data.entity, instance.player, ... ) }","","\t\tlocal ok = table.remove( result, 1 )","\t\tif not ok then","\t\t\tif not result[ 1 ] then continue end -- Call failed because of non-existent hook. Ignore","\t\t\tk:Error( \"Hook 'remote' errored with \" .. result[ 1 ], result[ 2 ] )","\t\t\t-- Their fault - don't return","\t\tend","\tend","","\tSF.instance = instance","\treturn result","end",""],"class":"function","summary":"\nRun a hook remotely.","library":"hook","name":"hook_library.runRemote","server":true,"private":false,"client":true,"description":"\nRun a hook remotely. \nThis will call the hook \"remote\" on either a specified entity or all instances on the server/client","param":{"1":"recipient","2":"...","recipient":"Starfall entity to call the hook on. Nil to run on every starfall entity","...":"Payload. These parameters will be used to call the hook functions"}},"remove":{"comment":["--- Remove a hook","-- @shared","-- @param hookname The hook name","-- @param name The unique name for this hook"],"code":["function hook_library.remove ( hookname, name )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\t","\tlocal lower = hookname:lower()","\tif instance.hooks[ lower ] then","\t\tinstance.hooks[ lower ][ name ] = nil","\t\t","\t\tif not next( instance.hooks[ lower ] ) then","\t\t\tinstance.hooks[ lower ] = nil","\t\tend","\tend","\t","\tif not next( instance.hooks ) then","\t\tregistered_instances[ instance ] = nil","\tend","end","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tregistered_instances[ instance ] = nil","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, name, func, err )","\tif name == \"_runFunction\" and err == true then","\t\tregistered_instances[ instance ] = nil","\t\tinstance.hooks = {}","\tend","end)","","local wrapArguments = SF.Sanitize","","local function run ( hookname, customfunc, ... )","\tlocal result = {}","\tfor instance,_ in pairs( registered_instances ) do","\t\tlocal ret = { instance:runScriptHookForResult( hookname, wrapArguments( ... ) ) }","\t\t","\t\tlocal ok = table.remove( ret, 1 )","\t\tif ok then","\t\t\tif customfunc then","\t\t\t\tlocal sane = customfunc( instance, ret, ... )","\t\t\t\tresult = sane ~= nil and { sane } or result","\t\t\tend","\t\telse","\t\t\tinstance:Error( \"Hook '\" .. hookname .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\tend","\tend","\treturn unpack( result )","end","","","local hooks = {}"],"class":"function","summary":"\nRemove a hook ","library":"hook","name":"hook_library.remove","server":true,"private":false,"client":true,"description":"\nRemove a hook","param":{"1":"hookname","2":"name","name":"The unique name for this hook","hookname":"The hook name"}},"run":{"comment":["--- Run a hook","-- @shared","-- @param hookname The hook name","-- @param ... arguments"],"code":["function hook_library.run ( hookname, ... )","\tSF.CheckType( hookname, \"string\" )","\t","\tlocal instance = SF.instance","\tlocal lower = hookname:lower()","\t","\tSF.instance = nil -- Pretend we're not running an instance","\tlocal ret = { instance:runScriptHookForResult( lower, ... ) }","\tSF.instance = instance -- Set it back","\t","\tlocal ok = table.remove( ret, 1 )","\tif not ok then","\t\tinstance:Error( \"Hook '\" .. lower .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\treturn","\tend","\t","\treturn unpack( ret )","end",""],"class":"function","summary":"\nRun a hook ","library":"hook","name":"hook_library.run","server":true,"private":false,"client":true,"description":"\nRun a hook","param":{"1":"hookname","2":"...","...":"arguments","hookname":"The hook name"}},"add":{"comment":["--- Sets a hook function","-- @param hookname Name of the event","-- @param name Unique identifier","-- @param func Function to run"],"code":["function hook_library.add ( hookname, name, func )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tif func then SF.CheckType( func, \"function\" ) else return end","\t","\tlocal inst = SF.instance","\tlocal hooks = inst.hooks[ hookname:lower() ]","\tif not hooks then","\t\thooks = {}","\t\tinst.hooks[ hookname:lower() ] = hooks","\tend","\t","\thooks[ name ] = func","\tregistered_instances[ inst ] = true","end",""],"class":"function","name":"hook_library.add","summary":"\nSets a hook function ","private":false,"library":"hook","description":"\nSets a hook function","param":{"1":"hookname","2":"name","3":"func","func":"Function to run","name":"Unique identifier","hookname":"Name of the event"}}},"class":"library","summary":"\nDeals with hooks ","code":["local hook_library, _ = SF.Libraries.Register( \"hook\" )","local registered_instances = {}",""],"fields":[],"name":"hook","client":true,"description":"\nDeals with hooks","libtbl":"hook_library","tables":[],"server":true},"bit":{"comment":["--- Bitwise library","-- @shared"],"functions":{"1":"arshift","2":"band","3":"bnot","4":"bor","5":"bswap","6":"bxor","7":"lshift","8":"rol","9":"ror","10":"rshift","11":"tobit","12":"tohex","band":{"ret":"Bitwise and of all values","comment":["--- Bitwise and","-- @param value1 First value","-- @param ... More values","-- @return Bitwise and of all values"],"code":["function bit_library.band ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.band( value1, ... )","end",""],"class":"function","name":"bit_library.band","summary":"\nBitwise and ","private":false,"library":"bit","description":"\nBitwise and","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"rshift":{"ret":"Shifted value","comment":["--- Shift right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.rshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.rshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.rshift","summary":"\nShift right ","private":false,"library":"bit","description":"\nShift right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"bor":{"ret":"Bitwise or of all values","comment":["--- Bitwise or","-- @param value1 First value","-- @param ... More values","-- @return Bitwise or of all values"],"code":["function bit_library.bor ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.bor( value1, ... )","end",""],"class":"function","name":"bit_library.bor","summary":"\nBitwise or ","private":false,"library":"bit","description":"\nBitwise or","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"bnot":{"ret":"Negated value","comment":["--- Bitwise not","-- Negates every bit","-- @param value Value to be modified","-- @return Negated value"],"code":["function bit_library.bnot ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.bnot( value )","end",""],"class":"function","name":"bit_library.bnot","summary":"\nBitwise not \nNegates every bit ","private":false,"library":"bit","description":"\nBitwise not \nNegates every bit","param":{"1":"value","value":"Value to be modified"}},"bswap":{"ret":"Value with swapped byte order","comment":["--- Swaps byte order","-- @param value Value to be modified","-- @return Value with swapped byte order"],"code":["function bit_library.bswap ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.bswap( value )","end",""],"class":"function","name":"bit_library.bswap","summary":"\nSwaps byte order ","private":false,"library":"bit","description":"\nSwaps byte order","param":{"1":"value","value":"Value to be modified"}},"bxor":{"ret":"Bitwise xor of all values","comment":["--- Bitwise xor","-- @param value1 First value","-- @param ... More values","-- @return Bitwise xor of all values"],"code":["function bit_library.bxor ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.bxor( value1, ... )","end",""],"class":"function","name":"bit_library.bxor","summary":"\nBitwise xor ","private":false,"library":"bit","description":"\nBitwise xor","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"tobit":{"ret":"Clamped value","comment":["--- Clamps to 32-bit integer","-- @param value Value to be modified","-- @return Clamped value"],"code":["function bit_library.tobit ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.tobit( value )","end",""],"class":"function","name":"bit_library.tobit","summary":"\nClamps to 32-bit integer ","private":false,"library":"bit","description":"\nClamps to 32-bit integer","param":{"1":"value","value":"Value to be modified"}},"ror":{"ret":"Rotated value","comment":["--- Rotate right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Rotated value"],"code":["function bit_library.ror ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.ror( value, shiftCount )","end",""],"class":"function","name":"bit_library.ror","summary":"\nRotate right ","private":false,"library":"bit","description":"\nRotate right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"lshift":{"ret":"Shifted value","comment":["--- Shift left","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.lshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.lshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.lshift","summary":"\nShift left ","private":false,"library":"bit","description":"\nShift left","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"tohex":{"ret":"Hexadecimal representation","comment":["--- Returns the hexadecimal representation of the value","-- @param value Value","-- @param digits Amounts of digits. Optional.","-- @return Hexadecimal representation"],"code":["function bit_library.tohex ( value, digits )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( digits, \"number\" )","","\treturn bit.tohex( value, digits )","end"],"class":"function","name":"bit_library.tohex","summary":"\nReturns the hexadecimal representation of the value ","private":false,"library":"bit","description":"\nReturns the hexadecimal representation of the value","param":{"1":"value","2":"digits","value":"Value","digits":"Amounts of digits. Optional."}},"arshift":{"ret":"Shifted value","comment":["--- Arithmetic shift right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.arshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.arshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.arshift","summary":"\nArithmetic shift right ","private":false,"library":"bit","description":"\nArithmetic shift right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"rol":{"ret":"Rotated value","comment":["--- Rotate left","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Rotated value"],"code":["function bit_library.rol ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.rol( value, shiftCount )","end",""],"class":"function","name":"bit_library.rol","summary":"\nRotate left ","private":false,"library":"bit","description":"\nRotate left","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}}},"class":"library","summary":"\nBitwise library ","code":["local bit_library, _ = SF.Libraries.Register( \"bit\" )","local bit = bit",""],"fields":[],"name":"bit","client":true,"description":"\nBitwise library","libtbl":"bit_library","tables":[],"server":true},"find":{"comment":["--- Find library. Finds entities in various shapes.","-- @shared"],"functions":{"1":"all","2":"allPlayers","3":"byClass","4":"byModel","5":"inBox","6":"inCone","7":"inSphere","inBox":{"ret":"An array of found entities","comment":["--- Finds entities in a box","-- @param min Bottom corner","-- @param max Top corner","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inBox ( min, max, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( min, SF.Types[ \"Vector\" ] )","\tSF.CheckType( max, SF.Types[ \"Vector\" ] )","","\tlocal min, max = vunwrap( min ), vunwrap( max )","","\treturn convert( ents.FindInBox( min, max ), filter )","end",""],"class":"function","name":"find_library.inBox","summary":"\nFinds entities in a box ","private":false,"library":"find","description":"\nFinds entities in a box","param":{"1":"min","2":"max","3":"filter","max":"Top corner","min":"Bottom corner","filter":"Optional function to filter results"}},"inSphere":{"ret":"An array of found entities","comment":["--- Finds entities in a sphere","-- @param center Center of the sphere","-- @param radius Sphere radius","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inSphere ( center, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( center, SF.Types[ \"Vector\" ] )","\tSF.CheckType( radius, \"number\" )","","\tlocal center = vunwrap( center )","\t","\treturn convert( ents.FindInSphere( center, radius ), filter )","end",""],"class":"function","name":"find_library.inSphere","summary":"\nFinds entities in a sphere ","private":false,"library":"find","description":"\nFinds entities in a sphere","param":{"1":"center","2":"radius","3":"filter","radius":"Sphere radius","center":"Center of the sphere","filter":"Optional function to filter results"}},"byClass":{"ret":"An array of found entities","comment":["--- Finds entities by class name","-- @param class The class name","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byClass(class, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(class,\"string\")","\t\t","\treturn convert(ents.FindByClass(class), filter)","end",""],"class":"function","name":"find_library.byClass","summary":"\nFinds entities by class name ","private":false,"library":"find","description":"\nFinds entities by class name","param":{"1":"class","2":"filter","filter":"Optional function to filter results","class":"The class name"}},"allPlayers":{"ret":"An array of found entities","comment":["--- Finds all players (including bots)","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.allPlayers(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(player.GetAll(), filter)","end",""],"class":"function","name":"find_library.allPlayers","summary":"\nFinds all players (including bots) ","private":false,"library":"find","description":"\nFinds all players (including bots)","param":{"1":"filter","filter":"Optional function to filter results"}},"all":{"ret":"An array of found entities","comment":["--- Finds all entitites","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.all(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(ents.GetAll(), filter)","end"],"class":"function","name":"find_library.all","summary":"\nFinds all entitites ","private":false,"library":"find","description":"\nFinds all entitites","param":{"1":"filter","filter":"Optional function to filter results"}},"byModel":{"ret":"An array of found entities","comment":["--- Finds entities by model","-- @param model The model file","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byModel(model, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(model,\"string\")","\t\t","\treturn convert(ents.FindByModel(model), filter)","end",""],"class":"function","name":"find_library.byModel","summary":"\nFinds entities by model ","private":false,"library":"find","description":"\nFinds entities by model","param":{"1":"model","2":"filter","filter":"Optional function to filter results","model":"The model file"}},"inCone":{"ret":"An array of found entities","comment":["--- Finds entities in a cone","-- @param pos The cone vertex position","-- @param dir The direction to project the cone","-- @param distance The length to project the cone","-- @param radius The angle of the cone","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inCone ( pos, dir, distance, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( dir, SF.Types[ \"Vector\" ] )","\tSF.CheckType( distance, \"number\" )","\tSF.CheckType( radius, \"number\" )","","\tlocal pos, dir = vunwrap( pos ), vunwrap( dir )","\t","\treturn convert( ents.FindInCone( pos, dir, distance, radius ), filter )","end",""],"class":"function","name":"find_library.inCone","summary":"\nFinds entities in a cone ","private":false,"library":"find","description":"\nFinds entities in a cone","param":{"1":"pos","2":"dir","3":"distance","4":"radius","5":"filter","radius":"The angle of the cone","dir":"The direction to project the cone","distance":"The length to project the cone","filter":"Optional function to filter results","pos":"The cone vertex position"}}},"class":"library","summary":"\nFind library.","code":["local find_library, _ = SF.Libraries.Register(\"find\")","","local vunwrap = SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"find\", \"Find\", \"Allows the user to access the find library\" )","end","","local function convert(results, func)","\tif func then SF.CheckType(func,\"function\") end","\tlocal wrap = SF.WrapObject","\t","\tlocal t = {}","\tlocal count = 1","\tfor i=1,#results do","\t\tlocal e = wrap(results[i])","\t\tif not func or func(e) then","\t\t\tt[count] = e","\t\t\tcount = count + 1","\t\tend","\tend","\treturn t","end",""],"fields":[],"name":"find","client":true,"description":"\nFind library. Finds entities in various shapes.","libtbl":"find_library","tables":[],"server":true},"globaltables":{"comment":["--- Cross-instance tables","-- @shared"],"functions":[],"class":"library","summary":"\nCross-instance tables ","code":["local gtables_library, gtables_metamethods = SF.Libraries.Register(\"globaltables\")","","SF.GlobalTables = {}","","SF.GlobalTables.Global = {}","SF.GlobalTables.Players = {}",""],"fields":[],"name":"globaltables","client":true,"description":"\nCross-instance tables","libtbl":"gtables_library","tables":{"1":"global","2":"player","global":{"description":"\nGlobal table shared by all instances on the same side.","code":["gtables_library.global = SF.GlobalTables.Global",""],"class":"table","classForced":true,"name":"gtables_library.global","summary":"\nGlobal table shared by all instances on the same side.","library":"globaltables","comment":["--- Global table shared by all instances on the same side.","-- @name gtables_library.global","-- @class table"],"param":[]},"player":{"description":"\nPlayer-unique global table.","code":["","hook.Add(\"PlayerInitialSpawn\", \"SF_GlobalTables_cn\", function(ply)","\tSF.GlobalTables.Players[ply] = {}","end)","","hook.Add(\"PlayerDisconnected\", \"SF_GlobalTables_dc\", function(ply)","\tSF.GlobalTables.Players[ply] = nil","end)","","local oldindex = gtables_metamethods.__index","function gtables_metamethods:__index(k)","\tif k == \"player\" then","\t\treturn SF.GlobalTables.Players[SF.instance.player]","\telse","\t\treturn oldindex[k]","\tend","end"],"class":"table","classForced":true,"name":"gtables_library.player","summary":"\nPlayer-unique global table.","library":"globaltables","comment":["--- Player-unique global table.","-- @name gtables_library.player","-- @class table"],"param":[]}},"server":true},"game":{"comment":["--- Game functions","-- @shared"],"functions":{"1":"getGamemode","2":"getHostname","3":"getMap","4":"getMaxPlayers","5":"isDedicated","6":"isLan","7":"isSinglePlayer","getMaxPlayers":{"comment":["--- Returns the maximum player limit"],"code":["function game_lib.getMaxPlayers ()","\treturn game.MaxPlayers()","end"],"class":"function","name":"game_lib.getMaxPlayers","summary":"\nReturns the maximum player limit ","private":false,"library":"game","description":"\nReturns the maximum player limit","param":[]},"isLan":{"comment":["--- Returns true if the server is on a LAN","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.isLan ()","\treturn GetConVar( \"sv_lan\" ):GetBool()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.isLan","summary":"\nReturns true if the server is on a LAN ","private":false,"library":"game","description":"\nReturns true if the server is on a LAN","param":[]},"getMap":{"comment":["--- Returns the map name"],"code":["function game_lib.getMap ()","\treturn game.GetMap()","end",""],"class":"function","name":"game_lib.getMap","summary":"\nReturns the map name ","private":false,"library":"game","description":"\nReturns the map name","param":[]},"isDedicated":{"comment":["--- Returns whether or not the server is a dedicated server"],"code":["function game_lib.isDedicated ()","\treturn game.IsDedicated()","end",""],"class":"function","name":"game_lib.isDedicated","summary":"\nReturns whether or not the server is a dedicated server ","private":false,"library":"game","description":"\nReturns whether or not the server is a dedicated server","param":[]},"isSinglePlayer":{"comment":["--- Returns whether or not the current game is single player"],"code":["function game_lib.isSinglePlayer ()","\treturn game.SinglePlayer()","end",""],"class":"function","name":"game_lib.isSinglePlayer","summary":"\nReturns whether or not the current game is single player ","private":false,"library":"game","description":"\nReturns whether or not the current game is single player","param":[]},"getGamemode":{"comment":["--- Returns the gamemode as a String"],"code":["function game_lib.getGamemode ()","\tlocal rtn = {}","\tlocal t = gmod.GetGamemode()","\tfor k, v in pairs( t ) do","\t\tif type( v ) ~= \"function\" and type( v ) ~= \"table\" then","\t\t\trtn[ k:gsub( \"^%u\", string.lower ) ] = v","\t\tend","\tend","\treturn SF.Sanitize( rtn )","end",""],"class":"function","name":"game_lib.getGamemode","summary":"\nReturns the gamemode as a String ","private":false,"library":"game","description":"\nReturns the gamemode as a String","param":[]},"getHostname":{"comment":["--- Returns The hostname","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.getHostname ()","\treturn GetConVar( \"hostname\" ):GetString()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.getHostname","summary":"\nReturns The hostname ","private":false,"library":"game","description":"\nReturns The hostname","param":[]}},"class":"library","summary":"\nGame functions ","code":["local game_lib, _ = SF.Libraries.Register( \"game\" )",""],"fields":[],"name":"game","client":true,"description":"\nGame functions","libtbl":"game_lib","tables":[],"server":true},"input":{"comment":["--- Input library.","-- @client"],"functions":{"1":"getCursorPos","2":"getKeyName","3":"getMBName","4":"isControlDown","5":"isKeyDown","6":"isMBDown","7":"isShiftDown","8":"lookupBinding","9":"wasKeyPressed","10":"wasKeyReleased","11":"wasMBPressed","12":"wasMBReleased","getCursorPos":{"ret":["The x position of the mouse","The y position of the mouse"],"comment":["--- Gets the position of the mouse","-- @return The x position of the mouse","-- @return The y position of the mouse"],"code":["function input_methods.getCursorPos( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetCursorPos( )","end",""],"class":"function","name":"input_methods.getCursorPos","summary":"\nGets the position of the mouse ","private":false,"library":"input","description":"\nGets the position of the mouse","param":[]},"lookupBinding":{"ret":["The id of the first key bound","The name of the first key bound"],"comment":["--- Gets the first key that is bound to the command passed","-- @param bind The name of the bind","-- @return The id of the first key bound","-- @return The name of the first key bound"],"code":["","function input_methods.lookupBinding( binding )","\tSF.CheckType( binding, \"string\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal bind = input.LookupBinding( binding )","\tif bind then","\t\tbind = bind:upper( )","\t\treturn input_methods.KEY[ bind ] or input_methods.MOUSE[ bind ], bind","\tend","end",""],"class":"function","name":"input_methods.lookupBinding","summary":"\nGets the first key that is bound to the command passed ","private":false,"library":"input","description":"\nGets the first key that is bound to the command passed","param":{"1":"binding","2":"bind","bind":"The name of the bind"}},"isControlDown":{"ret":"True if the control key is down","comment":["--- Gets whether the control key is down","-- @return True if the control key is down"],"code":["function input_methods.isControlDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsControlDown( )","end",""],"class":"function","name":"input_methods.isControlDown","summary":"\nGets whether the control key is down ","private":false,"library":"input","description":"\nGets whether the control key is down","param":[]},"wasKeyReleased":{"ret":"True if the key was released","comment":["--- Gets whether the key was released this frame","-- @param key The key id, see input.KEY","-- @return True if the key was released"],"code":["function input_methods.wasKeyReleased( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.key[ key ] and keystate.key[ key ].wasReleased","end","","","for i = MOUSE_FIRST, MOUSE_LAST do","\tlastState.mouse[ i ] = false","\tkeystate.mouse[ i ] = {","\t\twasPressed = false,","\t\twasReleased = false","\t}","end","","local _MOUSENAMES = {","\t[ 107 ] = \"MOUSE1\",","\t[ 108 ] = \"MOUSE2\",","\t[ 109 ] = \"MOUSE3\",","\t[ 110 ] = \"MOUSE4\",","\t[ 111 ] = \"MOUSE5\",","\t[ 112 ] = \"MWHEELUP\",","\t[ 113 ] = \"MWHEELDOWN\"","}","","hook.Add( \"Think\", \"sf_keystate_mouse update\", function( )","\tfor i = MOUSE_FIRST, MOUSE_LAST do","\t\tlocal isKeyDown = input.IsMouseDown( i )","","\t\tlocal keyName = _MOUSENAMES[ i ]","","\t\tkeystate.mouse[ i ].wasPressed = isKeyDown and lastState.mouse[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.mouse[ i ] and keystate.mouse[ i ].wasPressed then","\t\t\trunInputHook( \"inputPressed\", \"mouse\", _MOUSENAMES[ i ]:upper( ) )","\t\tend","","\t\tkeystate.mouse[ i ].wasReleased = not isKeyDown and lastState.mouse[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.mouse[ i ] and keystate.mouse[ i ].wasReleased then","\t\t\trunInputHook( \"inputReleased\", \"mouse\", _MOUSENAMES[ i ]:upper( ) )","\t\tend","","\t\tlastState.mouse[ i ] = isKeyDown","\tend","end )",""],"class":"function","name":"input_methods.wasKeyReleased","summary":"\nGets whether the key was released this frame ","private":false,"library":"input","description":"\nGets whether the key was released this frame","param":{"1":"key","key":"The key id, see input.KEY"}},"wasMBReleased":{"ret":"True if the button was released","comment":["--- Gets whether the mouse button was released this frame","-- @param key The key id, see input.MOUSE","-- @return True if the button was released"],"code":["function input_methods.wasMBReleased( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.mouse[ key ] and keystate.mouse[ key ].wasReleased","end",""],"class":"function","name":"input_methods.wasMBReleased","summary":"\nGets whether the mouse button was released this frame ","private":false,"library":"input","description":"\nGets whether the mouse button was released this frame","param":{"1":"key","key":"The key id, see input.MOUSE"}},"getMBName":{"ret":"The name of the mouse button","comment":["--- Gets the name of a mouse button from the id","-- @param key The button id, see input.MOUSE","-- @return The name of the mouse button"],"code":["function input_methods.getMBName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn _MOUSENAMES[ key ]","end"],"class":"function","name":"input_methods.getMBName","summary":"\nGets the name of a mouse button from the id ","private":false,"library":"input","description":"\nGets the name of a mouse button from the id","param":{"1":"key","key":"The button id, see input.MOUSE"}},"wasKeyPressed":{"ret":"True if the key was pressed","comment":["--- Gets whether the key was pressed this frame","-- @param key The key id, see input.KEY","-- @return True if the key was pressed"],"code":["function input_methods.wasKeyPressed( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.key[ key ] and keystate.key[ key ].wasPressed","end",""],"class":"function","name":"input_methods.wasKeyPressed","summary":"\nGets whether the key was pressed this frame ","private":false,"library":"input","description":"\nGets whether the key was pressed this frame","param":{"1":"key","key":"The key id, see input.KEY"}},"isShiftDown":{"ret":"True if the shift key is down","comment":["--- Gets whether the shift key is down","-- @return True if the shift key is down"],"code":["function input_methods.isShiftDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsShiftDown( )","end",""],"class":"function","name":"input_methods.isShiftDown","summary":"\nGets whether the shift key is down ","private":false,"library":"input","description":"\nGets whether the shift key is down","param":[]},"isKeyDown":{"ret":"True if the key is down","comment":["--- Gets whether a key is down","-- @param key The key id, see input.KEY","-- @return True if the key is down"],"code":["function input_methods.isKeyDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsKeyDown( key )","end",""],"class":"function","name":"input_methods.isKeyDown","summary":"\nGets whether a key is down ","private":false,"library":"input","description":"\nGets whether a key is down","param":{"1":"key","key":"The key id, see input.KEY"}},"wasMBPressed":{"ret":"True if the button was pressed","comment":["--- Gets whether the mouse button was pressed this frame","-- @param key The button id, see input.MOUSE","-- @return True if the button was pressed"],"code":["function input_methods.wasMBPressed( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.mouse[ key ] and keystate.mouse[ key ].wasPressed","end",""],"class":"function","name":"input_methods.wasMBPressed","summary":"\nGets whether the mouse button was pressed this frame ","private":false,"library":"input","description":"\nGets whether the mouse button was pressed this frame","param":{"1":"key","key":"The button id, see input.MOUSE"}},"isMBDown":{"ret":"True if the mouse button is down","comment":["--- Gets whether a mouse button is down","-- @param key The mouse button, see input.MOUSE","-- @return True if the mouse button is down"],"code":["function input_methods.isMBDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsMouseDown( key )","end","","local lastState = { key = { }, mouse = { } }","local keystate = { key = { }, mouse = { } }","","for i = KEY_FIRST, KEY_LAST do","\tlastState.key[ i ] = false","\tkeystate.key[ i ] = {","\t\twasPressed = false,","\t\twasReleased = false","\t}","end","","local function runInputHook( hookname, scope, key )","\tfor instance,_ in pairs( SF.allInstances ) do","\t\tif not SF.Permissions.check( instance.player, nil, \"input.\" .. scope ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t\t","\t\t","\t\tinstance:runScriptHook( hookname, key )","\tend","end","","hook.Add( \"Think\", \"sf_keystate_key update\", function( )","\tfor i = KEY_FIRST, KEY_LAST do","\t\tlocal isKeyDown = input.IsKeyDown( i )","","\t\tlocal keyName = input.GetKeyName( i )","","\t\tkeystate.key[ i ].wasPressed = isKeyDown and lastState.key[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.key[ i ] and keystate.key[ i ].wasPressed then","\t\t\trunInputHook( \"inputPressed\", \"key\", input.GetKeyName( i ):upper( ) )","\t\tend","","\t\tkeystate.key[ i ].wasReleased = not isKeyDown and lastState.key[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.key[ i ] and keystate.key[ i ].wasReleased then","\t\t\trunInputHook( \"inputReleased\", \"key\", input.GetKeyName( i ):upper( ) )","\t\tend","\t\t","\t\tlastState.key[ i ] = isKeyDown","\tend","end )",""],"class":"function","name":"input_methods.isMBDown","summary":"\nGets whether a mouse button is down ","private":false,"library":"input","description":"\nGets whether a mouse button is down","param":{"1":"key","key":"The mouse button, see input.MOUSE"}},"getKeyName":{"ret":"The name of the key","comment":["--- Gets the name of a key from the id","-- @param key The key id, see input.KEY","-- @return The name of the key"],"code":["function input_methods.getKeyName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetKeyName( key )","end",""],"class":"function","name":"input_methods.getKeyName","summary":"\nGets the name of a key from the id ","private":false,"library":"input","description":"\nGets the name of a key from the id","param":{"1":"key","key":"The key id, see input.KEY"}}},"class":"library","summary":"\nInput library.","fields":[],"name":"input","client":true,"description":"\nInput library.","libtbl":"input_methods","tables":[],"code":["local input_methods, input_metamethods = SF.Libraries.Register( \"input\" )","","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"input\", \"Input\", \"Allows the user to use the input library\" )","\tP.registerPrivilege( \"input.key\", \"Keyboard\", \"Allows the user to poll keyboard inputs\" )","\tP.registerPrivilege( \"input.mouse\", \"Mouse\", \"Allows the user to poll mouse inputs\" )","end",""]},"entities":{"comment":["--- Entities Library","-- @shared"],"functions":{"1":"entity","2":"owner","3":"player","4":"self","self":{"ret":"Starfall entity","comment":["--- Returns the entity representing a processor that this script is running on.","-- May be nil","-- @return Starfall entity"],"code":["function ents_lib.self ()","\tlocal ent = SF.instance.data.entity","\tif ent then ","\t\treturn SF.Entities.Wrap( ent )","\telse return nil end","end",""],"class":"function","name":"ents_lib.self","summary":"\nReturns the entity representing a processor that this script is running on.","private":false,"library":"entities","description":"\nReturns the entity representing a processor that this script is running on. \nMay be nil","param":[]},"owner":{"ret":"Owner entity","comment":["--- Returns whoever created the script","-- @return Owner entity"],"code":["function ents_lib.owner ()","\treturn SF.WrapObject( SF.instance.player )","end",""],"class":"function","name":"ents_lib.owner","summary":"\nReturns whoever created the script ","private":false,"library":"entities","description":"\nReturns whoever created the script","param":[]},"entity":{"ret":"entity","comment":["--- Returns the entity with index 'num'","-- @name ents_lib.entity","-- @class function","-- @param num Entity index","-- @return entity"],"code":["function ents_lib.entity ( num )","\tSF.CheckType( num, \"number\" )","\t","\treturn SF.WrapObject( Entity( num ) )","end","","-- ------------------------- Methods ------------------------- --",""],"class":"function","classForced":true,"name":"ents_lib.entity","summary":"\nReturns the entity with index 'num' ","private":false,"library":"entities","description":"\nReturns the entity with index 'num'","param":{"1":"num","num":"Entity index"}},"player":{"ret":"Either the owner (server) or the local player (client)","description":"\nSame as ents_lib.owner() on the server. On the client, returns the local player","code":["if SERVER then","\tents_lib.player = ents_lib.owner","else","\tfunction ents_lib.player ()","\t\treturn SF.WrapObject( LocalPlayer() )","\tend","\t","\tlocal renderProperties = {","\t\t[1] = function( ent ) --Color\t","\t\t\tent:SetColor( Color( net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ) ) )","\t\tend,","\t\t[2] = function( ent ) --Nodraw","\t\t\tent:SetNoDraw( net.ReadBit() == 1 )","\t\tend,","\t\t[3] = function( ent ) --Material","\t\t\tent:SetMaterial( net.ReadString() )","\t\tend,","\t\t[4] = function( ent ) --Submaterial","\t\t\tent:SetSubMaterial( net.ReadUInt( 16 ), net.ReadString() )","\t\tend,","\t\t[5] = function( ent ) --Bodygroup","\t\t\tent:SetBodyGroup( net.ReadUInt( 16 ), net.ReadUInt ( 16 ) )","\t\tend,","\t\t[6] = function( ent ) --Skin","\t\t\tent:SetSkin( net.ReadUInt( 16 ) )","\t\tend","\t}","\t","\t--Net function that allows the server to set the render properties of entities for specific players","\tnet.Receive( \"sf_setentityrenderproperty\", function()","\t\tlocal ent = net.ReadEntity()","\t\tif not ent:IsValid() then return end","\t\tlocal property = net.ReadUInt( 4 )","\t\tif not renderProperties[ property ] then return end","\t\t","\t\trenderProperties[ property ]( ent )","\tend)","end",""],"class":"function","classForced":true,"name":"ents_lib.player","summary":"\nSame as ents_lib.owner() on the server.","library":"entities","comment":["--- Same as ents_lib.owner() on the server. On the client, returns the local player","-- @name ents_lib.player","-- @class function","-- @return Either the owner (server) or the local player (client)"],"param":[]}},"class":"library","summary":"\nEntities Library ","code":["local ents_lib, _ = SF.Libraries.Register( \"entities\" )","","-- ------------------------- Internal functions ------------------------- --","","SF.Entities.Wrap = wrap","SF.Entities.Unwrap = unwrap","SF.Entities.Methods = ents_methods","SF.Entities.Metatable = ents_metamethods","SF.Entities.Library = ents_lib",""],"fields":[],"name":"entities","client":true,"description":"\nEntities Library","libtbl":"ents_lib","tables":[],"server":true},"constraint":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @server"],"functions":{"1":"axis","2":"ballsocket","3":"ballsocketadv","4":"breakAll","5":"breakType","6":"elastic","7":"getTable","8":"nocollide","9":"rope","10":"setElasticLength","11":"setRopeLength","12":"slider","13":"weld","ballsocketadv":{"comment":["--- Advanced Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocketadv(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, minv, maxv, frictionv, rotateonly, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal mins = vunwrap( minv ) or Vector ( 0, 0, 0 )","\tlocal maxs = vunwrap( maxv ) or Vector ( 0, 0, 0 )","\tlocal frictions = vunwrap( frictionv ) or Vector ( 0, 0, 0 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocketadv\" )","\tcheckConstraint( ent2, \"constraints.ballsocketadv\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\trotateonly = rotateonly and 1 or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.AdvBallsocket(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, mins.x, mins.y, mins.z, maxs.x, maxs.y, maxs.z, frictions.x, frictions.y, frictions.z, rotateonly, nocollide)","end",""],"class":"function","summary":"\nAdvanced Ballsocket two entities ","name":"constraint_library.ballsocketadv","library":"constraint","private":false,"server":true,"description":"\nAdvanced Ballsocket two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","minv","maxv","frictionv","rotateonly","nocollide"]},"nocollide":{"comment":["--- Nocollides two entities","-- @server "],"code":["function constraint_library.nocollide(e1, e2, bone1, bone2)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.nocollide\" )","\tcheckConstraint( ent2, \"constraints.nocollide\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\t","\tconstraint.NoCollide(ent1, ent2, bone1, bone2)","end",""],"class":"function","summary":"\nNocollides two entities ","name":"constraint_library.nocollide","library":"constraint","private":false,"server":true,"description":"\nNocollides two entities","param":["e1","e2","bone1","bone2"]},"elastic":{"comment":["--- Elastic two entities","-- @server "],"code":["function constraint_library.elastic(index, e1, e2, bone1, bone2, v1, v2, const, damp, rdamp, width, strech)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.elastic\" )","\tcheckConstraint( ent2, \"constraints.elastic\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tconst = const or 1000","\tdamp = damp or 100","\trdamp = rdamp or 0","\twidth = math.Clamp( width or 0, 0, 50)","\tstrech = strech and true or false","\t","\te1.Elastics = e1.Elastics or {}","\te2.Elastics = e2.Elastics or {}","\t","\tlocal e = constraint.Elastic( ent1, ent2, bone1, bone2, vec1, vec2, const, damp, rdamp, \"cable/cable2\", width, strech )","\t","\te1.Elastics[index] = e","\te2.Elastics[index] = e","end",""],"class":"function","summary":"\nElastic two entities ","name":"constraint_library.elastic","library":"constraint","private":false,"server":true,"description":"\nElastic two entities","param":["index","e1","e2","bone1","bone2","v1","v2","const","damp","rdamp","width","strech"]},"getTable":{"ret":"Table of entity constraints","comment":["--- Returns the table of constraints on an entity","-- @param ent The entity","-- @return Table of entity constraints"],"code":["function constraint_library.getTable( ent )","\tSF.CheckType( ent, ents_metatable )","","\tent = eunwrap( ent )","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn SF.Sanitize(constraint.GetTable( ent ))","end"],"class":"function","name":"constraint_library.getTable","summary":"\nReturns the table of constraints on an entity ","private":false,"library":"constraint","description":"\nReturns the table of constraints on an entity","param":{"1":"ent","ent":"The entity"}},"axis":{"comment":["--- Axis two entities","-- @server"],"code":["function constraint_library.axis(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, friction, nocollide, laxis)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal axis = laxis and vunwrap( laxis ) or nil","\t","\tcheckConstraint( ent1, \"constraints.axis\" )","\tcheckConstraint( ent2, \"constraints.axis\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tfriction = friction or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.Axis(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, friction, nocollide, axis)","end",""],"class":"function","summary":"\nAxis two entities ","name":"constraint_library.axis","library":"constraint","private":false,"server":true,"description":"\nAxis two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","friction","nocollide","laxis"]},"setElasticLength":{"comment":["--- Sets the length of an elastic attached to the entity","-- @server "],"code":["function constraint_library.setElasticLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.elastic\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlength = math.max( length or 0, 0)","","\tif e.Elastics then","\t\tlocal con = e.Elastics[index]","\t\tif IsValid(con) then","\t\t\tcon:Fire(\"SetSpringLength\", length, 0)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of an elastic attached to the entity ","name":"constraint_library.setElasticLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of an elastic attached to the entity","param":["index","e","length"]},"breakType":{"comment":["--- Breaks all constraints of a certain type on an entity","-- @server "],"code":["function constraint_library.breakType(e, typename)","\tSF.CheckType( e, ents_metatable )","    SF.CheckType( typename, \"string\" )","\t","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveConstraints(ent1, typename)","end","",""],"class":"function","summary":"\nBreaks all constraints of a certain type on an entity ","name":"constraint_library.breakType","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints of a certain type on an entity","param":["e","typename"]},"weld":{"comment":["--- Welds two entities","-- @param e1 The first entity","-- @param e2 The second entity","-- @param bone1 Number bone of the first entity","-- @param bone2 Number bone of the second entity","-- @param force_lim Max force the weld can take before breaking","-- @param nocollide Bool whether or not to nocollide the two entities","-- @server"],"code":["function constraint_library.weld(e1, e2, bone1, bone2, force_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.weld\" )","\tcheckConstraint( ent2, \"constraints.weld\" )","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\tnocollide = nocollide and true or false","\t","\tconstraint.Weld(ent1, ent2, bone1, bone2, force_lim, nocollide)","end",""],"class":"function","summary":"\nWelds two entities ","name":"constraint_library.weld","library":"constraint","private":false,"server":true,"description":"\nWelds two entities","param":{"1":"e1","2":"e2","3":"bone1","4":"bone2","5":"force_lim","6":"nocollide","e2":"The second entity","e1":"The first entity","bone2":"Number bone of the second entity","nocollide":"Bool whether or not to nocollide the two entities","bone1":"Number bone of the first entity","force_lim":"Max force the weld can take before breaking"}},"rope":{"comment":["--- Ropes two entities","-- @server "],"code":["function constraint_library.rope(index, e1, e2, bone1, bone2, v1, v2, length, addlength, force_lim, width, material, rigid)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.rope\" )","\tcheckConstraint( ent2, \"constraints.rope\" )","","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tlength = length or 0","\taddlength = addlength or 0","\tforce_lim = force_lim or 0","\twidth = math.Clamp( width or 0, 0, 50)","\trigid = rigid and true or false","\t","\te1.Ropes = e1.Ropes or {}","\te2.Ropes = e2.Ropes or {}","\t","\tlocal e = constraint.Rope( ent1, ent2, bone1, bone2, vec1, vec2, length, addlength, force_lim, width, material, rigid )","\t","\te1.Ropes[index] = e","\te2.Ropes[index] = e","end",""],"class":"function","summary":"\nRopes two entities ","name":"constraint_library.rope","library":"constraint","private":false,"server":true,"description":"\nRopes two entities","param":["index","e1","e2","bone1","bone2","v1","v2","length","addlength","force_lim","width","material","rigid"]},"breakAll":{"comment":["--- Breaks all constraints on an entity","-- @server "],"code":["function constraint_library.breakAll(e)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveAll(ent1)","end",""],"class":"function","summary":"\nBreaks all constraints on an entity ","name":"constraint_library.breakAll","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints on an entity","param":["e"]},"setRopeLength":{"comment":["--- Sets the length of a rope attached to the entity","-- @server "],"code":["function constraint_library.setRopeLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.rope\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlength = math.max( length or 0, 0)","","\t","\tif e.Ropes then","\t\tlocal con = e.Ropes[index]","\t\tif IsValid(con) then","\t\t\tcon:SetKeyValue(\"addlength\", length)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of a rope attached to the entity ","name":"constraint_library.setRopeLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of a rope attached to the entity","param":["index","e","length"]},"ballsocket":{"comment":["--- Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocket(e1, e2, bone1, bone2, v1, force_lim, torque_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocket\" )","\tcheckConstraint( ent2, \"constraints.ballsocket\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.Ballsocket(ent1, ent2, bone1, bone2, vec1, force_lim, torque_lim, nocollide)","end",""],"class":"function","summary":"\nBallsocket two entities ","name":"constraint_library.ballsocket","library":"constraint","private":false,"server":true,"description":"\nBallsocket two entities","param":["e1","e2","bone1","bone2","v1","force_lim","torque_lim","nocollide"]},"slider":{"comment":["--- Sliders two entities","-- @server "],"code":["function constraint_library.slider(e1, e2, bone1, bone2, v1, v2, width)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.slider\" )","\tcheckConstraint( ent2, \"constraints.slider\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\twidth = math.Clamp( width or 0, 0, 50)","","\tconstraint.Slider(ent1, ent2, bone1, bone2, vec1, vec2, width, \"cable/cable2\")","end",""],"class":"function","summary":"\nSliders two entities ","name":"constraint_library.slider","library":"constraint","private":false,"server":true,"description":"\nSliders two entities","param":["e1","e2","bone1","bone2","v1","v2","width"]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","fields":[],"name":"constraint","code":["local constraint_library, constraint_library_metamethods = SF.Libraries.Register(\"constraint\")","","local ents_metatable = SF.Entities.Metatable","local vunwrap = SF.UnwrapObject","local eunwrap = SF.Entities.Unwrap","local vwrap = SF.WrapObject","local ewrap = SF.Entities.Wrap","","local function checkConstraint(e, t)","\tif e then","\t\tif e:IsValid() then","\t\t\tif not SF.Permissions.check( SF.instance.player, e, t ) then","\t\t\t\tSF.throw( \"Insufficient permissions\", 3 )","\t\t\tend","\t\telseif not e:IsWorld() then","\t\t\tSF.throw( \"Invalid Entity\", 3 )","\t\tend","\telse","\t\tSF.throw( \"Invalid Entity\", 3 )","\tend","end","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"constraints.weld\", \"Weld\", \"Allows the user to weld two entities\" )","\tP.registerPrivilege( \"constraints.axis\", \"Axis\", \"Allows the user to axis two entities\" )","\tP.registerPrivilege( \"constraints.ballsocket\", \"Ballsocket\", \"Allows the user to ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.ballsocketadv\", \"BallsocketAdv\", \"Allows the user to advanced ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.slider\", \"Slider\", \"Allows the user to slider two entities\" )","\tP.registerPrivilege( \"constraints.rope\", \"Rope\", \"Allows the user to rope two entities\" )","\tP.registerPrivilege( \"constraints.elastic\", \"Elastic\", \"Allows the user to elastic two entities\" )","\tP.registerPrivilege( \"constraints.nocollide\", \"Nocollide\", \"Allows the user to nocollide two entities\" )","\tP.registerPrivilege( \"constraints.any\", \"Any\", \"General constraint functions\" )","end",""],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"constraint_library","tables":[],"server":true},"http":{"comment":["--- Http library. Requests content from urls.","-- @shared"],"functions":{"1":"canRequest","2":"get","3":"post","post":{"comment":["--- Runs a new http POST request","-- @param url http target url","-- @param params POST parameters to be sent","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.post ( url, params, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\t","\tif params then","\t\tSF.CheckType( params, \"table\" )","\t\tfor k,v in pairs( params ) do","\t\t\tif type( k ) ~= \"string\" or type( v ) ~= \"string\" then","\t\t\t\tSF.throw( \"Post parameters can only contain string keys and string values\", 2 )","\t\t\tend","\t\tend","\tend","\t","\tSF.CheckType( callbackSuccess, \"function\" )\t","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Post( url, params, function ( body, len, headers, code )","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end"],"class":"function","name":"http_library.post","summary":"\nRuns a new http POST request ","private":false,"library":"http","description":"\nRuns a new http POST request","param":{"1":"url","2":"params","3":"callbackSuccess","4":"callbackFail","callbackFail":"the function to be called on request fail, taking the failing reason as an argument","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","params":"POST parameters to be sent"}},"canRequest":{"comment":["--- Checks if a new http request can be started"],"code":["function http_library.canRequest ( )","\tlocal httpData = SF.instance.data.http","\treturn CurTime() - httpData.lastRequest >= http_interval:GetFloat() and httpData.active < http_max_active:GetInt()","end",""],"class":"function","name":"http_library.canRequest","summary":"\nChecks if a new http request can be started ","private":false,"library":"http","description":"\nChecks if a new http request can be started","param":[]},"get":{"comment":["--- Runs a new http GET request","-- @param url http target url","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.get ( url, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\tSF.CheckType( callbackSuccess, \"function\" )","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Fetch( url, function ( body, len, headers, code ) ","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end",""],"class":"function","name":"http_library.get","summary":"\nRuns a new http GET request ","private":false,"library":"http","description":"\nRuns a new http GET request","param":{"1":"url","2":"callbackSuccess","3":"callbackFail","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","callbackFail":"the function to be called on request fail, taking the failing reason as an argument"}}},"class":"library","summary":"\nHttp library.","code":["local http_library, _ = SF.Libraries.Register( \"http\" )","local http_interval = CreateConVar( \"sf_http_interval\", \"0.5\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"Interval in seconds in which one http request can be made\" )","local http_max_active = CreateConVar( \"sf_http_max_active\", \"3\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"The maximum amount of active http requests at the same time\" )","","-- Initializes the lastRequest variable to a value which ensures that the first call to httpRequestReady returns true","-- and the \"active requests counter\" to 0","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.http = {","\t\tlastRequest = 0,","\t\tactive = 0","\t}","end )","","-- Returns an error when a http request was already triggered in the current interval","-- or the maximum amount of simultaneous requests is currently active, returns true otherwise","local function httpRequestReady ( instance )","\tlocal httpData = instance.data.http","\tif CurTime() - httpData.lastRequest < http_interval:GetFloat() or httpData.active >= http_max_active:GetInt() then","\t\tSF.throw( \"You can't run a new http request yet\", 2 )","\tend","\treturn true","end","","-- Runs the appropriate callback after a http request","local function runCallback ( instance, callback, ... )","\tif callback then","\t\tlocal args = { ... }","\t\tif IsValid( instance.data.entity ) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, unpack( args ) )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"http callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend","\tinstance.data.http.active = instance.data.http.active - 1","end",""],"fields":[],"name":"http","client":true,"description":"\nHttp library. Requests content from urls.","libtbl":"http_library","tables":[],"server":true}},"files":{"1":"callback.lua","2":"compiler.lua","3":"database.lua","4":"editor.lua","5":"instance.lua","6":"libraries.lua","7":"libs_cl/bass.lua","8":"libs_cl/input.lua","9":"libs_cl/joystick.lua","10":"libs_cl/render.lua","11":"libs_sh/angles.lua","12":"libs_sh/bit.lua","13":"libs_sh/builtins.lua","14":"libs_sh/color.lua","15":"libs_sh/coroutine.lua","16":"libs_sh/entities.lua","17":"libs_sh/fastlz.lua","18":"libs_sh/file.lua","19":"libs_sh/find.lua","20":"libs_sh/game.lua","21":"libs_sh/globaltables.lua","22":"libs_sh/hook.lua","23":"libs_sh/http.lua","24":"libs_sh/json.lua","25":"libs_sh/net.lua","26":"libs_sh/physenv.lua","27":"libs_sh/players.lua","28":"libs_sh/quaternion.lua","29":"libs_sh/sounds.lua","30":"libs_sh/timer.lua","31":"libs_sh/trace.lua","32":"libs_sh/vectors.lua","33":"libs_sh/vehicles.lua","34":"libs_sh/vmatrix.lua","35":"libs_sh/von.lua","36":"libs_sh/weapons.lua","37":"libs_sv/constraint.lua","38":"libs_sv/entities.lua","39":"libs_sv/holograms.lua","40":"libs_sv/prop.lua","41":"libs_sv/wire.lua","42":"permissions/core.lua","43":"permissions/provider.lua","44":"permissions/providers_cl/files.lua","45":"permissions/providers_cl/input.lua","46":"permissions/providers_sh/placeholder.lua","47":"permissions/providers_sv/CPPI.lua","48":"permissions/providers_sv/default.lua","49":"preprocessor.lua","50":"sfderma.lua","51":"sfhelper.lua","52":"sflib.lua","libs_sh/quaternion.lua":{"libraries":{"1":"quaternion","quaternion":{"comment":["--- Quaternion library","-- @shared"],"functions":{"1":"New","2":"abs","3":"conj","4":"exp","5":"inv","6":"log","7":"qMod","8":"qRotation","9":"qRotation","10":"qi","11":"qj","12":"qk","13":"rotationAngle","14":"rotationAxis","15":"rotationEulerAngle","16":"rotationVector","17":"slerp","18":"vec","conj":{"comment":["--- Returns the conjugate of <q>"],"code":["function quat_lib.conj(q)","\treturn quicknew(q[1], -q[2], -q[3], -q[4])","end",""],"class":"function","name":"quat_lib.conj","summary":"\nReturns the conjugate of <q> ","private":false,"library":"quaternion","description":"\nReturns the conjugate of <q>","param":["q"]},"log":{"comment":["--- Calculates natural logarithm of <q>"],"code":["function quat_lib.log(q)","\treturn qlog(q)","end",""],"class":"function","name":"quat_lib.log","summary":"\nCalculates natural logarithm of <q> ","private":false,"library":"quaternion","description":"\nCalculates natural logarithm of <q>","param":["q"]},"exp":{"comment":["--- Raises Euler's constant e to the power <q>"],"code":["function quat_lib.exp(q)","\treturn qexp(q)","end",""],"class":"function","name":"quat_lib.exp","summary":"\nRaises Euler's constant e to the power <q> ","private":false,"library":"quaternion","description":"\nRaises Euler's constant e to the power <q>","param":["q"]},"slerp":{"comment":["--- Performs spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1"],"code":["function quat_lib.slerp(q0, q1, t)","\tlocal dot = q0[1]*q1[1] + q0[2]*q1[2] + q0[3]*q1[3] + q0[4]*q1[4]","\tlocal q11","\tif dot<0 then","\t\tq11 = {-q1[1], -q1[2], -q1[3], -q1[4]}","\telse","\t\tq11 = { q1[1], q1[2], q1[3], q1[4] }  -- dunno if just q11 = q1 works","\tend","","\tlocal l = q0[1]*q0[1] + q0[2]*q0[2] + q0[3]*q0[3] + q0[4]*q0[4]","","\tif l==0 then return quicknew( 0, 0, 0, 0 ) end","","\tlocal invq0 = { q0[1]/l, -q0[2]/l, -q0[3]/l, -q0[4]/l }","\tlocal logq = qlog(qmul(invq0,q11))","\tlocal q = qexp( { logq[1]*t, logq[2]*t, logq[3]*t, logq[4]*t } )","","\treturn qmul(q0,q)","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.slerp","summary":"\nPerforms spherical linear interpolation between <q0> and <q1>.","private":false,"library":"quaternion","description":"\nPerforms spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1","param":["q0","q1","t"]},"qRotation":{"comment":["--- Construct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)"],"code":["function quat_lib.qRotation(rv1)","\tlocal angSquared = rv1.x * rv1.x + rv1.y * rv1.y + rv1.z * rv1.z","","\tif angSquared == 0 then return quicknew( 1, 0, 0, 0 ) end","","\tlocal len = sqrt(angSquared)","\tlocal ang = (len + 180) % 360 - 180","\tlocal ang2 = ang*deg2rad*0.5","\tlocal sang2len = sin(ang2) / len","","\treturn quicknew( cos(ang2), rv1.x * sang2len , rv1.y * sang2len, rv1.z * sang2len )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nConstruct a quaternion from the rotation vector <rv1>.","private":false,"library":"quaternion","description":"\nConstruct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)","param":["rv1"]},"qMod":{"comment":["--- Changes quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)"],"code":["function quat_lib.qMod(q)","\tif q[1]<0 then return quicknew(-q[1], -q[2], -q[3], -q[4]) else return quicknew(q[1], q[2], q[3], q[4]) end","end",""],"class":"function","name":"quat_lib.qMod","summary":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)","param":["q"]},"rotationEulerAngle":{"comment":["--- Returns the euler angle of rotation in degrees"],"code":["function quat_lib.rotationEulerAngle(q)","\tlocal l = sqrt(q[1]*q[1]+q[2]*q[2]+q[3]*q[3]+q[4]*q[4])","\tif l == 0 then return SF.WrapObject( Angle( 0, 0, 0) ) end","\tlocal q1, q2, q3, q4 = q[1]/l, q[2]/l, q[3]/l, q[4]/l","","\tlocal x = Vector(q1*q1 + q2*q2 - q3*q3 - q4*q4,","\t\t2*q3*q2 + 2*q4*q1,","\t\t2*q4*q2 - 2*q3*q1)","","\tlocal y = Vector(2*q2*q3 - 2*q4*q1,","\t\tq1*q1 - q2*q2 + q3*q3 - q4*q4,","\t\t2*q2*q1 + 2*q3*q4)","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tang.roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = q2*q1 + q3*q4","\tif dot < 0 then ang.roll = -ang.roll end","","\treturn SF.WrapObject( ang )","end",""],"class":"function","name":"quat_lib.rotationEulerAngle","summary":"\nReturns the euler angle of rotation in degrees ","private":false,"library":"quaternion","description":"\nReturns the euler angle of rotation in degrees","param":["q"]},"New":{"comment":["--- Creates a new Quaternion given a variety of inputs","-- @param ... A series of arguments which lead to valid generation of a quaternion.","-- See argTypesToQuat table for examples of acceptable inputs."],"code":["function quat_lib.New( self, ...)","\tlocal args = {...}","\t","\tlocal argtypes = \"\"","\tfor i=1,min(#args,4) do","\t\targtypes = argtypes .. SF.GetType( args[i] )","\tend","\t","\treturn argTypesToQuat[argtypes] and argTypesToQuat[argtypes](...) or quicknew(0,0,0,0)","end","","quat_lib_metamethods.__call = quat_lib.New","","","local function format(value)","\tlocal r,i,j,k,dbginfo","","\tr = \"\"","\ti = \"\"","\tj = \"\"","\tk = \"\"","","\tif abs(value[1]) > 0.0005 then","\t\tr = Round(value[1]*1000)/1000","\tend","","\tdbginfo = r","","\tif abs(value[2]) > 0.0005 then","\t\ti = tostring(Round(value[2]*1000)/1000)","","\t\tif string.sub(i,1,1) ~= \"-\" and dbginfo ~= \"\" then i = \"+\"..i end","","\t\ti = i .. \"i\"","\tend","","\tdbginfo = dbginfo .. i","","\tif abs(value[3]) > 0.0005 then","\t\tj = tostring(Round(value[3]*1000)/1000)","","\t\tif string.sub(j,1,1) ~= \"-\" and dbginfo ~= \"\" then j = \"+\"..j end","","\t\tj = j .. \"j\"","\tend","","\tdbginfo = dbginfo .. j","","\tif abs(value[4]) > 0.0005 then","\t\tk = tostring(Round(value[4]*1000)/1000)","","\t\tif string.sub(k,1,1) ~= \"-\" and dbginfo ~= \"\" then k = \"+\"..k end","","\t\tk = k .. \"k\"","\tend","","\tdbginfo = dbginfo .. k","","\tif dbginfo == \"\" then dbginfo = \"0 LAWL\" end","","\treturn dbginfo","end","","","quat_metamethods.__tostring = format","","","",""],"class":"function","name":"quat_lib.New","summary":"\nCreates a new Quaternion given a variety of inputs ","private":false,"library":"quaternion","description":"\nCreates a new Quaternion given a variety of inputs","param":{"1":"self","2":"...","...":"A series of arguments which lead to valid generation of a quaternion. \nSee argTypesToQuat table for examples of acceptable inputs."}},"qi":{"comment":["--- Returns Quaternion <n>*i"],"code":["function quat_lib.qi(n)","\treturn quicknew(0, n or 1, 0, 0)","end",""],"class":"function","name":"quat_lib.qi","summary":"\nReturns Quaternion <n>*i ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*i","param":["n"]},"qk":{"comment":["--- Returns Quaternion <n>*k"],"code":["function quat_lib.qk(n)","\treturn quicknew(0, 0, 0, n or 1)","end","","","","","quat_metamethods.__unm = function(q)","\treturn quicknew( -q[1], -q[2], -q[3], -q[4] )","end","","","quat_metamethods.__add = function(lhs, rhs)","","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3], lhs[4] + rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] + rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs + rhs[1], rhs[2], rhs[3], rhs[4] )","\tend","","\tError(\"Tried to add a \" .. ltype .. \" to a \" .. rtype .. \"not \")","end","","","quat_metamethods.__sub = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] - rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs - rhs[1], -rhs[2], -rhs[3], -rhs[4] )","\tend","","\tError(\"Tried to subtract a \" .. ltype .. \" from a \" .. rtype .. \"not \")","end","","","quat_metamethods.__mul = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] * rhs, lhs[2] * rhs, lhs[3] * rhs, lhs[4] * rhs )","\t\telseif rtype == \"Vector\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\treturn quicknew( lhs * rhs[1], lhs * rhs[2], lhs * rhs[3], lhs * rhs[4] )","\t\telseif ltype == \"Vector\" then","\t\t\tlocal lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\tend","","\tError(\"Tried to multiply a \" .. ltype .. \" with a \" .. rtype .. \"not \\n\")","end","","","quat_metamethods.__div = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs1 * rhs1 + lhs2 * rhs2 + lhs3 * rhs3 + lhs4 * rhs4)/l,","\t\t\t(-lhs1 * rhs2 + lhs2 * rhs1 - lhs3 * rhs4 + lhs4 * rhs3)/l,","\t\t\t(-lhs1 * rhs3 + lhs3 * rhs1 - lhs4 * rhs2 + lhs2 * rhs4)/l,","\t\t\t(-lhs1 * rhs4 + lhs4 * rhs1 - lhs2 * rhs3 + lhs3 * rhs2)/l","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1/rhs,","\t\t\tlhs2/rhs,","\t\t\tlhs3/rhs,","\t\t\tlhs4/rhs","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs * rhs1)/l,","\t\t\t(-lhs * rhs2)/l,","\t\t\t(-lhs * rhs3)/l,","\t\t\t(-lhs * rhs4)/l","\t\t\t)","\t\tend","\tend","","\terror(\"Tried to divide a \" .. ltype .. \" with a \" .. rtype)","end","","","quat_metamethods.__pow = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"number\" then","\t\tif lhs == 0 then return { 0, 0, 0, 0 } end","","\t\tlocal l = log(lhs)","\t\treturn qexp({ l*rhs[1], l*rhs[2], l*rhs[3], l*rhs[4] })","\telseif rtype == \"Quaternion\" and ltype == \"number\" then","\t\tlocal l = qlog(lhs)","\t\treturn qexp({ l[1]*rhs, l[2]*rhs, l[3]*rhs, l[4]*rhs })","\tend","","\tError(\"Tried to exponentiate a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end","","","--[[****************************************************************************]]","","quat_metamethods.__eq = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"Quaternion\" then","\t\tlocal rvd1, rvd2, rvd3, rvd4 = lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4]","\t\tif rvd1 <= delta and rvd1 >= -delta and","\t\t\trvd2 <= delta and rvd2 >= -delta and","\t\t\trvd3 <= delta and rvd3 >= -delta and","\t\t\trvd4 <= delta and rvd4 >= -delta","\t\tthen","\t\t\treturn 1","\t\telse","\t\t\treturn 0","\t\tend","\tend","","\tError(\"Tried to compare a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end",""],"class":"function","name":"quat_lib.qk","summary":"\nReturns Quaternion <n>*k ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*k","param":["n"]},"qj":{"comment":["--- Returns Quaternion <n>*j"],"code":["function quat_lib.qj(n)","\treturn quicknew(0, 0, n or 1, 0)","end",""],"class":"function","name":"quat_lib.qj","summary":"\nReturns Quaternion <n>*j ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*j","param":["n"]},"abs":{"comment":["--- Returns absolute value of <q>"],"code":["function quat_lib.abs(q)","\treturn sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","end",""],"class":"function","name":"quat_lib.abs","summary":"\nReturns absolute value of <q> ","private":false,"library":"quaternion","description":"\nReturns absolute value of <q>","param":["q"]},"rotationAxis":{"comment":["--- Returns the axis of rotation (by coder0xff)"],"code":["function quat_lib.rotationAxis(q)","\tlocal m2 = q[2] * q[2] + q[3] * q[3] + q[4] * q[4]","","\tif m2 == 0 then return vwrap( Vector( 0, 0, 1 ) ) end","","\tlocal m = sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] / m, q[ 3 ] / m, q[ 4 ] / m ) )","end",""],"class":"function","name":"quat_lib.rotationAxis","summary":"\nReturns the axis of rotation (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the axis of rotation (by coder0xff)","param":["q"]},"inv":{"comment":["--- Returns the inverse of <q>"],"code":["function quat_lib.inv(q)","\tlocal l = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\treturn quicknew( q[1]/l, -q[2]/l, -q[3]/l, -q[4]/l )","end",""],"class":"function","name":"quat_lib.inv","summary":"\nReturns the inverse of <q> ","private":false,"library":"quaternion","description":"\nReturns the inverse of <q>","param":["q"]},"rotationAngle":{"comment":["--- Returns the angle of rotation in degrees (by coder0xff)"],"code":["function quat_lib.rotationAngle(q)","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","","\tif l2 == 0 then return 0 end","","\tlocal l = sqrt(l2)","\tlocal ang = 2*acos(math.Clamp(q[1]/l, -1, 1))*rad2deg  --this returns angle from 0 to 360","","\tif ang > 180 then ang = ang - 360 end  -- make it -180 - 180","","\treturn ang","end",""],"class":"function","name":"quat_lib.rotationAngle","summary":"\nReturns the angle of rotation in degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the angle of rotation in degrees (by coder0xff)","param":["q"]},"vec":{"comment":["--- Converts <q> to a vector by dropping the real component"],"code":["function quat_lib.vec(q)","\treturn vwrap( Vector( q[ 2 ], q[ 3 ], q[ 4 ] ) )","end","","--[[****************************************************************************]]"],"class":"function","name":"quat_lib.vec","summary":"\nConverts <q> to a vector by dropping the real component ","private":false,"library":"quaternion","description":"\nConverts <q> to a vector by dropping the real component","param":["q"]},"rotationVector":{"comment":["--- Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)"],"code":["function quat_lib.rotationVector(q)","\tSF.CheckType( q, quat_metamethods )","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\tlocal m2 = math.max( q[2]*q[2] + q[3]*q[3] + q[4]*q[4], 0 )","","\tif l2 == 0 or m2 == 0 then return vwrap( Vector( 0, 0, 0 ) ) end","","\tlocal s = 2 * acos( math.Clamp( q[1] / sqrt(l2), -1, 1 ) ) * rad2deg","","\tif s > 180 then s = s - 360 end","","\ts = s / sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] * s, q[ 3 ] * s, q[ 4 ] * s ) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.rotationVector","summary":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)","param":["q"]}},"class":"library","summary":"\nQuaternion library ","code":["local quat_lib, quat_lib_metamethods = SF.Libraries.Register(\"quaternion\")","","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","--[[","-- Quaternion Support","-- Converted from Wiremod's E2 Quaternion library for general lua use","-- Original code for use by Bubbus","-- Permission received for use from Bubbus by Radon","-- http:\\\\wiki.wiremod.com/?title=Expression2#Quaternion","--","-- Credits to Radon for addition to Starfall","-- Credits to Divran for painful amounts of testing","]]","","-- faster access to some math library functions","local math = math -- Because global lookups suck","local setmetatable = setmetatable","local abs   = math.abs","local Round = math.Round","local sqrt  = math.sqrt","local exp   = math.exp","local log   = math.log","local sin   = math.sin","local cos   = math.cos","local sinh  = math.sinh","local cosh  = math.cosh","local acos  = math.acos","local min \t= math.min","","local delta = wire_expression2_delta or 0.0000001000000","","local isValid = SF.Entities.IsValid -- For checking shit","","local deg2rad = math.pi/180","local rad2deg = 180/math.pi",""],"fields":[],"name":"quaternion","client":true,"description":"\nQuaternion library","libtbl":"quat_lib","tables":[],"server":true}},"type":"file","name":"libs_sh/quaternion.lua","functions":{"1":"argTypesToQuat[\"Angle\"]","2":"argTypesToQuat[\"Entity\"]","3":"argTypesToQuat[\"Vector\"]","4":"argTypesToQuat[\"VectorVector\"]","5":"argTypesToQuat[\"number\"]","6":"argTypesToQuat[\"numberVector\"]","7":"argTypesToQuat[\"numbernumbernumbernumber\"]","8":"quat_lib.New","9":"quat_lib.abs","10":"quat_lib.conj","11":"quat_lib.exp","12":"quat_lib.inv","13":"quat_lib.log","14":"quat_lib.qMod","15":"quat_lib.qRotation","16":"quat_lib.qRotation","17":"quat_lib.qi","18":"quat_lib.qj","19":"quat_lib.qk","20":"quat_lib.rotationAngle","21":"quat_lib.rotationAxis","22":"quat_lib.rotationEulerAngle","23":"quat_lib.rotationVector","24":"quat_lib.slerp","25":"quat_lib.vec","26":"quat_methods:conj","27":"quat_methods:forward","28":"quat_methods:i","29":"quat_methods:j","30":"quat_methods:k","31":"quat_methods:r","32":"quat_methods:real","33":"quat_methods:right","34":"quat_methods:up","argTypesToQuat[\"numbernumbernumbernumber\"]":{"summary":"\nConverts 4 numbers to a Quaternion format for generation ","description":"\nConverts 4 numbers to a Quaternion format for generation","comment":["--- Converts 4 numbers to a Quaternion format for generation","-- @param args"],"code":["argTypesToQuat[\"numbernumbernumbernumber\"] = function(a,b,c,d)","\treturn quicknew(a,b,c,d)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"numbernumbernumbernumber\"]","param":{"1":"a","2":"b","3":"c","4":"d","5":"args","args":""}},"quat_lib.conj":{"comment":["--- Returns the conjugate of <q>"],"code":["function quat_lib.conj(q)","\treturn quicknew(q[1], -q[2], -q[3], -q[4])","end",""],"class":"function","name":"quat_lib.conj","summary":"\nReturns the conjugate of <q> ","private":false,"library":"quaternion","description":"\nReturns the conjugate of <q>","param":["q"]},"quat_lib.qRotation":{"comment":["--- Construct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)"],"code":["function quat_lib.qRotation(rv1)","\tlocal angSquared = rv1.x * rv1.x + rv1.y * rv1.y + rv1.z * rv1.z","","\tif angSquared == 0 then return quicknew( 1, 0, 0, 0 ) end","","\tlocal len = sqrt(angSquared)","\tlocal ang = (len + 180) % 360 - 180","\tlocal ang2 = ang*deg2rad*0.5","\tlocal sang2len = sin(ang2) / len","","\treturn quicknew( cos(ang2), rv1.x * sang2len , rv1.y * sang2len, rv1.z * sang2len )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nConstruct a quaternion from the rotation vector <rv1>.","private":false,"library":"quaternion","description":"\nConstruct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)","param":["rv1"]},"quat_lib.rotationVector":{"comment":["--- Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)"],"code":["function quat_lib.rotationVector(q)","\tSF.CheckType( q, quat_metamethods )","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\tlocal m2 = math.max( q[2]*q[2] + q[3]*q[3] + q[4]*q[4], 0 )","","\tif l2 == 0 or m2 == 0 then return vwrap( Vector( 0, 0, 0 ) ) end","","\tlocal s = 2 * acos( math.Clamp( q[1] / sqrt(l2), -1, 1 ) ) * rad2deg","","\tif s > 180 then s = s - 360 end","","\ts = s / sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] * s, q[ 3 ] * s, q[ 4 ] * s ) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.rotationVector","summary":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)","param":["q"]},"quat_methods:forward":{"comment":["--- Returns vector pointing forward for <this>"],"code":["function quat_methods:forward()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tthis1 * this1 + this2 * this2 - this3 * this3 - this4 * this4,","\tt3 * this2 + t4 * this1,","\tt4 * this2 - t3 * this1","\t) )","end",""],"class":"function","name":"quat_methods:forward","summary":"\nReturns vector pointing forward for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing forward for <this>","param":[]},"quat_lib.abs":{"comment":["--- Returns absolute value of <q>"],"code":["function quat_lib.abs(q)","\treturn sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","end",""],"class":"function","name":"quat_lib.abs","summary":"\nReturns absolute value of <q> ","private":false,"library":"quaternion","description":"\nReturns absolute value of <q>","param":["q"]},"quat_methods:r":{"comment":["--- Alias for :real() as r is easier"],"code":["function quat_methods:r()","\treturn self:real()","end","",""],"class":"function","name":"quat_methods:r","summary":"\nAlias for :real() as r is easier ","private":false,"classlib":"Quaternion","description":"\nAlias for :real() as r is easier","param":[]},"quat_lib.qi":{"comment":["--- Returns Quaternion <n>*i"],"code":["function quat_lib.qi(n)","\treturn quicknew(0, n or 1, 0, 0)","end",""],"class":"function","name":"quat_lib.qi","summary":"\nReturns Quaternion <n>*i ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*i","param":["n"]},"quat_methods:i":{"comment":["--- Returns the i component of the quaternion"],"code":["function quat_methods:i()","\treturn self[2]","end",""],"class":"function","name":"quat_methods:i","summary":"\nReturns the i component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the i component of the quaternion","param":[]},"argTypesToQuat[\"number\"]":{"summary":"\nConverts a number to a Quaternion format for generation ","description":"\nConverts a number to a Quaternion format for generation","comment":["--- Converts a number to a Quaternion format for generation","-- @param args"],"code":["argTypesToQuat[\"number\"] = function(num)","\treturn quicknew(num, 0, 0, 0)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"number\"]","param":{"1":"num","2":"args","args":""}},"quat_lib.rotationAxis":{"comment":["--- Returns the axis of rotation (by coder0xff)"],"code":["function quat_lib.rotationAxis(q)","\tlocal m2 = q[2] * q[2] + q[3] * q[3] + q[4] * q[4]","","\tif m2 == 0 then return vwrap( Vector( 0, 0, 1 ) ) end","","\tlocal m = sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] / m, q[ 3 ] / m, q[ 4 ] / m ) )","end",""],"class":"function","name":"quat_lib.rotationAxis","summary":"\nReturns the axis of rotation (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the axis of rotation (by coder0xff)","param":["q"]},"argTypesToQuat[\"Vector\"]":{"summary":"\nConverts a Vector to a Quaternion format for generation ","description":"\nConverts a Vector to a Quaternion format for generation","comment":["--- Converts a Vector to a Quaternion format for generation","-- @param args"],"code":["argTypesToQuat[\"Vector\"] = function(vec)","\treturn quicknew(0, vec.x, vec.y, vec.z)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"Vector\"]","param":{"1":"vec","2":"args","args":""}},"quat_methods:conj":{"comment":["--- Returns the conj of self"],"code":["function quat_methods:conj()","\treturn quat_lib.conj( self )","end","","function quat_methods:inv()","\treturn quat_lib.inv( self )","end",""],"class":"function","name":"quat_methods:conj","summary":"\nReturns the conj of self ","private":false,"classlib":"Quaternion","description":"\nReturns the conj of self","param":[]},"argTypesToQuat[\"Entity\"]":{"summary":"\nConverts an Entity to a Quaternion format for generation ","description":"\nConverts an Entity to a Quaternion format for generation","comment":["--- Converts an Entity to a Quaternion format for generation","-- @param args Table, containing an Entity to be used at the first index."],"code":["argTypesToQuat[\"Entity\"] = function(ent)","\tent = SF.UnwrapObject( ent )","\t","\tif not isValid( ent ) then","\t\treturn quicknew( 0, 0, 0, 0 )","\tend","","\tlocal ang = ent:GetAngles()","\tlocal p, y, r = ang.p, ang.y, ang.r","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end","","",""],"private":false,"class":"function","name":"argTypesToQuat[\"Entity\"]","param":{"1":"ent","2":"args","args":"Table, containing an Entity to be used at the first index."}},"quat_lib.qMod":{"comment":["--- Changes quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)"],"code":["function quat_lib.qMod(q)","\tif q[1]<0 then return quicknew(-q[1], -q[2], -q[3], -q[4]) else return quicknew(q[1], q[2], q[3], q[4]) end","end",""],"class":"function","name":"quat_lib.qMod","summary":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)","param":["q"]},"argTypesToQuat[\"VectorVector\"]":{"summary":"\nConverts two Vectors to a Quaternion format for generation using Cross product and the angle between them ","description":"\nConverts two Vectors to a Quaternion format for generation using Cross product and the angle between them","comment":["--- Converts two Vectors to a Quaternion format for generation using Cross product and the angle between them","-- @param args"],"code":["argTypesToQuat[\"VectorVector\"] = function(forward,up)","\tlocal x = Vector(forward.x, forward.y, forward.z)","\tlocal z = Vector(up.x, up.y, up.z)","\tlocal y = z:Cross(x):GetNormalized() --up x forward = left","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tlocal roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = y.z","\tif dot < 0 then roll = -roll end","","\tlocal p, y, r = ang.p, ang.y, roll","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"VectorVector\"]","param":{"1":"forward","2":"up","3":"args","args":""}},"quat_lib.rotationAngle":{"comment":["--- Returns the angle of rotation in degrees (by coder0xff)"],"code":["function quat_lib.rotationAngle(q)","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","","\tif l2 == 0 then return 0 end","","\tlocal l = sqrt(l2)","\tlocal ang = 2*acos(math.Clamp(q[1]/l, -1, 1))*rad2deg  --this returns angle from 0 to 360","","\tif ang > 180 then ang = ang - 360 end  -- make it -180 - 180","","\treturn ang","end",""],"class":"function","name":"quat_lib.rotationAngle","summary":"\nReturns the angle of rotation in degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the angle of rotation in degrees (by coder0xff)","param":["q"]},"quat_lib.qk":{"comment":["--- Returns Quaternion <n>*k"],"code":["function quat_lib.qk(n)","\treturn quicknew(0, 0, 0, n or 1)","end","","","","","quat_metamethods.__unm = function(q)","\treturn quicknew( -q[1], -q[2], -q[3], -q[4] )","end","","","quat_metamethods.__add = function(lhs, rhs)","","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3], lhs[4] + rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] + rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs + rhs[1], rhs[2], rhs[3], rhs[4] )","\tend","","\tError(\"Tried to add a \" .. ltype .. \" to a \" .. rtype .. \"not \")","end","","","quat_metamethods.__sub = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] - rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs - rhs[1], -rhs[2], -rhs[3], -rhs[4] )","\tend","","\tError(\"Tried to subtract a \" .. ltype .. \" from a \" .. rtype .. \"not \")","end","","","quat_metamethods.__mul = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] * rhs, lhs[2] * rhs, lhs[3] * rhs, lhs[4] * rhs )","\t\telseif rtype == \"Vector\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\treturn quicknew( lhs * rhs[1], lhs * rhs[2], lhs * rhs[3], lhs * rhs[4] )","\t\telseif ltype == \"Vector\" then","\t\t\tlocal lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\tend","","\tError(\"Tried to multiply a \" .. ltype .. \" with a \" .. rtype .. \"not \\n\")","end","","","quat_metamethods.__div = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs1 * rhs1 + lhs2 * rhs2 + lhs3 * rhs3 + lhs4 * rhs4)/l,","\t\t\t(-lhs1 * rhs2 + lhs2 * rhs1 - lhs3 * rhs4 + lhs4 * rhs3)/l,","\t\t\t(-lhs1 * rhs3 + lhs3 * rhs1 - lhs4 * rhs2 + lhs2 * rhs4)/l,","\t\t\t(-lhs1 * rhs4 + lhs4 * rhs1 - lhs2 * rhs3 + lhs3 * rhs2)/l","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1/rhs,","\t\t\tlhs2/rhs,","\t\t\tlhs3/rhs,","\t\t\tlhs4/rhs","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs * rhs1)/l,","\t\t\t(-lhs * rhs2)/l,","\t\t\t(-lhs * rhs3)/l,","\t\t\t(-lhs * rhs4)/l","\t\t\t)","\t\tend","\tend","","\terror(\"Tried to divide a \" .. ltype .. \" with a \" .. rtype)","end","","","quat_metamethods.__pow = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"number\" then","\t\tif lhs == 0 then return { 0, 0, 0, 0 } end","","\t\tlocal l = log(lhs)","\t\treturn qexp({ l*rhs[1], l*rhs[2], l*rhs[3], l*rhs[4] })","\telseif rtype == \"Quaternion\" and ltype == \"number\" then","\t\tlocal l = qlog(lhs)","\t\treturn qexp({ l[1]*rhs, l[2]*rhs, l[3]*rhs, l[4]*rhs })","\tend","","\tError(\"Tried to exponentiate a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end","","","--[[****************************************************************************]]","","quat_metamethods.__eq = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"Quaternion\" then","\t\tlocal rvd1, rvd2, rvd3, rvd4 = lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4]","\t\tif rvd1 <= delta and rvd1 >= -delta and","\t\t\trvd2 <= delta and rvd2 >= -delta and","\t\t\trvd3 <= delta and rvd3 >= -delta and","\t\t\trvd4 <= delta and rvd4 >= -delta","\t\tthen","\t\t\treturn 1","\t\telse","\t\t\treturn 0","\t\tend","\tend","","\tError(\"Tried to compare a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end",""],"class":"function","name":"quat_lib.qk","summary":"\nReturns Quaternion <n>*k ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*k","param":["n"]},"quat_lib.inv":{"comment":["--- Returns the inverse of <q>"],"code":["function quat_lib.inv(q)","\tlocal l = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\treturn quicknew( q[1]/l, -q[2]/l, -q[3]/l, -q[4]/l )","end",""],"class":"function","name":"quat_lib.inv","summary":"\nReturns the inverse of <q> ","private":false,"library":"quaternion","description":"\nReturns the inverse of <q>","param":["q"]},"quat_methods:real":{"comment":["--- Returns the real component of the quaternion"],"code":["function quat_methods:real()","\treturn self[1]","end",""],"class":"function","name":"quat_methods:real","summary":"\nReturns the real component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the real component of the quaternion","param":[]},"quat_lib.vec":{"comment":["--- Converts <q> to a vector by dropping the real component"],"code":["function quat_lib.vec(q)","\treturn vwrap( Vector( q[ 2 ], q[ 3 ], q[ 4 ] ) )","end","","--[[****************************************************************************]]"],"class":"function","name":"quat_lib.vec","summary":"\nConverts <q> to a vector by dropping the real component ","private":false,"library":"quaternion","description":"\nConverts <q> to a vector by dropping the real component","param":["q"]},"quat_lib.slerp":{"comment":["--- Performs spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1"],"code":["function quat_lib.slerp(q0, q1, t)","\tlocal dot = q0[1]*q1[1] + q0[2]*q1[2] + q0[3]*q1[3] + q0[4]*q1[4]","\tlocal q11","\tif dot<0 then","\t\tq11 = {-q1[1], -q1[2], -q1[3], -q1[4]}","\telse","\t\tq11 = { q1[1], q1[2], q1[3], q1[4] }  -- dunno if just q11 = q1 works","\tend","","\tlocal l = q0[1]*q0[1] + q0[2]*q0[2] + q0[3]*q0[3] + q0[4]*q0[4]","","\tif l==0 then return quicknew( 0, 0, 0, 0 ) end","","\tlocal invq0 = { q0[1]/l, -q0[2]/l, -q0[3]/l, -q0[4]/l }","\tlocal logq = qlog(qmul(invq0,q11))","\tlocal q = qexp( { logq[1]*t, logq[2]*t, logq[3]*t, logq[4]*t } )","","\treturn qmul(q0,q)","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.slerp","summary":"\nPerforms spherical linear interpolation between <q0> and <q1>.","private":false,"library":"quaternion","description":"\nPerforms spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1","param":["q0","q1","t"]},"quat_methods:k":{"comment":["--- Returns the k component of the quaternion"],"code":["function quat_methods:k()","\treturn self[4]","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:k","summary":"\nReturns the k component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the k component of the quaternion","param":[]},"quat_lib.log":{"comment":["--- Calculates natural logarithm of <q>"],"code":["function quat_lib.log(q)","\treturn qlog(q)","end",""],"class":"function","name":"quat_lib.log","summary":"\nCalculates natural logarithm of <q> ","private":false,"library":"quaternion","description":"\nCalculates natural logarithm of <q>","param":["q"]},"quat_lib.exp":{"comment":["--- Raises Euler's constant e to the power <q>"],"code":["function quat_lib.exp(q)","\treturn qexp(q)","end",""],"class":"function","name":"quat_lib.exp","summary":"\nRaises Euler's constant e to the power <q> ","private":false,"library":"quaternion","description":"\nRaises Euler's constant e to the power <q>","param":["q"]},"argTypesToQuat[\"numberVector\"]":{"summary":"\nConverts a Number/Vector combination to a Quaternion format for generation ","description":"\nConverts a Number/Vector combination to a Quaternion format for generation","comment":["--- Converts a Number/Vector combination to a Quaternion format for generation","-- @param args"],"code":["argTypesToQuat[\"numberVector\"] = function(num,vec)","\treturn quicknew(num, vec.x, vec.y, vec.z) -- TODO Cannot change protect metatable? fix this","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"numberVector\"]","param":{"1":"num","2":"vec","3":"args","args":""}},"quat_methods:up":{"comment":["--- Returns vector pointing up for <this>"],"code":["function quat_methods:up()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt3 * this1 + t2 * this4,","\tt3 * this4 - t2 * this1,","\tthis1 * this1 - this2 * this2 - this3 * this3 + this4 * this4","\t) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:up","summary":"\nReturns vector pointing up for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing up for <this>","param":[]},"argTypesToQuat[\"Angle\"]":{"summary":"\nConverts an Angle to a Quaternion format for generation ","description":"\nConverts an Angle to a Quaternion format for generation","comment":["--- Converts an Angle to a Quaternion format for generation","-- @param args"],"code":["argTypesToQuat[\"Angle\"] = function(ang)","\tlocal p, y, r = ang.p, ang.y, ang.r","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"Angle\"]","param":{"1":"ang","2":"args","args":""}},"quat_methods:j":{"comment":["--- Returns the j component of the quaternion"],"code":["function quat_methods:j()","\treturn self[3]","end",""],"class":"function","name":"quat_methods:j","summary":"\nReturns the j component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the j component of the quaternion","param":[]},"quat_lib.qj":{"comment":["--- Returns Quaternion <n>*j"],"code":["function quat_lib.qj(n)","\treturn quicknew(0, 0, n or 1, 0)","end",""],"class":"function","name":"quat_lib.qj","summary":"\nReturns Quaternion <n>*j ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*j","param":["n"]},"quat_lib.New":{"comment":["--- Creates a new Quaternion given a variety of inputs","-- @param ... A series of arguments which lead to valid generation of a quaternion.","-- See argTypesToQuat table for examples of acceptable inputs."],"code":["function quat_lib.New( self, ...)","\tlocal args = {...}","\t","\tlocal argtypes = \"\"","\tfor i=1,min(#args,4) do","\t\targtypes = argtypes .. SF.GetType( args[i] )","\tend","\t","\treturn argTypesToQuat[argtypes] and argTypesToQuat[argtypes](...) or quicknew(0,0,0,0)","end","","quat_lib_metamethods.__call = quat_lib.New","","","local function format(value)","\tlocal r,i,j,k,dbginfo","","\tr = \"\"","\ti = \"\"","\tj = \"\"","\tk = \"\"","","\tif abs(value[1]) > 0.0005 then","\t\tr = Round(value[1]*1000)/1000","\tend","","\tdbginfo = r","","\tif abs(value[2]) > 0.0005 then","\t\ti = tostring(Round(value[2]*1000)/1000)","","\t\tif string.sub(i,1,1) ~= \"-\" and dbginfo ~= \"\" then i = \"+\"..i end","","\t\ti = i .. \"i\"","\tend","","\tdbginfo = dbginfo .. i","","\tif abs(value[3]) > 0.0005 then","\t\tj = tostring(Round(value[3]*1000)/1000)","","\t\tif string.sub(j,1,1) ~= \"-\" and dbginfo ~= \"\" then j = \"+\"..j end","","\t\tj = j .. \"j\"","\tend","","\tdbginfo = dbginfo .. j","","\tif abs(value[4]) > 0.0005 then","\t\tk = tostring(Round(value[4]*1000)/1000)","","\t\tif string.sub(k,1,1) ~= \"-\" and dbginfo ~= \"\" then k = \"+\"..k end","","\t\tk = k .. \"k\"","\tend","","\tdbginfo = dbginfo .. k","","\tif dbginfo == \"\" then dbginfo = \"0 LAWL\" end","","\treturn dbginfo","end","","","quat_metamethods.__tostring = format","","","",""],"class":"function","name":"quat_lib.New","summary":"\nCreates a new Quaternion given a variety of inputs ","private":false,"library":"quaternion","description":"\nCreates a new Quaternion given a variety of inputs","param":{"1":"self","2":"...","...":"A series of arguments which lead to valid generation of a quaternion. \nSee argTypesToQuat table for examples of acceptable inputs."}},"quat_methods:right":{"comment":["--- Returns vector pointing right for <this>"],"code":["function quat_methods:right()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt4 * this1 - t2 * this3,","\tthis2 * this2 - this1 * this1 + this4 * this4 - this3 * this3,","\t- t2 * this1 - t3 * this4","\t) )","end",""],"class":"function","name":"quat_methods:right","summary":"\nReturns vector pointing right for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing right for <this>","param":[]},"quat_lib.rotationEulerAngle":{"comment":["--- Returns the euler angle of rotation in degrees"],"code":["function quat_lib.rotationEulerAngle(q)","\tlocal l = sqrt(q[1]*q[1]+q[2]*q[2]+q[3]*q[3]+q[4]*q[4])","\tif l == 0 then return SF.WrapObject( Angle( 0, 0, 0) ) end","\tlocal q1, q2, q3, q4 = q[1]/l, q[2]/l, q[3]/l, q[4]/l","","\tlocal x = Vector(q1*q1 + q2*q2 - q3*q3 - q4*q4,","\t\t2*q3*q2 + 2*q4*q1,","\t\t2*q4*q2 - 2*q3*q1)","","\tlocal y = Vector(2*q2*q3 - 2*q4*q1,","\t\tq1*q1 - q2*q2 + q3*q3 - q4*q4,","\t\t2*q2*q1 + 2*q3*q4)","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tang.roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = q2*q1 + q3*q4","\tif dot < 0 then ang.roll = -ang.roll end","","\treturn SF.WrapObject( ang )","end",""],"class":"function","name":"quat_lib.rotationEulerAngle","summary":"\nReturns the euler angle of rotation in degrees ","private":false,"library":"quaternion","description":"\nReturns the euler angle of rotation in degrees","param":["q"]}},"doc":[{"summary":"\nQuaternion library ","description":"\nQuaternion library","comment":["--- Quaternion library"],"code":[""]},{"comment":["--- Quaternion library","-- @shared"],"functions":{"1":"New","2":"abs","3":"conj","4":"exp","5":"inv","6":"log","7":"qMod","8":"qRotation","9":"qRotation","10":"qi","11":"qj","12":"qk","13":"rotationAngle","14":"rotationAxis","15":"rotationEulerAngle","16":"rotationVector","17":"slerp","18":"vec","conj":{"comment":["--- Returns the conjugate of <q>"],"code":["function quat_lib.conj(q)","\treturn quicknew(q[1], -q[2], -q[3], -q[4])","end",""],"class":"function","name":"quat_lib.conj","summary":"\nReturns the conjugate of <q> ","private":false,"library":"quaternion","description":"\nReturns the conjugate of <q>","param":["q"]},"log":{"comment":["--- Calculates natural logarithm of <q>"],"code":["function quat_lib.log(q)","\treturn qlog(q)","end",""],"class":"function","name":"quat_lib.log","summary":"\nCalculates natural logarithm of <q> ","private":false,"library":"quaternion","description":"\nCalculates natural logarithm of <q>","param":["q"]},"exp":{"comment":["--- Raises Euler's constant e to the power <q>"],"code":["function quat_lib.exp(q)","\treturn qexp(q)","end",""],"class":"function","name":"quat_lib.exp","summary":"\nRaises Euler's constant e to the power <q> ","private":false,"library":"quaternion","description":"\nRaises Euler's constant e to the power <q>","param":["q"]},"slerp":{"comment":["--- Performs spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1"],"code":["function quat_lib.slerp(q0, q1, t)","\tlocal dot = q0[1]*q1[1] + q0[2]*q1[2] + q0[3]*q1[3] + q0[4]*q1[4]","\tlocal q11","\tif dot<0 then","\t\tq11 = {-q1[1], -q1[2], -q1[3], -q1[4]}","\telse","\t\tq11 = { q1[1], q1[2], q1[3], q1[4] }  -- dunno if just q11 = q1 works","\tend","","\tlocal l = q0[1]*q0[1] + q0[2]*q0[2] + q0[3]*q0[3] + q0[4]*q0[4]","","\tif l==0 then return quicknew( 0, 0, 0, 0 ) end","","\tlocal invq0 = { q0[1]/l, -q0[2]/l, -q0[3]/l, -q0[4]/l }","\tlocal logq = qlog(qmul(invq0,q11))","\tlocal q = qexp( { logq[1]*t, logq[2]*t, logq[3]*t, logq[4]*t } )","","\treturn qmul(q0,q)","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.slerp","summary":"\nPerforms spherical linear interpolation between <q0> and <q1>.","private":false,"library":"quaternion","description":"\nPerforms spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1","param":["q0","q1","t"]},"qRotation":{"comment":["--- Construct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)"],"code":["function quat_lib.qRotation(rv1)","\tlocal angSquared = rv1.x * rv1.x + rv1.y * rv1.y + rv1.z * rv1.z","","\tif angSquared == 0 then return quicknew( 1, 0, 0, 0 ) end","","\tlocal len = sqrt(angSquared)","\tlocal ang = (len + 180) % 360 - 180","\tlocal ang2 = ang*deg2rad*0.5","\tlocal sang2len = sin(ang2) / len","","\treturn quicknew( cos(ang2), rv1.x * sang2len , rv1.y * sang2len, rv1.z * sang2len )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nConstruct a quaternion from the rotation vector <rv1>.","private":false,"library":"quaternion","description":"\nConstruct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)","param":["rv1"]},"qMod":{"comment":["--- Changes quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)"],"code":["function quat_lib.qMod(q)","\tif q[1]<0 then return quicknew(-q[1], -q[2], -q[3], -q[4]) else return quicknew(q[1], q[2], q[3], q[4]) end","end",""],"class":"function","name":"quat_lib.qMod","summary":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)","param":["q"]},"rotationEulerAngle":{"comment":["--- Returns the euler angle of rotation in degrees"],"code":["function quat_lib.rotationEulerAngle(q)","\tlocal l = sqrt(q[1]*q[1]+q[2]*q[2]+q[3]*q[3]+q[4]*q[4])","\tif l == 0 then return SF.WrapObject( Angle( 0, 0, 0) ) end","\tlocal q1, q2, q3, q4 = q[1]/l, q[2]/l, q[3]/l, q[4]/l","","\tlocal x = Vector(q1*q1 + q2*q2 - q3*q3 - q4*q4,","\t\t2*q3*q2 + 2*q4*q1,","\t\t2*q4*q2 - 2*q3*q1)","","\tlocal y = Vector(2*q2*q3 - 2*q4*q1,","\t\tq1*q1 - q2*q2 + q3*q3 - q4*q4,","\t\t2*q2*q1 + 2*q3*q4)","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tang.roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = q2*q1 + q3*q4","\tif dot < 0 then ang.roll = -ang.roll end","","\treturn SF.WrapObject( ang )","end",""],"class":"function","name":"quat_lib.rotationEulerAngle","summary":"\nReturns the euler angle of rotation in degrees ","private":false,"library":"quaternion","description":"\nReturns the euler angle of rotation in degrees","param":["q"]},"New":{"comment":["--- Creates a new Quaternion given a variety of inputs","-- @param ... A series of arguments which lead to valid generation of a quaternion.","-- See argTypesToQuat table for examples of acceptable inputs."],"code":["function quat_lib.New( self, ...)","\tlocal args = {...}","\t","\tlocal argtypes = \"\"","\tfor i=1,min(#args,4) do","\t\targtypes = argtypes .. SF.GetType( args[i] )","\tend","\t","\treturn argTypesToQuat[argtypes] and argTypesToQuat[argtypes](...) or quicknew(0,0,0,0)","end","","quat_lib_metamethods.__call = quat_lib.New","","","local function format(value)","\tlocal r,i,j,k,dbginfo","","\tr = \"\"","\ti = \"\"","\tj = \"\"","\tk = \"\"","","\tif abs(value[1]) > 0.0005 then","\t\tr = Round(value[1]*1000)/1000","\tend","","\tdbginfo = r","","\tif abs(value[2]) > 0.0005 then","\t\ti = tostring(Round(value[2]*1000)/1000)","","\t\tif string.sub(i,1,1) ~= \"-\" and dbginfo ~= \"\" then i = \"+\"..i end","","\t\ti = i .. \"i\"","\tend","","\tdbginfo = dbginfo .. i","","\tif abs(value[3]) > 0.0005 then","\t\tj = tostring(Round(value[3]*1000)/1000)","","\t\tif string.sub(j,1,1) ~= \"-\" and dbginfo ~= \"\" then j = \"+\"..j end","","\t\tj = j .. \"j\"","\tend","","\tdbginfo = dbginfo .. j","","\tif abs(value[4]) > 0.0005 then","\t\tk = tostring(Round(value[4]*1000)/1000)","","\t\tif string.sub(k,1,1) ~= \"-\" and dbginfo ~= \"\" then k = \"+\"..k end","","\t\tk = k .. \"k\"","\tend","","\tdbginfo = dbginfo .. k","","\tif dbginfo == \"\" then dbginfo = \"0 LAWL\" end","","\treturn dbginfo","end","","","quat_metamethods.__tostring = format","","","",""],"class":"function","name":"quat_lib.New","summary":"\nCreates a new Quaternion given a variety of inputs ","private":false,"library":"quaternion","description":"\nCreates a new Quaternion given a variety of inputs","param":{"1":"self","2":"...","...":"A series of arguments which lead to valid generation of a quaternion. \nSee argTypesToQuat table for examples of acceptable inputs."}},"qi":{"comment":["--- Returns Quaternion <n>*i"],"code":["function quat_lib.qi(n)","\treturn quicknew(0, n or 1, 0, 0)","end",""],"class":"function","name":"quat_lib.qi","summary":"\nReturns Quaternion <n>*i ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*i","param":["n"]},"qk":{"comment":["--- Returns Quaternion <n>*k"],"code":["function quat_lib.qk(n)","\treturn quicknew(0, 0, 0, n or 1)","end","","","","","quat_metamethods.__unm = function(q)","\treturn quicknew( -q[1], -q[2], -q[3], -q[4] )","end","","","quat_metamethods.__add = function(lhs, rhs)","","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3], lhs[4] + rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] + rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs + rhs[1], rhs[2], rhs[3], rhs[4] )","\tend","","\tError(\"Tried to add a \" .. ltype .. \" to a \" .. rtype .. \"not \")","end","","","quat_metamethods.__sub = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] - rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs - rhs[1], -rhs[2], -rhs[3], -rhs[4] )","\tend","","\tError(\"Tried to subtract a \" .. ltype .. \" from a \" .. rtype .. \"not \")","end","","","quat_metamethods.__mul = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] * rhs, lhs[2] * rhs, lhs[3] * rhs, lhs[4] * rhs )","\t\telseif rtype == \"Vector\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\treturn quicknew( lhs * rhs[1], lhs * rhs[2], lhs * rhs[3], lhs * rhs[4] )","\t\telseif ltype == \"Vector\" then","\t\t\tlocal lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\tend","","\tError(\"Tried to multiply a \" .. ltype .. \" with a \" .. rtype .. \"not \\n\")","end","","","quat_metamethods.__div = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs1 * rhs1 + lhs2 * rhs2 + lhs3 * rhs3 + lhs4 * rhs4)/l,","\t\t\t(-lhs1 * rhs2 + lhs2 * rhs1 - lhs3 * rhs4 + lhs4 * rhs3)/l,","\t\t\t(-lhs1 * rhs3 + lhs3 * rhs1 - lhs4 * rhs2 + lhs2 * rhs4)/l,","\t\t\t(-lhs1 * rhs4 + lhs4 * rhs1 - lhs2 * rhs3 + lhs3 * rhs2)/l","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1/rhs,","\t\t\tlhs2/rhs,","\t\t\tlhs3/rhs,","\t\t\tlhs4/rhs","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs * rhs1)/l,","\t\t\t(-lhs * rhs2)/l,","\t\t\t(-lhs * rhs3)/l,","\t\t\t(-lhs * rhs4)/l","\t\t\t)","\t\tend","\tend","","\terror(\"Tried to divide a \" .. ltype .. \" with a \" .. rtype)","end","","","quat_metamethods.__pow = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"number\" then","\t\tif lhs == 0 then return { 0, 0, 0, 0 } end","","\t\tlocal l = log(lhs)","\t\treturn qexp({ l*rhs[1], l*rhs[2], l*rhs[3], l*rhs[4] })","\telseif rtype == \"Quaternion\" and ltype == \"number\" then","\t\tlocal l = qlog(lhs)","\t\treturn qexp({ l[1]*rhs, l[2]*rhs, l[3]*rhs, l[4]*rhs })","\tend","","\tError(\"Tried to exponentiate a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end","","","--[[****************************************************************************]]","","quat_metamethods.__eq = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"Quaternion\" then","\t\tlocal rvd1, rvd2, rvd3, rvd4 = lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4]","\t\tif rvd1 <= delta and rvd1 >= -delta and","\t\t\trvd2 <= delta and rvd2 >= -delta and","\t\t\trvd3 <= delta and rvd3 >= -delta and","\t\t\trvd4 <= delta and rvd4 >= -delta","\t\tthen","\t\t\treturn 1","\t\telse","\t\t\treturn 0","\t\tend","\tend","","\tError(\"Tried to compare a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end",""],"class":"function","name":"quat_lib.qk","summary":"\nReturns Quaternion <n>*k ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*k","param":["n"]},"qj":{"comment":["--- Returns Quaternion <n>*j"],"code":["function quat_lib.qj(n)","\treturn quicknew(0, 0, n or 1, 0)","end",""],"class":"function","name":"quat_lib.qj","summary":"\nReturns Quaternion <n>*j ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*j","param":["n"]},"abs":{"comment":["--- Returns absolute value of <q>"],"code":["function quat_lib.abs(q)","\treturn sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","end",""],"class":"function","name":"quat_lib.abs","summary":"\nReturns absolute value of <q> ","private":false,"library":"quaternion","description":"\nReturns absolute value of <q>","param":["q"]},"rotationAxis":{"comment":["--- Returns the axis of rotation (by coder0xff)"],"code":["function quat_lib.rotationAxis(q)","\tlocal m2 = q[2] * q[2] + q[3] * q[3] + q[4] * q[4]","","\tif m2 == 0 then return vwrap( Vector( 0, 0, 1 ) ) end","","\tlocal m = sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] / m, q[ 3 ] / m, q[ 4 ] / m ) )","end",""],"class":"function","name":"quat_lib.rotationAxis","summary":"\nReturns the axis of rotation (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the axis of rotation (by coder0xff)","param":["q"]},"inv":{"comment":["--- Returns the inverse of <q>"],"code":["function quat_lib.inv(q)","\tlocal l = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\treturn quicknew( q[1]/l, -q[2]/l, -q[3]/l, -q[4]/l )","end",""],"class":"function","name":"quat_lib.inv","summary":"\nReturns the inverse of <q> ","private":false,"library":"quaternion","description":"\nReturns the inverse of <q>","param":["q"]},"rotationAngle":{"comment":["--- Returns the angle of rotation in degrees (by coder0xff)"],"code":["function quat_lib.rotationAngle(q)","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","","\tif l2 == 0 then return 0 end","","\tlocal l = sqrt(l2)","\tlocal ang = 2*acos(math.Clamp(q[1]/l, -1, 1))*rad2deg  --this returns angle from 0 to 360","","\tif ang > 180 then ang = ang - 360 end  -- make it -180 - 180","","\treturn ang","end",""],"class":"function","name":"quat_lib.rotationAngle","summary":"\nReturns the angle of rotation in degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the angle of rotation in degrees (by coder0xff)","param":["q"]},"vec":{"comment":["--- Converts <q> to a vector by dropping the real component"],"code":["function quat_lib.vec(q)","\treturn vwrap( Vector( q[ 2 ], q[ 3 ], q[ 4 ] ) )","end","","--[[****************************************************************************]]"],"class":"function","name":"quat_lib.vec","summary":"\nConverts <q> to a vector by dropping the real component ","private":false,"library":"quaternion","description":"\nConverts <q> to a vector by dropping the real component","param":["q"]},"rotationVector":{"comment":["--- Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)"],"code":["function quat_lib.rotationVector(q)","\tSF.CheckType( q, quat_metamethods )","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\tlocal m2 = math.max( q[2]*q[2] + q[3]*q[3] + q[4]*q[4], 0 )","","\tif l2 == 0 or m2 == 0 then return vwrap( Vector( 0, 0, 0 ) ) end","","\tlocal s = 2 * acos( math.Clamp( q[1] / sqrt(l2), -1, 1 ) ) * rad2deg","","\tif s > 180 then s = s - 360 end","","\ts = s / sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] * s, q[ 3 ] * s, q[ 4 ] * s ) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.rotationVector","summary":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)","param":["q"]}},"class":"library","summary":"\nQuaternion library ","code":["local quat_lib, quat_lib_metamethods = SF.Libraries.Register(\"quaternion\")","","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","--[[","-- Quaternion Support","-- Converted from Wiremod's E2 Quaternion library for general lua use","-- Original code for use by Bubbus","-- Permission received for use from Bubbus by Radon","-- http:\\\\wiki.wiremod.com/?title=Expression2#Quaternion","--","-- Credits to Radon for addition to Starfall","-- Credits to Divran for painful amounts of testing","]]","","-- faster access to some math library functions","local math = math -- Because global lookups suck","local setmetatable = setmetatable","local abs   = math.abs","local Round = math.Round","local sqrt  = math.sqrt","local exp   = math.exp","local log   = math.log","local sin   = math.sin","local cos   = math.cos","local sinh  = math.sinh","local cosh  = math.cosh","local acos  = math.acos","local min \t= math.min","","local delta = wire_expression2_delta or 0.0000001000000","","local isValid = SF.Entities.IsValid -- For checking shit","","local deg2rad = math.pi/180","local rad2deg = 180/math.pi",""],"fields":[],"name":"quaternion","client":true,"description":"\nQuaternion library","libtbl":"quat_lib","tables":[],"server":true},{"comment":["--- Quaternion type"],"code":["local quat_methods, quat_metamethods = SF.Typedef(\"Quaternion\")","--[[quat_metamethods = {__index = quat_lib}","quat_lib.__metatable = quat_metamethods","quat_metamethods.__type = \"Quaternion\"","setmetatable(quat_lib, quat_metamethods)]]","","--****************************** Helper functions ******************************--","","local function quicknew(r, i, j, k)","\tlocal new = {r, i, j, k}","\tsetmetatable( new, quat_metamethods )","\treturn new","end","","local function qmul(lhs, rhs)","\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\treturn quicknew(","\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t)","end","","local function qexp(q)","\tlocal m = sqrt(q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","\tlocal u","\tif m ~= 0 then","\t\tu = { q[2]*sin(m)/m, q[3]*sin(m)/m, q[4]*sin(m)/m }","\telse","\t\tu = { 0, 0, 0 }","\tend","\tlocal r = exp(q[1])","\treturn quicknew( r*cos(m), r*u[1], r*u[2], r*u[3] )","end","","local function qlog(q)","\tlocal l = sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","\tif l == 0 then return { -1e+100, 0, 0, 0 } end","\tlocal u = { q[1]/l, q[2]/l, q[3]/l, q[4]/l }","\tlocal a = acos(u[1])","\tlocal m = sqrt(u[2]*u[2] + u[3]*u[3] + u[4]*u[4])","\tif abs(m) > delta then","\t\treturn quicknew( log(l), a*u[2]/m, a*u[3]/m, a*u[4]/m )","\telse","\t\treturn quicknew( log(l), 0, 0, 0 )  --when m is 0, u[2], u[3] and u[4] are 0 too","\tend","end","","--******************************************************************************--","","local argTypesToQuat = {}"],"typtbl":"quat_methods","fields":[],"name":"Quaternion","summary":"\nQuaternion type ","description":"\nQuaternion type","class":"class","methods":{"1":"conj","2":"forward","3":"i","4":"j","5":"k","6":"r","7":"real","8":"right","9":"up","conj":{"comment":["--- Returns the conj of self"],"code":["function quat_methods:conj()","\treturn quat_lib.conj( self )","end","","function quat_methods:inv()","\treturn quat_lib.inv( self )","end",""],"class":"function","name":"quat_methods:conj","summary":"\nReturns the conj of self ","private":false,"classlib":"Quaternion","description":"\nReturns the conj of self","param":[]},"r":{"comment":["--- Alias for :real() as r is easier"],"code":["function quat_methods:r()","\treturn self:real()","end","",""],"class":"function","name":"quat_methods:r","summary":"\nAlias for :real() as r is easier ","private":false,"classlib":"Quaternion","description":"\nAlias for :real() as r is easier","param":[]},"right":{"comment":["--- Returns vector pointing right for <this>"],"code":["function quat_methods:right()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt4 * this1 - t2 * this3,","\tthis2 * this2 - this1 * this1 + this4 * this4 - this3 * this3,","\t- t2 * this1 - t3 * this4","\t) )","end",""],"class":"function","name":"quat_methods:right","summary":"\nReturns vector pointing right for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing right for <this>","param":[]},"real":{"comment":["--- Returns the real component of the quaternion"],"code":["function quat_methods:real()","\treturn self[1]","end",""],"class":"function","name":"quat_methods:real","summary":"\nReturns the real component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the real component of the quaternion","param":[]},"i":{"comment":["--- Returns the i component of the quaternion"],"code":["function quat_methods:i()","\treturn self[2]","end",""],"class":"function","name":"quat_methods:i","summary":"\nReturns the i component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the i component of the quaternion","param":[]},"k":{"comment":["--- Returns the k component of the quaternion"],"code":["function quat_methods:k()","\treturn self[4]","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:k","summary":"\nReturns the k component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the k component of the quaternion","param":[]},"j":{"comment":["--- Returns the j component of the quaternion"],"code":["function quat_methods:j()","\treturn self[3]","end",""],"class":"function","name":"quat_methods:j","summary":"\nReturns the j component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the j component of the quaternion","param":[]},"forward":{"comment":["--- Returns vector pointing forward for <this>"],"code":["function quat_methods:forward()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tthis1 * this1 + this2 * this2 - this3 * this3 - this4 * this4,","\tt3 * this2 + t4 * this1,","\tt4 * this2 - t3 * this1","\t) )","end",""],"class":"function","name":"quat_methods:forward","summary":"\nReturns vector pointing forward for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing forward for <this>","param":[]},"up":{"comment":["--- Returns vector pointing up for <this>"],"code":["function quat_methods:up()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt3 * this1 + t2 * this4,","\tt3 * this4 - t2 * this1,","\tthis1 * this1 - this2 * this2 - this3 * this3 + this4 * this4","\t) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:up","summary":"\nReturns vector pointing up for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing up for <this>","param":[]}}},{"summary":"\nConverts a number to a Quaternion format for generation ","description":"\nConverts a number to a Quaternion format for generation","comment":["--- Converts a number to a Quaternion format for generation","-- @param args"],"code":["argTypesToQuat[\"number\"] = function(num)","\treturn quicknew(num, 0, 0, 0)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"number\"]","param":{"1":"num","2":"args","args":""}},{"summary":"\nConverts 4 numbers to a Quaternion format for generation ","description":"\nConverts 4 numbers to a Quaternion format for generation","comment":["--- Converts 4 numbers to a Quaternion format for generation","-- @param args"],"code":["argTypesToQuat[\"numbernumbernumbernumber\"] = function(a,b,c,d)","\treturn quicknew(a,b,c,d)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"numbernumbernumbernumber\"]","param":{"1":"a","2":"b","3":"c","4":"d","5":"args","args":""}},{"summary":"\nConverts a Vector to a Quaternion format for generation ","description":"\nConverts a Vector to a Quaternion format for generation","comment":["--- Converts a Vector to a Quaternion format for generation","-- @param args"],"code":["argTypesToQuat[\"Vector\"] = function(vec)","\treturn quicknew(0, vec.x, vec.y, vec.z)","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"Vector\"]","param":{"1":"vec","2":"args","args":""}},{"summary":"\nConverts an Angle to a Quaternion format for generation ","description":"\nConverts an Angle to a Quaternion format for generation","comment":["--- Converts an Angle to a Quaternion format for generation","-- @param args"],"code":["argTypesToQuat[\"Angle\"] = function(ang)","\tlocal p, y, r = ang.p, ang.y, ang.r","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"Angle\"]","param":{"1":"ang","2":"args","args":""}},{"summary":"\nConverts a Number/Vector combination to a Quaternion format for generation ","description":"\nConverts a Number/Vector combination to a Quaternion format for generation","comment":["--- Converts a Number/Vector combination to a Quaternion format for generation","-- @param args"],"code":["argTypesToQuat[\"numberVector\"] = function(num,vec)","\treturn quicknew(num, vec.x, vec.y, vec.z) -- TODO Cannot change protect metatable? fix this","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"numberVector\"]","param":{"1":"num","2":"vec","3":"args","args":""}},{"summary":"\nConverts two Vectors to a Quaternion format for generation using Cross product and the angle between them ","description":"\nConverts two Vectors to a Quaternion format for generation using Cross product and the angle between them","comment":["--- Converts two Vectors to a Quaternion format for generation using Cross product and the angle between them","-- @param args"],"code":["argTypesToQuat[\"VectorVector\"] = function(forward,up)","\tlocal x = Vector(forward.x, forward.y, forward.z)","\tlocal z = Vector(up.x, up.y, up.z)","\tlocal y = z:Cross(x):GetNormalized() --up x forward = left","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tlocal roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = y.z","\tif dot < 0 then roll = -roll end","","\tlocal p, y, r = ang.p, ang.y, roll","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end",""],"private":false,"class":"function","name":"argTypesToQuat[\"VectorVector\"]","param":{"1":"forward","2":"up","3":"args","args":""}},{"summary":"\nConverts an Entity to a Quaternion format for generation ","description":"\nConverts an Entity to a Quaternion format for generation","comment":["--- Converts an Entity to a Quaternion format for generation","-- @param args Table, containing an Entity to be used at the first index."],"code":["argTypesToQuat[\"Entity\"] = function(ent)","\tent = SF.UnwrapObject( ent )","\t","\tif not isValid( ent ) then","\t\treturn quicknew( 0, 0, 0, 0 )","\tend","","\tlocal ang = ent:GetAngles()","\tlocal p, y, r = ang.p, ang.y, ang.r","\tp = p*deg2rad*0.5","\ty = y*deg2rad*0.5","\tr = r*deg2rad*0.5","\tlocal qr = {cos(r), sin(r), 0, 0}","\tlocal qp = {cos(p), 0, sin(p), 0}","\tlocal qy = {cos(y), 0, 0, sin(y)}","\treturn qmul(qy,qmul(qp,qr))","end","","",""],"private":false,"class":"function","name":"argTypesToQuat[\"Entity\"]","param":{"1":"ent","2":"args","args":"Table, containing an Entity to be used at the first index."}},{"comment":["--- Creates a new Quaternion given a variety of inputs","-- @param ... A series of arguments which lead to valid generation of a quaternion.","-- See argTypesToQuat table for examples of acceptable inputs."],"code":["function quat_lib.New( self, ...)","\tlocal args = {...}","\t","\tlocal argtypes = \"\"","\tfor i=1,min(#args,4) do","\t\targtypes = argtypes .. SF.GetType( args[i] )","\tend","\t","\treturn argTypesToQuat[argtypes] and argTypesToQuat[argtypes](...) or quicknew(0,0,0,0)","end","","quat_lib_metamethods.__call = quat_lib.New","","","local function format(value)","\tlocal r,i,j,k,dbginfo","","\tr = \"\"","\ti = \"\"","\tj = \"\"","\tk = \"\"","","\tif abs(value[1]) > 0.0005 then","\t\tr = Round(value[1]*1000)/1000","\tend","","\tdbginfo = r","","\tif abs(value[2]) > 0.0005 then","\t\ti = tostring(Round(value[2]*1000)/1000)","","\t\tif string.sub(i,1,1) ~= \"-\" and dbginfo ~= \"\" then i = \"+\"..i end","","\t\ti = i .. \"i\"","\tend","","\tdbginfo = dbginfo .. i","","\tif abs(value[3]) > 0.0005 then","\t\tj = tostring(Round(value[3]*1000)/1000)","","\t\tif string.sub(j,1,1) ~= \"-\" and dbginfo ~= \"\" then j = \"+\"..j end","","\t\tj = j .. \"j\"","\tend","","\tdbginfo = dbginfo .. j","","\tif abs(value[4]) > 0.0005 then","\t\tk = tostring(Round(value[4]*1000)/1000)","","\t\tif string.sub(k,1,1) ~= \"-\" and dbginfo ~= \"\" then k = \"+\"..k end","","\t\tk = k .. \"k\"","\tend","","\tdbginfo = dbginfo .. k","","\tif dbginfo == \"\" then dbginfo = \"0 LAWL\" end","","\treturn dbginfo","end","","","quat_metamethods.__tostring = format","","","",""],"class":"function","name":"quat_lib.New","summary":"\nCreates a new Quaternion given a variety of inputs ","private":false,"library":"quaternion","description":"\nCreates a new Quaternion given a variety of inputs","param":{"1":"self","2":"...","...":"A series of arguments which lead to valid generation of a quaternion. \nSee argTypesToQuat table for examples of acceptable inputs."}},{"comment":["--- Returns Quaternion <n>*i"],"code":["function quat_lib.qi(n)","\treturn quicknew(0, n or 1, 0, 0)","end",""],"class":"function","name":"quat_lib.qi","summary":"\nReturns Quaternion <n>*i ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*i","param":["n"]},{"comment":["--- Returns Quaternion <n>*j"],"code":["function quat_lib.qj(n)","\treturn quicknew(0, 0, n or 1, 0)","end",""],"class":"function","name":"quat_lib.qj","summary":"\nReturns Quaternion <n>*j ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*j","param":["n"]},{"comment":["--- Returns Quaternion <n>*k"],"code":["function quat_lib.qk(n)","\treturn quicknew(0, 0, 0, n or 1)","end","","","","","quat_metamethods.__unm = function(q)","\treturn quicknew( -q[1], -q[2], -q[3], -q[4] )","end","","","quat_metamethods.__add = function(lhs, rhs)","","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3], lhs[4] + rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] + rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs + rhs[1], rhs[2], rhs[3], rhs[4] )","\tend","","\tError(\"Tried to add a \" .. ltype .. \" to a \" .. rtype .. \"not \")","end","","","quat_metamethods.__sub = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\treturn quicknew( lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4] )","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] - rhs, lhs[2], lhs[3], lhs[4] )","\t\tend","\telseif ltype == \"number\" and rtype == \"Quaternion\" then","\t\treturn quicknew( lhs - rhs[1], -rhs[2], -rhs[3], -rhs[4] )","\tend","","\tError(\"Tried to subtract a \" .. ltype .. \" from a \" .. rtype .. \"not \")","end","","","quat_metamethods.__mul = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\treturn quicknew( lhs[1] * rhs, lhs[2] * rhs, lhs[3] * rhs, lhs[4] * rhs )","\t\telseif rtype == \"Vector\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs1 * rhs2 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs1 * rhs3 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs1 * rhs4 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\treturn quicknew( lhs * rhs[1], lhs * rhs[2], lhs * rhs[3], lhs * rhs[4] )","\t\telseif ltype == \"Vector\" then","\t\t\tlocal lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\treturn quicknew(","\t\t\t-lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\t\tlhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\t\tlhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\t\tlhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t\t\t)","\t\tend","\tend","","\tError(\"Tried to multiply a \" .. ltype .. \" with a \" .. rtype .. \"not \\n\")","end","","","quat_metamethods.__div = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" then","\t\tif rtype == \"Quaternion\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs1 * rhs1 + lhs2 * rhs2 + lhs3 * rhs3 + lhs4 * rhs4)/l,","\t\t\t(-lhs1 * rhs2 + lhs2 * rhs1 - lhs3 * rhs4 + lhs4 * rhs3)/l,","\t\t\t(-lhs1 * rhs3 + lhs3 * rhs1 - lhs4 * rhs2 + lhs2 * rhs4)/l,","\t\t\t(-lhs1 * rhs4 + lhs4 * rhs1 - lhs2 * rhs3 + lhs3 * rhs2)/l","\t\t\t)","\t\telseif rtype == \"number\" then","\t\t\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\t\t\treturn quicknew(","\t\t\tlhs1/rhs,","\t\t\tlhs2/rhs,","\t\t\tlhs3/rhs,","\t\t\tlhs4/rhs","\t\t\t)","\t\tend","\telseif rtype == \"Quaternion\" then","\t\tif ltype == \"number\" then","\t\t\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\t\t\tlocal l = rhs1*rhs1 + rhs2*rhs2 + rhs3*rhs3 + rhs4*rhs4","\t\t\treturn quicknew(","\t\t\t( lhs * rhs1)/l,","\t\t\t(-lhs * rhs2)/l,","\t\t\t(-lhs * rhs3)/l,","\t\t\t(-lhs * rhs4)/l","\t\t\t)","\t\tend","\tend","","\terror(\"Tried to divide a \" .. ltype .. \" with a \" .. rtype)","end","","","quat_metamethods.__pow = function(lhs, rhs)","\tSF.CheckType(lhs, quat_metamethods)","\tSF.CheckType(rhs, quat_metamethods)","","","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"number\" then","\t\tif lhs == 0 then return { 0, 0, 0, 0 } end","","\t\tlocal l = log(lhs)","\t\treturn qexp({ l*rhs[1], l*rhs[2], l*rhs[3], l*rhs[4] })","\telseif rtype == \"Quaternion\" and ltype == \"number\" then","\t\tlocal l = qlog(lhs)","\t\treturn qexp({ l[1]*rhs, l[2]*rhs, l[3]*rhs, l[4]*rhs })","\tend","","\tError(\"Tried to exponentiate a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end","","","--[[****************************************************************************]]","","quat_metamethods.__eq = function(lhs, rhs)","\tlocal ltype = SF.GetType(lhs)","\tlocal rtype = SF.GetType(rhs)","","\tif ltype == \"Quaternion\" and rtype == \"Quaternion\" then","\t\tlocal rvd1, rvd2, rvd3, rvd4 = lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3], lhs[4] - rhs[4]","\t\tif rvd1 <= delta and rvd1 >= -delta and","\t\t\trvd2 <= delta and rvd2 >= -delta and","\t\t\trvd3 <= delta and rvd3 >= -delta and","\t\t\trvd4 <= delta and rvd4 >= -delta","\t\tthen","\t\t\treturn 1","\t\telse","\t\t\treturn 0","\t\tend","\tend","","\tError(\"Tried to compare a \" .. ltype .. \" with a \" .. rtype .. \"not \")","end",""],"class":"function","name":"quat_lib.qk","summary":"\nReturns Quaternion <n>*k ","private":false,"library":"quaternion","description":"\nReturns Quaternion <n>*k","param":["n"]},{"comment":["--- Returns absolute value of <q>"],"code":["function quat_lib.abs(q)","\treturn sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","end",""],"class":"function","name":"quat_lib.abs","summary":"\nReturns absolute value of <q> ","private":false,"library":"quaternion","description":"\nReturns absolute value of <q>","param":["q"]},{"comment":["--- Returns the conjugate of <q>"],"code":["function quat_lib.conj(q)","\treturn quicknew(q[1], -q[2], -q[3], -q[4])","end",""],"class":"function","name":"quat_lib.conj","summary":"\nReturns the conjugate of <q> ","private":false,"library":"quaternion","description":"\nReturns the conjugate of <q>","param":["q"]},{"comment":["--- Returns the inverse of <q>"],"code":["function quat_lib.inv(q)","\tlocal l = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\treturn quicknew( q[1]/l, -q[2]/l, -q[3]/l, -q[4]/l )","end",""],"class":"function","name":"quat_lib.inv","summary":"\nReturns the inverse of <q> ","private":false,"library":"quaternion","description":"\nReturns the inverse of <q>","param":["q"]},{"comment":["--- Returns the conj of self"],"code":["function quat_methods:conj()","\treturn quat_lib.conj( self )","end","","function quat_methods:inv()","\treturn quat_lib.inv( self )","end",""],"class":"function","name":"quat_methods:conj","summary":"\nReturns the conj of self ","private":false,"classlib":"Quaternion","description":"\nReturns the conj of self","param":[]},{"comment":["--- Returns the real component of the quaternion"],"code":["function quat_methods:real()","\treturn self[1]","end",""],"class":"function","name":"quat_methods:real","summary":"\nReturns the real component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the real component of the quaternion","param":[]},{"comment":["--- Alias for :real() as r is easier"],"code":["function quat_methods:r()","\treturn self:real()","end","",""],"class":"function","name":"quat_methods:r","summary":"\nAlias for :real() as r is easier ","private":false,"classlib":"Quaternion","description":"\nAlias for :real() as r is easier","param":[]},{"comment":["--- Returns the i component of the quaternion"],"code":["function quat_methods:i()","\treturn self[2]","end",""],"class":"function","name":"quat_methods:i","summary":"\nReturns the i component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the i component of the quaternion","param":[]},{"comment":["--- Returns the j component of the quaternion"],"code":["function quat_methods:j()","\treturn self[3]","end",""],"class":"function","name":"quat_methods:j","summary":"\nReturns the j component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the j component of the quaternion","param":[]},{"comment":["--- Returns the k component of the quaternion"],"code":["function quat_methods:k()","\treturn self[4]","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:k","summary":"\nReturns the k component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the k component of the quaternion","param":[]},{"comment":["--- Raises Euler's constant e to the power <q>"],"code":["function quat_lib.exp(q)","\treturn qexp(q)","end",""],"class":"function","name":"quat_lib.exp","summary":"\nRaises Euler's constant e to the power <q> ","private":false,"library":"quaternion","description":"\nRaises Euler's constant e to the power <q>","param":["q"]},{"comment":["--- Calculates natural logarithm of <q>"],"code":["function quat_lib.log(q)","\treturn qlog(q)","end",""],"class":"function","name":"quat_lib.log","summary":"\nCalculates natural logarithm of <q> ","private":false,"library":"quaternion","description":"\nCalculates natural logarithm of <q>","param":["q"]},{"comment":["--- Changes quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)"],"code":["function quat_lib.qMod(q)","\tif q[1]<0 then return quicknew(-q[1], -q[2], -q[3], -q[4]) else return quicknew(q[1], q[2], q[3], q[4]) end","end",""],"class":"function","name":"quat_lib.qMod","summary":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nChanges quaternion <q> so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)","param":["q"]},{"comment":["--- Performs spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1"],"code":["function quat_lib.slerp(q0, q1, t)","\tlocal dot = q0[1]*q1[1] + q0[2]*q1[2] + q0[3]*q1[3] + q0[4]*q1[4]","\tlocal q11","\tif dot<0 then","\t\tq11 = {-q1[1], -q1[2], -q1[3], -q1[4]}","\telse","\t\tq11 = { q1[1], q1[2], q1[3], q1[4] }  -- dunno if just q11 = q1 works","\tend","","\tlocal l = q0[1]*q0[1] + q0[2]*q0[2] + q0[3]*q0[3] + q0[4]*q0[4]","","\tif l==0 then return quicknew( 0, 0, 0, 0 ) end","","\tlocal invq0 = { q0[1]/l, -q0[2]/l, -q0[3]/l, -q0[4]/l }","\tlocal logq = qlog(qmul(invq0,q11))","\tlocal q = qexp( { logq[1]*t, logq[2]*t, logq[3]*t, logq[4]*t } )","","\treturn qmul(q0,q)","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.slerp","summary":"\nPerforms spherical linear interpolation between <q0> and <q1>.","private":false,"library":"quaternion","description":"\nPerforms spherical linear interpolation between <q0> and <q1>. Returns <q0> for <t>=0, <q1> for <t>=1","param":["q0","q1","t"]},{"comment":["--- Returns vector pointing forward for <this>"],"code":["function quat_methods:forward()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tthis1 * this1 + this2 * this2 - this3 * this3 - this4 * this4,","\tt3 * this2 + t4 * this1,","\tt4 * this2 - t3 * this1","\t) )","end",""],"class":"function","name":"quat_methods:forward","summary":"\nReturns vector pointing forward for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing forward for <this>","param":[]},{"comment":["--- Returns vector pointing right for <this>"],"code":["function quat_methods:right()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt4 * this1 - t2 * this3,","\tthis2 * this2 - this1 * this1 + this4 * this4 - this3 * this3,","\t- t2 * this1 - t3 * this4","\t) )","end",""],"class":"function","name":"quat_methods:right","summary":"\nReturns vector pointing right for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing right for <this>","param":[]},{"comment":["--- Returns vector pointing up for <this>"],"code":["function quat_methods:up()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt3 * this1 + t2 * this4,","\tt3 * this4 - t2 * this1,","\tthis1 * this1 - this2 * this2 - this3 * this3 + this4 * this4","\t) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:up","summary":"\nReturns vector pointing up for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing up for <this>","param":[]},{"comment":["--- Returns quaternion for rotation about axis <axis> by angle <ang>"],"code":["function quat_lib.qRotation(axis, ang)","\tlocal ax = axis","\tax:Normalize()","\tlocal ang2 = ang*deg2rad*0.5","","\treturn quicknew( cos(ang2), ax.x*sin(ang2), ax.y*sin(ang2), ax.z*sin(ang2) )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nReturns quaternion for rotation about axis <axis> by angle <ang> ","private":false,"library":"quaternion","description":"\nReturns quaternion for rotation about axis <axis> by angle <ang>","param":["axis","ang"]},{"comment":["--- Construct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)"],"code":["function quat_lib.qRotation(rv1)","\tlocal angSquared = rv1.x * rv1.x + rv1.y * rv1.y + rv1.z * rv1.z","","\tif angSquared == 0 then return quicknew( 1, 0, 0, 0 ) end","","\tlocal len = sqrt(angSquared)","\tlocal ang = (len + 180) % 360 - 180","\tlocal ang2 = ang*deg2rad*0.5","\tlocal sang2len = sin(ang2) / len","","\treturn quicknew( cos(ang2), rv1.x * sang2len , rv1.y * sang2len, rv1.z * sang2len )","end",""],"class":"function","name":"quat_lib.qRotation","summary":"\nConstruct a quaternion from the rotation vector <rv1>.","private":false,"library":"quaternion","description":"\nConstruct a quaternion from the rotation vector <rv1>. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)","param":["rv1"]},{"comment":["--- Returns the euler angle of rotation in degrees"],"code":["function quat_lib.rotationEulerAngle(q)","\tlocal l = sqrt(q[1]*q[1]+q[2]*q[2]+q[3]*q[3]+q[4]*q[4])","\tif l == 0 then return SF.WrapObject( Angle( 0, 0, 0) ) end","\tlocal q1, q2, q3, q4 = q[1]/l, q[2]/l, q[3]/l, q[4]/l","","\tlocal x = Vector(q1*q1 + q2*q2 - q3*q3 - q4*q4,","\t\t2*q3*q2 + 2*q4*q1,","\t\t2*q4*q2 - 2*q3*q1)","","\tlocal y = Vector(2*q2*q3 - 2*q4*q1,","\t\tq1*q1 - q2*q2 + q3*q3 - q4*q4,","\t\t2*q2*q1 + 2*q3*q4)","","\tlocal ang = x:Angle()","\tif ang.p > 180 then ang.p = ang.p - 360 end","\tif ang.y > 180 then ang.y = ang.y - 360 end","","\tlocal yyaw = Vector(0,1,0)","\tyyaw:Rotate(Angle(0,ang.y,0))","","\tang.roll = acos(math.Clamp(y:Dot(yyaw), -1, 1))*rad2deg","","\tlocal dot = q2*q1 + q3*q4","\tif dot < 0 then ang.roll = -ang.roll end","","\treturn SF.WrapObject( ang )","end",""],"class":"function","name":"quat_lib.rotationEulerAngle","summary":"\nReturns the euler angle of rotation in degrees ","private":false,"library":"quaternion","description":"\nReturns the euler angle of rotation in degrees","param":["q"]},{"comment":["--- Returns the angle of rotation in degrees (by coder0xff)"],"code":["function quat_lib.rotationAngle(q)","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","","\tif l2 == 0 then return 0 end","","\tlocal l = sqrt(l2)","\tlocal ang = 2*acos(math.Clamp(q[1]/l, -1, 1))*rad2deg  --this returns angle from 0 to 360","","\tif ang > 180 then ang = ang - 360 end  -- make it -180 - 180","","\treturn ang","end",""],"class":"function","name":"quat_lib.rotationAngle","summary":"\nReturns the angle of rotation in degrees (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the angle of rotation in degrees (by coder0xff)","param":["q"]},{"comment":["--- Returns the axis of rotation (by coder0xff)"],"code":["function quat_lib.rotationAxis(q)","\tlocal m2 = q[2] * q[2] + q[3] * q[3] + q[4] * q[4]","","\tif m2 == 0 then return vwrap( Vector( 0, 0, 1 ) ) end","","\tlocal m = sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] / m, q[ 3 ] / m, q[ 4 ] / m ) )","end",""],"class":"function","name":"quat_lib.rotationAxis","summary":"\nReturns the axis of rotation (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the axis of rotation (by coder0xff)","param":["q"]},{"comment":["--- Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)"],"code":["function quat_lib.rotationVector(q)","\tSF.CheckType( q, quat_metamethods )","\tlocal l2 = q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]","\tlocal m2 = math.max( q[2]*q[2] + q[3]*q[3] + q[4]*q[4], 0 )","","\tif l2 == 0 or m2 == 0 then return vwrap( Vector( 0, 0, 0 ) ) end","","\tlocal s = 2 * acos( math.Clamp( q[1] / sqrt(l2), -1, 1 ) ) * rad2deg","","\tif s > 180 then s = s - 360 end","","\ts = s / sqrt(m2)","\treturn vwrap( Vector( q[ 2 ] * s, q[ 3 ] * s, q[ 4 ] * s ) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_lib.rotationVector","summary":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff) ","private":false,"library":"quaternion","description":"\nReturns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)","param":["q"]},{"comment":["--- Converts <q> to a vector by dropping the real component"],"code":["function quat_lib.vec(q)","\treturn vwrap( Vector( q[ 2 ], q[ 3 ], q[ 4 ] ) )","end","","--[[****************************************************************************]]"],"class":"function","name":"quat_lib.vec","summary":"\nConverts <q> to a vector by dropping the real component ","private":false,"library":"quaternion","description":"\nConverts <q> to a vector by dropping the real component","param":["q"]}],"tables":[],"description":"\nQuaternion library","summary":"\nQuaternion library "},"callback.lua":{"libraries":[],"type":"file","name":"callback.lua","functions":{"1":"P:addListener","2":"P:dispatch","3":"P:removeListener","4":"SF.Callback.new","P:addListener":{"summary":"\nAdds a listener to the callback object's storage ","description":"\nAdds a listener to the callback object's storage","comment":["--- Adds a listener to the callback object's storage","-- @param func the callback function that will be called when data is returned"],"code":["function P:addListener( func )","\tself.listeners[func] = func","end",""],"private":false,"class":"function","name":"P:addListener","param":{"1":"func","func":"the callback function that will be called when data is returned"}},"P:dispatch":{"ret":"if any function errors, returns the error message","comment":["--- Calls all of the stored listeners, passing them the data you pass","-- @param ... data","-- @return if any function errors, returns the error message"],"code":["function P:dispatch( ... )","\tlocal error = nil","\tfor _, listener in pairs(self.listeners) do","\t\terror = pcall( listener, ... )","\tend","\t","\treturn error","end",""],"class":"function","name":"P:dispatch","private":false,"summary":"\nCalls all of the stored listeners, passing them the data you pass ","description":"\nCalls all of the stored listeners, passing them the data you pass","param":{"1":"...","...":"data"}},"SF.Callback.new":{"summary":"\n \nConstructor \n ","description":"\n \nConstructor \n","comment":["---------------------------------------------------------------------","-- Constructor","---------------------------------------------------------------------"],"code":["function SF.Callback.new()","\tlocal table = {}","\ttable.listeners = {}","\tsetmetatable( table, P_meta )","\t","\treturn table","end"],"private":false,"class":"function","name":"SF.Callback.new","param":[]},"P:removeListener":{"summary":"\nRemoves a listener from the callback object's storage ","description":"\nRemoves a listener from the callback object's storage","comment":["--- Removes a listener from the callback object's storage","-- @param func the function you want to remove from listening"],"code":["function P:removeListener( func )","\tself.listeners[func] = nil","end",""],"private":false,"class":"function","name":"P:removeListener","param":{"1":"func","func":"the function you want to remove from listening"}}},"doc":[{"comment":["---------------------------------------------------------------------","-- SF callback class.","---------------------------------------------------------------------"],"code":["","-- Initialize the class, and set it's __index value to itself.","local P, P_meta = SF.Typedef(\"Callback\")","P_meta.__newindex = function()","\treturn","end","","-- Store the class on starfall global table.","SF.Callback = {}",""],"summary":"\n \nSF callback class.","description":"\n \nSF callback class. \n","param":[]},{"summary":"\n \nMethods \n ","description":"\n \nMethods \n","comment":["---------------------------------------------------------------------","-- Methods","---------------------------------------------------------------------"],"code":[""]},{"summary":"\nAdds a listener to the callback object's storage ","description":"\nAdds a listener to the callback object's storage","comment":["--- Adds a listener to the callback object's storage","-- @param func the callback function that will be called when data is returned"],"code":["function P:addListener( func )","\tself.listeners[func] = func","end",""],"private":false,"class":"function","name":"P:addListener","param":{"1":"func","func":"the callback function that will be called when data is returned"}},{"summary":"\nRemoves a listener from the callback object's storage ","description":"\nRemoves a listener from the callback object's storage","comment":["--- Removes a listener from the callback object's storage","-- @param func the function you want to remove from listening"],"code":["function P:removeListener( func )","\tself.listeners[func] = nil","end",""],"private":false,"class":"function","name":"P:removeListener","param":{"1":"func","func":"the function you want to remove from listening"}},{"ret":"if any function errors, returns the error message","comment":["--- Calls all of the stored listeners, passing them the data you pass","-- @param ... data","-- @return if any function errors, returns the error message"],"code":["function P:dispatch( ... )","\tlocal error = nil","\tfor _, listener in pairs(self.listeners) do","\t\terror = pcall( listener, ... )","\tend","\t","\treturn error","end",""],"class":"function","name":"P:dispatch","private":false,"summary":"\nCalls all of the stored listeners, passing them the data you pass ","description":"\nCalls all of the stored listeners, passing them the data you pass","param":{"1":"...","...":"data"}},{"summary":"\n \nConstructor \n ","description":"\n \nConstructor \n","comment":["---------------------------------------------------------------------","-- Constructor","---------------------------------------------------------------------"],"code":["function SF.Callback.new()","\tlocal table = {}","\ttable.listeners = {}","\tsetmetatable( table, P_meta )","\t","\treturn table","end"],"private":false,"class":"function","name":"SF.Callback.new","param":[]}],"tables":[],"description":"\n \nSF callback class. \n","summary":"\n \nSF callback class."},"libs_sh/http.lua":{"libraries":{"1":"http","http":{"comment":["--- Http library. Requests content from urls.","-- @shared"],"functions":{"1":"canRequest","2":"get","3":"post","post":{"comment":["--- Runs a new http POST request","-- @param url http target url","-- @param params POST parameters to be sent","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.post ( url, params, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\t","\tif params then","\t\tSF.CheckType( params, \"table\" )","\t\tfor k,v in pairs( params ) do","\t\t\tif type( k ) ~= \"string\" or type( v ) ~= \"string\" then","\t\t\t\tSF.throw( \"Post parameters can only contain string keys and string values\", 2 )","\t\t\tend","\t\tend","\tend","\t","\tSF.CheckType( callbackSuccess, \"function\" )\t","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Post( url, params, function ( body, len, headers, code )","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end"],"class":"function","name":"http_library.post","summary":"\nRuns a new http POST request ","private":false,"library":"http","description":"\nRuns a new http POST request","param":{"1":"url","2":"params","3":"callbackSuccess","4":"callbackFail","callbackFail":"the function to be called on request fail, taking the failing reason as an argument","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","params":"POST parameters to be sent"}},"canRequest":{"comment":["--- Checks if a new http request can be started"],"code":["function http_library.canRequest ( )","\tlocal httpData = SF.instance.data.http","\treturn CurTime() - httpData.lastRequest >= http_interval:GetFloat() and httpData.active < http_max_active:GetInt()","end",""],"class":"function","name":"http_library.canRequest","summary":"\nChecks if a new http request can be started ","private":false,"library":"http","description":"\nChecks if a new http request can be started","param":[]},"get":{"comment":["--- Runs a new http GET request","-- @param url http target url","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.get ( url, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\tSF.CheckType( callbackSuccess, \"function\" )","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Fetch( url, function ( body, len, headers, code ) ","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end",""],"class":"function","name":"http_library.get","summary":"\nRuns a new http GET request ","private":false,"library":"http","description":"\nRuns a new http GET request","param":{"1":"url","2":"callbackSuccess","3":"callbackFail","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","callbackFail":"the function to be called on request fail, taking the failing reason as an argument"}}},"class":"library","summary":"\nHttp library.","code":["local http_library, _ = SF.Libraries.Register( \"http\" )","local http_interval = CreateConVar( \"sf_http_interval\", \"0.5\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"Interval in seconds in which one http request can be made\" )","local http_max_active = CreateConVar( \"sf_http_max_active\", \"3\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"The maximum amount of active http requests at the same time\" )","","-- Initializes the lastRequest variable to a value which ensures that the first call to httpRequestReady returns true","-- and the \"active requests counter\" to 0","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.http = {","\t\tlastRequest = 0,","\t\tactive = 0","\t}","end )","","-- Returns an error when a http request was already triggered in the current interval","-- or the maximum amount of simultaneous requests is currently active, returns true otherwise","local function httpRequestReady ( instance )","\tlocal httpData = instance.data.http","\tif CurTime() - httpData.lastRequest < http_interval:GetFloat() or httpData.active >= http_max_active:GetInt() then","\t\tSF.throw( \"You can't run a new http request yet\", 2 )","\tend","\treturn true","end","","-- Runs the appropriate callback after a http request","local function runCallback ( instance, callback, ... )","\tif callback then","\t\tlocal args = { ... }","\t\tif IsValid( instance.data.entity ) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, unpack( args ) )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"http callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend","\tinstance.data.http.active = instance.data.http.active - 1","end",""],"fields":[],"name":"http","client":true,"description":"\nHttp library. Requests content from urls.","libtbl":"http_library","tables":[],"server":true}},"type":"file","name":"libs_sh/http.lua","functions":{"1":"http_library.canRequest","2":"http_library.get","3":"http_library.post","http_library.canRequest":{"comment":["--- Checks if a new http request can be started"],"code":["function http_library.canRequest ( )","\tlocal httpData = SF.instance.data.http","\treturn CurTime() - httpData.lastRequest >= http_interval:GetFloat() and httpData.active < http_max_active:GetInt()","end",""],"class":"function","name":"http_library.canRequest","summary":"\nChecks if a new http request can be started ","private":false,"library":"http","description":"\nChecks if a new http request can be started","param":[]},"http_library.get":{"comment":["--- Runs a new http GET request","-- @param url http target url","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.get ( url, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\tSF.CheckType( callbackSuccess, \"function\" )","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Fetch( url, function ( body, len, headers, code ) ","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end",""],"class":"function","name":"http_library.get","summary":"\nRuns a new http GET request ","private":false,"library":"http","description":"\nRuns a new http GET request","param":{"1":"url","2":"callbackSuccess","3":"callbackFail","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","callbackFail":"the function to be called on request fail, taking the failing reason as an argument"}},"http_library.post":{"comment":["--- Runs a new http POST request","-- @param url http target url","-- @param params POST parameters to be sent","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.post ( url, params, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\t","\tif params then","\t\tSF.CheckType( params, \"table\" )","\t\tfor k,v in pairs( params ) do","\t\t\tif type( k ) ~= \"string\" or type( v ) ~= \"string\" then","\t\t\t\tSF.throw( \"Post parameters can only contain string keys and string values\", 2 )","\t\t\tend","\t\tend","\tend","\t","\tSF.CheckType( callbackSuccess, \"function\" )\t","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Post( url, params, function ( body, len, headers, code )","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end"],"class":"function","name":"http_library.post","summary":"\nRuns a new http POST request ","private":false,"library":"http","description":"\nRuns a new http POST request","param":{"1":"url","2":"params","3":"callbackSuccess","4":"callbackFail","callbackFail":"the function to be called on request fail, taking the failing reason as an argument","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","params":"POST parameters to be sent"}}},"doc":[{"summary":"\nHTTP Library ","description":"\nHTTP Library","comment":["--- HTTP Library"],"code":[""]},{"comment":["--- Http library. Requests content from urls.","-- @shared"],"functions":{"1":"canRequest","2":"get","3":"post","post":{"comment":["--- Runs a new http POST request","-- @param url http target url","-- @param params POST parameters to be sent","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.post ( url, params, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\t","\tif params then","\t\tSF.CheckType( params, \"table\" )","\t\tfor k,v in pairs( params ) do","\t\t\tif type( k ) ~= \"string\" or type( v ) ~= \"string\" then","\t\t\t\tSF.throw( \"Post parameters can only contain string keys and string values\", 2 )","\t\t\tend","\t\tend","\tend","\t","\tSF.CheckType( callbackSuccess, \"function\" )\t","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Post( url, params, function ( body, len, headers, code )","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end"],"class":"function","name":"http_library.post","summary":"\nRuns a new http POST request ","private":false,"library":"http","description":"\nRuns a new http POST request","param":{"1":"url","2":"params","3":"callbackSuccess","4":"callbackFail","callbackFail":"the function to be called on request fail, taking the failing reason as an argument","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","params":"POST parameters to be sent"}},"canRequest":{"comment":["--- Checks if a new http request can be started"],"code":["function http_library.canRequest ( )","\tlocal httpData = SF.instance.data.http","\treturn CurTime() - httpData.lastRequest >= http_interval:GetFloat() and httpData.active < http_max_active:GetInt()","end",""],"class":"function","name":"http_library.canRequest","summary":"\nChecks if a new http request can be started ","private":false,"library":"http","description":"\nChecks if a new http request can be started","param":[]},"get":{"comment":["--- Runs a new http GET request","-- @param url http target url","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.get ( url, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\tSF.CheckType( callbackSuccess, \"function\" )","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Fetch( url, function ( body, len, headers, code ) ","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end",""],"class":"function","name":"http_library.get","summary":"\nRuns a new http GET request ","private":false,"library":"http","description":"\nRuns a new http GET request","param":{"1":"url","2":"callbackSuccess","3":"callbackFail","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","callbackFail":"the function to be called on request fail, taking the failing reason as an argument"}}},"class":"library","summary":"\nHttp library.","code":["local http_library, _ = SF.Libraries.Register( \"http\" )","local http_interval = CreateConVar( \"sf_http_interval\", \"0.5\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"Interval in seconds in which one http request can be made\" )","local http_max_active = CreateConVar( \"sf_http_max_active\", \"3\", { FCVAR_ARCHIVE, FCVAR_REPLICATED }, \"The maximum amount of active http requests at the same time\" )","","-- Initializes the lastRequest variable to a value which ensures that the first call to httpRequestReady returns true","-- and the \"active requests counter\" to 0","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.http = {","\t\tlastRequest = 0,","\t\tactive = 0","\t}","end )","","-- Returns an error when a http request was already triggered in the current interval","-- or the maximum amount of simultaneous requests is currently active, returns true otherwise","local function httpRequestReady ( instance )","\tlocal httpData = instance.data.http","\tif CurTime() - httpData.lastRequest < http_interval:GetFloat() or httpData.active >= http_max_active:GetInt() then","\t\tSF.throw( \"You can't run a new http request yet\", 2 )","\tend","\treturn true","end","","-- Runs the appropriate callback after a http request","local function runCallback ( instance, callback, ... )","\tif callback then","\t\tlocal args = { ... }","\t\tif IsValid( instance.data.entity ) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, unpack( args ) )","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"http callback errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend","\tinstance.data.http.active = instance.data.http.active - 1","end",""],"fields":[],"name":"http","client":true,"description":"\nHttp library. Requests content from urls.","libtbl":"http_library","tables":[],"server":true},{"comment":["--- Checks if a new http request can be started"],"code":["function http_library.canRequest ( )","\tlocal httpData = SF.instance.data.http","\treturn CurTime() - httpData.lastRequest >= http_interval:GetFloat() and httpData.active < http_max_active:GetInt()","end",""],"class":"function","name":"http_library.canRequest","summary":"\nChecks if a new http request can be started ","private":false,"library":"http","description":"\nChecks if a new http request can be started","param":[]},{"comment":["--- Runs a new http GET request","-- @param url http target url","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.get ( url, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\tSF.CheckType( callbackSuccess, \"function\" )","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Fetch( url, function ( body, len, headers, code ) ","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end",""],"class":"function","name":"http_library.get","summary":"\nRuns a new http GET request ","private":false,"library":"http","description":"\nRuns a new http GET request","param":{"1":"url","2":"callbackSuccess","3":"callbackFail","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","callbackFail":"the function to be called on request fail, taking the failing reason as an argument"}},{"comment":["--- Runs a new http POST request","-- @param url http target url","-- @param params POST parameters to be sent","-- @param callbackSuccess the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","-- @param callbackFail the function to be called on request fail, taking the failing reason as an argument"],"code":["function http_library.post ( url, params, callbackSuccess, callbackFail )","\tlocal instance = SF.instance","\t","\thttpRequestReady( instance )","\t","\tSF.CheckType( url, \"string\" )","\t","\tif params then","\t\tSF.CheckType( params, \"table\" )","\t\tfor k,v in pairs( params ) do","\t\t\tif type( k ) ~= \"string\" or type( v ) ~= \"string\" then","\t\t\t\tSF.throw( \"Post parameters can only contain string keys and string values\", 2 )","\t\t\tend","\t\tend","\tend","\t","\tSF.CheckType( callbackSuccess, \"function\" )\t","\tif callbackFail then SF.CheckType( callbackFail, \"function\" ) end","\t","\tinstance.data.http.lastRequest = CurTime()","\tinstance.data.http.active = instance.data.http.active + 1","\thttp.Post( url, params, function ( body, len, headers, code )","\t\trunCallback( instance, callbackSuccess, body, len, headers, code )","\tend, function ( err )","\t\trunCallback( instance, callbackFail, err )","\tend )","end"],"class":"function","name":"http_library.post","summary":"\nRuns a new http POST request ","private":false,"library":"http","description":"\nRuns a new http POST request","param":{"1":"url","2":"params","3":"callbackSuccess","4":"callbackFail","callbackFail":"the function to be called on request fail, taking the failing reason as an argument","url":"http target url","callbackSuccess":"the function to be called on request success, taking the arguments body (string), length (number), headers (table) and code (number)","params":"POST parameters to be sent"}}],"tables":[],"description":"\nHTTP Library","summary":"\nHTTP Library "},"permissions/providers_cl/input.lua":{"type":"file","name":"permissions/providers_cl/input.lua","functions":[],"doc":[],"libraries":[],"tables":[]},"libs_sh/sounds.lua":{"libraries":{"1":"sounds","sounds":{"comment":["--- Sounds library.","-- @shared"],"functions":{"1":"create","create":{"ret":"Sound Object","comment":["--- Creates a sound and attaches it to an entity","-- @param ent Entity to attach sound to.","-- @param path Filepath to the sound file.","-- @return Sound Object"],"code":["function sound_library.create ( ent, path )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tSF.CheckType( path, \"string\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","","\tlocal e = SF.UnwrapObject( ent )","\tif not ( e or e:IsValid() ) then","\t\tSF.throw( \"Invalid Entity\", 2 )","\tend","","\tlocal s = wrap( CreateSound( e, path ) )","\tlocal i = SF.instance.data.sounds.sounds","\ti[ s ] = s","","\treturn i[ s ]","end",""],"class":"function","name":"sound_library.create","summary":"\nCreates a sound and attaches it to an entity ","private":false,"library":"sounds","description":"\nCreates a sound and attaches it to an entity","param":{"1":"ent","2":"path","ent":"Entity to attach sound to.","path":"Filepath to the sound file."}}},"class":"library","summary":"\nSounds library.","code":["local sound_library, _ = SF.Libraries.Register( \"sounds\" )","","SF.Sounds.Wrap = wrap","SF.Sounds.Unwrap = unwrap","SF.Sounds.Methods = sound_methods","SF.Sounds.Metatable = sound_metamethods","","-- Register Privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"sound.create\", \"Sound\", \"Allows the user to create sounds\" )","\tP.registerPrivilege( \"sound.modify\", \"Sound\", \"Allows the user to modify created sounds\" )","end","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.sounds = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.sounds.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tunwrap( s ):Stop()","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""],"fields":[],"name":"sounds","client":true,"description":"\nSounds library.","libtbl":"sound_library","tables":[],"server":true}},"type":"file","name":"libs_sh/sounds.lua","functions":{"1":"sound_library.create","2":"sound_methods:isPlaying","3":"sound_methods:play","4":"sound_methods:setPitch","5":"sound_methods:setSoundLevel","6":"sound_methods:setVolume","7":"sound_methods:stop","sound_methods:setSoundLevel":{"comment":["--- Sets the sound level in dB.","-- @param level dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."],"code":["function sound_methods:setSoundLevel ( level )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( level, \"number\" )","\tunwrap( self ):SetSoundLevel( math.Clamp( level, 0, 511 ) )","end"],"class":"function","name":"sound_methods:setSoundLevel","summary":"\nSets the sound level in dB.","private":false,"classlib":"Sound","description":"\nSets the sound level in dB.","param":{"1":"level","level":"dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."}},"sound_library.create":{"ret":"Sound Object","comment":["--- Creates a sound and attaches it to an entity","-- @param ent Entity to attach sound to.","-- @param path Filepath to the sound file.","-- @return Sound Object"],"code":["function sound_library.create ( ent, path )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tSF.CheckType( path, \"string\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","","\tlocal e = SF.UnwrapObject( ent )","\tif not ( e or e:IsValid() ) then","\t\tSF.throw( \"Invalid Entity\", 2 )","\tend","","\tlocal s = wrap( CreateSound( e, path ) )","\tlocal i = SF.instance.data.sounds.sounds","\ti[ s ] = s","","\treturn i[ s ]","end",""],"class":"function","name":"sound_library.create","summary":"\nCreates a sound and attaches it to an entity ","private":false,"library":"sounds","description":"\nCreates a sound and attaches it to an entity","param":{"1":"ent","2":"path","ent":"Entity to attach sound to.","path":"Filepath to the sound file."}},"sound_methods:stop":{"comment":["--- Stops the sound from being played.","-- @param fade Time in seconds to fade out, if nil or 0 the sound stops instantly."],"code":["function sound_methods:stop ( fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tunwrap( self ):FadeOut( math.max( fade, 0 ) )","\telse","\t\tunwrap( self ):Stop()","\tend","end",""],"class":"function","name":"sound_methods:stop","summary":"\nStops the sound from being played.","private":false,"classlib":"Sound","description":"\nStops the sound from being played.","param":{"1":"fade","fade":"Time in seconds to fade out, if nil or 0 the sound stops instantly."}},"sound_methods:setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 255.","-- @param fade Time in seconds to transition to this new pitch."],"code":["function sound_methods:setPitch ( pitch, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pitch, \"number\" )","\t","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.max( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tpitch = math.Clamp( pitch, 0, 255 )","\tunwrap( self ):ChangePitch( pitch, fade )","end",""],"class":"function","name":"sound_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Sound","description":"\nSets the pitch of the sound.","param":{"1":"pitch","2":"fade","pitch":"Pitch to set to, between 0 and 255.","fade":"Time in seconds to transition to this new pitch."}},"sound_methods:isPlaying":{"comment":["--- Returns whether the sound is being played."],"code":["function sound_methods:isPlaying ()","\treturn unwrap( self ):IsPlaying()\t","end",""],"class":"function","name":"sound_methods:isPlaying","summary":"\nReturns whether the sound is being played.","private":false,"classlib":"Sound","description":"\nReturns whether the sound is being played.","param":[]},"sound_methods:setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1.","-- @param fade Time in seconds to transition to this new volume."],"code":["function sound_methods:setVolume ( vol, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( vol, \"number\" )","","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.abs( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tvol = math.Clamp( vol, 0, 1 )","\tunwrap( self ):ChangeVolume( vol, fade )","end",""],"class":"function","name":"sound_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Sound","description":"\nSets the volume of the sound.","param":{"1":"vol","2":"fade","vol":"Volume to set to, between 0 and 1.","fade":"Time in seconds to transition to this new volume."}},"sound_methods:play":{"comment":["--- Starts to play the sound."],"code":["function sound_methods:play ()","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( self, sound_metamethods )","\tunwrap( self ):Play()","end",""],"class":"function","name":"sound_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Sound","description":"\nStarts to play the sound.","param":[]}},"doc":[{"comment":["--- Sound type","-- @shared"],"code":["local sound_methods, sound_metamethods = SF.Typedef( \"Sound\" )","local wrap, unwrap = SF.CreateWrapper( sound_metamethods, true, false, debug.getregistry().CSoundPatch )",""],"typtbl":"sound_methods","summary":"\nSound type ","fields":[],"name":"Sound","server":true,"description":"\nSound type","client":true,"class":"class","methods":{"1":"isPlaying","2":"play","3":"setPitch","4":"setSoundLevel","5":"setVolume","6":"stop","setSoundLevel":{"comment":["--- Sets the sound level in dB.","-- @param level dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."],"code":["function sound_methods:setSoundLevel ( level )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( level, \"number\" )","\tunwrap( self ):SetSoundLevel( math.Clamp( level, 0, 511 ) )","end"],"class":"function","name":"sound_methods:setSoundLevel","summary":"\nSets the sound level in dB.","private":false,"classlib":"Sound","description":"\nSets the sound level in dB.","param":{"1":"level","level":"dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."}},"stop":{"comment":["--- Stops the sound from being played.","-- @param fade Time in seconds to fade out, if nil or 0 the sound stops instantly."],"code":["function sound_methods:stop ( fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tunwrap( self ):FadeOut( math.max( fade, 0 ) )","\telse","\t\tunwrap( self ):Stop()","\tend","end",""],"class":"function","name":"sound_methods:stop","summary":"\nStops the sound from being played.","private":false,"classlib":"Sound","description":"\nStops the sound from being played.","param":{"1":"fade","fade":"Time in seconds to fade out, if nil or 0 the sound stops instantly."}},"isPlaying":{"comment":["--- Returns whether the sound is being played."],"code":["function sound_methods:isPlaying ()","\treturn unwrap( self ):IsPlaying()\t","end",""],"class":"function","name":"sound_methods:isPlaying","summary":"\nReturns whether the sound is being played.","private":false,"classlib":"Sound","description":"\nReturns whether the sound is being played.","param":[]},"setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1.","-- @param fade Time in seconds to transition to this new volume."],"code":["function sound_methods:setVolume ( vol, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( vol, \"number\" )","","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.abs( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tvol = math.Clamp( vol, 0, 1 )","\tunwrap( self ):ChangeVolume( vol, fade )","end",""],"class":"function","name":"sound_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Sound","description":"\nSets the volume of the sound.","param":{"1":"vol","2":"fade","vol":"Volume to set to, between 0 and 1.","fade":"Time in seconds to transition to this new volume."}},"play":{"comment":["--- Starts to play the sound."],"code":["function sound_methods:play ()","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( self, sound_metamethods )","\tunwrap( self ):Play()","end",""],"class":"function","name":"sound_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Sound","description":"\nStarts to play the sound.","param":[]},"setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 255.","-- @param fade Time in seconds to transition to this new pitch."],"code":["function sound_methods:setPitch ( pitch, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pitch, \"number\" )","\t","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.max( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tpitch = math.Clamp( pitch, 0, 255 )","\tunwrap( self ):ChangePitch( pitch, fade )","end",""],"class":"function","name":"sound_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Sound","description":"\nSets the pitch of the sound.","param":{"1":"pitch","2":"fade","pitch":"Pitch to set to, between 0 and 255.","fade":"Time in seconds to transition to this new pitch."}}}},{"comment":["--- Sounds library.","-- @shared"],"functions":{"1":"create","create":{"ret":"Sound Object","comment":["--- Creates a sound and attaches it to an entity","-- @param ent Entity to attach sound to.","-- @param path Filepath to the sound file.","-- @return Sound Object"],"code":["function sound_library.create ( ent, path )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tSF.CheckType( path, \"string\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","","\tlocal e = SF.UnwrapObject( ent )","\tif not ( e or e:IsValid() ) then","\t\tSF.throw( \"Invalid Entity\", 2 )","\tend","","\tlocal s = wrap( CreateSound( e, path ) )","\tlocal i = SF.instance.data.sounds.sounds","\ti[ s ] = s","","\treturn i[ s ]","end",""],"class":"function","name":"sound_library.create","summary":"\nCreates a sound and attaches it to an entity ","private":false,"library":"sounds","description":"\nCreates a sound and attaches it to an entity","param":{"1":"ent","2":"path","ent":"Entity to attach sound to.","path":"Filepath to the sound file."}}},"class":"library","summary":"\nSounds library.","code":["local sound_library, _ = SF.Libraries.Register( \"sounds\" )","","SF.Sounds.Wrap = wrap","SF.Sounds.Unwrap = unwrap","SF.Sounds.Methods = sound_methods","SF.Sounds.Metatable = sound_metamethods","","-- Register Privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"sound.create\", \"Sound\", \"Allows the user to create sounds\" )","\tP.registerPrivilege( \"sound.modify\", \"Sound\", \"Allows the user to modify created sounds\" )","end","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.sounds = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.sounds.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tunwrap( s ):Stop()","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""],"fields":[],"name":"sounds","client":true,"description":"\nSounds library.","libtbl":"sound_library","tables":[],"server":true},{"ret":"Sound Object","comment":["--- Creates a sound and attaches it to an entity","-- @param ent Entity to attach sound to.","-- @param path Filepath to the sound file.","-- @return Sound Object"],"code":["function sound_library.create ( ent, path )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tSF.CheckType( path, \"string\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","","\tlocal e = SF.UnwrapObject( ent )","\tif not ( e or e:IsValid() ) then","\t\tSF.throw( \"Invalid Entity\", 2 )","\tend","","\tlocal s = wrap( CreateSound( e, path ) )","\tlocal i = SF.instance.data.sounds.sounds","\ti[ s ] = s","","\treturn i[ s ]","end",""],"class":"function","name":"sound_library.create","summary":"\nCreates a sound and attaches it to an entity ","private":false,"library":"sounds","description":"\nCreates a sound and attaches it to an entity","param":{"1":"ent","2":"path","ent":"Entity to attach sound to.","path":"Filepath to the sound file."}},{"summary":"\n ","description":"\n","comment":["--------------------------------------------------"],"code":[""]},{"comment":["--- Starts to play the sound."],"code":["function sound_methods:play ()","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( self, sound_metamethods )","\tunwrap( self ):Play()","end",""],"class":"function","name":"sound_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Sound","description":"\nStarts to play the sound.","param":[]},{"comment":["--- Stops the sound from being played.","-- @param fade Time in seconds to fade out, if nil or 0 the sound stops instantly."],"code":["function sound_methods:stop ( fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tunwrap( self ):FadeOut( math.max( fade, 0 ) )","\telse","\t\tunwrap( self ):Stop()","\tend","end",""],"class":"function","name":"sound_methods:stop","summary":"\nStops the sound from being played.","private":false,"classlib":"Sound","description":"\nStops the sound from being played.","param":{"1":"fade","fade":"Time in seconds to fade out, if nil or 0 the sound stops instantly."}},{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1.","-- @param fade Time in seconds to transition to this new volume."],"code":["function sound_methods:setVolume ( vol, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( vol, \"number\" )","","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.abs( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tvol = math.Clamp( vol, 0, 1 )","\tunwrap( self ):ChangeVolume( vol, fade )","end",""],"class":"function","name":"sound_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Sound","description":"\nSets the volume of the sound.","param":{"1":"vol","2":"fade","vol":"Volume to set to, between 0 and 1.","fade":"Time in seconds to transition to this new volume."}},{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 255.","-- @param fade Time in seconds to transition to this new pitch."],"code":["function sound_methods:setPitch ( pitch, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pitch, \"number\" )","\t","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.max( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tpitch = math.Clamp( pitch, 0, 255 )","\tunwrap( self ):ChangePitch( pitch, fade )","end",""],"class":"function","name":"sound_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Sound","description":"\nSets the pitch of the sound.","param":{"1":"pitch","2":"fade","pitch":"Pitch to set to, between 0 and 255.","fade":"Time in seconds to transition to this new pitch."}},{"comment":["--- Returns whether the sound is being played."],"code":["function sound_methods:isPlaying ()","\treturn unwrap( self ):IsPlaying()\t","end",""],"class":"function","name":"sound_methods:isPlaying","summary":"\nReturns whether the sound is being played.","private":false,"classlib":"Sound","description":"\nReturns whether the sound is being played.","param":[]},{"comment":["--- Sets the sound level in dB.","-- @param level dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."],"code":["function sound_methods:setSoundLevel ( level )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( level, \"number\" )","\tunwrap( self ):SetSoundLevel( math.Clamp( level, 0, 511 ) )","end"],"class":"function","name":"sound_methods:setSoundLevel","summary":"\nSets the sound level in dB.","private":false,"classlib":"Sound","description":"\nSets the sound level in dB.","param":{"1":"level","level":"dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."}}],"tables":[],"description":"\nSound type","summary":"\nSound type "},"libs_sh/net.lua":{"libraries":{"1":"net","net":{"comment":["--- Net message library. Used for sending data from the server to the client and back"],"functions":{"1":"bytesWritten","2":"canSend","3":"readBit","4":"readDouble","5":"readFloat","6":"readInt","7":"readString","8":"readTable","9":"readUInt","10":"send","11":"start","12":"writeBit","13":"writeDouble","14":"writeFloat","15":"writeInt","16":"writeString","17":"writeTable","18":"writeUInt","readDouble":{"ret":"The double that was read","comment":["--- Reads a double from the net message","-- @shared","-- @return The double that was read"],"code":["","function net_library.readDouble()","\treturn net.ReadDouble()","end",""],"class":"function","summary":"\nReads a double from the net message ","library":"net","name":"net_library.readDouble","server":true,"private":false,"client":true,"description":"\nReads a double from the net message","param":[]},"send":{"comment":["--- Send a net message from client->server, or server->client.","--@shared","--@param target Optional target location to send the net message."],"code":["function net_library.send ( target )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tlocal data = instance.data.net.data","\tif #data == 0 then return false end","\tnet.Start( \"SF_netmessage\" )","\tnet.WriteEntity( SF.instance.data.entity )","\tfor i = 1, #data do","\t\tlocal writefunc = data[ i ][ 1 ]","\t\tlocal writevalue = data[ i ][ 2 ]","\t\tlocal writesetting = data[ i ][ 3 ]","","\t\tnet[ writefunc ]( writevalue, writesetting )","\tend","","\tinstance.data.net.burst = instance.data.net.burst - net.BytesWritten() / 1000","\t","\tif SERVER then","\t\tlocal sendfunc","\t\tlocal newtarget","","\t\tif target then","\t\t\tif SF.GetType( target ) == \"table\" then","\t\t\t\tlocal nt = { }","\t\t\t\tfor i = 1, #target do","\t\t\t\t\tSF.CheckType( SF.Entities.Unwrap( target[ i ] ), \"Player\", 1 )","\t\t\t\t\tnt[ i ] = SF.Entities.Unwrap( target[ i ] )","\t\t\t\tend","\t\t\t\tsendfunc, newtarget = net.Send, nt","\t\t\telse","\t\t\t\tSF.CheckType( SF.Entities.Unwrap( target ), \"Player\", 1 ) -- TODO: unhacky this","\t\t\t\tsendfunc, newtarget = net.Send, SF.Entities.Unwrap( target )","\t\t\tend","\t\telse","\t\t\tsendfunc = net.Broadcast","\t\tend","","\t\tsendfunc( newtarget )","\telse","\t\tnet.SendToServer()","\tend","end",""],"class":"function","summary":"\nSend a net message from client->server, or server->client.","library":"net","name":"net_library.send","server":true,"private":false,"client":true,"description":"\nSend a net message from client->server, or server->client.","param":{"1":"target","target":"Optional target location to send the net message."}},"writeTable":{"comment":["--- Writes a table to the net message","-- @shared","-- @param t The table to be written. This will be checked for blacklisted types. eg VMatrix."],"code":["function net_library.writeTable( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","\t","\tSF.CheckType( t, \"table\" )","","\tcheckTblForBlacklist( t )","","\twrite( instance, \"Table\", SF.Unsanitize(t) )","\treturn true","end",""],"class":"function","summary":"\nWrites a table to the net message ","library":"net","name":"net_library.writeTable","server":true,"private":false,"client":true,"description":"\nWrites a table to the net message","param":{"1":"t","t":"The table to be written. This will be checked for blacklisted types. eg VMatrix."}},"readFloat":{"ret":"The float that was read","comment":["--- Reads a float from the net message","-- @shared","-- @return The float that was read"],"code":["","function net_library.readFloat()","\treturn net.ReadFloat()","end",""],"class":"function","summary":"\nReads a float from the net message ","library":"net","name":"net_library.readFloat","server":true,"private":false,"client":true,"description":"\nReads a float from the net message","param":[]},"writeBit":{"comment":["--- Writes a bit to the net message","-- @shared","-- @param t The bit to be written. (boolean)"],"code":["","function net_library.writeBit( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"boolean\" )","","\twrite( instance, \"Bit\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a bit to the net message ","library":"net","name":"net_library.writeBit","server":true,"private":false,"client":true,"description":"\nWrites a bit to the net message","param":{"1":"t","t":"The bit to be written. (boolean)"}},"readUInt":{"ret":"The unsigned integer that was read","comment":["--- Reads an unsigned integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The unsigned integer that was read"],"code":["","function net_library.readUInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadUInt(n)","end",""],"class":"function","summary":"\nReads an unsigned integer from the net message ","library":"net","name":"net_library.readUInt","server":true,"private":false,"client":true,"description":"\nReads an unsigned integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"readBit":{"ret":"The bit that was read. (0 for false, 1 for true)","comment":["--- Reads a bit from the net message","-- @shared","-- @return The bit that was read. (0 for false, 1 for true)"],"code":["","function net_library.readBit()","\treturn net.ReadBit()","end",""],"class":"function","summary":"\nReads a bit from the net message ","library":"net","name":"net_library.readBit","server":true,"private":false,"client":true,"description":"\nReads a bit from the net message","param":[]},"readTable":{"ret":"The table that was read","comment":["--- Reads a table from the net message","-- @shared","-- @return The table that was read"],"code":["","function net_library.readTable()","\treturn SF.Sanitize(net.ReadTable())","end",""],"class":"function","summary":"\nReads a table from the net message ","library":"net","name":"net_library.readTable","server":true,"private":false,"client":true,"description":"\nReads a table from the net message","param":[]},"readString":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @return The string that was read"],"code":["","function net_library.readString()","\treturn net.ReadString()","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readString","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":[]},"readInt":{"ret":"The integer that was read","comment":["--- Reads an integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The integer that was read"],"code":["","function net_library.readInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadInt(n)","end",""],"class":"function","summary":"\nReads an integer from the net message ","library":"net","name":"net_library.readInt","server":true,"private":false,"client":true,"description":"\nReads an integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"writeInt":{"comment":["--- Writes an integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of"],"code":["","function net_library.writeInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Int\", t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an integer to the net message ","library":"net","name":"net_library.writeInt","server":true,"private":false,"client":true,"description":"\nWrites an integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of","t":"The integer to be written"}},"writeString":{"comment":["--- Writes a string to the net message","-- @shared","-- @param t The string to be written"],"code":["","function net_library.writeString( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","","\twrite( instance, \"String\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a string to the net message ","library":"net","name":"net_library.writeString","server":true,"private":false,"client":true,"description":"\nWrites a string to the net message","param":{"1":"t","t":"The string to be written"}},"writeUInt":{"comment":["--- Writes an unsigned integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of. Should not be greater than 32"],"code":["","function net_library.writeUInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"UInt\", t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an unsigned integer to the net message ","library":"net","name":"net_library.writeUInt","server":true,"private":false,"client":true,"description":"\nWrites an unsigned integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of. Should not be greater than 32","t":"The integer to be written"}},"canSend":{"ret":"A boolean that states whether or not you can currently send a net message","comment":["--- Checks whether you can currently send a net message","-- @return A boolean that states whether or not you can currently send a net message"],"code":["","function net_library.canSend()","\treturn SF.instance.data.net.burst > 0","end","","net.Receive( \"SF_netmessage\", function( len, ply )","\tlocal ent = net.ReadEntity()","\tif ent:IsValid() and ent.runScriptHook then","\t\tent:runScriptHook( \"net\", net.ReadString(), len, ply and SF.WrapObject( ply ) )","\tend","end)",""],"class":"function","name":"net_library.canSend","summary":"\nChecks whether you can currently send a net message ","private":false,"library":"net","description":"\nChecks whether you can currently send a net message","param":[]},"start":{"comment":["--- Starts the net message","-- @shared","-- @param name The message name"],"code":["function net_library.start( name )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\tif instance.data.net.burst <= 0 then return SF.throw( \"can't send that much data that often\", 2 ) end","\t","\tinstance.data.net.started = true","\tinstance.data.net.data = {}","\twrite( instance, \"String\", name )","end",""],"class":"function","summary":"\nStarts the net message ","library":"net","name":"net_library.start","server":true,"private":false,"client":true,"description":"\nStarts the net message","param":{"1":"name","name":"The message name"}},"bytesWritten":{"ret":"The amount of bytes written so far","comment":["--- Gets the amount of bytes written so far","-- @return The amount of bytes written so far"],"code":["","function net_library.bytesWritten()","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\treturn net.BytesWritten()","end",""],"class":"function","name":"net_library.bytesWritten","summary":"\nGets the amount of bytes written so far ","private":false,"library":"net","description":"\nGets the amount of bytes written so far","param":[]},"writeDouble":{"comment":["--- Writes a double to the net message","-- @shared","-- @param t The double to be written"],"code":["","function net_library.writeDouble( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Double\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a double to the net message ","library":"net","name":"net_library.writeDouble","server":true,"private":false,"client":true,"description":"\nWrites a double to the net message","param":{"1":"t","t":"The double to be written"}},"writeFloat":{"comment":["--- Writes a float to the net message","-- @shared","-- @param t The float to be written"],"code":["","function net_library.writeFloat( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Float\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a float to the net message ","library":"net","name":"net_library.writeFloat","server":true,"private":false,"client":true,"description":"\nWrites a float to the net message","param":{"1":"t","t":"The float to be written"}}},"class":"library","fields":[],"name":"net","summary":"\nNet message library.","description":"\nNet message library. Used for sending data from the server to the client and back","libtbl":"net_library","tables":[],"code":["local net_library, _ = SF.Libraries.Register(\"net\")","","local burst_limit = CreateConVar( \"sf_net_burst_limit\", \"10\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\"The net message burst limit in kB.\" )","","local burst_interval = CreateConVar( \"sf_net_burst_interval\", \"0.1\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\t\"The interval of the timer that adds 1kB more available net message. Requires a map reload to update.\" )","","","local function write( instance, type, value, setting )","\tinstance.data.net.data[#instance.data.net.data+1] = { \"Write\" .. type, value, setting }","end","","local instances = {}","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.net = {","\t\tstarted = false,","\t\tburst = burst_limit:GetInt(),","\t\tdata = {},","\t}","\t","\tinstances[instance] = true","end)","","SF.Libraries.AddHook( \"deinitialize\", function( instance )","\tif instance.data.net.started then","\t\tinstance.data.net.started = false","\tend","\t","\tinstances[instance] = nil","end)","","timer.Create( \"SF_Net_BurstCounter\", burst_interval:GetFloat(), 0, function()","\tfor instance, b in pairs( instances ) do","\t\tif instance.data.net.burst < burst_limit:GetInt() then","\t\t\tinstance.data.net.burst = instance.data.net.burst + 1","\t\tend","\tend","end)","","if SERVER then","\tutil.AddNetworkString( \"SF_netmessage\" )","end",""]}},"type":"file","name":"libs_sh/net.lua","functions":{"1":"net_library.bytesWritten","2":"net_library.canSend","3":"net_library.readBit","4":"net_library.readDouble","5":"net_library.readFloat","6":"net_library.readInt","7":"net_library.readString","8":"net_library.readTable","9":"net_library.readUInt","10":"net_library.send","11":"net_library.start","12":"net_library.writeBit","13":"net_library.writeDouble","14":"net_library.writeFloat","15":"net_library.writeInt","16":"net_library.writeString","17":"net_library.writeTable","18":"net_library.writeUInt","net_library.start":{"comment":["--- Starts the net message","-- @shared","-- @param name The message name"],"code":["function net_library.start( name )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\tif instance.data.net.burst <= 0 then return SF.throw( \"can't send that much data that often\", 2 ) end","\t","\tinstance.data.net.started = true","\tinstance.data.net.data = {}","\twrite( instance, \"String\", name )","end",""],"class":"function","summary":"\nStarts the net message ","library":"net","name":"net_library.start","server":true,"private":false,"client":true,"description":"\nStarts the net message","param":{"1":"name","name":"The message name"}},"net_library.writeString":{"comment":["--- Writes a string to the net message","-- @shared","-- @param t The string to be written"],"code":["","function net_library.writeString( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","","\twrite( instance, \"String\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a string to the net message ","library":"net","name":"net_library.writeString","server":true,"private":false,"client":true,"description":"\nWrites a string to the net message","param":{"1":"t","t":"The string to be written"}},"net_library.readTable":{"ret":"The table that was read","comment":["--- Reads a table from the net message","-- @shared","-- @return The table that was read"],"code":["","function net_library.readTable()","\treturn SF.Sanitize(net.ReadTable())","end",""],"class":"function","summary":"\nReads a table from the net message ","library":"net","name":"net_library.readTable","server":true,"private":false,"client":true,"description":"\nReads a table from the net message","param":[]},"net_library.writeTable":{"comment":["--- Writes a table to the net message","-- @shared","-- @param t The table to be written. This will be checked for blacklisted types. eg VMatrix."],"code":["function net_library.writeTable( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","\t","\tSF.CheckType( t, \"table\" )","","\tcheckTblForBlacklist( t )","","\twrite( instance, \"Table\", SF.Unsanitize(t) )","\treturn true","end",""],"class":"function","summary":"\nWrites a table to the net message ","library":"net","name":"net_library.writeTable","server":true,"private":false,"client":true,"description":"\nWrites a table to the net message","param":{"1":"t","t":"The table to be written. This will be checked for blacklisted types. eg VMatrix."}},"net_library.writeDouble":{"comment":["--- Writes a double to the net message","-- @shared","-- @param t The double to be written"],"code":["","function net_library.writeDouble( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Double\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a double to the net message ","library":"net","name":"net_library.writeDouble","server":true,"private":false,"client":true,"description":"\nWrites a double to the net message","param":{"1":"t","t":"The double to be written"}},"net_library.readInt":{"ret":"The integer that was read","comment":["--- Reads an integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The integer that was read"],"code":["","function net_library.readInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadInt(n)","end",""],"class":"function","summary":"\nReads an integer from the net message ","library":"net","name":"net_library.readInt","server":true,"private":false,"client":true,"description":"\nReads an integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"net_library.writeInt":{"comment":["--- Writes an integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of"],"code":["","function net_library.writeInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Int\", t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an integer to the net message ","library":"net","name":"net_library.writeInt","server":true,"private":false,"client":true,"description":"\nWrites an integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of","t":"The integer to be written"}},"net_library.readUInt":{"ret":"The unsigned integer that was read","comment":["--- Reads an unsigned integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The unsigned integer that was read"],"code":["","function net_library.readUInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadUInt(n)","end",""],"class":"function","summary":"\nReads an unsigned integer from the net message ","library":"net","name":"net_library.readUInt","server":true,"private":false,"client":true,"description":"\nReads an unsigned integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"net_library.readDouble":{"ret":"The double that was read","comment":["--- Reads a double from the net message","-- @shared","-- @return The double that was read"],"code":["","function net_library.readDouble()","\treturn net.ReadDouble()","end",""],"class":"function","summary":"\nReads a double from the net message ","library":"net","name":"net_library.readDouble","server":true,"private":false,"client":true,"description":"\nReads a double from the net message","param":[]},"net_library.writeBit":{"comment":["--- Writes a bit to the net message","-- @shared","-- @param t The bit to be written. (boolean)"],"code":["","function net_library.writeBit( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"boolean\" )","","\twrite( instance, \"Bit\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a bit to the net message ","library":"net","name":"net_library.writeBit","server":true,"private":false,"client":true,"description":"\nWrites a bit to the net message","param":{"1":"t","t":"The bit to be written. (boolean)"}},"net_library.writeFloat":{"comment":["--- Writes a float to the net message","-- @shared","-- @param t The float to be written"],"code":["","function net_library.writeFloat( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Float\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a float to the net message ","library":"net","name":"net_library.writeFloat","server":true,"private":false,"client":true,"description":"\nWrites a float to the net message","param":{"1":"t","t":"The float to be written"}},"net_library.readBit":{"ret":"The bit that was read. (0 for false, 1 for true)","comment":["--- Reads a bit from the net message","-- @shared","-- @return The bit that was read. (0 for false, 1 for true)"],"code":["","function net_library.readBit()","\treturn net.ReadBit()","end",""],"class":"function","summary":"\nReads a bit from the net message ","library":"net","name":"net_library.readBit","server":true,"private":false,"client":true,"description":"\nReads a bit from the net message","param":[]},"net_library.canSend":{"ret":"A boolean that states whether or not you can currently send a net message","comment":["--- Checks whether you can currently send a net message","-- @return A boolean that states whether or not you can currently send a net message"],"code":["","function net_library.canSend()","\treturn SF.instance.data.net.burst > 0","end","","net.Receive( \"SF_netmessage\", function( len, ply )","\tlocal ent = net.ReadEntity()","\tif ent:IsValid() and ent.runScriptHook then","\t\tent:runScriptHook( \"net\", net.ReadString(), len, ply and SF.WrapObject( ply ) )","\tend","end)",""],"class":"function","name":"net_library.canSend","summary":"\nChecks whether you can currently send a net message ","private":false,"library":"net","description":"\nChecks whether you can currently send a net message","param":[]},"net_library.bytesWritten":{"ret":"The amount of bytes written so far","comment":["--- Gets the amount of bytes written so far","-- @return The amount of bytes written so far"],"code":["","function net_library.bytesWritten()","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\treturn net.BytesWritten()","end",""],"class":"function","name":"net_library.bytesWritten","summary":"\nGets the amount of bytes written so far ","private":false,"library":"net","description":"\nGets the amount of bytes written so far","param":[]},"net_library.writeUInt":{"comment":["--- Writes an unsigned integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of. Should not be greater than 32"],"code":["","function net_library.writeUInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"UInt\", t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an unsigned integer to the net message ","library":"net","name":"net_library.writeUInt","server":true,"private":false,"client":true,"description":"\nWrites an unsigned integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of. Should not be greater than 32","t":"The integer to be written"}},"net_library.readFloat":{"ret":"The float that was read","comment":["--- Reads a float from the net message","-- @shared","-- @return The float that was read"],"code":["","function net_library.readFloat()","\treturn net.ReadFloat()","end",""],"class":"function","summary":"\nReads a float from the net message ","library":"net","name":"net_library.readFloat","server":true,"private":false,"client":true,"description":"\nReads a float from the net message","param":[]},"net_library.send":{"comment":["--- Send a net message from client->server, or server->client.","--@shared","--@param target Optional target location to send the net message."],"code":["function net_library.send ( target )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tlocal data = instance.data.net.data","\tif #data == 0 then return false end","\tnet.Start( \"SF_netmessage\" )","\tnet.WriteEntity( SF.instance.data.entity )","\tfor i = 1, #data do","\t\tlocal writefunc = data[ i ][ 1 ]","\t\tlocal writevalue = data[ i ][ 2 ]","\t\tlocal writesetting = data[ i ][ 3 ]","","\t\tnet[ writefunc ]( writevalue, writesetting )","\tend","","\tinstance.data.net.burst = instance.data.net.burst - net.BytesWritten() / 1000","\t","\tif SERVER then","\t\tlocal sendfunc","\t\tlocal newtarget","","\t\tif target then","\t\t\tif SF.GetType( target ) == \"table\" then","\t\t\t\tlocal nt = { }","\t\t\t\tfor i = 1, #target do","\t\t\t\t\tSF.CheckType( SF.Entities.Unwrap( target[ i ] ), \"Player\", 1 )","\t\t\t\t\tnt[ i ] = SF.Entities.Unwrap( target[ i ] )","\t\t\t\tend","\t\t\t\tsendfunc, newtarget = net.Send, nt","\t\t\telse","\t\t\t\tSF.CheckType( SF.Entities.Unwrap( target ), \"Player\", 1 ) -- TODO: unhacky this","\t\t\t\tsendfunc, newtarget = net.Send, SF.Entities.Unwrap( target )","\t\t\tend","\t\telse","\t\t\tsendfunc = net.Broadcast","\t\tend","","\t\tsendfunc( newtarget )","\telse","\t\tnet.SendToServer()","\tend","end",""],"class":"function","summary":"\nSend a net message from client->server, or server->client.","library":"net","name":"net_library.send","server":true,"private":false,"client":true,"description":"\nSend a net message from client->server, or server->client.","param":{"1":"target","target":"Optional target location to send the net message."}},"net_library.readString":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @return The string that was read"],"code":["","function net_library.readString()","\treturn net.ReadString()","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readString","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":[]}},"doc":[{"summary":"\n \nNetworking library.","description":"\n \nNetworking library. \n","comment":["-------------------------------------------------------------------------------","-- Networking library.","-------------------------------------------------------------------------------"],"code":["","local net = net",""]},{"comment":["--- Net message library. Used for sending data from the server to the client and back"],"functions":{"1":"bytesWritten","2":"canSend","3":"readBit","4":"readDouble","5":"readFloat","6":"readInt","7":"readString","8":"readTable","9":"readUInt","10":"send","11":"start","12":"writeBit","13":"writeDouble","14":"writeFloat","15":"writeInt","16":"writeString","17":"writeTable","18":"writeUInt","readDouble":{"ret":"The double that was read","comment":["--- Reads a double from the net message","-- @shared","-- @return The double that was read"],"code":["","function net_library.readDouble()","\treturn net.ReadDouble()","end",""],"class":"function","summary":"\nReads a double from the net message ","library":"net","name":"net_library.readDouble","server":true,"private":false,"client":true,"description":"\nReads a double from the net message","param":[]},"send":{"comment":["--- Send a net message from client->server, or server->client.","--@shared","--@param target Optional target location to send the net message."],"code":["function net_library.send ( target )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tlocal data = instance.data.net.data","\tif #data == 0 then return false end","\tnet.Start( \"SF_netmessage\" )","\tnet.WriteEntity( SF.instance.data.entity )","\tfor i = 1, #data do","\t\tlocal writefunc = data[ i ][ 1 ]","\t\tlocal writevalue = data[ i ][ 2 ]","\t\tlocal writesetting = data[ i ][ 3 ]","","\t\tnet[ writefunc ]( writevalue, writesetting )","\tend","","\tinstance.data.net.burst = instance.data.net.burst - net.BytesWritten() / 1000","\t","\tif SERVER then","\t\tlocal sendfunc","\t\tlocal newtarget","","\t\tif target then","\t\t\tif SF.GetType( target ) == \"table\" then","\t\t\t\tlocal nt = { }","\t\t\t\tfor i = 1, #target do","\t\t\t\t\tSF.CheckType( SF.Entities.Unwrap( target[ i ] ), \"Player\", 1 )","\t\t\t\t\tnt[ i ] = SF.Entities.Unwrap( target[ i ] )","\t\t\t\tend","\t\t\t\tsendfunc, newtarget = net.Send, nt","\t\t\telse","\t\t\t\tSF.CheckType( SF.Entities.Unwrap( target ), \"Player\", 1 ) -- TODO: unhacky this","\t\t\t\tsendfunc, newtarget = net.Send, SF.Entities.Unwrap( target )","\t\t\tend","\t\telse","\t\t\tsendfunc = net.Broadcast","\t\tend","","\t\tsendfunc( newtarget )","\telse","\t\tnet.SendToServer()","\tend","end",""],"class":"function","summary":"\nSend a net message from client->server, or server->client.","library":"net","name":"net_library.send","server":true,"private":false,"client":true,"description":"\nSend a net message from client->server, or server->client.","param":{"1":"target","target":"Optional target location to send the net message."}},"writeTable":{"comment":["--- Writes a table to the net message","-- @shared","-- @param t The table to be written. This will be checked for blacklisted types. eg VMatrix."],"code":["function net_library.writeTable( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","\t","\tSF.CheckType( t, \"table\" )","","\tcheckTblForBlacklist( t )","","\twrite( instance, \"Table\", SF.Unsanitize(t) )","\treturn true","end",""],"class":"function","summary":"\nWrites a table to the net message ","library":"net","name":"net_library.writeTable","server":true,"private":false,"client":true,"description":"\nWrites a table to the net message","param":{"1":"t","t":"The table to be written. This will be checked for blacklisted types. eg VMatrix."}},"readFloat":{"ret":"The float that was read","comment":["--- Reads a float from the net message","-- @shared","-- @return The float that was read"],"code":["","function net_library.readFloat()","\treturn net.ReadFloat()","end",""],"class":"function","summary":"\nReads a float from the net message ","library":"net","name":"net_library.readFloat","server":true,"private":false,"client":true,"description":"\nReads a float from the net message","param":[]},"writeBit":{"comment":["--- Writes a bit to the net message","-- @shared","-- @param t The bit to be written. (boolean)"],"code":["","function net_library.writeBit( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"boolean\" )","","\twrite( instance, \"Bit\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a bit to the net message ","library":"net","name":"net_library.writeBit","server":true,"private":false,"client":true,"description":"\nWrites a bit to the net message","param":{"1":"t","t":"The bit to be written. (boolean)"}},"readUInt":{"ret":"The unsigned integer that was read","comment":["--- Reads an unsigned integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The unsigned integer that was read"],"code":["","function net_library.readUInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadUInt(n)","end",""],"class":"function","summary":"\nReads an unsigned integer from the net message ","library":"net","name":"net_library.readUInt","server":true,"private":false,"client":true,"description":"\nReads an unsigned integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"readBit":{"ret":"The bit that was read. (0 for false, 1 for true)","comment":["--- Reads a bit from the net message","-- @shared","-- @return The bit that was read. (0 for false, 1 for true)"],"code":["","function net_library.readBit()","\treturn net.ReadBit()","end",""],"class":"function","summary":"\nReads a bit from the net message ","library":"net","name":"net_library.readBit","server":true,"private":false,"client":true,"description":"\nReads a bit from the net message","param":[]},"readTable":{"ret":"The table that was read","comment":["--- Reads a table from the net message","-- @shared","-- @return The table that was read"],"code":["","function net_library.readTable()","\treturn SF.Sanitize(net.ReadTable())","end",""],"class":"function","summary":"\nReads a table from the net message ","library":"net","name":"net_library.readTable","server":true,"private":false,"client":true,"description":"\nReads a table from the net message","param":[]},"readString":{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @return The string that was read"],"code":["","function net_library.readString()","\treturn net.ReadString()","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readString","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":[]},"readInt":{"ret":"The integer that was read","comment":["--- Reads an integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The integer that was read"],"code":["","function net_library.readInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadInt(n)","end",""],"class":"function","summary":"\nReads an integer from the net message ","library":"net","name":"net_library.readInt","server":true,"private":false,"client":true,"description":"\nReads an integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},"writeInt":{"comment":["--- Writes an integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of"],"code":["","function net_library.writeInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Int\", t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an integer to the net message ","library":"net","name":"net_library.writeInt","server":true,"private":false,"client":true,"description":"\nWrites an integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of","t":"The integer to be written"}},"writeString":{"comment":["--- Writes a string to the net message","-- @shared","-- @param t The string to be written"],"code":["","function net_library.writeString( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","","\twrite( instance, \"String\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a string to the net message ","library":"net","name":"net_library.writeString","server":true,"private":false,"client":true,"description":"\nWrites a string to the net message","param":{"1":"t","t":"The string to be written"}},"writeUInt":{"comment":["--- Writes an unsigned integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of. Should not be greater than 32"],"code":["","function net_library.writeUInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"UInt\", t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an unsigned integer to the net message ","library":"net","name":"net_library.writeUInt","server":true,"private":false,"client":true,"description":"\nWrites an unsigned integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of. Should not be greater than 32","t":"The integer to be written"}},"canSend":{"ret":"A boolean that states whether or not you can currently send a net message","comment":["--- Checks whether you can currently send a net message","-- @return A boolean that states whether or not you can currently send a net message"],"code":["","function net_library.canSend()","\treturn SF.instance.data.net.burst > 0","end","","net.Receive( \"SF_netmessage\", function( len, ply )","\tlocal ent = net.ReadEntity()","\tif ent:IsValid() and ent.runScriptHook then","\t\tent:runScriptHook( \"net\", net.ReadString(), len, ply and SF.WrapObject( ply ) )","\tend","end)",""],"class":"function","name":"net_library.canSend","summary":"\nChecks whether you can currently send a net message ","private":false,"library":"net","description":"\nChecks whether you can currently send a net message","param":[]},"start":{"comment":["--- Starts the net message","-- @shared","-- @param name The message name"],"code":["function net_library.start( name )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\tif instance.data.net.burst <= 0 then return SF.throw( \"can't send that much data that often\", 2 ) end","\t","\tinstance.data.net.started = true","\tinstance.data.net.data = {}","\twrite( instance, \"String\", name )","end",""],"class":"function","summary":"\nStarts the net message ","library":"net","name":"net_library.start","server":true,"private":false,"client":true,"description":"\nStarts the net message","param":{"1":"name","name":"The message name"}},"bytesWritten":{"ret":"The amount of bytes written so far","comment":["--- Gets the amount of bytes written so far","-- @return The amount of bytes written so far"],"code":["","function net_library.bytesWritten()","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\treturn net.BytesWritten()","end",""],"class":"function","name":"net_library.bytesWritten","summary":"\nGets the amount of bytes written so far ","private":false,"library":"net","description":"\nGets the amount of bytes written so far","param":[]},"writeDouble":{"comment":["--- Writes a double to the net message","-- @shared","-- @param t The double to be written"],"code":["","function net_library.writeDouble( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Double\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a double to the net message ","library":"net","name":"net_library.writeDouble","server":true,"private":false,"client":true,"description":"\nWrites a double to the net message","param":{"1":"t","t":"The double to be written"}},"writeFloat":{"comment":["--- Writes a float to the net message","-- @shared","-- @param t The float to be written"],"code":["","function net_library.writeFloat( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Float\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a float to the net message ","library":"net","name":"net_library.writeFloat","server":true,"private":false,"client":true,"description":"\nWrites a float to the net message","param":{"1":"t","t":"The float to be written"}}},"class":"library","fields":[],"name":"net","summary":"\nNet message library.","description":"\nNet message library. Used for sending data from the server to the client and back","libtbl":"net_library","tables":[],"code":["local net_library, _ = SF.Libraries.Register(\"net\")","","local burst_limit = CreateConVar( \"sf_net_burst_limit\", \"10\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\"The net message burst limit in kB.\" )","","local burst_interval = CreateConVar( \"sf_net_burst_interval\", \"0.1\", { FCVAR_ARCHIVE, FCVAR_REPLICATED },","\t\t\t\t\t\t\"The interval of the timer that adds 1kB more available net message. Requires a map reload to update.\" )","","","local function write( instance, type, value, setting )","\tinstance.data.net.data[#instance.data.net.data+1] = { \"Write\" .. type, value, setting }","end","","local instances = {}","SF.Libraries.AddHook( \"initialize\", function( instance )","\tinstance.data.net = {","\t\tstarted = false,","\t\tburst = burst_limit:GetInt(),","\t\tdata = {},","\t}","\t","\tinstances[instance] = true","end)","","SF.Libraries.AddHook( \"deinitialize\", function( instance )","\tif instance.data.net.started then","\t\tinstance.data.net.started = false","\tend","\t","\tinstances[instance] = nil","end)","","timer.Create( \"SF_Net_BurstCounter\", burst_interval:GetFloat(), 0, function()","\tfor instance, b in pairs( instances ) do","\t\tif instance.data.net.burst < burst_limit:GetInt() then","\t\t\tinstance.data.net.burst = instance.data.net.burst + 1","\t\tend","\tend","end)","","if SERVER then","\tutil.AddNetworkString( \"SF_netmessage\" )","end",""]},{"comment":["--- Send a net message from client->server, or server->client.","--@shared","--@param target Optional target location to send the net message."],"code":["function net_library.send ( target )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tlocal data = instance.data.net.data","\tif #data == 0 then return false end","\tnet.Start( \"SF_netmessage\" )","\tnet.WriteEntity( SF.instance.data.entity )","\tfor i = 1, #data do","\t\tlocal writefunc = data[ i ][ 1 ]","\t\tlocal writevalue = data[ i ][ 2 ]","\t\tlocal writesetting = data[ i ][ 3 ]","","\t\tnet[ writefunc ]( writevalue, writesetting )","\tend","","\tinstance.data.net.burst = instance.data.net.burst - net.BytesWritten() / 1000","\t","\tif SERVER then","\t\tlocal sendfunc","\t\tlocal newtarget","","\t\tif target then","\t\t\tif SF.GetType( target ) == \"table\" then","\t\t\t\tlocal nt = { }","\t\t\t\tfor i = 1, #target do","\t\t\t\t\tSF.CheckType( SF.Entities.Unwrap( target[ i ] ), \"Player\", 1 )","\t\t\t\t\tnt[ i ] = SF.Entities.Unwrap( target[ i ] )","\t\t\t\tend","\t\t\t\tsendfunc, newtarget = net.Send, nt","\t\t\telse","\t\t\t\tSF.CheckType( SF.Entities.Unwrap( target ), \"Player\", 1 ) -- TODO: unhacky this","\t\t\t\tsendfunc, newtarget = net.Send, SF.Entities.Unwrap( target )","\t\t\tend","\t\telse","\t\t\tsendfunc = net.Broadcast","\t\tend","","\t\tsendfunc( newtarget )","\telse","\t\tnet.SendToServer()","\tend","end",""],"class":"function","summary":"\nSend a net message from client->server, or server->client.","library":"net","name":"net_library.send","server":true,"private":false,"client":true,"description":"\nSend a net message from client->server, or server->client.","param":{"1":"target","target":"Optional target location to send the net message."}},{"comment":["--- Starts the net message","-- @shared","-- @param name The message name"],"code":["function net_library.start( name )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\tif instance.data.net.burst <= 0 then return SF.throw( \"can't send that much data that often\", 2 ) end","\t","\tinstance.data.net.started = true","\tinstance.data.net.data = {}","\twrite( instance, \"String\", name )","end",""],"class":"function","summary":"\nStarts the net message ","library":"net","name":"net_library.start","server":true,"private":false,"client":true,"description":"\nStarts the net message","param":{"1":"name","name":"The message name"}},{"comment":["--- Blacklist for net messages.","-- If an item with the same type as the key is found, then it will throw an error.","-- Key must be exactly as is reported by type( var ) otherwise it won't catch it."],"code":["local blacklist = {","\t[ \"VMatrix\" ] = true","}","","local function checkTblForBlacklist ( t )","\tfor _, v in pairs( t ) do","\t\tif type( v ) == \"table\" and not SF.UnwrapObject( v ) then","\t\t\tcheckTblForBlacklist( v )","\t\telse","\t\t\tlocal typmeta = getmetatable( v )","\t\t\tlocal typ = type( typmeta ) == \"string\" and typmeta or type( v )","\t\t\tif blacklist[ typ ] then","\t\t\t\tSF.throw( \"Item of type \" .. typ .. \" cannot be sent through a net message\", 3 )","\t\t\tend","\t\tend","\tend","end",""],"summary":"\nBlacklist for net messages.","description":"\nBlacklist for net messages. \nIf an item with the same type as the key is found, then it will throw an error. \nKey must be exactly as is reported by type( var ) otherwise it won't catch it.","param":[]},{"comment":["--- Writes a table to the net message","-- @shared","-- @param t The table to be written. This will be checked for blacklisted types. eg VMatrix."],"code":["function net_library.writeTable( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","\t","\tSF.CheckType( t, \"table\" )","","\tcheckTblForBlacklist( t )","","\twrite( instance, \"Table\", SF.Unsanitize(t) )","\treturn true","end",""],"class":"function","summary":"\nWrites a table to the net message ","library":"net","name":"net_library.writeTable","server":true,"private":false,"client":true,"description":"\nWrites a table to the net message","param":{"1":"t","t":"The table to be written. This will be checked for blacklisted types. eg VMatrix."}},{"ret":"The table that was read","comment":["--- Reads a table from the net message","-- @shared","-- @return The table that was read"],"code":["","function net_library.readTable()","\treturn SF.Sanitize(net.ReadTable())","end",""],"class":"function","summary":"\nReads a table from the net message ","library":"net","name":"net_library.readTable","server":true,"private":false,"client":true,"description":"\nReads a table from the net message","param":[]},{"comment":["--- Writes a string to the net message","-- @shared","-- @param t The string to be written"],"code":["","function net_library.writeString( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"string\" )","","\twrite( instance, \"String\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a string to the net message ","library":"net","name":"net_library.writeString","server":true,"private":false,"client":true,"description":"\nWrites a string to the net message","param":{"1":"t","t":"The string to be written"}},{"ret":"The string that was read","comment":["--- Reads a string from the net message","-- @shared","-- @return The string that was read"],"code":["","function net_library.readString()","\treturn net.ReadString()","end",""],"class":"function","summary":"\nReads a string from the net message ","library":"net","name":"net_library.readString","server":true,"private":false,"client":true,"description":"\nReads a string from the net message","param":[]},{"comment":["--- Writes an integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of"],"code":["","function net_library.writeInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"Int\", t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an integer to the net message ","library":"net","name":"net_library.writeInt","server":true,"private":false,"client":true,"description":"\nWrites an integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of","t":"The integer to be written"}},{"ret":"The integer that was read","comment":["--- Reads an integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The integer that was read"],"code":["","function net_library.readInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadInt(n)","end",""],"class":"function","summary":"\nReads an integer from the net message ","library":"net","name":"net_library.readInt","server":true,"private":false,"client":true,"description":"\nReads an integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},{"comment":["--- Writes an unsigned integer to the net message","-- @shared","-- @param t The integer to be written","-- @param n The amount of bits the integer consists of. Should not be greater than 32"],"code":["","function net_library.writeUInt( t, n )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","\tSF.CheckType( n, \"number\" )","","\twrite( instance, \"UInt\", t, n )","\treturn true","end",""],"class":"function","summary":"\nWrites an unsigned integer to the net message ","library":"net","name":"net_library.writeUInt","server":true,"private":false,"client":true,"description":"\nWrites an unsigned integer to the net message","param":{"1":"t","2":"n","n":"The amount of bits the integer consists of. Should not be greater than 32","t":"The integer to be written"}},{"ret":"The unsigned integer that was read","comment":["--- Reads an unsigned integer from the net message","-- @shared","-- @param n The amount of bits to read","-- @return The unsigned integer that was read"],"code":["","function net_library.readUInt(n)","\tSF.CheckType( n, \"number\" )","\treturn net.ReadUInt(n)","end",""],"class":"function","summary":"\nReads an unsigned integer from the net message ","library":"net","name":"net_library.readUInt","server":true,"private":false,"client":true,"description":"\nReads an unsigned integer from the net message","param":{"1":"n","n":"The amount of bits to read"}},{"comment":["--- Writes a bit to the net message","-- @shared","-- @param t The bit to be written. (boolean)"],"code":["","function net_library.writeBit( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"boolean\" )","","\twrite( instance, \"Bit\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a bit to the net message ","library":"net","name":"net_library.writeBit","server":true,"private":false,"client":true,"description":"\nWrites a bit to the net message","param":{"1":"t","t":"The bit to be written. (boolean)"}},{"ret":"The bit that was read. (0 for false, 1 for true)","comment":["--- Reads a bit from the net message","-- @shared","-- @return The bit that was read. (0 for false, 1 for true)"],"code":["","function net_library.readBit()","\treturn net.ReadBit()","end",""],"class":"function","summary":"\nReads a bit from the net message ","library":"net","name":"net_library.readBit","server":true,"private":false,"client":true,"description":"\nReads a bit from the net message","param":[]},{"comment":["--- Writes a double to the net message","-- @shared","-- @param t The double to be written"],"code":["","function net_library.writeDouble( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Double\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a double to the net message ","library":"net","name":"net_library.writeDouble","server":true,"private":false,"client":true,"description":"\nWrites a double to the net message","param":{"1":"t","t":"The double to be written"}},{"ret":"The double that was read","comment":["--- Reads a double from the net message","-- @shared","-- @return The double that was read"],"code":["","function net_library.readDouble()","\treturn net.ReadDouble()","end",""],"class":"function","summary":"\nReads a double from the net message ","library":"net","name":"net_library.readDouble","server":true,"private":false,"client":true,"description":"\nReads a double from the net message","param":[]},{"comment":["--- Writes a float to the net message","-- @shared","-- @param t The float to be written"],"code":["","function net_library.writeFloat( t )","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\tSF.CheckType( t, \"number\" )","","\twrite( instance, \"Float\", t )","\treturn true","end",""],"class":"function","summary":"\nWrites a float to the net message ","library":"net","name":"net_library.writeFloat","server":true,"private":false,"client":true,"description":"\nWrites a float to the net message","param":{"1":"t","t":"The float to be written"}},{"ret":"The float that was read","comment":["--- Reads a float from the net message","-- @shared","-- @return The float that was read"],"code":["","function net_library.readFloat()","\treturn net.ReadFloat()","end",""],"class":"function","summary":"\nReads a float from the net message ","library":"net","name":"net_library.readFloat","server":true,"private":false,"client":true,"description":"\nReads a float from the net message","param":[]},{"ret":"The amount of bytes written so far","comment":["--- Gets the amount of bytes written so far","-- @return The amount of bytes written so far"],"code":["","function net_library.bytesWritten()","\tlocal instance = SF.instance","\tif not instance.data.net.started then SF.throw( \"net message not started\", 2 ) end","","\treturn net.BytesWritten()","end",""],"class":"function","name":"net_library.bytesWritten","summary":"\nGets the amount of bytes written so far ","private":false,"library":"net","description":"\nGets the amount of bytes written so far","param":[]},{"ret":"A boolean that states whether or not you can currently send a net message","comment":["--- Checks whether you can currently send a net message","-- @return A boolean that states whether or not you can currently send a net message"],"code":["","function net_library.canSend()","\treturn SF.instance.data.net.burst > 0","end","","net.Receive( \"SF_netmessage\", function( len, ply )","\tlocal ent = net.ReadEntity()","\tif ent:IsValid() and ent.runScriptHook then","\t\tent:runScriptHook( \"net\", net.ReadString(), len, ply and SF.WrapObject( ply ) )","\tend","end)",""],"class":"function","name":"net_library.canSend","summary":"\nChecks whether you can currently send a net message ","private":false,"library":"net","description":"\nChecks whether you can currently send a net message","param":[]},{"classForced":true,"summary":"\nCalled when a net message arrives ","comment":["--- Called when a net message arrives","-- @name net","-- @class hook","-- @param name Name of the arriving net message","-- @param len Length of the arriving net message in bytes","-- @param ply On server, the player that sent the message. Nil on client."],"code":[],"description":"\nCalled when a net message arrives","class":"hook","name":"net","param":{"1":"name","2":"len","3":"ply","len":"Length of the arriving net message in bytes","name":"Name of the arriving net message","ply":"On server, the player that sent the message. Nil on client."}}],"tables":[],"description":"\n \nNetworking library. \n","summary":"\n \nNetworking library."},"preprocessor.lua":{"libraries":[],"type":"file","name":"preprocessor.lua","functions":{"1":"SF.Preprocessor.ParseDirectives","2":"SF.Preprocessor.SetGlobalDirective","SF.Preprocessor.SetGlobalDirective":{"summary":"\nSets a global preprocessor directive.","description":"\nSets a global preprocessor directive.","comment":["--- Sets a global preprocessor directive.","-- @param directive The directive to set.","-- @param func The callback. Takes the directive arguments, the file name, and instance.data"],"code":["function SF.Preprocessor.SetGlobalDirective(directive, func)","\tSF.Preprocessor.directives[directive] = func","end","","local function FindComments( line )","\tlocal ret, count, pos, found = {}, 0, 1","\trepeat","\t\tfound = line:find( '[\"%-%[%]]', pos )","\t\tif (found) then -- We found something","\t\t\tlocal oldpos = pos","\t\t\t","\t\t\tlocal char = line:sub(found,found)","\t\t\tif char == \"-\" then","\t\t\t\tif line:sub(found,found+1) == \"--\" then","\t\t\t\t\t-- Comment beginning","\t\t\t\t\tif line:sub(found,found+3) == \"--[[\" then","\t\t\t\t\t\t-- Block Comment beginning","\t\t\t\t\t\tcount = count + 1","\t\t\t\t\t\tret[count] = {type = \"start\", pos = found}","\t\t\t\t\t\tpos = found + 4","\t\t\t\t\telse","\t\t\t\t\t\t-- Line comment beginning","\t\t\t\t\t\tcount = count + 1","\t\t\t\t\t\tret[count] = {type = \"line\", pos = found}","\t\t\t\t\t\tpos = found + 2","\t\t\t\t\tend","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"[\" then","\t\t\t\tlocal level = line:sub(found+1):match(\"^(=*)\")","\t\t\t\tif level then level = string.len(level) else level = 0 end","\t\t\t\t","\t\t\t\tif line:sub(found+level+1, found+level+1) == \"[\" then","\t\t\t\t\t-- Block string start","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"stringblock\", pos = found, level = level}","\t\t\t\t\tpos = found + level + 2","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"]\" then","\t\t\t\tlocal level = line:sub(found+1):match(\"^(=*)\")","\t\t\t\tif level then level = string.len(level) else level = 0 end","\t\t\t\t","\t\t\t\tif line:sub(found+level+1,found+level+1) == \"]\" then","\t\t\t\t\t-- Ending","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"end\", pos = found, level = level}","\t\t\t\t\tpos = found + level + 2","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"\\\"\" then","\t\t\t\tif line:sub(found-1,found-1) == \"\\\\\" and line:sub(found-2,found-1) ~= \"\\\\\\\\\" then","\t\t\t\t\t-- Escaped character","\t\t\t\t\tpos = found+1","\t\t\t\telse","\t\t\t\t\t-- String","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"string\", pos = found}","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\tend","\t\t\t","\t\t\tif oldpos == pos then error(\"Regex found something, but nothing handled it\") end","\t\tend","\tuntil not found","\treturn ret, count","end","",""],"private":false,"class":"function","name":"SF.Preprocessor.SetGlobalDirective","param":{"1":"directive","2":"func","directive":"The directive to set.","func":"The callback. Takes the directive arguments, the file name, and instance.data"}},"SF.Preprocessor.ParseDirectives":{"summary":"\nParses a source file for directives.","description":"\nParses a source file for directives.","comment":["--- Parses a source file for directives.","-- @param filename The file name of the source code","-- @param source The source code to parse.","-- @param directives A table of additional directives to use.","-- @param data The data table passed to the directives."],"code":["function SF.Preprocessor.ParseDirectives(filename, source, directives, data)","\tlocal ending = nil","\tlocal endingLevel = nil","\t","\tlocal str = source","\twhile str ~= \"\" do","\t\tlocal line","\t\tline, str = string.match(str,\"^([^\\n]*)\\n?(.*)$\")","\t\t","\t\tfor _,comment in ipairs(FindComments(line)) do","\t\t\tif ending then","\t\t\t\tif comment.type == ending then","\t\t\t\t\tif endingLevel then","\t\t\t\t\t\tif comment.level and comment.level == endingLevel then","\t\t\t\t\t\t\tending = nil","\t\t\t\t\t\t\tendingLevel = nil","\t\t\t\t\t\t\tend","\t\t\t\t\telse","\t\t\t\t\t\tending = nil","\t\t\t\t\tend","\t\t\t\tend","\t\t\telseif comment.type == \"start\" then","\t\t\t\tending = \"end\"","\t\t\telseif comment.type == \"string\" then","\t\t\t\tending = \"string\"","\t\t\telseif comment.type == \"stringblock\" then","\t\t\t\tending = \"end\"","\t\t\t\tendingLevel = comment.level","\t\t\telseif comment.type == \"line\" then","\t\t\t\tlocal directive, args = string.match(line,\"--@([^ ]+)%s*(.*)$\")","\t\t\t\tlocal func = directives[directive] or SF.Preprocessor.directives[directive]","\t\t\t\tif func then","\t\t\t\t\tfunc(args, filename, data)","\t\t\t\tend","\t\t\tend","\t\tend","\t\t","\t\tif ending == \"newline\" then ending = nil end","\tend","end","","local function directive_include(args, filename, data)","\tif not data.includes then data.includes = {} end","\tif not data.includes[filename] then data.includes[filename] = {} end","\t","\tlocal incl = data.includes[filename]","\tincl[#incl+1] = args","end","SF.Preprocessor.SetGlobalDirective(\"include\",directive_include)","","local function directive_includedir( args, filename, data )","\tif not data.includes then data.includes = {} end","\tif not data.includes[filename] then data.includes[filename] = {} end","","\tlocal incl = data.includes[filename]","","\tlocal files = file.Find( \"starfall/\" ..args.. \"/*\", \"DATA\" )","\tfor _, v in pairs( files ) do","\t\tincl[ #incl+1 ] = args .. \"/\" .. v","\tend","end","SF.Preprocessor.SetGlobalDirective( \"includedir\", directive_includedir )","","local function directive_name(args, filename, data)","\tif not data.scriptnames then data.scriptnames = {} end","\tdata.scriptnames[filename] = args","end","SF.Preprocessor.SetGlobalDirective(\"name\",directive_name)","","local function directive_sharedscreen(args, filename, data)","\tif not data.sharedscreen then data.sharedscreen = true end","\t","end","SF.Preprocessor.SetGlobalDirective(\"sharedscreen\",directive_sharedscreen)","","local function directive_model( args, filename, data )","\tif not data.models then data.models = {} end","\tdata.models[ filename ] = args","end","SF.Preprocessor.SetGlobalDirective( \"model\", directive_model )",""],"private":false,"class":"function","name":"SF.Preprocessor.ParseDirectives","param":{"1":"filename","2":"source","3":"directives","4":"data","data":"The data table passed to the directives.","directives":"A table of additional directives to use.","source":"The source code to parse.","filename":"The file name of the source code"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- SF Preprocessor.","-- Processes code for compile time directives.","-------------------------------------------------------------------------------"],"code":["","-- TODO: Make an @include-only parser","","SF.Preprocessor = {}","SF.Preprocessor.directives = {}",""],"summary":"\n \nSF Preprocessor.","description":"\n \nSF Preprocessor. \nProcesses code for compile time directives. \n","param":[]},{"summary":"\nSets a global preprocessor directive.","description":"\nSets a global preprocessor directive.","comment":["--- Sets a global preprocessor directive.","-- @param directive The directive to set.","-- @param func The callback. Takes the directive arguments, the file name, and instance.data"],"code":["function SF.Preprocessor.SetGlobalDirective(directive, func)","\tSF.Preprocessor.directives[directive] = func","end","","local function FindComments( line )","\tlocal ret, count, pos, found = {}, 0, 1","\trepeat","\t\tfound = line:find( '[\"%-%[%]]', pos )","\t\tif (found) then -- We found something","\t\t\tlocal oldpos = pos","\t\t\t","\t\t\tlocal char = line:sub(found,found)","\t\t\tif char == \"-\" then","\t\t\t\tif line:sub(found,found+1) == \"--\" then","\t\t\t\t\t-- Comment beginning","\t\t\t\t\tif line:sub(found,found+3) == \"--[[\" then","\t\t\t\t\t\t-- Block Comment beginning","\t\t\t\t\t\tcount = count + 1","\t\t\t\t\t\tret[count] = {type = \"start\", pos = found}","\t\t\t\t\t\tpos = found + 4","\t\t\t\t\telse","\t\t\t\t\t\t-- Line comment beginning","\t\t\t\t\t\tcount = count + 1","\t\t\t\t\t\tret[count] = {type = \"line\", pos = found}","\t\t\t\t\t\tpos = found + 2","\t\t\t\t\tend","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"[\" then","\t\t\t\tlocal level = line:sub(found+1):match(\"^(=*)\")","\t\t\t\tif level then level = string.len(level) else level = 0 end","\t\t\t\t","\t\t\t\tif line:sub(found+level+1, found+level+1) == \"[\" then","\t\t\t\t\t-- Block string start","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"stringblock\", pos = found, level = level}","\t\t\t\t\tpos = found + level + 2","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"]\" then","\t\t\t\tlocal level = line:sub(found+1):match(\"^(=*)\")","\t\t\t\tif level then level = string.len(level) else level = 0 end","\t\t\t\t","\t\t\t\tif line:sub(found+level+1,found+level+1) == \"]\" then","\t\t\t\t\t-- Ending","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"end\", pos = found, level = level}","\t\t\t\t\tpos = found + level + 2","\t\t\t\telse","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\telseif char == \"\\\"\" then","\t\t\t\tif line:sub(found-1,found-1) == \"\\\\\" and line:sub(found-2,found-1) ~= \"\\\\\\\\\" then","\t\t\t\t\t-- Escaped character","\t\t\t\t\tpos = found+1","\t\t\t\telse","\t\t\t\t\t-- String","\t\t\t\t\tcount = count + 1","\t\t\t\t\tret[count] = {type = \"string\", pos = found}","\t\t\t\t\tpos = found + 1","\t\t\t\tend","\t\t\tend","\t\t\t","\t\t\tif oldpos == pos then error(\"Regex found something, but nothing handled it\") end","\t\tend","\tuntil not found","\treturn ret, count","end","",""],"private":false,"class":"function","name":"SF.Preprocessor.SetGlobalDirective","param":{"1":"directive","2":"func","directive":"The directive to set.","func":"The callback. Takes the directive arguments, the file name, and instance.data"}},{"summary":"\nParses a source file for directives.","description":"\nParses a source file for directives.","comment":["--- Parses a source file for directives.","-- @param filename The file name of the source code","-- @param source The source code to parse.","-- @param directives A table of additional directives to use.","-- @param data The data table passed to the directives."],"code":["function SF.Preprocessor.ParseDirectives(filename, source, directives, data)","\tlocal ending = nil","\tlocal endingLevel = nil","\t","\tlocal str = source","\twhile str ~= \"\" do","\t\tlocal line","\t\tline, str = string.match(str,\"^([^\\n]*)\\n?(.*)$\")","\t\t","\t\tfor _,comment in ipairs(FindComments(line)) do","\t\t\tif ending then","\t\t\t\tif comment.type == ending then","\t\t\t\t\tif endingLevel then","\t\t\t\t\t\tif comment.level and comment.level == endingLevel then","\t\t\t\t\t\t\tending = nil","\t\t\t\t\t\t\tendingLevel = nil","\t\t\t\t\t\t\tend","\t\t\t\t\telse","\t\t\t\t\t\tending = nil","\t\t\t\t\tend","\t\t\t\tend","\t\t\telseif comment.type == \"start\" then","\t\t\t\tending = \"end\"","\t\t\telseif comment.type == \"string\" then","\t\t\t\tending = \"string\"","\t\t\telseif comment.type == \"stringblock\" then","\t\t\t\tending = \"end\"","\t\t\t\tendingLevel = comment.level","\t\t\telseif comment.type == \"line\" then","\t\t\t\tlocal directive, args = string.match(line,\"--@([^ ]+)%s*(.*)$\")","\t\t\t\tlocal func = directives[directive] or SF.Preprocessor.directives[directive]","\t\t\t\tif func then","\t\t\t\t\tfunc(args, filename, data)","\t\t\t\tend","\t\t\tend","\t\tend","\t\t","\t\tif ending == \"newline\" then ending = nil end","\tend","end","","local function directive_include(args, filename, data)","\tif not data.includes then data.includes = {} end","\tif not data.includes[filename] then data.includes[filename] = {} end","\t","\tlocal incl = data.includes[filename]","\tincl[#incl+1] = args","end","SF.Preprocessor.SetGlobalDirective(\"include\",directive_include)","","local function directive_includedir( args, filename, data )","\tif not data.includes then data.includes = {} end","\tif not data.includes[filename] then data.includes[filename] = {} end","","\tlocal incl = data.includes[filename]","","\tlocal files = file.Find( \"starfall/\" ..args.. \"/*\", \"DATA\" )","\tfor _, v in pairs( files ) do","\t\tincl[ #incl+1 ] = args .. \"/\" .. v","\tend","end","SF.Preprocessor.SetGlobalDirective( \"includedir\", directive_includedir )","","local function directive_name(args, filename, data)","\tif not data.scriptnames then data.scriptnames = {} end","\tdata.scriptnames[filename] = args","end","SF.Preprocessor.SetGlobalDirective(\"name\",directive_name)","","local function directive_sharedscreen(args, filename, data)","\tif not data.sharedscreen then data.sharedscreen = true end","\t","end","SF.Preprocessor.SetGlobalDirective(\"sharedscreen\",directive_sharedscreen)","","local function directive_model( args, filename, data )","\tif not data.models then data.models = {} end","\tdata.models[ filename ] = args","end","SF.Preprocessor.SetGlobalDirective( \"model\", directive_model )",""],"private":false,"class":"function","name":"SF.Preprocessor.ParseDirectives","param":{"1":"filename","2":"source","3":"directives","4":"data","data":"The data table passed to the directives.","directives":"A table of additional directives to use.","source":"The source code to parse.","filename":"The file name of the source code"}},{"description":"\nMark a file to be included in the upload. \nThis is required to use the file in require() and dofile()","code":[""],"class":"directive","classForced":true,"name":"include","summary":"\nMark a file to be included in the upload.","usage":"\n--@include lib/someLibrary.txt \n \nrequire( \"lib/someLibrary.txt\" ) \n-- CODE","comment":["--- Mark a file to be included in the upload.","-- This is required to use the file in require() and dofile()","-- @name include","-- @class directive","-- @param path Path to the file","-- @usage","-- \\--@include lib/someLibrary.txt","-- ","-- require( \"lib/someLibrary.txt\" )","-- -- CODE"],"param":{"1":"path","path":"Path to the file"}},{"description":"\nMark a directory to be included in the upload. \nThis is optional to include all files in the directory in require() and dofile()","code":[""],"class":"directive","classForced":true,"name":"includedir","summary":"\nMark a directory to be included in the upload.","usage":"\n--@includedir lib \n \nrequire( \"lib/someLibraryInLib.txt\" ) \nrequire( \"lib/someOtherLibraryInLib.txt\" ) \n-- CODE","comment":["--- Mark a directory to be included in the upload.","-- This is optional to include all files in the directory in require() and dofile()","-- @name includedir","-- @class directive","-- @param path Path to the directory","-- @usage","-- \\--@includedir lib","--","-- require( \"lib/someLibraryInLib.txt\" )","-- require( \"lib/someOtherLibraryInLib.txt\" )","-- -- CODE"],"param":{"1":"path","path":"Path to the directory"}},{"description":"\nSet the name of the script. \nThis will become the name of the tab and will show on the overlay of the processor","code":["","--","-- if SERVER then","-- \\\t-- Do important calculations","-- \\\t-- Send net message","-- else","-- \\\t-- Display result of important calculations","-- end",""],"class":"directive","classForced":true,"name":"name","summary":"\nSet the name of the script.","usage":"\n--@name Awesome script \n-- CODE","comment":["--- Set the name of the script.","-- This will become the name of the tab and will show on the overlay of the processor","-- @name name","-- @class directive","-- @param name Name of the script","-- @usage","-- \\--@name Awesome script","-- -- CODE"],"param":{"1":"name","name":"Name of the script"}},{"description":"\nSet the model of the processor entity. \nThis does not set the model of the screen entity","code":[],"class":"directive","classForced":true,"name":"model","summary":"\nSet the model of the processor entity.","usage":"\n--@model models/props_junk/watermelon01.mdl \n-- CODE","comment":["--- Set the model of the processor entity.","-- This does not set the model of the screen entity","-- @name model","-- @class directive","-- @param model String of the model","-- @usage","-- \\--@model models/props_junk/watermelon01.mdl","-- -- CODE"],"param":{"1":"model","model":"String of the model"}}],"tables":[],"description":"\n \nSF Preprocessor. \nProcesses code for compile time directives. \n","summary":"\n \nSF Preprocessor."},"libs_sh/hook.lua":{"libraries":{"1":"hook","hook":{"comment":["--- Deals with hooks","-- @shared"],"functions":{"1":"add","2":"remove","3":"run","4":"runRemote","runRemote":{"ret":"tbl A list of the resultset of each called hook","comment":["--- Run a hook remotely.","-- This will call the hook \"remote\" on either a specified entity or all instances on the server/client","-- @shared","-- @param recipient Starfall entity to call the hook on. Nil to run on every starfall entity","-- @param ... Payload. These parameters will be used to call the hook functions","-- @return tbl A list of the resultset of each called hook"],"code":["function hook_library.runRemote ( recipient, ... )","\tif recipient then SF.CheckType( recipient, SF.Entities.Metatable ) end","","\tlocal recipients","\tif recipient then","\t\tlocal ent = SF.Entities.Unwrap( recipient )","\t\tif not ent.instance then SF.throw( \"Entity has no starfall instance\", 2 ) end","\t\trecipients = {","\t\t\t[ ent.instance ] = true","\t\t}","\telse","\t\trecipients = registered_instances","\tend","","\tlocal instance = SF.instance","","\tlocal result = {}","\tfor k, _ in pairs( recipients ) do","\t\tSF.instance = nil","\t\tresult = { k:runScriptHookForResult( \"remote\", instance.data.entity, instance.player, ... ) }","","\t\tlocal ok = table.remove( result, 1 )","\t\tif not ok then","\t\t\tif not result[ 1 ] then continue end -- Call failed because of non-existent hook. Ignore","\t\t\tk:Error( \"Hook 'remote' errored with \" .. result[ 1 ], result[ 2 ] )","\t\t\t-- Their fault - don't return","\t\tend","\tend","","\tSF.instance = instance","\treturn result","end",""],"class":"function","summary":"\nRun a hook remotely.","library":"hook","name":"hook_library.runRemote","server":true,"private":false,"client":true,"description":"\nRun a hook remotely. \nThis will call the hook \"remote\" on either a specified entity or all instances on the server/client","param":{"1":"recipient","2":"...","recipient":"Starfall entity to call the hook on. Nil to run on every starfall entity","...":"Payload. These parameters will be used to call the hook functions"}},"remove":{"comment":["--- Remove a hook","-- @shared","-- @param hookname The hook name","-- @param name The unique name for this hook"],"code":["function hook_library.remove ( hookname, name )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\t","\tlocal lower = hookname:lower()","\tif instance.hooks[ lower ] then","\t\tinstance.hooks[ lower ][ name ] = nil","\t\t","\t\tif not next( instance.hooks[ lower ] ) then","\t\t\tinstance.hooks[ lower ] = nil","\t\tend","\tend","\t","\tif not next( instance.hooks ) then","\t\tregistered_instances[ instance ] = nil","\tend","end","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tregistered_instances[ instance ] = nil","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, name, func, err )","\tif name == \"_runFunction\" and err == true then","\t\tregistered_instances[ instance ] = nil","\t\tinstance.hooks = {}","\tend","end)","","local wrapArguments = SF.Sanitize","","local function run ( hookname, customfunc, ... )","\tlocal result = {}","\tfor instance,_ in pairs( registered_instances ) do","\t\tlocal ret = { instance:runScriptHookForResult( hookname, wrapArguments( ... ) ) }","\t\t","\t\tlocal ok = table.remove( ret, 1 )","\t\tif ok then","\t\t\tif customfunc then","\t\t\t\tlocal sane = customfunc( instance, ret, ... )","\t\t\t\tresult = sane ~= nil and { sane } or result","\t\t\tend","\t\telse","\t\t\tinstance:Error( \"Hook '\" .. hookname .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\tend","\tend","\treturn unpack( result )","end","","","local hooks = {}"],"class":"function","summary":"\nRemove a hook ","library":"hook","name":"hook_library.remove","server":true,"private":false,"client":true,"description":"\nRemove a hook","param":{"1":"hookname","2":"name","name":"The unique name for this hook","hookname":"The hook name"}},"run":{"comment":["--- Run a hook","-- @shared","-- @param hookname The hook name","-- @param ... arguments"],"code":["function hook_library.run ( hookname, ... )","\tSF.CheckType( hookname, \"string\" )","\t","\tlocal instance = SF.instance","\tlocal lower = hookname:lower()","\t","\tSF.instance = nil -- Pretend we're not running an instance","\tlocal ret = { instance:runScriptHookForResult( lower, ... ) }","\tSF.instance = instance -- Set it back","\t","\tlocal ok = table.remove( ret, 1 )","\tif not ok then","\t\tinstance:Error( \"Hook '\" .. lower .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\treturn","\tend","\t","\treturn unpack( ret )","end",""],"class":"function","summary":"\nRun a hook ","library":"hook","name":"hook_library.run","server":true,"private":false,"client":true,"description":"\nRun a hook","param":{"1":"hookname","2":"...","...":"arguments","hookname":"The hook name"}},"add":{"comment":["--- Sets a hook function","-- @param hookname Name of the event","-- @param name Unique identifier","-- @param func Function to run"],"code":["function hook_library.add ( hookname, name, func )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tif func then SF.CheckType( func, \"function\" ) else return end","\t","\tlocal inst = SF.instance","\tlocal hooks = inst.hooks[ hookname:lower() ]","\tif not hooks then","\t\thooks = {}","\t\tinst.hooks[ hookname:lower() ] = hooks","\tend","\t","\thooks[ name ] = func","\tregistered_instances[ inst ] = true","end",""],"class":"function","name":"hook_library.add","summary":"\nSets a hook function ","private":false,"library":"hook","description":"\nSets a hook function","param":{"1":"hookname","2":"name","3":"func","func":"Function to run","name":"Unique identifier","hookname":"Name of the event"}}},"class":"library","summary":"\nDeals with hooks ","code":["local hook_library, _ = SF.Libraries.Register( \"hook\" )","local registered_instances = {}",""],"fields":[],"name":"hook","client":true,"description":"\nDeals with hooks","libtbl":"hook_library","tables":[],"server":true}},"type":"file","name":"libs_sh/hook.lua","functions":{"1":"SF.hookAdd","2":"hook_library.add","3":"hook_library.remove","4":"hook_library.run","5":"hook_library.runRemote","hook_library.runRemote":{"ret":"tbl A list of the resultset of each called hook","comment":["--- Run a hook remotely.","-- This will call the hook \"remote\" on either a specified entity or all instances on the server/client","-- @shared","-- @param recipient Starfall entity to call the hook on. Nil to run on every starfall entity","-- @param ... Payload. These parameters will be used to call the hook functions","-- @return tbl A list of the resultset of each called hook"],"code":["function hook_library.runRemote ( recipient, ... )","\tif recipient then SF.CheckType( recipient, SF.Entities.Metatable ) end","","\tlocal recipients","\tif recipient then","\t\tlocal ent = SF.Entities.Unwrap( recipient )","\t\tif not ent.instance then SF.throw( \"Entity has no starfall instance\", 2 ) end","\t\trecipients = {","\t\t\t[ ent.instance ] = true","\t\t}","\telse","\t\trecipients = registered_instances","\tend","","\tlocal instance = SF.instance","","\tlocal result = {}","\tfor k, _ in pairs( recipients ) do","\t\tSF.instance = nil","\t\tresult = { k:runScriptHookForResult( \"remote\", instance.data.entity, instance.player, ... ) }","","\t\tlocal ok = table.remove( result, 1 )","\t\tif not ok then","\t\t\tif not result[ 1 ] then continue end -- Call failed because of non-existent hook. Ignore","\t\t\tk:Error( \"Hook 'remote' errored with \" .. result[ 1 ], result[ 2 ] )","\t\t\t-- Their fault - don't return","\t\tend","\tend","","\tSF.instance = instance","\treturn result","end",""],"class":"function","summary":"\nRun a hook remotely.","library":"hook","name":"hook_library.runRemote","server":true,"private":false,"client":true,"description":"\nRun a hook remotely. \nThis will call the hook \"remote\" on either a specified entity or all instances on the server/client","param":{"1":"recipient","2":"...","recipient":"Starfall entity to call the hook on. Nil to run on every starfall entity","...":"Payload. These parameters will be used to call the hook functions"}},"hook_library.add":{"comment":["--- Sets a hook function","-- @param hookname Name of the event","-- @param name Unique identifier","-- @param func Function to run"],"code":["function hook_library.add ( hookname, name, func )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tif func then SF.CheckType( func, \"function\" ) else return end","\t","\tlocal inst = SF.instance","\tlocal hooks = inst.hooks[ hookname:lower() ]","\tif not hooks then","\t\thooks = {}","\t\tinst.hooks[ hookname:lower() ] = hooks","\tend","\t","\thooks[ name ] = func","\tregistered_instances[ inst ] = true","end",""],"class":"function","name":"hook_library.add","summary":"\nSets a hook function ","private":false,"library":"hook","description":"\nSets a hook function","param":{"1":"hookname","2":"name","3":"func","func":"Function to run","name":"Unique identifier","hookname":"Name of the event"}},"hook_library.run":{"comment":["--- Run a hook","-- @shared","-- @param hookname The hook name","-- @param ... arguments"],"code":["function hook_library.run ( hookname, ... )","\tSF.CheckType( hookname, \"string\" )","\t","\tlocal instance = SF.instance","\tlocal lower = hookname:lower()","\t","\tSF.instance = nil -- Pretend we're not running an instance","\tlocal ret = { instance:runScriptHookForResult( lower, ... ) }","\tSF.instance = instance -- Set it back","\t","\tlocal ok = table.remove( ret, 1 )","\tif not ok then","\t\tinstance:Error( \"Hook '\" .. lower .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\treturn","\tend","\t","\treturn unpack( ret )","end",""],"class":"function","summary":"\nRun a hook ","library":"hook","name":"hook_library.run","server":true,"private":false,"client":true,"description":"\nRun a hook","param":{"1":"hookname","2":"...","...":"arguments","hookname":"The hook name"}},"SF.hookAdd":{"comment":["--- Add a GMod hook so that SF gets access to it","-- @shared","-- @param hookname The hook name. In-SF hookname will be lowercased","-- @param customfunc Optional custom function"],"code":["function SF.hookAdd ( hookname, customfunc )","\thooks[ #hooks + 1 ] = hookname","\tlocal lower = hookname:lower()","\thook.Add( hookname, \"SF_\" .. hookname, function ( ... )","\t\treturn run( lower, customfunc, ... )","\tend)","end","","local function returnOnlyOnYourself( instance, args, ply )","\tif instance.player ~= ply then return end","\tif args then return args[1] end","end","","local add = SF.hookAdd","","if SERVER then","\t-- Server hooks","\tadd( \"GravGunOnPickedUp\" )","\tadd( \"GravGunOnDropped\" )","\tadd( \"OnPhysgunFreeze\" )","\tadd( \"OnPhysgunReload\" )","\tadd( \"PlayerDeath\" )","\tadd( \"PlayerDisconnected\" )","\tadd( \"PlayerInitialSpawn\" )","\tadd( \"PlayerSpawn\" )","\tadd( \"PlayerEnteredVehicle\" )","\tadd( \"PlayerLeaveVehicle\" )","\tadd( \"PlayerSay\", returnOnlyOnYourself )","\tadd( \"PlayerSpray\" )","\tadd( \"PlayerUse\" )","\tadd( \"PlayerSwitchFlashlight\" )","\tadd( \"PlayerCanPickupWeapon\", returnOnlyOnYourself  )","\t","\thook.Add(\"EntityTakeDamage\", \"SF_EntityTakeDamage\", function( target, dmg )","\t\tlocal lower = (\"EntityTakeDamage\"):lower()","\t\trun( lower, nil, target, dmg:GetAttacker(), ","\t\t\tdmg:GetInflictor(), ","\t\t\tdmg:GetDamage(), ","\t\t\tdmg:GetDamageType(), ","\t\t\tdmg:GetDamagePosition(), ","\t\t\tdmg:GetDamageForce())","\tend)","\t","else","\t-- Client hooks","\t-- todo","end","","-- Shared hooks","","-- Player hooks","add( \"PlayerHurt\" )","add( \"PlayerNoClip\" )","add( \"KeyPress\" )","add( \"KeyRelease\" )","add( \"GravGunPunt\" )","add( \"PhysgunPickup\" )","add( \"PhysgunDrop\" )","add( \"PlayerSwitchWeapon\", returnOnlyOnYourself )","","-- Entity hooks","add( \"OnEntityCreated\" )","add( \"EntityRemoved\" )","add( \"PropBreak\" )","","-- Other","add( \"EndEntityDriving\" )","add( \"StartEntityDriving\" )",""],"class":"function","summary":"\nAdd a GMod hook so that SF gets access to it ","name":"SF.hookAdd","server":true,"private":false,"client":true,"description":"\nAdd a GMod hook so that SF gets access to it","param":{"1":"hookname","2":"customfunc","customfunc":"Optional custom function","hookname":"The hook name. In-SF hookname will be lowercased"}},"hook_library.remove":{"comment":["--- Remove a hook","-- @shared","-- @param hookname The hook name","-- @param name The unique name for this hook"],"code":["function hook_library.remove ( hookname, name )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\t","\tlocal lower = hookname:lower()","\tif instance.hooks[ lower ] then","\t\tinstance.hooks[ lower ][ name ] = nil","\t\t","\t\tif not next( instance.hooks[ lower ] ) then","\t\t\tinstance.hooks[ lower ] = nil","\t\tend","\tend","\t","\tif not next( instance.hooks ) then","\t\tregistered_instances[ instance ] = nil","\tend","end","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tregistered_instances[ instance ] = nil","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, name, func, err )","\tif name == \"_runFunction\" and err == true then","\t\tregistered_instances[ instance ] = nil","\t\tinstance.hooks = {}","\tend","end)","","local wrapArguments = SF.Sanitize","","local function run ( hookname, customfunc, ... )","\tlocal result = {}","\tfor instance,_ in pairs( registered_instances ) do","\t\tlocal ret = { instance:runScriptHookForResult( hookname, wrapArguments( ... ) ) }","\t\t","\t\tlocal ok = table.remove( ret, 1 )","\t\tif ok then","\t\t\tif customfunc then","\t\t\t\tlocal sane = customfunc( instance, ret, ... )","\t\t\t\tresult = sane ~= nil and { sane } or result","\t\t\tend","\t\telse","\t\t\tinstance:Error( \"Hook '\" .. hookname .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\tend","\tend","\treturn unpack( result )","end","","","local hooks = {}"],"class":"function","summary":"\nRemove a hook ","library":"hook","name":"hook_library.remove","server":true,"private":false,"client":true,"description":"\nRemove a hook","param":{"1":"hookname","2":"name","name":"The unique name for this hook","hookname":"The hook name"}}},"doc":[{"summary":"\n \nHook library \n ","description":"\n \nHook library \n","comment":["-------------------------------------------------------------------------------","-- Hook library","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- Deals with hooks","-- @shared"],"functions":{"1":"add","2":"remove","3":"run","4":"runRemote","runRemote":{"ret":"tbl A list of the resultset of each called hook","comment":["--- Run a hook remotely.","-- This will call the hook \"remote\" on either a specified entity or all instances on the server/client","-- @shared","-- @param recipient Starfall entity to call the hook on. Nil to run on every starfall entity","-- @param ... Payload. These parameters will be used to call the hook functions","-- @return tbl A list of the resultset of each called hook"],"code":["function hook_library.runRemote ( recipient, ... )","\tif recipient then SF.CheckType( recipient, SF.Entities.Metatable ) end","","\tlocal recipients","\tif recipient then","\t\tlocal ent = SF.Entities.Unwrap( recipient )","\t\tif not ent.instance then SF.throw( \"Entity has no starfall instance\", 2 ) end","\t\trecipients = {","\t\t\t[ ent.instance ] = true","\t\t}","\telse","\t\trecipients = registered_instances","\tend","","\tlocal instance = SF.instance","","\tlocal result = {}","\tfor k, _ in pairs( recipients ) do","\t\tSF.instance = nil","\t\tresult = { k:runScriptHookForResult( \"remote\", instance.data.entity, instance.player, ... ) }","","\t\tlocal ok = table.remove( result, 1 )","\t\tif not ok then","\t\t\tif not result[ 1 ] then continue end -- Call failed because of non-existent hook. Ignore","\t\t\tk:Error( \"Hook 'remote' errored with \" .. result[ 1 ], result[ 2 ] )","\t\t\t-- Their fault - don't return","\t\tend","\tend","","\tSF.instance = instance","\treturn result","end",""],"class":"function","summary":"\nRun a hook remotely.","library":"hook","name":"hook_library.runRemote","server":true,"private":false,"client":true,"description":"\nRun a hook remotely. \nThis will call the hook \"remote\" on either a specified entity or all instances on the server/client","param":{"1":"recipient","2":"...","recipient":"Starfall entity to call the hook on. Nil to run on every starfall entity","...":"Payload. These parameters will be used to call the hook functions"}},"remove":{"comment":["--- Remove a hook","-- @shared","-- @param hookname The hook name","-- @param name The unique name for this hook"],"code":["function hook_library.remove ( hookname, name )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\t","\tlocal lower = hookname:lower()","\tif instance.hooks[ lower ] then","\t\tinstance.hooks[ lower ][ name ] = nil","\t\t","\t\tif not next( instance.hooks[ lower ] ) then","\t\t\tinstance.hooks[ lower ] = nil","\t\tend","\tend","\t","\tif not next( instance.hooks ) then","\t\tregistered_instances[ instance ] = nil","\tend","end","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tregistered_instances[ instance ] = nil","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, name, func, err )","\tif name == \"_runFunction\" and err == true then","\t\tregistered_instances[ instance ] = nil","\t\tinstance.hooks = {}","\tend","end)","","local wrapArguments = SF.Sanitize","","local function run ( hookname, customfunc, ... )","\tlocal result = {}","\tfor instance,_ in pairs( registered_instances ) do","\t\tlocal ret = { instance:runScriptHookForResult( hookname, wrapArguments( ... ) ) }","\t\t","\t\tlocal ok = table.remove( ret, 1 )","\t\tif ok then","\t\t\tif customfunc then","\t\t\t\tlocal sane = customfunc( instance, ret, ... )","\t\t\t\tresult = sane ~= nil and { sane } or result","\t\t\tend","\t\telse","\t\t\tinstance:Error( \"Hook '\" .. hookname .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\tend","\tend","\treturn unpack( result )","end","","","local hooks = {}"],"class":"function","summary":"\nRemove a hook ","library":"hook","name":"hook_library.remove","server":true,"private":false,"client":true,"description":"\nRemove a hook","param":{"1":"hookname","2":"name","name":"The unique name for this hook","hookname":"The hook name"}},"run":{"comment":["--- Run a hook","-- @shared","-- @param hookname The hook name","-- @param ... arguments"],"code":["function hook_library.run ( hookname, ... )","\tSF.CheckType( hookname, \"string\" )","\t","\tlocal instance = SF.instance","\tlocal lower = hookname:lower()","\t","\tSF.instance = nil -- Pretend we're not running an instance","\tlocal ret = { instance:runScriptHookForResult( lower, ... ) }","\tSF.instance = instance -- Set it back","\t","\tlocal ok = table.remove( ret, 1 )","\tif not ok then","\t\tinstance:Error( \"Hook '\" .. lower .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\treturn","\tend","\t","\treturn unpack( ret )","end",""],"class":"function","summary":"\nRun a hook ","library":"hook","name":"hook_library.run","server":true,"private":false,"client":true,"description":"\nRun a hook","param":{"1":"hookname","2":"...","...":"arguments","hookname":"The hook name"}},"add":{"comment":["--- Sets a hook function","-- @param hookname Name of the event","-- @param name Unique identifier","-- @param func Function to run"],"code":["function hook_library.add ( hookname, name, func )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tif func then SF.CheckType( func, \"function\" ) else return end","\t","\tlocal inst = SF.instance","\tlocal hooks = inst.hooks[ hookname:lower() ]","\tif not hooks then","\t\thooks = {}","\t\tinst.hooks[ hookname:lower() ] = hooks","\tend","\t","\thooks[ name ] = func","\tregistered_instances[ inst ] = true","end",""],"class":"function","name":"hook_library.add","summary":"\nSets a hook function ","private":false,"library":"hook","description":"\nSets a hook function","param":{"1":"hookname","2":"name","3":"func","func":"Function to run","name":"Unique identifier","hookname":"Name of the event"}}},"class":"library","summary":"\nDeals with hooks ","code":["local hook_library, _ = SF.Libraries.Register( \"hook\" )","local registered_instances = {}",""],"fields":[],"name":"hook","client":true,"description":"\nDeals with hooks","libtbl":"hook_library","tables":[],"server":true},{"comment":["--- Sets a hook function","-- @param hookname Name of the event","-- @param name Unique identifier","-- @param func Function to run"],"code":["function hook_library.add ( hookname, name, func )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tif func then SF.CheckType( func, \"function\" ) else return end","\t","\tlocal inst = SF.instance","\tlocal hooks = inst.hooks[ hookname:lower() ]","\tif not hooks then","\t\thooks = {}","\t\tinst.hooks[ hookname:lower() ] = hooks","\tend","\t","\thooks[ name ] = func","\tregistered_instances[ inst ] = true","end",""],"class":"function","name":"hook_library.add","summary":"\nSets a hook function ","private":false,"library":"hook","description":"\nSets a hook function","param":{"1":"hookname","2":"name","3":"func","func":"Function to run","name":"Unique identifier","hookname":"Name of the event"}},{"comment":["--- Run a hook","-- @shared","-- @param hookname The hook name","-- @param ... arguments"],"code":["function hook_library.run ( hookname, ... )","\tSF.CheckType( hookname, \"string\" )","\t","\tlocal instance = SF.instance","\tlocal lower = hookname:lower()","\t","\tSF.instance = nil -- Pretend we're not running an instance","\tlocal ret = { instance:runScriptHookForResult( lower, ... ) }","\tSF.instance = instance -- Set it back","\t","\tlocal ok = table.remove( ret, 1 )","\tif not ok then","\t\tinstance:Error( \"Hook '\" .. lower .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\treturn","\tend","\t","\treturn unpack( ret )","end",""],"class":"function","summary":"\nRun a hook ","library":"hook","name":"hook_library.run","server":true,"private":false,"client":true,"description":"\nRun a hook","param":{"1":"hookname","2":"...","...":"arguments","hookname":"The hook name"}},{"description":"\nRemote hook. \nThis hook can be called from other instances","code":[""],"class":"hook","classForced":true,"name":"remote","summary":"\nRemote hook.","server":true,"client":true,"comment":["--- Remote hook.","-- This hook can be called from other instances","-- @name remote","-- @class hook","-- @shared","-- @param sender The entity that caused the hook to run","-- @param owner The owner of the sender","-- @param ... The payload that was supplied when calling the hook"],"param":{"1":"sender","2":"owner","3":"...","sender":"The entity that caused the hook to run","...":"The payload that was supplied when calling the hook","owner":"The owner of the sender"}},{"ret":"tbl A list of the resultset of each called hook","comment":["--- Run a hook remotely.","-- This will call the hook \"remote\" on either a specified entity or all instances on the server/client","-- @shared","-- @param recipient Starfall entity to call the hook on. Nil to run on every starfall entity","-- @param ... Payload. These parameters will be used to call the hook functions","-- @return tbl A list of the resultset of each called hook"],"code":["function hook_library.runRemote ( recipient, ... )","\tif recipient then SF.CheckType( recipient, SF.Entities.Metatable ) end","","\tlocal recipients","\tif recipient then","\t\tlocal ent = SF.Entities.Unwrap( recipient )","\t\tif not ent.instance then SF.throw( \"Entity has no starfall instance\", 2 ) end","\t\trecipients = {","\t\t\t[ ent.instance ] = true","\t\t}","\telse","\t\trecipients = registered_instances","\tend","","\tlocal instance = SF.instance","","\tlocal result = {}","\tfor k, _ in pairs( recipients ) do","\t\tSF.instance = nil","\t\tresult = { k:runScriptHookForResult( \"remote\", instance.data.entity, instance.player, ... ) }","","\t\tlocal ok = table.remove( result, 1 )","\t\tif not ok then","\t\t\tif not result[ 1 ] then continue end -- Call failed because of non-existent hook. Ignore","\t\t\tk:Error( \"Hook 'remote' errored with \" .. result[ 1 ], result[ 2 ] )","\t\t\t-- Their fault - don't return","\t\tend","\tend","","\tSF.instance = instance","\treturn result","end",""],"class":"function","summary":"\nRun a hook remotely.","library":"hook","name":"hook_library.runRemote","server":true,"private":false,"client":true,"description":"\nRun a hook remotely. \nThis will call the hook \"remote\" on either a specified entity or all instances on the server/client","param":{"1":"recipient","2":"...","recipient":"Starfall entity to call the hook on. Nil to run on every starfall entity","...":"Payload. These parameters will be used to call the hook functions"}},{"comment":["--- Remove a hook","-- @shared","-- @param hookname The hook name","-- @param name The unique name for this hook"],"code":["function hook_library.remove ( hookname, name )","\tSF.CheckType( hookname, \"string\" )","\tSF.CheckType( name, \"string\" )","\tlocal instance = SF.instance","\t","\tlocal lower = hookname:lower()","\tif instance.hooks[ lower ] then","\t\tinstance.hooks[ lower ][ name ] = nil","\t\t","\t\tif not next( instance.hooks[ lower ] ) then","\t\t\tinstance.hooks[ lower ] = nil","\t\tend","\tend","\t","\tif not next( instance.hooks ) then","\t\tregistered_instances[ instance ] = nil","\tend","end","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tregistered_instances[ instance ] = nil","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance, name, func, err )","\tif name == \"_runFunction\" and err == true then","\t\tregistered_instances[ instance ] = nil","\t\tinstance.hooks = {}","\tend","end)","","local wrapArguments = SF.Sanitize","","local function run ( hookname, customfunc, ... )","\tlocal result = {}","\tfor instance,_ in pairs( registered_instances ) do","\t\tlocal ret = { instance:runScriptHookForResult( hookname, wrapArguments( ... ) ) }","\t\t","\t\tlocal ok = table.remove( ret, 1 )","\t\tif ok then","\t\t\tif customfunc then","\t\t\t\tlocal sane = customfunc( instance, ret, ... )","\t\t\t\tresult = sane ~= nil and { sane } or result","\t\t\tend","\t\telse","\t\t\tinstance:Error( \"Hook '\" .. hookname .. \"' errored with \" .. ret[ 1 ], ret[ 2 ] )","\t\tend","\tend","\treturn unpack( result )","end","","","local hooks = {}"],"class":"function","summary":"\nRemove a hook ","library":"hook","name":"hook_library.remove","server":true,"private":false,"client":true,"description":"\nRemove a hook","param":{"1":"hookname","2":"name","name":"The unique name for this hook","hookname":"The hook name"}},{"comment":["--- Add a GMod hook so that SF gets access to it","-- @shared","-- @param hookname The hook name. In-SF hookname will be lowercased","-- @param customfunc Optional custom function"],"code":["function SF.hookAdd ( hookname, customfunc )","\thooks[ #hooks + 1 ] = hookname","\tlocal lower = hookname:lower()","\thook.Add( hookname, \"SF_\" .. hookname, function ( ... )","\t\treturn run( lower, customfunc, ... )","\tend)","end","","local function returnOnlyOnYourself( instance, args, ply )","\tif instance.player ~= ply then return end","\tif args then return args[1] end","end","","local add = SF.hookAdd","","if SERVER then","\t-- Server hooks","\tadd( \"GravGunOnPickedUp\" )","\tadd( \"GravGunOnDropped\" )","\tadd( \"OnPhysgunFreeze\" )","\tadd( \"OnPhysgunReload\" )","\tadd( \"PlayerDeath\" )","\tadd( \"PlayerDisconnected\" )","\tadd( \"PlayerInitialSpawn\" )","\tadd( \"PlayerSpawn\" )","\tadd( \"PlayerEnteredVehicle\" )","\tadd( \"PlayerLeaveVehicle\" )","\tadd( \"PlayerSay\", returnOnlyOnYourself )","\tadd( \"PlayerSpray\" )","\tadd( \"PlayerUse\" )","\tadd( \"PlayerSwitchFlashlight\" )","\tadd( \"PlayerCanPickupWeapon\", returnOnlyOnYourself  )","\t","\thook.Add(\"EntityTakeDamage\", \"SF_EntityTakeDamage\", function( target, dmg )","\t\tlocal lower = (\"EntityTakeDamage\"):lower()","\t\trun( lower, nil, target, dmg:GetAttacker(), ","\t\t\tdmg:GetInflictor(), ","\t\t\tdmg:GetDamage(), ","\t\t\tdmg:GetDamageType(), ","\t\t\tdmg:GetDamagePosition(), ","\t\t\tdmg:GetDamageForce())","\tend)","\t","else","\t-- Client hooks","\t-- todo","end","","-- Shared hooks","","-- Player hooks","add( \"PlayerHurt\" )","add( \"PlayerNoClip\" )","add( \"KeyPress\" )","add( \"KeyRelease\" )","add( \"GravGunPunt\" )","add( \"PhysgunPickup\" )","add( \"PhysgunDrop\" )","add( \"PlayerSwitchWeapon\", returnOnlyOnYourself )","","-- Entity hooks","add( \"OnEntityCreated\" )","add( \"EntityRemoved\" )","add( \"PropBreak\" )","","-- Other","add( \"EndEntityDriving\" )","add( \"StartEntityDriving\" )",""],"class":"function","summary":"\nAdd a GMod hook so that SF gets access to it ","name":"SF.hookAdd","server":true,"private":false,"client":true,"description":"\nAdd a GMod hook so that SF gets access to it","param":{"1":"hookname","2":"customfunc","customfunc":"Optional custom function","hookname":"The hook name. In-SF hookname will be lowercased"}},{"description":"\nCalled when an entity is being picked up by a gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunOnPickedUp","summary":"\nCalled when an entity is being picked up by a gravity gun ","server":true,"comment":["--- Called when an entity is being picked up by a gravity gun","-- @name GravGunOnPickedUp","-- @class hook","-- @server","-- @param ply Player picking up an object","-- @param ent Entity being picked up"],"param":{"1":"ply","2":"ent","ply":"Player picking up an object","ent":"Entity being picked up"}},{"description":"\nCalled when an entity is being dropped by a gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunOnDropped","summary":"\nCalled when an entity is being dropped by a gravity gun ","server":true,"comment":["--- Called when an entity is being dropped by a gravity gun","-- @name GravGunOnDropped","-- @class hook","-- @server","-- @param ply Player dropping the object","-- @param ent Entity being dropped"],"param":{"1":"ply","2":"ent","ply":"Player dropping the object","ent":"Entity being dropped"}},{"description":"\nCalled when an entity is being frozen","code":[""],"class":"hook","classForced":true,"name":"OnPhysgunFreeze","summary":"\nCalled when an entity is being frozen ","server":true,"comment":["--- Called when an entity is being frozen","-- @name OnPhysgunFreeze","-- @class hook","-- @server","-- @param physgun Entity of the physgun","-- @param physobj PhysObj of the entity","-- @param ent Entity being frozen","-- @param ply Player freezing the entity"],"param":{"1":"physgun","2":"physobj","3":"ent","4":"ply","physobj":"PhysObj of the entity","ply":"Player freezing the entity","physgun":"Entity of the physgun","ent":"Entity being frozen"}},{"description":"\nCalled when a player reloads his physgun","code":[""],"class":"hook","classForced":true,"name":"OnPhysgunReload","summary":"\nCalled when a player reloads his physgun ","server":true,"comment":["--- Called when a player reloads his physgun","-- @name OnPhysgunReload","-- @class hook","-- @server","-- @param physgun Entity of the physgun","-- @param ply Player reloading the physgun"],"param":{"1":"physgun","2":"ply","physgun":"Entity of the physgun","ply":"Player reloading the physgun"}},{"description":"\nCalled when a player dies","code":[""],"class":"hook","classForced":true,"name":"PlayerDeath","summary":"\nCalled when a player dies ","server":true,"comment":["--- Called when a player dies","-- @name PlayerDeath","-- @class hook","-- @server","-- @param ply Player who died","-- @param inflictor Entity used to kill the player","-- @param attacker Entity that killed the player"],"param":{"1":"ply","2":"inflictor","3":"attacker","inflictor":"Entity used to kill the player","ply":"Player who died","attacker":"Entity that killed the player"}},{"description":"\nCalled when a player disconnects","code":[""],"class":"hook","classForced":true,"name":"PlayerDisconnected","summary":"\nCalled when a player disconnects ","server":true,"comment":["--- Called when a player disconnects","-- @name PlayerDisconnected","-- @class hook","-- @server","-- @param ply Player that disconnected"],"param":{"1":"ply","ply":"Player that disconnected"}},{"summary":"\nCalled when a player spawns for the first time ","comment":["--- Called when a player spawns for the first time","-- @name PlayerInitialSpawn","-- @param player Player who spawned","-- @server"],"code":[""],"server":true,"description":"\nCalled when a player spawns for the first time","name":"PlayerInitialSpawn","param":{"1":"player","player":"Player who spawned"}},{"description":"\nCalled when a player spawns","code":[""],"class":"hook","classForced":true,"name":"PlayerSpawn","summary":"\nCalled when a player spawns ","server":true,"comment":["--- Called when a player spawns","-- @name PlayerSpawn","-- @class hook","-- @server","-- @param player Player who spawned"],"param":{"1":"player","player":"Player who spawned"}},{"description":"\nCalled when a players enters a vehicle","code":[""],"class":"hook","classForced":true,"name":"PlayerEnteredVehicle","summary":"\nCalled when a players enters a vehicle ","server":true,"comment":["--- Called when a players enters a vehicle","-- @name PlayerEnteredVehicle","-- @class hook","-- @server","-- @param ply Player who entered a vehicle","-- @param vehicle Vehicle that was entered","-- @param num Role"],"param":{"1":"ply","2":"vehicle","3":"num","vehicle":"Vehicle that was entered","ply":"Player who entered a vehicle","num":"Role"}},{"description":"\nCalled when a players leaves a vehicle","code":[""],"class":"hook","classForced":true,"name":"PlayerLeaveVehicle","summary":"\nCalled when a players leaves a vehicle ","server":true,"comment":["--- Called when a players leaves a vehicle","-- @name PlayerLeaveVehicle","-- @class hook","-- @server","-- @param ply Player who left a vehicle","-- @param vehicle Vehicle that was left"],"param":{"1":"ply","2":"vehicle","ply":"Player who left a vehicle","vehicle":"Vehicle that was left"}},{"ret":"New text. \"\" to stop from displaying. Nil to keep original.","description":"\nCalled when a player sends a chat message","code":[""],"class":"hook","classForced":true,"name":"PlayerSay","summary":"\nCalled when a player sends a chat message ","server":true,"comment":["--- Called when a player sends a chat message","-- @name PlayerSay","-- @class hook","-- @server","-- @param ply Player that sent the message","-- @param text Content of the message","-- @param teamChat True if team chat","-- @return New text. \"\" to stop from displaying. Nil to keep original."],"param":{"1":"ply","2":"text","3":"teamChat","text":"Content of the message","ply":"Player that sent the message","teamChat":"True if team chat"}},{"description":"\nCalled when a players sprays his logo","code":[""],"class":"hook","classForced":true,"name":"PlayerSpray","summary":"\nCalled when a players sprays his logo ","server":true,"comment":["--- Called when a players sprays his logo","-- @name PlayerSpray","-- @class hook","-- @server","-- @param ply Player that sprayed"],"param":{"1":"ply","ply":"Player that sprayed"}},{"description":"\nCalled when a player holds their use key and looks at an entity. \nWill continuously run.","code":[""],"class":"hook","classForced":true,"name":"PlayerUse","summary":"\nCalled when a player holds their use key and looks at an entity.","param":{"1":"ply","2":"ent","ply":"Player using the entity","ent":"Entity being used"},"comment":["--- Called when a player holds their use key and looks at an entity.","-- Will continuously run.","-- @name PlayerUse","-- @server","-- @class hook","-- @param ply Player using the entity","-- @param ent Entity being used"],"server":true},{"description":"\nCalled when a players turns their flashlight on or off","code":[""],"class":"hook","classForced":true,"name":"PlayerSwitchFlashlight","summary":"\nCalled when a players turns their flashlight on or off ","server":true,"comment":["--- Called when a players turns their flashlight on or off","-- @name PlayerSwitchFlashlight","-- @class hook","-- @server","-- @param ply Player switching flashlight","-- @param state New flashlight state. True if on."],"param":{"1":"ply","2":"state","ply":"Player switching flashlight","state":"New flashlight state. True if on."}},{"description":"\nCalled when a wants to pick up a weapon","code":[""],"class":"hook","classForced":true,"name":"PlayerCanPickupWeapon","summary":"\nCalled when a wants to pick up a weapon ","server":true,"comment":["--- Called when a wants to pick up a weapon","-- @name PlayerCanPickupWeapon","-- @class hook","-- @server","-- @param ply Player","-- @param wep Weapon"],"param":{"1":"ply","2":"wep","ply":"Player","wep":"Weapon"}},{"description":"\nCalled when a player gets hurt","code":[""],"class":"hook","classForced":true,"name":"PlayerHurt","summary":"\nCalled when a player gets hurt ","server":true,"client":true,"comment":["--- Called when a player gets hurt","-- @name PlayerHurt","-- @class hook","-- @shared","-- @param ply Player being hurt","-- @param attacker Entity causing damage to the player","-- @param newHealth New health of the player","-- @param damageTaken Amount of damage the player has taken"],"param":{"1":"ply","2":"attacker","3":"newHealth","4":"damageTaken","damageTaken":"Amount of damage the player has taken","attacker":"Entity causing damage to the player","ply":"Player being hurt","newHealth":"New health of the player"}},{"description":"\nCalled when a player toggles noclip","code":[""],"class":"hook","classForced":true,"name":"PlayerNoClip","summary":"\nCalled when a player toggles noclip ","server":true,"client":true,"comment":["--- Called when a player toggles noclip","-- @name PlayerNoClip","-- @class hook","-- @shared","-- @param ply Player toggling noclip","-- @param newState New noclip state. True if on."],"param":{"1":"ply","2":"newState","ply":"Player toggling noclip","newState":"New noclip state. True if on."}},{"description":"\nCalled when a player presses a key","code":[""],"class":"hook","classForced":true,"name":"KeyPress","summary":"\nCalled when a player presses a key ","server":true,"client":true,"comment":["--- Called when a player presses a key","-- @name KeyPress","-- @class hook","-- @shared","-- @param ply Player pressing the key","-- @param key The key being pressed"],"param":{"1":"ply","2":"key","ply":"Player pressing the key","key":"The key being pressed"}},{"description":"\nCalled when a player releases a key","code":[""],"class":"hook","classForced":true,"name":"KeyRelease","summary":"\nCalled when a player releases a key ","server":true,"client":true,"comment":["--- Called when a player releases a key","-- @name KeyRelease","-- @class hook","-- @shared","-- @param ply Player releasing the key","-- @param key The key being released"],"param":{"1":"ply","2":"key","ply":"Player releasing the key","key":"The key being released"}},{"description":"\nCalled when a player punts with the gravity gun","code":[""],"class":"hook","classForced":true,"name":"GravGunPunt","summary":"\nCalled when a player punts with the gravity gun ","server":true,"client":true,"comment":["--- Called when a player punts with the gravity gun","-- @name GravGunPunt","-- @class hook","-- @shared","-- @param ply Player punting the gravgun","-- @param ent Entity being punted"],"param":{"1":"ply","2":"ent","ply":"Player punting the gravgun","ent":"Entity being punted"}},{"description":"\nCalled when an entity gets picked up by a physgun","code":[""],"class":"hook","classForced":true,"name":"PhysgunPickup","summary":"\nCalled when an entity gets picked up by a physgun ","server":true,"client":true,"comment":["--- Called when an entity gets picked up by a physgun","-- @name PhysgunPickup","-- @class hook","-- @shared","-- @param ply Player picking up the entity","-- @param ent Entity being picked up"],"param":{"1":"ply","2":"ent","ply":"Player picking up the entity","ent":"Entity being picked up"}},{"description":"\nCalled when an entity being held by a physgun gets dropped","code":[""],"class":"hook","classForced":true,"name":"PhysgunDrop","summary":"\nCalled when an entity being held by a physgun gets dropped ","server":true,"client":true,"comment":["--- Called when an entity being held by a physgun gets dropped","-- @name PhysgunDrop","-- @class hook","-- @shared","-- @param ply Player droppig the entity","-- @param ent Entity being dropped"],"param":{"1":"ply","2":"ent","ply":"Player droppig the entity","ent":"Entity being dropped"}},{"description":"\nCalled when a player switches their weapon","code":[""],"class":"hook","classForced":true,"name":"PlayerSwitchWeapon","summary":"\nCalled when a player switches their weapon ","server":true,"client":true,"comment":["--- Called when a player switches their weapon","-- @name PlayerSwitchWeapon","-- @class hook","-- @shared","-- @param ply Player droppig the entity","-- @param oldwep Old weapon","-- @param newweapon New weapon"],"param":{"1":"ply","2":"oldwep","3":"newweapon","oldwep":"Old weapon","ply":"Player droppig the entity","newweapon":"New weapon"}},{"description":"\nCalled when an entity gets created","code":[""],"class":"hook","classForced":true,"name":"OnEntityCreated","summary":"\nCalled when an entity gets created ","server":true,"client":true,"comment":["--- Called when an entity gets created","-- @name OnEntityCreated","-- @class hook","-- @shared","-- @param ent New entity"],"param":{"1":"ent","ent":"New entity"}},{"description":"\nCalled when an entity is removed","code":[""],"class":"hook","classForced":true,"name":"EntityRemoved","summary":"\nCalled when an entity is removed ","server":true,"client":true,"comment":["--- Called when an entity is removed","-- @name EntityRemoved","-- @class hook","-- @shared","-- @param ent Entity being removed"],"param":{"1":"ent","ent":"Entity being removed"}},{"description":"\nCalled when an entity is broken","code":[""],"class":"hook","classForced":true,"name":"PropBreak","summary":"\nCalled when an entity is broken ","server":true,"client":true,"comment":["--- Called when an entity is broken","-- @name PropBreak","-- @class hook","-- @shared","-- @param ply Player who broke it","-- @param ent Entity broken"],"param":{"1":"ply","2":"ent","ply":"Player who broke it","ent":"Entity broken"}},{"description":"\nCalled when an entity is damaged","code":[""],"class":"hook","classForced":true,"name":"EntityTakeDamage","summary":"\nCalled when an entity is damaged ","server":true,"comment":["--- Called when an entity is damaged","-- @name EntityTakeDamage","-- @class hook","-- @server","-- @param target Entity that is hurt","-- @param attacker Entity that attacked","-- @param inflictor Entity that inflicted the damage","-- @param amount How much damage","-- @param type Type of the damage","-- @param position Position of the damage","-- @param force Force of the damage"],"param":{"1":"target","2":"attacker","3":"inflictor","4":"amount","5":"type","6":"position","7":"force","inflictor":"Entity that inflicted the damage","position":"Position of the damage","amount":"How much damage","target":"Entity that is hurt","force":"Force of the damage","attacker":"Entity that attacked","type":"Type of the damage"}},{"description":"\nCalled when a player stops driving an entity","code":[""],"class":"hook","classForced":true,"name":"EndEntityDriving","summary":"\nCalled when a player stops driving an entity ","server":true,"client":true,"comment":["--- Called when a player stops driving an entity","-- @name EndEntityDriving","-- @class hook","-- @shared","-- @param ent Entity that had been driven","-- @param ply Player that drove the entity"],"param":{"1":"ent","2":"ply","ent":"Entity that had been driven","ply":"Player that drove the entity"}},{"description":"\nCalled when a player starts driving an entity","code":[""],"class":"hook","classForced":true,"name":"StartEntityDriving","summary":"\nCalled when a player starts driving an entity ","server":true,"client":true,"comment":["--- Called when a player starts driving an entity","-- @name StartEntityDriving","-- @class hook","-- @shared","-- @param ent Entity being driven","-- @param ply Player that is driving the entity"],"param":{"1":"ent","2":"ply","ent":"Entity being driven","ply":"Player that is driving the entity"}},{"description":"\nThink hook. Called each game tick","code":[""],"class":"hook","classForced":true,"name":"think","summary":"\nThink hook.","server":true,"client":true,"comment":["--- Think hook. Called each game tick","-- @name think","-- @class hook","-- @shared"],"param":[]},{"description":"\nCalled when the starfall chip is removed","code":[""],"class":"hook","classForced":true,"name":"Removed","summary":"\nCalled when the starfall chip is removed ","server":true,"comment":["--- Called when the starfall chip is removed","-- @name Removed","-- @class hook","-- @server"],"param":[]},{"description":"\nCalled after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","code":[],"class":"hook","classForced":true,"name":"Initialize","summary":"\nCalled after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","server":true,"comment":["--- Called after the starfall chip is placed/reloaded with the toolgun or duplicated and the duplication is finished.","-- @name Initialize","-- @class hook","-- @server"],"param":[]}],"tables":[],"description":"\n \nHook library \n","summary":"\n \nHook library \n "},"libs_sh/entities.lua":{"libraries":{"1":"entities","entities":{"comment":["--- Entities Library","-- @shared"],"functions":{"1":"entity","2":"owner","3":"player","4":"self","self":{"ret":"Starfall entity","comment":["--- Returns the entity representing a processor that this script is running on.","-- May be nil","-- @return Starfall entity"],"code":["function ents_lib.self ()","\tlocal ent = SF.instance.data.entity","\tif ent then ","\t\treturn SF.Entities.Wrap( ent )","\telse return nil end","end",""],"class":"function","name":"ents_lib.self","summary":"\nReturns the entity representing a processor that this script is running on.","private":false,"library":"entities","description":"\nReturns the entity representing a processor that this script is running on. \nMay be nil","param":[]},"owner":{"ret":"Owner entity","comment":["--- Returns whoever created the script","-- @return Owner entity"],"code":["function ents_lib.owner ()","\treturn SF.WrapObject( SF.instance.player )","end",""],"class":"function","name":"ents_lib.owner","summary":"\nReturns whoever created the script ","private":false,"library":"entities","description":"\nReturns whoever created the script","param":[]},"entity":{"ret":"entity","comment":["--- Returns the entity with index 'num'","-- @name ents_lib.entity","-- @class function","-- @param num Entity index","-- @return entity"],"code":["function ents_lib.entity ( num )","\tSF.CheckType( num, \"number\" )","\t","\treturn SF.WrapObject( Entity( num ) )","end","","-- ------------------------- Methods ------------------------- --",""],"class":"function","classForced":true,"name":"ents_lib.entity","summary":"\nReturns the entity with index 'num' ","private":false,"library":"entities","description":"\nReturns the entity with index 'num'","param":{"1":"num","num":"Entity index"}},"player":{"ret":"Either the owner (server) or the local player (client)","description":"\nSame as ents_lib.owner() on the server. On the client, returns the local player","code":["if SERVER then","\tents_lib.player = ents_lib.owner","else","\tfunction ents_lib.player ()","\t\treturn SF.WrapObject( LocalPlayer() )","\tend","\t","\tlocal renderProperties = {","\t\t[1] = function( ent ) --Color\t","\t\t\tent:SetColor( Color( net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ) ) )","\t\tend,","\t\t[2] = function( ent ) --Nodraw","\t\t\tent:SetNoDraw( net.ReadBit() == 1 )","\t\tend,","\t\t[3] = function( ent ) --Material","\t\t\tent:SetMaterial( net.ReadString() )","\t\tend,","\t\t[4] = function( ent ) --Submaterial","\t\t\tent:SetSubMaterial( net.ReadUInt( 16 ), net.ReadString() )","\t\tend,","\t\t[5] = function( ent ) --Bodygroup","\t\t\tent:SetBodyGroup( net.ReadUInt( 16 ), net.ReadUInt ( 16 ) )","\t\tend,","\t\t[6] = function( ent ) --Skin","\t\t\tent:SetSkin( net.ReadUInt( 16 ) )","\t\tend","\t}","\t","\t--Net function that allows the server to set the render properties of entities for specific players","\tnet.Receive( \"sf_setentityrenderproperty\", function()","\t\tlocal ent = net.ReadEntity()","\t\tif not ent:IsValid() then return end","\t\tlocal property = net.ReadUInt( 4 )","\t\tif not renderProperties[ property ] then return end","\t\t","\t\trenderProperties[ property ]( ent )","\tend)","end",""],"class":"function","classForced":true,"name":"ents_lib.player","summary":"\nSame as ents_lib.owner() on the server.","library":"entities","comment":["--- Same as ents_lib.owner() on the server. On the client, returns the local player","-- @name ents_lib.player","-- @class function","-- @return Either the owner (server) or the local player (client)"],"param":[]}},"class":"library","summary":"\nEntities Library ","code":["local ents_lib, _ = SF.Libraries.Register( \"entities\" )","","-- ------------------------- Internal functions ------------------------- --","","SF.Entities.Wrap = wrap","SF.Entities.Unwrap = unwrap","SF.Entities.Methods = ents_methods","SF.Entities.Metatable = ents_metamethods","SF.Entities.Library = ents_lib",""],"fields":[],"name":"entities","client":true,"description":"\nEntities Library","libtbl":"ents_lib","tables":[],"server":true}},"type":"file","name":"libs_sh/entities.lua","functions":{"1":"SF.Entities.GetPhysObject","2":"SF.Entities.IsValid","3":"ents_lib.entity","4":"ents_lib.owner","5":"ents_lib.player","6":"ents_lib.self","7":"ents_metamethods:__tostring","8":"ents_methods:entIndex","9":"ents_methods:getAngleVelocity","10":"ents_methods:getAngles","11":"ents_methods:getClass","12":"ents_methods:getColor","13":"ents_methods:getEyeAngles","14":"ents_methods:getEyePos","15":"ents_methods:getForward","16":"ents_methods:getInertia","17":"ents_methods:getMass","18":"ents_methods:getMassCenter","19":"ents_methods:getMassCenterW","20":"ents_methods:getMaterial","21":"ents_methods:getMaterials","22":"ents_methods:getMatrix","23":"ents_methods:getModel","24":"ents_methods:getPos","25":"ents_methods:getRight","26":"ents_methods:getSubMaterial","27":"ents_methods:getUp","28":"ents_methods:getVelocity","29":"ents_methods:isNPC","30":"ents_methods:isPlayer","31":"ents_methods:isValid","32":"ents_methods:isVehicle","33":"ents_methods:isWeapon","34":"ents_methods:localToWorld","35":"ents_methods:localToWorldAngles","36":"ents_methods:obbCenter","37":"ents_methods:obbCenterW","38":"ents_methods:obbSize","39":"ents_methods:worldToLocal","40":"ents_methods:worldToLocalAngles","ents_methods:getColor":{"ret":"Color","comment":["--- Gets the color of an entity","-- @shared","-- @return Color"],"code":["function ents_methods:getColor ()","\tlocal this = unwrap( self )","\treturn SF.Color.Wrap( this:GetColor() )","end",""],"class":"function","summary":"\nGets the color of an entity ","classlib":"Entity","name":"ents_methods:getColor","server":true,"private":false,"client":true,"description":"\nGets the color of an entity","param":[]},"ents_methods:localToWorld":{"ret":"data as world space vector","comment":["--- Converts a vector in entity local space to world space","-- @shared","-- @param data Local space vector","-- @return data as world space vector"],"code":["function ents_methods:localToWorld( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Vector\" ] )","\tlocal ent = unwrap( self )","\t","\treturn SF.WrapObject( ent:LocalToWorld( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorld","server":true,"private":false,"client":true,"description":"\nConverts a vector in entity local space to world space","param":{"1":"data","data":"Local space vector"}},"ents_methods:getMaterials":{"ret":"Material","comment":["--- Gets an entities' material list","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterials ()","    local ent = unwrap( self )","    return ent:GetMaterials() or {}","end",""],"class":"function","summary":"\nGets an entities' material list ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterials","server":true,"private":false,"client":true,"description":"\nGets an entities' material list","param":[]},"ents_methods:isNPC":{"ret":"True if npc, false if not","comment":["--- Checks if an entity is an npc.","-- @shared","-- @return True if npc, false if not"],"code":["function ents_methods:isNPC ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsNPC()","end",""],"class":"function","summary":"\nChecks if an entity is an npc.","classlib":"Entity","name":"ents_methods:isNPC","server":true,"private":false,"client":true,"description":"\nChecks if an entity is an npc.","param":[]},"ents_methods:getMassCenterW":{"ret":"The position vector of the mass center","comment":["--- Returns the world position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn SF.WrapObject( ent:LocalToWorld( phys:GetMassCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's mass center","param":[]},"ents_lib.entity":{"ret":"entity","comment":["--- Returns the entity with index 'num'","-- @name ents_lib.entity","-- @class function","-- @param num Entity index","-- @return entity"],"code":["function ents_lib.entity ( num )","\tSF.CheckType( num, \"number\" )","\t","\treturn SF.WrapObject( Entity( num ) )","end","","-- ------------------------- Methods ------------------------- --",""],"class":"function","classForced":true,"name":"ents_lib.entity","summary":"\nReturns the entity with index 'num' ","private":false,"library":"entities","description":"\nReturns the entity with index 'num'","param":{"1":"num","num":"Entity index"}},"ents_methods:getAngles":{"ret":"The angle","comment":["--- Returns the angle of the entity","-- @shared","-- @return The angle"],"code":["function ents_methods:getAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:GetAngles() )","end",""],"class":"function","summary":"\nReturns the angle of the entity ","classlib":"Entity","name":"ents_methods:getAngles","server":true,"private":false,"client":true,"description":"\nReturns the angle of the entity","param":[]},"ents_methods:getPos":{"ret":"The position vector","comment":["--- Returns the position of the entity","-- @shared","-- @return The position vector"],"code":["function ents_methods:getPos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:GetPos() )","end",""],"class":"function","summary":"\nReturns the position of the entity ","classlib":"Entity","name":"ents_methods:getPos","server":true,"private":false,"client":true,"description":"\nReturns the position of the entity","param":[]},"ents_methods:obbSize":{"ret":"The outer bounding box size","comment":["--- Returns the x, y, z size of the entity's outer bounding box (local to the entity)","-- @shared","-- @return The outer bounding box size"],"code":["function ents_methods:obbSize ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:OBBMaxs() - ent:OBBMins() )","end",""],"class":"function","summary":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity) ","classlib":"Entity","name":"ents_methods:obbSize","server":true,"private":false,"client":true,"description":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity)","param":[]},"ents_methods:getUp":{"comment":["--- Gets the entities up vector"],"code":["function ents_methods:getUp ()","\treturn SF.WrapObject( unwrap( self ):GetUp() )","end",""],"class":"function","name":"ents_methods:getUp","summary":"\nGets the entities up vector ","private":false,"classlib":"Entity","description":"\nGets the entities up vector","param":[]},"ents_methods:getMassCenter":{"ret":"The position vector of the mass center","comment":["--- Returns the local position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn SF.WrapObject( phys:GetMassCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's mass center","param":[]},"ents_methods:localToWorldAngles":{"ret":"data as world space angle","comment":["--- Converts an angle in entity local space to world space","-- @shared","-- @param data Local space angle","-- @return data as world space angle"],"code":["function ents_methods:localToWorldAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Angle\" ] )","\tlocal ent = unwrap( self )","\tlocal data = SF.UnwrapObject( data )","\t","\treturn SF.WrapObject( ent:LocalToWorldAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorldAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in entity local space to world space","param":{"1":"data","data":"Local space angle"}},"ents_lib.owner":{"ret":"Owner entity","comment":["--- Returns whoever created the script","-- @return Owner entity"],"code":["function ents_lib.owner ()","\treturn SF.WrapObject( SF.instance.player )","end",""],"class":"function","name":"ents_lib.owner","summary":"\nReturns whoever created the script ","private":false,"library":"entities","description":"\nReturns whoever created the script","param":[]},"ents_methods:getMass":{"ret":"The numerical mass","comment":["--- Returns the mass of the entity","-- @shared","-- @return The numerical mass"],"code":["function ents_methods:getMass ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetMass()","end",""],"class":"function","summary":"\nReturns the mass of the entity ","classlib":"Entity","name":"ents_methods:getMass","server":true,"private":false,"client":true,"description":"\nReturns the mass of the entity","param":[]},"ents_methods:getEyePos":{"ret":["Eye position of the entity","In case of a ragdoll, the position of the other eye"],"comment":["--- Gets the entity's eye position","-- @shared","-- @return Eye position of the entity","-- @return In case of a ragdoll, the position of the other eye"],"code":["function ents_methods:getEyePos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:EyePos() )","end",""],"class":"function","summary":"\nGets the entity's eye position ","classlib":"Entity","name":"ents_methods:getEyePos","server":true,"private":false,"client":true,"description":"\nGets the entity's eye position","param":[]},"ents_methods:entIndex":{"ret":"The numerical index of the entity","comment":["--- Returns the EntIndex of the entity","-- @shared","-- @return The numerical index of the entity"],"code":["function ents_methods:entIndex ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:EntIndex()","end",""],"class":"function","summary":"\nReturns the EntIndex of the entity ","classlib":"Entity","name":"ents_methods:entIndex","server":true,"private":false,"client":true,"description":"\nReturns the EntIndex of the entity","param":[]},"ents_methods:obbCenterW":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the world position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:LocalToWorld( ent:OBBCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's outer bounding box","param":[]},"SF.Entities.GetPhysObject":{"ret":"The physobj, or nil if the entity isn't valid or isn't vphysics","comment":["--- Gets the physics object of the entity","-- @return The physobj, or nil if the entity isn't valid or isn't vphysics"],"code":["function SF.Entities.GetPhysObject ( ent )","\treturn ( isValid( ent ) and ent:GetMoveType() == MOVETYPE_VPHYSICS and ent:GetPhysicsObject() ) or nil","end","local getPhysObject = SF.Entities.GetPhysObject","","-- ------------------------- Library functions ------------------------- --",""],"class":"function","name":"SF.Entities.GetPhysObject","private":false,"summary":"\nGets the physics object of the entity ","description":"\nGets the physics object of the entity","param":["ent"]},"ents_methods:getInertia":{"ret":"The principle moments of inertia as a vector","comment":["--- Returns the principle moments of inertia of the entity","-- @shared","-- @return The principle moments of inertia as a vector"],"code":["function ents_methods:getInertia ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetInertia()","end",""],"class":"function","summary":"\nReturns the principle moments of inertia of the entity ","classlib":"Entity","name":"ents_methods:getInertia","server":true,"private":false,"client":true,"description":"\nReturns the principle moments of inertia of the entity","param":[]},"ents_methods:getForward":{"comment":["--- Gets the entities forward vector"],"code":["function ents_methods:getForward ()","\treturn SF.WrapObject( unwrap( self ):GetForward() )","end"],"class":"function","name":"ents_methods:getForward","summary":"\nGets the entities forward vector ","private":false,"classlib":"Entity","description":"\nGets the entities forward vector","param":[]},"ents_methods:getModel":{"ret":"Model of the entity","comment":["--- Gets the model of an entity","-- @shared","-- @return Model of the entity"],"code":["function ents_methods:getModel ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:GetModel()","end",""],"class":"function","summary":"\nGets the model of an entity ","classlib":"Entity","name":"ents_methods:getModel","server":true,"private":false,"client":true,"description":"\nGets the model of an entity","param":[]},"ents_methods:getRight":{"comment":["--- Gets the entities right vector"],"code":["function ents_methods:getRight ()","\treturn SF.WrapObject( unwrap( self ):GetRight() )","end",""],"class":"function","name":"ents_methods:getRight","summary":"\nGets the entities right vector ","private":false,"classlib":"Entity","description":"\nGets the entities right vector","param":[]},"ents_methods:obbCenter":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the local position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:OBBCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's outer bounding box","param":[]},"ents_methods:getMaterial":{"ret":"Material","comment":["--- Gets an entities' material","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterial ()","    local ent = unwrap( self )","    return ent:GetMaterial() or \"\"","end",""],"class":"function","summary":"\nGets an entities' material ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' material","param":[]},"ents_methods:isVehicle":{"ret":"True if vehicle, false if not","comment":["--- Checks if an entity is a vehicle.","-- @shared","-- @return True if vehicle, false if not"],"code":["function ents_methods:isVehicle ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsVehicle()","end",""],"class":"function","summary":"\nChecks if an entity is a vehicle.","classlib":"Entity","name":"ents_methods:isVehicle","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a vehicle.","param":[]},"ents_methods:getEyeAngles":{"ret":"Angles of the entity's eyes","comment":["--- Gets the entitiy's eye angles","-- @shared","-- @return Angles of the entity's eyes"],"code":["function ents_methods:getEyeAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:EyeAngles() )","end",""],"class":"function","summary":"\nGets the entitiy's eye angles ","classlib":"Entity","name":"ents_methods:getEyeAngles","server":true,"private":false,"client":true,"description":"\nGets the entitiy's eye angles","param":[]},"ents_methods:getMatrix":{"ret":"The matrix","comment":["--- Returns the matrix of the entity","-- @shared","-- @param bone Bone of the entity (def 0)","-- @return The matrix"],"code":["function ents_methods:getMatrix (bone)","\tSF.CheckType( self, ents_metamethods )","\tbone = SF.CheckType( bone, \"number\", 0, 0 )","\t","\tlocal ent = unwrap( self )","\treturn vwrap( ent:GetBoneMatrix(bone) )","end",""],"class":"function","summary":"\nReturns the matrix of the entity ","classlib":"Entity","name":"ents_methods:getMatrix","server":true,"private":false,"client":true,"description":"\nReturns the matrix of the entity","param":{"1":"bone","bone":"Bone of the entity (def 0)"}},"ents_methods:getVelocity":{"ret":"The velocity vector","comment":["--- Returns the velocity of the entity","-- @shared","-- @return The velocity vector"],"code":["function ents_methods:getVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\treturn SF.WrapObject( ent:GetVelocity() )","end",""],"class":"function","summary":"\nReturns the velocity of the entity ","classlib":"Entity","name":"ents_methods:getVelocity","server":true,"private":false,"client":true,"description":"\nReturns the velocity of the entity","param":[]},"ents_lib.player":{"ret":"Either the owner (server) or the local player (client)","description":"\nSame as ents_lib.owner() on the server. On the client, returns the local player","code":["if SERVER then","\tents_lib.player = ents_lib.owner","else","\tfunction ents_lib.player ()","\t\treturn SF.WrapObject( LocalPlayer() )","\tend","\t","\tlocal renderProperties = {","\t\t[1] = function( ent ) --Color\t","\t\t\tent:SetColor( Color( net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ) ) )","\t\tend,","\t\t[2] = function( ent ) --Nodraw","\t\t\tent:SetNoDraw( net.ReadBit() == 1 )","\t\tend,","\t\t[3] = function( ent ) --Material","\t\t\tent:SetMaterial( net.ReadString() )","\t\tend,","\t\t[4] = function( ent ) --Submaterial","\t\t\tent:SetSubMaterial( net.ReadUInt( 16 ), net.ReadString() )","\t\tend,","\t\t[5] = function( ent ) --Bodygroup","\t\t\tent:SetBodyGroup( net.ReadUInt( 16 ), net.ReadUInt ( 16 ) )","\t\tend,","\t\t[6] = function( ent ) --Skin","\t\t\tent:SetSkin( net.ReadUInt( 16 ) )","\t\tend","\t}","\t","\t--Net function that allows the server to set the render properties of entities for specific players","\tnet.Receive( \"sf_setentityrenderproperty\", function()","\t\tlocal ent = net.ReadEntity()","\t\tif not ent:IsValid() then return end","\t\tlocal property = net.ReadUInt( 4 )","\t\tif not renderProperties[ property ] then return end","\t\t","\t\trenderProperties[ property ]( ent )","\tend)","end",""],"class":"function","classForced":true,"name":"ents_lib.player","summary":"\nSame as ents_lib.owner() on the server.","library":"entities","comment":["--- Same as ents_lib.owner() on the server. On the client, returns the local player","-- @name ents_lib.player","-- @class function","-- @return Either the owner (server) or the local player (client)"],"param":[]},"ents_methods:getClass":{"ret":"The string class name","comment":["--- Returns the class of the entity","-- @shared","-- @return The string class name"],"code":["function ents_methods:getClass ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:GetClass()","end",""],"class":"function","summary":"\nReturns the class of the entity ","classlib":"Entity","name":"ents_methods:getClass","server":true,"private":false,"client":true,"description":"\nReturns the class of the entity","param":[]},"ents_methods:isValid":{"ret":"True if valid, false if not","comment":["--- Checks if an entity is valid.","-- @shared","-- @return True if valid, false if not"],"code":["function ents_methods:isValid ()","\tSF.CheckType( self, ents_metamethods )","\treturn isValid( unwrap( self ) )","end",""],"class":"function","summary":"\nChecks if an entity is valid.","classlib":"Entity","name":"ents_methods:isValid","server":true,"private":false,"client":true,"description":"\nChecks if an entity is valid.","param":[]},"ents_methods:isPlayer":{"ret":"True if player, false if not","comment":["--- Checks if an entity is a player.","-- @shared","-- @return True if player, false if not"],"code":["function ents_methods:isPlayer ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsPlayer()","end",""],"class":"function","summary":"\nChecks if an entity is a player.","classlib":"Entity","name":"ents_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a player.","param":[]},"ents_methods:worldToLocalAngles":{"ret":"data as local space angle","comment":["--- Converts an angle in world space to entity local space","-- @shared","-- @param data World space angle","-- @return data as local space angle"],"code":["function ents_methods:worldToLocalAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Angle\" ] )","\tlocal ent = unwrap( self )","\tlocal data = SF.UnwrapObject( data )","\t","\treturn SF.WrapObject( ent:WorldToLocalAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocalAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in world space to entity local space","param":{"1":"data","data":"World space angle"}},"ents_metamethods:__tostring":{"comment":["--- To string","-- @shared"],"code":["function ents_metamethods:__tostring ()","\tlocal ent = unwrap( self )","\tif not ent then return \"(null entity)\"","\telse return tostring( ent ) end","end",""],"class":"function","summary":"\nTo string ","name":"ents_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},"ents_lib.self":{"ret":"Starfall entity","comment":["--- Returns the entity representing a processor that this script is running on.","-- May be nil","-- @return Starfall entity"],"code":["function ents_lib.self ()","\tlocal ent = SF.instance.data.entity","\tif ent then ","\t\treturn SF.Entities.Wrap( ent )","\telse return nil end","end",""],"class":"function","name":"ents_lib.self","summary":"\nReturns the entity representing a processor that this script is running on.","private":false,"library":"entities","description":"\nReturns the entity representing a processor that this script is running on. \nMay be nil","param":[]},"SF.Entities.IsValid":{"summary":"\nReturns true if valid and is not the world, false if not ","description":"\nReturns true if valid and is not the world, false if not","comment":["--- Returns true if valid and is not the world, false if not","-- @param entity Entity to check"],"code":["function SF.Entities.IsValid ( entity )","\treturn entity and entity:IsValid()","end","local isValid = SF.Entities.IsValid",""],"private":false,"class":"function","name":"SF.Entities.IsValid","param":{"1":"entity","entity":"Entity to check"}},"ents_methods:worldToLocal":{"ret":"data as local space vector","comment":["--- Converts a vector in world space to entity local space","-- @shared","-- @param data World space vector","-- @return data as local space vector"],"code":["function ents_methods:worldToLocal ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Vector\" ] )","\tlocal ent = unwrap( self )","\t","\treturn SF.WrapObject( ent:WorldToLocal( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocal","server":true,"private":false,"client":true,"description":"\nConverts a vector in world space to entity local space","param":{"1":"data","data":"World space vector"}},"ents_methods:getSubMaterial":{"ret":"Material","comment":["--- Gets an entities' submaterial","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getSubMaterial ( index )","    local ent = unwrap( self )","    return ent:GetSubMaterial( index ) or \"\"","end",""],"class":"function","summary":"\nGets an entities' submaterial ","classForced":true,"classlib":"Entity","name":"ents_methods:getSubMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' submaterial","param":["index"]},"ents_methods:getAngleVelocity":{"ret":"The angular velocity vector","comment":["--- Returns the angular velocity of the entity","-- @shared","-- @return The angular velocity vector"],"code":["function ents_methods:getAngleVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal phys = getPhysObject( unwrap( self ) )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end\t","\treturn SF.WrapObject( phys:GetAngleVelocity() )","end",""],"class":"function","summary":"\nReturns the angular velocity of the entity ","classlib":"Entity","name":"ents_methods:getAngleVelocity","server":true,"private":false,"client":true,"description":"\nReturns the angular velocity of the entity","param":[]},"ents_methods:isWeapon":{"ret":"True if weapon, false if not","comment":["--- Checks if an entity is a weapon.","-- @shared","-- @return True if weapon, false if not"],"code":["function ents_methods:isWeapon ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsWeapon()","end",""],"class":"function","summary":"\nChecks if an entity is a weapon.","classlib":"Entity","name":"ents_methods:isWeapon","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a weapon.","param":[]}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Shared entity library functions","-------------------------------------------------------------------------------"],"code":["","SF.Entities = {}",""],"summary":"\n \nShared entity library functions \n ","description":"\n \nShared entity library functions \n","param":[]},{"comment":["--- Entity type","-- @shared"],"code":["local ents_methods, ents_metamethods = SF.Typedef( \"Entity\" )","local wrap, unwrap = SF.CreateWrapper( ents_metamethods, true, true, debug.getregistry().Entity )","","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject",""],"typtbl":"ents_methods","summary":"\nEntity type ","fields":[],"name":"Entity","server":true,"description":"\nEntity type","client":true,"class":"class","methods":{"1":"addCollisionListener","2":"applyAngForce","3":"applyDamage","4":"applyForceCenter","5":"applyForceOffset","6":"applyTorque","7":"destroy","8":"emitSound","9":"enableDrag","10":"enableGravity","11":"enableMotion","12":"entIndex","13":"getAngleVelocity","14":"getAngles","15":"getClass","16":"getColor","17":"getEyeAngles","18":"getEyePos","19":"getForward","20":"getInertia","21":"getMass","22":"getMassCenter","23":"getMassCenterW","24":"getMaterial","25":"getMaterials","26":"getMatrix","27":"getModel","28":"getOwner","29":"getPos","30":"getRight","31":"getSubMaterial","32":"getUp","33":"getVelocity","34":"isFrozen","35":"isNPC","36":"isPlayer","37":"isValid","38":"isVehicle","39":"isWeapon","40":"isWeldedTo","41":"localToWorld","42":"localToWorldAngles","43":"obbCenter","44":"obbCenterW","45":"obbSize","46":"remove","47":"setAngles","48":"setBodygroup","49":"setColor","50":"setFrozen","51":"setMass","52":"setMaterial","53":"setNoDraw","54":"setParent","55":"setPos","56":"setSkin","57":"setSolid","58":"setSubMaterial","59":"setVelocity","60":"unparent","61":"worldToLocal","62":"worldToLocalAngles","getRight":{"comment":["--- Gets the entities right vector"],"code":["function ents_methods:getRight ()","\treturn SF.WrapObject( unwrap( self ):GetRight() )","end",""],"class":"function","name":"ents_methods:getRight","summary":"\nGets the entities right vector ","private":false,"classlib":"Entity","description":"\nGets the entities right vector","param":[]},"applyTorque":{"comment":["--- Applies torque","-- @param tq The torque vector","-- @param offset Optional offset position"],"code":["function ents_methods:applyTorque ( tq, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( tq, SF.Types[ \"Vector\" ] )","","\tlocal tq = vunwrap( tq )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal torqueamount = tq:Length()","","\tif offset then","\t\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","\t\toffset = vunwrap( offset )","\telse","\t\toffset = phys:GetPos()","\tend","\t-- Convert torque from local to world axis","\ttq = phys:LocalToWorld( tq ) - offset","","\t-- Find two vectors perpendicular to the torque axis","\tlocal off","\tif abs( tq.x ) > torqueamount * 0.1 or abs( tq.z ) > torqueamount * 0.1 then","\t\toff = Vector( -tq.z, 0, tq.x )","\telse","\t\toff = Vector( -tq.y, tq.x, 0 )","\tend","\toff = off:GetNormal() * torqueamount * 0.5","","\tlocal dir = ( tq:Cross( off ) ):GetNormal()","","\tif not check( dir ) or not check( off ) then SF.throw( \"infinite vector\", 2) end","","\tphys:ApplyForceOffset( dir, off )","\tphys:ApplyForceOffset( dir * -1, off * -1 )","end",""],"class":"function","name":"ents_methods:applyTorque","summary":"\nApplies torque ","private":false,"classlib":"Entity","description":"\nApplies torque","param":{"1":"tq","2":"offset","offset":"Optional offset position","tq":"The torque vector"}},"setColor":{"comment":["--- Sets the color of the entity","-- @server","-- @param clr New color","-- @param ply Optional player arguement to set the entity's color only for that player"],"code":["function ents_methods:setColor ( clr, ply )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 1, clr )","\telse","\t\tent:SetColor( clr )","\t\tent:SetRenderMode( clr.a == 255 and RENDERMODE_NORMAL or RENDERMODE_TRANSALPHA )","\tend","","end",""],"class":"function","summary":"\nSets the color of the entity ","name":"ents_methods:setColor","classlib":"Entity","private":false,"server":true,"description":"\nSets the color of the entity","param":{"1":"clr","2":"ply","clr":"New color","ply":"Optional player arguement to set the entity's color only for that player"}},"setSubMaterial":{"comment":["--- Sets an entities' submaterial","-- @server","-- @class function","-- @param index, number, submaterial index.","-- @param material, string, New material name.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setSubMaterial ( index, material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if materialBlacklist[ material:lower() ] then SF.throw( \"This material has been blacklisted\", 2 ) end","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 4, index, material )","\telse","\t\tent:SetSubMaterial( index, material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' submaterial ","name":"ents_methods:setSubMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' submaterial","param":{"1":"index","2":"material","3":"ply","material":", string, New material name.","index":", number, submaterial index.","ply":"Optional player arguement to set material of an entity only for that player"}},"localToWorld":{"ret":"data as world space vector","comment":["--- Converts a vector in entity local space to world space","-- @shared","-- @param data Local space vector","-- @return data as world space vector"],"code":["function ents_methods:localToWorld( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Vector\" ] )","\tlocal ent = unwrap( self )","\t","\treturn SF.WrapObject( ent:LocalToWorld( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorld","server":true,"private":false,"client":true,"description":"\nConverts a vector in entity local space to world space","param":{"1":"data","data":"Local space vector"}},"getAngles":{"ret":"The angle","comment":["--- Returns the angle of the entity","-- @shared","-- @return The angle"],"code":["function ents_methods:getAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:GetAngles() )","end",""],"class":"function","summary":"\nReturns the angle of the entity ","classlib":"Entity","name":"ents_methods:getAngles","server":true,"private":false,"client":true,"description":"\nReturns the angle of the entity","param":[]},"applyForceOffset":{"comment":["--- Applies linear force to the entity with an offset","-- @param vec The force vector","-- @param offset An optional offset position"],"code":["function ents_methods:applyForceOffset ( vec, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal offset = vunwrap( offset )","","\tif not check( vec ) or not check( offset ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceOffset( vec, offset )","end",""],"class":"function","name":"ents_methods:applyForceOffset","summary":"\nApplies linear force to the entity with an offset ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity with an offset","param":{"1":"vec","2":"offset","vec":"The force vector","offset":"An optional offset position"}},"getSubMaterial":{"ret":"Material","comment":["--- Gets an entities' submaterial","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getSubMaterial ( index )","    local ent = unwrap( self )","    return ent:GetSubMaterial( index ) or \"\"","end",""],"class":"function","summary":"\nGets an entities' submaterial ","classForced":true,"classlib":"Entity","name":"ents_methods:getSubMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' submaterial","param":["index"]},"applyDamage":{"comment":["--- Applies damage to an entity","-- @param amt damage amount","-- @param attacker damage attacker","-- @param inflictor damage inflictor"],"code":["function ents_methods:applyDamage( amt, attacker, inflictor )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( amt, \"number\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyDamage\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif attacker then","\t\tSF.CheckType( attacker, ents_metatable )","\t\tattacker = unwrap( attacker )","\t\tif not isValid( attacker ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","\tif inflictor then","\t\tSF.CheckType( inflictor, ents_metatable )","\t\tinflictor = unwrap( inflictor )","\t\tif not isValid( inflictor ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","","\tent:TakeDamage( amt, attacker, inflictor )","end","",""],"class":"function","name":"ents_methods:applyDamage","summary":"\nApplies damage to an entity ","private":false,"classlib":"Entity","description":"\nApplies damage to an entity","param":{"1":"amt","2":"attacker","3":"inflictor","inflictor":"damage inflictor","attacker":"damage attacker","amt":"damage amount"}},"applyAngForce":{"comment":["--- Applies angular force to the entity","-- @param ang The force angle"],"code":["function ents_methods:applyAngForce ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t-- assign vectors","\tlocal up = ent:GetUp()","\tlocal left = ent:GetRight() * -1","\tlocal forward = ent:GetForward()","","\t-- apply pitch force","\tif ang.p ~= 0 then","\t\tlocal pitch = up * ( ang.p * 0.5 )","\t\tphys:ApplyForceOffset( forward, pitch )","\t\tphys:ApplyForceOffset( forward * -1, pitch * -1 )","\tend","","\t-- apply yaw force","\tif ang.y ~= 0 then","\t\tlocal yaw = forward * ( ang.y * 0.5 )","\t\tphys:ApplyForceOffset( left, yaw )","\t\tphys:ApplyForceOffset( left * -1, yaw * -1 )","\tend","","\t-- apply roll force","\tif ang.r ~= 0 then","\t\tlocal roll = left * ( ang.r * 0.5 )","\t\tphys:ApplyForceOffset( up, roll )","\t\tphys:ApplyForceOffset( up * -1, roll * -1 )","\tend","end",""],"class":"function","name":"ents_methods:applyAngForce","summary":"\nApplies angular force to the entity ","private":false,"classlib":"Entity","description":"\nApplies angular force to the entity","param":{"1":"ang","ang":"The force angle"}},"setAngles":{"comment":["--- Sets the entity's angles","-- @param ang New angles"],"code":["function ents_methods:setAngles ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setAngles\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setAng( ent, ang )","end",""],"class":"function","name":"ents_methods:setAngles","summary":"\nSets the entity's angles ","private":false,"classlib":"Entity","description":"\nSets the entity's angles","param":{"1":"ang","ang":"New angles"}},"unparent":{"comment":["--- Unparents the entity from another entity"],"code":["function ents_methods:unparent ()","\tlocal this = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.unparent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tthis:SetParent( nil )","end",""],"class":"function","name":"ents_methods:unparent","summary":"\nUnparents the entity from another entity ","private":false,"classlib":"Entity","description":"\nUnparents the entity from another entity","param":[]},"applyForceCenter":{"comment":["--- Applies linear force to the entity","-- @param vec The force vector"],"code":["function ents_methods:applyForceCenter ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","\tif not check( vec ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceCenter( vec )","end",""],"class":"function","name":"ents_methods:applyForceCenter","summary":"\nApplies linear force to the entity ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity","param":{"1":"vec","vec":"The force vector"}},"setSkin":{"comment":["--- Sets the skin of the entity","-- @server","-- @class function","-- @param skinIndex Number, Index of the skin to use.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setSkin ( skinIndex, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( skinIndex, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 6, skinIndex )","\telse","\t\tent:SetSkin( skinIndex )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the skin of the entity ","name":"ents_methods:setSkin","classlib":"Entity","private":false,"server":true,"description":"\nSets the skin of the entity","param":{"1":"skinIndex","2":"ply","skinIndex":"Number, Index of the skin to use.","ply":"Optional player arguement to set material of an entity only for that player"}},"getMatrix":{"ret":"The matrix","comment":["--- Returns the matrix of the entity","-- @shared","-- @param bone Bone of the entity (def 0)","-- @return The matrix"],"code":["function ents_methods:getMatrix (bone)","\tSF.CheckType( self, ents_metamethods )","\tbone = SF.CheckType( bone, \"number\", 0, 0 )","\t","\tlocal ent = unwrap( self )","\treturn vwrap( ent:GetBoneMatrix(bone) )","end",""],"class":"function","summary":"\nReturns the matrix of the entity ","classlib":"Entity","name":"ents_methods:getMatrix","server":true,"private":false,"client":true,"description":"\nReturns the matrix of the entity","param":{"1":"bone","bone":"Bone of the entity (def 0)"}},"isValid":{"ret":"True if valid, false if not","comment":["--- Checks if an entity is valid.","-- @shared","-- @return True if valid, false if not"],"code":["function ents_methods:isValid ()","\tSF.CheckType( self, ents_metamethods )","\treturn isValid( unwrap( self ) )","end",""],"class":"function","summary":"\nChecks if an entity is valid.","classlib":"Entity","name":"ents_methods:isValid","server":true,"private":false,"client":true,"description":"\nChecks if an entity is valid.","param":[]},"getUp":{"comment":["--- Gets the entities up vector"],"code":["function ents_methods:getUp ()","\treturn SF.WrapObject( unwrap( self ):GetUp() )","end",""],"class":"function","name":"ents_methods:getUp","summary":"\nGets the entities up vector ","private":false,"classlib":"Entity","description":"\nGets the entities up vector","param":[]},"setBodygroup":{"comment":["--- Sets an entities' bodygroup","-- @server","-- @class function","-- @param bodygroup Number, The ID of the bodygroup you're setting.","-- @param value Number, The value you're setting the bodygroup to.","-- @param ply Optional player arguement to set bodygroup of an entity only for that player"],"code":["function ents_methods:setBodygroup ( bodygroup, value, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( bodygroup, \"number\" )","    SF.CheckType( value, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 5, bodygroup, value )","\telse","\t\tent:SetBodyGroup( bodygroup, value )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' bodygroup ","name":"ents_methods:setBodygroup","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' bodygroup","param":{"1":"bodygroup","2":"value","3":"ply","value":"Number, The value you're setting the bodygroup to.","ply":"Optional player arguement to set bodygroup of an entity only for that player","bodygroup":"Number, The ID of the bodygroup you're setting."}},"setNoDraw":{"comment":["--- Sets the whether an entity should be drawn or not","-- @server","-- @param draw Whether to draw the entity or not.","-- @param ply Optional player arguement to set drawing of an entity only for that player"],"code":["function ents_methods:setNoDraw ( draw, ply )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 2, draw and true or false )","\telse","\t\tent:SetNoDraw( draw and true or false )","\tend","end","","local materialBlacklist = {","\t[ \"pp/copy\" ] = true","}",""],"class":"function","summary":"\nSets the whether an entity should be drawn or not ","name":"ents_methods:setNoDraw","classlib":"Entity","private":false,"server":true,"description":"\nSets the whether an entity should be drawn or not","param":{"1":"draw","2":"ply","draw":"Whether to draw the entity or not.","ply":"Optional player arguement to set drawing of an entity only for that player"}},"addCollisionListener":{"comment":["--- Allows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","-- @param func The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"],"code":["function ents_methods:addCollisionListener ( func )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( func, \"function\" )","\tlocal ent = unwrap( self )","\tif ent.SF_CollisionCallback then SF.throw( \"The entity is already listening to collisions!\", 2 ) end","\tent.SF_CollisionCallback = true","","\tlocal instance = SF.instance","\tent:AddCallback(\"PhysicsCollide\", function(ent, data)","\t\tlocal ok, msg, traceback = instance:runFunction( func, setmetatable({}, {","\t\t\t__index=function(t,k)","\t\t\t\treturn SF.WrapObject( data[k] )","\t\t\tend,","\t\t\t__metatable={}","\t\t}))","","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend)","end","","util.AddNetworkString( \"sf_setentityrenderproperty\" )","","local renderProperties = {","\t[1] = function( clr ) --Color","\t\tnet.WriteUInt( clr.r, 8 )","\t\tnet.WriteUInt( clr.g, 8 )","\t\tnet.WriteUInt( clr.b, 8 )","\t\tnet.WriteUInt( clr.a, 8 )","\tend,","\t[2] = function( draw ) --Nodraw","\t\tnet.WriteBit( draw )","\tend,","\t[3] = function( material ) --Material","\t\tnet.WriteString( material )","\tend,","\t[4] = function( index, material ) --Submaterial","\t\tnet.WriteUInt( index, 16 )","\t\tnet.WriteString( material )","\tend,","\t[5] = function( bodygroup, value ) --Bodygroup","\t\tnet.WriteUInt( bodygroup, 16 )","\t\tnet.WriteUInt( value, 16 )","\tend,","\t[6] = function( skin ) --Skin","\t\tnet.WriteUInt( skin, 16 )","\tend","}","","local function sendRenderPropertyToClient( ply, ent, func, ... )","\tSF.CheckType( ply, SF.Types[ \"Player\" ] )","\tply = unwrap( ply )","\tif isValid( ply ) and ply:IsPlayer() then","\t\tnet.Start( \"sf_setentityrenderproperty\" )","\t\tnet.WriteEntity( ent )","\t\tnet.WriteUInt( func, 4 )","\t\trenderProperties[ func ]( ... )","\t\tnet.Send( ply )","\tend","end",""],"class":"function","name":"ents_methods:addCollisionListener","summary":"\nAllows detecting collisions on an entity.","private":false,"classlib":"Entity","description":"\nAllows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","param":{"1":"func","func":"The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"}},"remove":{"comment":["--- Removes an entity"],"code":["function ents_methods:remove ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not ent:IsValid() or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Remove()","end",""],"class":"function","name":"ents_methods:remove","summary":"\nRemoves an entity ","private":false,"classlib":"Entity","description":"\nRemoves an entity","param":[]},"getEyeAngles":{"ret":"Angles of the entity's eyes","comment":["--- Gets the entitiy's eye angles","-- @shared","-- @return Angles of the entity's eyes"],"code":["function ents_methods:getEyeAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:EyeAngles() )","end",""],"class":"function","summary":"\nGets the entitiy's eye angles ","classlib":"Entity","name":"ents_methods:getEyeAngles","server":true,"private":false,"client":true,"description":"\nGets the entitiy's eye angles","param":[]},"getAngleVelocity":{"ret":"The angular velocity vector","comment":["--- Returns the angular velocity of the entity","-- @shared","-- @return The angular velocity vector"],"code":["function ents_methods:getAngleVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal phys = getPhysObject( unwrap( self ) )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end\t","\treturn SF.WrapObject( phys:GetAngleVelocity() )","end",""],"class":"function","summary":"\nReturns the angular velocity of the entity ","classlib":"Entity","name":"ents_methods:getAngleVelocity","server":true,"private":false,"client":true,"description":"\nReturns the angular velocity of the entity","param":[]},"getMaterials":{"ret":"Material","comment":["--- Gets an entities' material list","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterials ()","    local ent = unwrap( self )","    return ent:GetMaterials() or {}","end",""],"class":"function","summary":"\nGets an entities' material list ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterials","server":true,"private":false,"client":true,"description":"\nGets an entities' material list","param":[]},"enableMotion":{"comment":["--- Sets the entity movement state","-- @param move Bool should the entity move?"],"code":["function ents_methods:enableMotion ( move )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( move and true or false )","\tphys:Wake()","end","","","local function ent1or2 ( ent, con, num )","\tif not con then return nil end","\tif num then","\t\tcon = con[ num ]","\t\tif not con then return nil end","\tend","\tif con.Ent1 == ent then return con.Ent2 end","\treturn con.Ent1","end",""],"class":"function","name":"ents_methods:enableMotion","summary":"\nSets the entity movement state ","private":false,"classlib":"Entity","description":"\nSets the entity movement state","param":{"1":"move","move":"Bool should the entity move?"}},"getForward":{"comment":["--- Gets the entities forward vector"],"code":["function ents_methods:getForward ()","\treturn SF.WrapObject( unwrap( self ):GetForward() )","end"],"class":"function","name":"ents_methods:getForward","summary":"\nGets the entities forward vector ","private":false,"classlib":"Entity","description":"\nGets the entities forward vector","param":[]},"worldToLocalAngles":{"ret":"data as local space angle","comment":["--- Converts an angle in world space to entity local space","-- @shared","-- @param data World space angle","-- @return data as local space angle"],"code":["function ents_methods:worldToLocalAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Angle\" ] )","\tlocal ent = unwrap( self )","\tlocal data = SF.UnwrapObject( data )","\t","\treturn SF.WrapObject( ent:WorldToLocalAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocalAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in world space to entity local space","param":{"1":"data","data":"World space angle"}},"getClass":{"ret":"The string class name","comment":["--- Returns the class of the entity","-- @shared","-- @return The string class name"],"code":["function ents_methods:getClass ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:GetClass()","end",""],"class":"function","summary":"\nReturns the class of the entity ","classlib":"Entity","name":"ents_methods:getClass","server":true,"private":false,"client":true,"description":"\nReturns the class of the entity","param":[]},"setFrozen":{"comment":["--- Sets the entity frozen state","-- @param freeze Should the entity be frozen?"],"code":["function ents_methods:setFrozen ( freeze )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setFrozen\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( not ( freeze and true or false ) )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:setFrozen","summary":"\nSets the entity frozen state ","private":false,"classlib":"Entity","description":"\nSets the entity frozen state","param":{"1":"freeze","freeze":"Should the entity be frozen?"}},"obbCenter":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the local position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:OBBCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's outer bounding box","param":[]},"isNPC":{"ret":"True if npc, false if not","comment":["--- Checks if an entity is an npc.","-- @shared","-- @return True if npc, false if not"],"code":["function ents_methods:isNPC ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsNPC()","end",""],"class":"function","summary":"\nChecks if an entity is an npc.","classlib":"Entity","name":"ents_methods:isNPC","server":true,"private":false,"client":true,"description":"\nChecks if an entity is an npc.","param":[]},"isFrozen":{"ret":"True if entity is frozen","comment":["--- Checks the entities frozen state","-- @return True if entity is frozen"],"code":["function ents_methods:isFrozen ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = ent:GetPhysicsObject()","\tif phys:IsMoveable() then return false else return true end","end",""],"class":"function","name":"ents_methods:isFrozen","summary":"\nChecks the entities frozen state ","private":false,"classlib":"Entity","description":"\nChecks the entities frozen state","param":[]},"getModel":{"ret":"Model of the entity","comment":["--- Gets the model of an entity","-- @shared","-- @return Model of the entity"],"code":["function ents_methods:getModel ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:GetModel()","end",""],"class":"function","summary":"\nGets the model of an entity ","classlib":"Entity","name":"ents_methods:getModel","server":true,"private":false,"client":true,"description":"\nGets the model of an entity","param":[]},"isVehicle":{"ret":"True if vehicle, false if not","comment":["--- Checks if an entity is a vehicle.","-- @shared","-- @return True if vehicle, false if not"],"code":["function ents_methods:isVehicle ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsVehicle()","end",""],"class":"function","summary":"\nChecks if an entity is a vehicle.","classlib":"Entity","name":"ents_methods:isVehicle","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a vehicle.","param":[]},"isWeldedTo":{"comment":["--- Gets what the entity is welded to"],"code":["function ents_methods:isWeldedTo ()","\tlocal this = unwrap( self )","\tif not constraint.HasConstraints( this ) then return nil end","","\treturn wrap( ent1or2( this, constraint.FindConstraint( this, \"Weld\" ) ) )","end"],"class":"function","name":"ents_methods:isWeldedTo","summary":"\nGets what the entity is welded to ","private":false,"classlib":"Entity","description":"\nGets what the entity is welded to","param":[]},"setVelocity":{"comment":["--- Sets the entity's linear velocity","-- @param vel New velocity"],"code":["function ents_methods:setVelocity ( vel )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","","\tlocal vel = vunwrap( vel )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setVelocity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetVelocity( vel )","end",""],"class":"function","name":"ents_methods:setVelocity","summary":"\nSets the entity's linear velocity ","private":false,"classlib":"Entity","description":"\nSets the entity's linear velocity","param":{"1":"vel","vel":"New velocity"}},"setMaterial":{"comment":["--- Sets an entities' material","-- @server","-- @class function","-- @param material, string, New material name.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setMaterial ( material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if materialBlacklist[ material:lower() ] then SF.throw( \"This material has been blacklisted\", 2 ) end","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 3, material )","\telse","\t\tent:SetMaterial( material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' material ","name":"ents_methods:setMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' material","param":{"1":"material","2":"ply","ply":"Optional player arguement to set material of an entity only for that player","material":", string, New material name."}},"getMass":{"ret":"The numerical mass","comment":["--- Returns the mass of the entity","-- @shared","-- @return The numerical mass"],"code":["function ents_methods:getMass ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetMass()","end",""],"class":"function","summary":"\nReturns the mass of the entity ","classlib":"Entity","name":"ents_methods:getMass","server":true,"private":false,"client":true,"description":"\nReturns the mass of the entity","param":[]},"destroy":{"comment":["--- Breaks an entity"],"code":["function ents_methods:destroy ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Fire( \"break\", 1, 0 )","end",""],"class":"function","name":"ents_methods:destroy","summary":"\nBreaks an entity ","private":false,"classlib":"Entity","description":"\nBreaks an entity","param":[]},"setSolid":{"comment":["--- Sets the entity to be Solid or not.","-- For more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","-- @param solid Boolean, Should the entity be solid?"],"code":["function ents_methods:setSolid ( solid )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:SetNotSolid( not solid )","end",""],"class":"function","name":"ents_methods:setSolid","summary":"\nSets the entity to be Solid or not.","private":false,"classlib":"Entity","description":"\nSets the entity to be Solid or not. \nFor more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","param":{"1":"solid","solid":"Boolean, Should the entity be solid?"}},"getEyePos":{"ret":["Eye position of the entity","In case of a ragdoll, the position of the other eye"],"comment":["--- Gets the entity's eye position","-- @shared","-- @return Eye position of the entity","-- @return In case of a ragdoll, the position of the other eye"],"code":["function ents_methods:getEyePos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:EyePos() )","end",""],"class":"function","summary":"\nGets the entity's eye position ","classlib":"Entity","name":"ents_methods:getEyePos","server":true,"private":false,"client":true,"description":"\nGets the entity's eye position","param":[]},"getColor":{"ret":"Color","comment":["--- Gets the color of an entity","-- @shared","-- @return Color"],"code":["function ents_methods:getColor ()","\tlocal this = unwrap( self )","\treturn SF.Color.Wrap( this:GetColor() )","end",""],"class":"function","summary":"\nGets the color of an entity ","classlib":"Entity","name":"ents_methods:getColor","server":true,"private":false,"client":true,"description":"\nGets the color of an entity","param":[]},"entIndex":{"ret":"The numerical index of the entity","comment":["--- Returns the EntIndex of the entity","-- @shared","-- @return The numerical index of the entity"],"code":["function ents_methods:entIndex ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:EntIndex()","end",""],"class":"function","summary":"\nReturns the EntIndex of the entity ","classlib":"Entity","name":"ents_methods:entIndex","server":true,"private":false,"client":true,"description":"\nReturns the EntIndex of the entity","param":[]},"obbSize":{"ret":"The outer bounding box size","comment":["--- Returns the x, y, z size of the entity's outer bounding box (local to the entity)","-- @shared","-- @return The outer bounding box size"],"code":["function ents_methods:obbSize ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:OBBMaxs() - ent:OBBMins() )","end",""],"class":"function","summary":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity) ","classlib":"Entity","name":"ents_methods:obbSize","server":true,"private":false,"client":true,"description":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity)","param":[]},"getInertia":{"ret":"The principle moments of inertia as a vector","comment":["--- Returns the principle moments of inertia of the entity","-- @shared","-- @return The principle moments of inertia as a vector"],"code":["function ents_methods:getInertia ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetInertia()","end",""],"class":"function","summary":"\nReturns the principle moments of inertia of the entity ","classlib":"Entity","name":"ents_methods:getInertia","server":true,"private":false,"client":true,"description":"\nReturns the principle moments of inertia of the entity","param":[]},"enableGravity":{"comment":["--- Sets entity gravity","-- @param grav Bool should the entity respect gravity?"],"code":["function ents_methods:enableGravity ( grav )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableGravity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableGravity( grav and true or false )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:enableGravity","summary":"\nSets entity gravity ","private":false,"classlib":"Entity","description":"\nSets entity gravity","param":{"1":"grav","grav":"Bool should the entity respect gravity?"}},"isPlayer":{"ret":"True if player, false if not","comment":["--- Checks if an entity is a player.","-- @shared","-- @return True if player, false if not"],"code":["function ents_methods:isPlayer ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsPlayer()","end",""],"class":"function","summary":"\nChecks if an entity is a player.","classlib":"Entity","name":"ents_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a player.","param":[]},"enableDrag":{"comment":["--- Sets the entity drag state","-- @param drag Bool should the entity have air resistence?"],"code":["function ents_methods:enableDrag ( drag )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableDrag\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableDrag( drag and true or false )","end",""],"class":"function","name":"ents_methods:enableDrag","summary":"\nSets the entity drag state ","private":false,"classlib":"Entity","description":"\nSets the entity drag state","param":{"1":"drag","drag":"Bool should the entity have air resistence?"}},"getMaterial":{"ret":"Material","comment":["--- Gets an entities' material","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterial ()","    local ent = unwrap( self )","    return ent:GetMaterial() or \"\"","end",""],"class":"function","summary":"\nGets an entities' material ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' material","param":[]},"setPos":{"comment":["--- Sets the entitiy's position","-- @param vec New position"],"code":["function ents_methods:setPos ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setPos\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setPos( ent, vec )","end",""],"class":"function","name":"ents_methods:setPos","summary":"\nSets the entitiy's position ","private":false,"classlib":"Entity","description":"\nSets the entitiy's position","param":{"1":"vec","vec":"New position"}},"emitSound":{"comment":["--- Plays a sound on the entity","-- @param snd string Sound path","-- @param lvl number soundLevel=75","-- @param pitch pitchPercent=100","-- @param volume volume=1","-- @param channel channel=CHAN_AUTO"],"code":["function ents_methods:emitSound ( snd, lvl, pitch, volume, channel )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( snd, \"string\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.emitSound\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:EmitSound(snd, lvl, pitch, volume, channel)","end",""],"class":"function","name":"ents_methods:emitSound","summary":"\nPlays a sound on the entity ","private":false,"classlib":"Entity","description":"\nPlays a sound on the entity","param":{"1":"snd","2":"lvl","3":"pitch","4":"volume","5":"channel","pitch":"pitchPercent=100","snd":"string Sound path","lvl":"number soundLevel=75","channel":"channel=CHAN_AUTO","volume":"volume=1"}},"getPos":{"ret":"The position vector","comment":["--- Returns the position of the entity","-- @shared","-- @return The position vector"],"code":["function ents_methods:getPos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:GetPos() )","end",""],"class":"function","summary":"\nReturns the position of the entity ","classlib":"Entity","name":"ents_methods:getPos","server":true,"private":false,"client":true,"description":"\nReturns the position of the entity","param":[]},"getOwner":{"ret":"Owner","comment":["--- Gets the owner of the entity","-- @return Owner"],"code":["function ents_methods:getOwner ()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\treturn wrap( getOwner( ent ) )","end","","local function check ( v )","\treturn \t-math.huge < v.x and v.x < math.huge and","\t\t\t-math.huge < v.y and v.y < math.huge and","\t\t\t-math.huge < v.z and v.z < math.huge","end","","local function parent_check ( child, parent )","\twhile isValid( parent ) do","\t\tif child == parent then","\t\t\treturn false","\t\tend","\t\tparent = parent:GetParent()","\tend","\treturn true","end",""],"class":"function","name":"ents_methods:getOwner","summary":"\nGets the owner of the entity ","private":false,"classlib":"Entity","description":"\nGets the owner of the entity","param":[]},"isWeapon":{"ret":"True if weapon, false if not","comment":["--- Checks if an entity is a weapon.","-- @shared","-- @return True if weapon, false if not"],"code":["function ents_methods:isWeapon ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsWeapon()","end",""],"class":"function","summary":"\nChecks if an entity is a weapon.","classlib":"Entity","name":"ents_methods:isWeapon","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a weapon.","param":[]},"obbCenterW":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the world position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:LocalToWorld( ent:OBBCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's outer bounding box","param":[]},"setParent":{"comment":["--- Parents the entity to another entity","-- @param ent Entity to parent to"],"code":["function ents_methods:setParent ( ent )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( ent )","\tlocal this = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif not parent_check( this, ent ) then SF.throw( \"Cannot parent to self\", 2 ) end","","\tthis:SetParent( ent )","end",""],"class":"function","name":"ents_methods:setParent","summary":"\nParents the entity to another entity ","private":false,"classlib":"Entity","description":"\nParents the entity to another entity","param":{"1":"ent","ent":"Entity to parent to"}},"localToWorldAngles":{"ret":"data as world space angle","comment":["--- Converts an angle in entity local space to world space","-- @shared","-- @param data Local space angle","-- @return data as world space angle"],"code":["function ents_methods:localToWorldAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Angle\" ] )","\tlocal ent = unwrap( self )","\tlocal data = SF.UnwrapObject( data )","\t","\treturn SF.WrapObject( ent:LocalToWorldAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorldAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in entity local space to world space","param":{"1":"data","data":"Local space angle"}},"setMass":{"comment":["--- Sets the entity's mass","-- @param mass number mass"],"code":["function ents_methods:setMass ( mass )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetMass( math.Clamp(mass, 1, 50000) )","end",""],"class":"function","name":"ents_methods:setMass","summary":"\nSets the entity's mass ","private":false,"classlib":"Entity","description":"\nSets the entity's mass","param":{"1":"mass","mass":"number mass"}},"getMassCenter":{"ret":"The position vector of the mass center","comment":["--- Returns the local position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn SF.WrapObject( phys:GetMassCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's mass center","param":[]},"worldToLocal":{"ret":"data as local space vector","comment":["--- Converts a vector in world space to entity local space","-- @shared","-- @param data World space vector","-- @return data as local space vector"],"code":["function ents_methods:worldToLocal ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Vector\" ] )","\tlocal ent = unwrap( self )","\t","\treturn SF.WrapObject( ent:WorldToLocal( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocal","server":true,"private":false,"client":true,"description":"\nConverts a vector in world space to entity local space","param":{"1":"data","data":"World space vector"}},"getVelocity":{"ret":"The velocity vector","comment":["--- Returns the velocity of the entity","-- @shared","-- @return The velocity vector"],"code":["function ents_methods:getVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\treturn SF.WrapObject( ent:GetVelocity() )","end",""],"class":"function","summary":"\nReturns the velocity of the entity ","classlib":"Entity","name":"ents_methods:getVelocity","server":true,"private":false,"client":true,"description":"\nReturns the velocity of the entity","param":[]},"getMassCenterW":{"ret":"The position vector of the mass center","comment":["--- Returns the world position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn SF.WrapObject( ent:LocalToWorld( phys:GetMassCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's mass center","param":[]}}},{"comment":["--- Entities Library","-- @shared"],"functions":{"1":"entity","2":"owner","3":"player","4":"self","self":{"ret":"Starfall entity","comment":["--- Returns the entity representing a processor that this script is running on.","-- May be nil","-- @return Starfall entity"],"code":["function ents_lib.self ()","\tlocal ent = SF.instance.data.entity","\tif ent then ","\t\treturn SF.Entities.Wrap( ent )","\telse return nil end","end",""],"class":"function","name":"ents_lib.self","summary":"\nReturns the entity representing a processor that this script is running on.","private":false,"library":"entities","description":"\nReturns the entity representing a processor that this script is running on. \nMay be nil","param":[]},"owner":{"ret":"Owner entity","comment":["--- Returns whoever created the script","-- @return Owner entity"],"code":["function ents_lib.owner ()","\treturn SF.WrapObject( SF.instance.player )","end",""],"class":"function","name":"ents_lib.owner","summary":"\nReturns whoever created the script ","private":false,"library":"entities","description":"\nReturns whoever created the script","param":[]},"entity":{"ret":"entity","comment":["--- Returns the entity with index 'num'","-- @name ents_lib.entity","-- @class function","-- @param num Entity index","-- @return entity"],"code":["function ents_lib.entity ( num )","\tSF.CheckType( num, \"number\" )","\t","\treturn SF.WrapObject( Entity( num ) )","end","","-- ------------------------- Methods ------------------------- --",""],"class":"function","classForced":true,"name":"ents_lib.entity","summary":"\nReturns the entity with index 'num' ","private":false,"library":"entities","description":"\nReturns the entity with index 'num'","param":{"1":"num","num":"Entity index"}},"player":{"ret":"Either the owner (server) or the local player (client)","description":"\nSame as ents_lib.owner() on the server. On the client, returns the local player","code":["if SERVER then","\tents_lib.player = ents_lib.owner","else","\tfunction ents_lib.player ()","\t\treturn SF.WrapObject( LocalPlayer() )","\tend","\t","\tlocal renderProperties = {","\t\t[1] = function( ent ) --Color\t","\t\t\tent:SetColor( Color( net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ) ) )","\t\tend,","\t\t[2] = function( ent ) --Nodraw","\t\t\tent:SetNoDraw( net.ReadBit() == 1 )","\t\tend,","\t\t[3] = function( ent ) --Material","\t\t\tent:SetMaterial( net.ReadString() )","\t\tend,","\t\t[4] = function( ent ) --Submaterial","\t\t\tent:SetSubMaterial( net.ReadUInt( 16 ), net.ReadString() )","\t\tend,","\t\t[5] = function( ent ) --Bodygroup","\t\t\tent:SetBodyGroup( net.ReadUInt( 16 ), net.ReadUInt ( 16 ) )","\t\tend,","\t\t[6] = function( ent ) --Skin","\t\t\tent:SetSkin( net.ReadUInt( 16 ) )","\t\tend","\t}","\t","\t--Net function that allows the server to set the render properties of entities for specific players","\tnet.Receive( \"sf_setentityrenderproperty\", function()","\t\tlocal ent = net.ReadEntity()","\t\tif not ent:IsValid() then return end","\t\tlocal property = net.ReadUInt( 4 )","\t\tif not renderProperties[ property ] then return end","\t\t","\t\trenderProperties[ property ]( ent )","\tend)","end",""],"class":"function","classForced":true,"name":"ents_lib.player","summary":"\nSame as ents_lib.owner() on the server.","library":"entities","comment":["--- Same as ents_lib.owner() on the server. On the client, returns the local player","-- @name ents_lib.player","-- @class function","-- @return Either the owner (server) or the local player (client)"],"param":[]}},"class":"library","summary":"\nEntities Library ","code":["local ents_lib, _ = SF.Libraries.Register( \"entities\" )","","-- ------------------------- Internal functions ------------------------- --","","SF.Entities.Wrap = wrap","SF.Entities.Unwrap = unwrap","SF.Entities.Methods = ents_methods","SF.Entities.Metatable = ents_metamethods","SF.Entities.Library = ents_lib",""],"fields":[],"name":"entities","client":true,"description":"\nEntities Library","libtbl":"ents_lib","tables":[],"server":true},{"summary":"\nReturns true if valid and is not the world, false if not ","description":"\nReturns true if valid and is not the world, false if not","comment":["--- Returns true if valid and is not the world, false if not","-- @param entity Entity to check"],"code":["function SF.Entities.IsValid ( entity )","\treturn entity and entity:IsValid()","end","local isValid = SF.Entities.IsValid",""],"private":false,"class":"function","name":"SF.Entities.IsValid","param":{"1":"entity","entity":"Entity to check"}},{"ret":"The physobj, or nil if the entity isn't valid or isn't vphysics","comment":["--- Gets the physics object of the entity","-- @return The physobj, or nil if the entity isn't valid or isn't vphysics"],"code":["function SF.Entities.GetPhysObject ( ent )","\treturn ( isValid( ent ) and ent:GetMoveType() == MOVETYPE_VPHYSICS and ent:GetPhysicsObject() ) or nil","end","local getPhysObject = SF.Entities.GetPhysObject","","-- ------------------------- Library functions ------------------------- --",""],"class":"function","name":"SF.Entities.GetPhysObject","private":false,"summary":"\nGets the physics object of the entity ","description":"\nGets the physics object of the entity","param":["ent"]},{"ret":"Starfall entity","comment":["--- Returns the entity representing a processor that this script is running on.","-- May be nil","-- @return Starfall entity"],"code":["function ents_lib.self ()","\tlocal ent = SF.instance.data.entity","\tif ent then ","\t\treturn SF.Entities.Wrap( ent )","\telse return nil end","end",""],"class":"function","name":"ents_lib.self","summary":"\nReturns the entity representing a processor that this script is running on.","private":false,"library":"entities","description":"\nReturns the entity representing a processor that this script is running on. \nMay be nil","param":[]},{"ret":"Owner entity","comment":["--- Returns whoever created the script","-- @return Owner entity"],"code":["function ents_lib.owner ()","\treturn SF.WrapObject( SF.instance.player )","end",""],"class":"function","name":"ents_lib.owner","summary":"\nReturns whoever created the script ","private":false,"library":"entities","description":"\nReturns whoever created the script","param":[]},{"ret":"Either the owner (server) or the local player (client)","description":"\nSame as ents_lib.owner() on the server. On the client, returns the local player","code":["if SERVER then","\tents_lib.player = ents_lib.owner","else","\tfunction ents_lib.player ()","\t\treturn SF.WrapObject( LocalPlayer() )","\tend","\t","\tlocal renderProperties = {","\t\t[1] = function( ent ) --Color\t","\t\t\tent:SetColor( Color( net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ), net.ReadUInt( 8 ) ) )","\t\tend,","\t\t[2] = function( ent ) --Nodraw","\t\t\tent:SetNoDraw( net.ReadBit() == 1 )","\t\tend,","\t\t[3] = function( ent ) --Material","\t\t\tent:SetMaterial( net.ReadString() )","\t\tend,","\t\t[4] = function( ent ) --Submaterial","\t\t\tent:SetSubMaterial( net.ReadUInt( 16 ), net.ReadString() )","\t\tend,","\t\t[5] = function( ent ) --Bodygroup","\t\t\tent:SetBodyGroup( net.ReadUInt( 16 ), net.ReadUInt ( 16 ) )","\t\tend,","\t\t[6] = function( ent ) --Skin","\t\t\tent:SetSkin( net.ReadUInt( 16 ) )","\t\tend","\t}","\t","\t--Net function that allows the server to set the render properties of entities for specific players","\tnet.Receive( \"sf_setentityrenderproperty\", function()","\t\tlocal ent = net.ReadEntity()","\t\tif not ent:IsValid() then return end","\t\tlocal property = net.ReadUInt( 4 )","\t\tif not renderProperties[ property ] then return end","\t\t","\t\trenderProperties[ property ]( ent )","\tend)","end",""],"class":"function","classForced":true,"name":"ents_lib.player","summary":"\nSame as ents_lib.owner() on the server.","library":"entities","comment":["--- Same as ents_lib.owner() on the server. On the client, returns the local player","-- @name ents_lib.player","-- @class function","-- @return Either the owner (server) or the local player (client)"],"param":[]},{"ret":"entity","comment":["--- Returns the entity with index 'num'","-- @name ents_lib.entity","-- @class function","-- @param num Entity index","-- @return entity"],"code":["function ents_lib.entity ( num )","\tSF.CheckType( num, \"number\" )","\t","\treturn SF.WrapObject( Entity( num ) )","end","","-- ------------------------- Methods ------------------------- --",""],"class":"function","classForced":true,"name":"ents_lib.entity","summary":"\nReturns the entity with index 'num' ","private":false,"library":"entities","description":"\nReturns the entity with index 'num'","param":{"1":"num","num":"Entity index"}},{"comment":["--- To string","-- @shared"],"code":["function ents_metamethods:__tostring ()","\tlocal ent = unwrap( self )","\tif not ent then return \"(null entity)\"","\telse return tostring( ent ) end","end",""],"class":"function","summary":"\nTo string ","name":"ents_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},{"ret":"Color","comment":["--- Gets the color of an entity","-- @shared","-- @return Color"],"code":["function ents_methods:getColor ()","\tlocal this = unwrap( self )","\treturn SF.Color.Wrap( this:GetColor() )","end",""],"class":"function","summary":"\nGets the color of an entity ","classlib":"Entity","name":"ents_methods:getColor","server":true,"private":false,"client":true,"description":"\nGets the color of an entity","param":[]},{"ret":"True if valid, false if not","comment":["--- Checks if an entity is valid.","-- @shared","-- @return True if valid, false if not"],"code":["function ents_methods:isValid ()","\tSF.CheckType( self, ents_metamethods )","\treturn isValid( unwrap( self ) )","end",""],"class":"function","summary":"\nChecks if an entity is valid.","classlib":"Entity","name":"ents_methods:isValid","server":true,"private":false,"client":true,"description":"\nChecks if an entity is valid.","param":[]},{"ret":"True if player, false if not","comment":["--- Checks if an entity is a player.","-- @shared","-- @return True if player, false if not"],"code":["function ents_methods:isPlayer ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsPlayer()","end",""],"class":"function","summary":"\nChecks if an entity is a player.","classlib":"Entity","name":"ents_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a player.","param":[]},{"ret":"True if weapon, false if not","comment":["--- Checks if an entity is a weapon.","-- @shared","-- @return True if weapon, false if not"],"code":["function ents_methods:isWeapon ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsWeapon()","end",""],"class":"function","summary":"\nChecks if an entity is a weapon.","classlib":"Entity","name":"ents_methods:isWeapon","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a weapon.","param":[]},{"ret":"True if vehicle, false if not","comment":["--- Checks if an entity is a vehicle.","-- @shared","-- @return True if vehicle, false if not"],"code":["function ents_methods:isVehicle ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsVehicle()","end",""],"class":"function","summary":"\nChecks if an entity is a vehicle.","classlib":"Entity","name":"ents_methods:isVehicle","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a vehicle.","param":[]},{"ret":"True if npc, false if not","comment":["--- Checks if an entity is an npc.","-- @shared","-- @return True if npc, false if not"],"code":["function ents_methods:isNPC ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsNPC()","end",""],"class":"function","summary":"\nChecks if an entity is an npc.","classlib":"Entity","name":"ents_methods:isNPC","server":true,"private":false,"client":true,"description":"\nChecks if an entity is an npc.","param":[]},{"ret":"The numerical index of the entity","comment":["--- Returns the EntIndex of the entity","-- @shared","-- @return The numerical index of the entity"],"code":["function ents_methods:entIndex ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:EntIndex()","end",""],"class":"function","summary":"\nReturns the EntIndex of the entity ","classlib":"Entity","name":"ents_methods:entIndex","server":true,"private":false,"client":true,"description":"\nReturns the EntIndex of the entity","param":[]},{"ret":"The string class name","comment":["--- Returns the class of the entity","-- @shared","-- @return The string class name"],"code":["function ents_methods:getClass ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:GetClass()","end",""],"class":"function","summary":"\nReturns the class of the entity ","classlib":"Entity","name":"ents_methods:getClass","server":true,"private":false,"client":true,"description":"\nReturns the class of the entity","param":[]},{"ret":"The position vector","comment":["--- Returns the position of the entity","-- @shared","-- @return The position vector"],"code":["function ents_methods:getPos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:GetPos() )","end",""],"class":"function","summary":"\nReturns the position of the entity ","classlib":"Entity","name":"ents_methods:getPos","server":true,"private":false,"client":true,"description":"\nReturns the position of the entity","param":[]},{"ret":"The matrix","comment":["--- Returns the matrix of the entity","-- @shared","-- @param bone Bone of the entity (def 0)","-- @return The matrix"],"code":["function ents_methods:getMatrix (bone)","\tSF.CheckType( self, ents_metamethods )","\tbone = SF.CheckType( bone, \"number\", 0, 0 )","\t","\tlocal ent = unwrap( self )","\treturn vwrap( ent:GetBoneMatrix(bone) )","end",""],"class":"function","summary":"\nReturns the matrix of the entity ","classlib":"Entity","name":"ents_methods:getMatrix","server":true,"private":false,"client":true,"description":"\nReturns the matrix of the entity","param":{"1":"bone","bone":"Bone of the entity (def 0)"}},{"ret":"The outer bounding box size","comment":["--- Returns the x, y, z size of the entity's outer bounding box (local to the entity)","-- @shared","-- @return The outer bounding box size"],"code":["function ents_methods:obbSize ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:OBBMaxs() - ent:OBBMins() )","end",""],"class":"function","summary":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity) ","classlib":"Entity","name":"ents_methods:obbSize","server":true,"private":false,"client":true,"description":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity)","param":[]},{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the local position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:OBBCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's outer bounding box","param":[]},{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the world position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:LocalToWorld( ent:OBBCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's outer bounding box","param":[]},{"ret":"The position vector of the mass center","comment":["--- Returns the local position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn SF.WrapObject( phys:GetMassCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's mass center","param":[]},{"ret":"The position vector of the mass center","comment":["--- Returns the world position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn SF.WrapObject( ent:LocalToWorld( phys:GetMassCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's mass center","param":[]},{"ret":"The angle","comment":["--- Returns the angle of the entity","-- @shared","-- @return The angle"],"code":["function ents_methods:getAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:GetAngles() )","end",""],"class":"function","summary":"\nReturns the angle of the entity ","classlib":"Entity","name":"ents_methods:getAngles","server":true,"private":false,"client":true,"description":"\nReturns the angle of the entity","param":[]},{"ret":"The numerical mass","comment":["--- Returns the mass of the entity","-- @shared","-- @return The numerical mass"],"code":["function ents_methods:getMass ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetMass()","end",""],"class":"function","summary":"\nReturns the mass of the entity ","classlib":"Entity","name":"ents_methods:getMass","server":true,"private":false,"client":true,"description":"\nReturns the mass of the entity","param":[]},{"ret":"The principle moments of inertia as a vector","comment":["--- Returns the principle moments of inertia of the entity","-- @shared","-- @return The principle moments of inertia as a vector"],"code":["function ents_methods:getInertia ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetInertia()","end",""],"class":"function","summary":"\nReturns the principle moments of inertia of the entity ","classlib":"Entity","name":"ents_methods:getInertia","server":true,"private":false,"client":true,"description":"\nReturns the principle moments of inertia of the entity","param":[]},{"ret":"The velocity vector","comment":["--- Returns the velocity of the entity","-- @shared","-- @return The velocity vector"],"code":["function ents_methods:getVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\treturn SF.WrapObject( ent:GetVelocity() )","end",""],"class":"function","summary":"\nReturns the velocity of the entity ","classlib":"Entity","name":"ents_methods:getVelocity","server":true,"private":false,"client":true,"description":"\nReturns the velocity of the entity","param":[]},{"ret":"The angular velocity vector","comment":["--- Returns the angular velocity of the entity","-- @shared","-- @return The angular velocity vector"],"code":["function ents_methods:getAngleVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal phys = getPhysObject( unwrap( self ) )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end\t","\treturn SF.WrapObject( phys:GetAngleVelocity() )","end",""],"class":"function","summary":"\nReturns the angular velocity of the entity ","classlib":"Entity","name":"ents_methods:getAngleVelocity","server":true,"private":false,"client":true,"description":"\nReturns the angular velocity of the entity","param":[]},{"ret":"data as world space vector","comment":["--- Converts a vector in entity local space to world space","-- @shared","-- @param data Local space vector","-- @return data as world space vector"],"code":["function ents_methods:localToWorld( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Vector\" ] )","\tlocal ent = unwrap( self )","\t","\treturn SF.WrapObject( ent:LocalToWorld( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorld","server":true,"private":false,"client":true,"description":"\nConverts a vector in entity local space to world space","param":{"1":"data","data":"Local space vector"}},{"ret":"data as world space angle","comment":["--- Converts an angle in entity local space to world space","-- @shared","-- @param data Local space angle","-- @return data as world space angle"],"code":["function ents_methods:localToWorldAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Angle\" ] )","\tlocal ent = unwrap( self )","\tlocal data = SF.UnwrapObject( data )","\t","\treturn SF.WrapObject( ent:LocalToWorldAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorldAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in entity local space to world space","param":{"1":"data","data":"Local space angle"}},{"ret":"data as local space vector","comment":["--- Converts a vector in world space to entity local space","-- @shared","-- @param data World space vector","-- @return data as local space vector"],"code":["function ents_methods:worldToLocal ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Vector\" ] )","\tlocal ent = unwrap( self )","\t","\treturn SF.WrapObject( ent:WorldToLocal( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocal","server":true,"private":false,"client":true,"description":"\nConverts a vector in world space to entity local space","param":{"1":"data","data":"World space vector"}},{"ret":"data as local space angle","comment":["--- Converts an angle in world space to entity local space","-- @shared","-- @param data World space angle","-- @return data as local space angle"],"code":["function ents_methods:worldToLocalAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Angle\" ] )","\tlocal ent = unwrap( self )","\tlocal data = SF.UnwrapObject( data )","\t","\treturn SF.WrapObject( ent:WorldToLocalAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocalAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in world space to entity local space","param":{"1":"data","data":"World space angle"}},{"ret":"Model of the entity","comment":["--- Gets the model of an entity","-- @shared","-- @return Model of the entity"],"code":["function ents_methods:getModel ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:GetModel()","end",""],"class":"function","summary":"\nGets the model of an entity ","classlib":"Entity","name":"ents_methods:getModel","server":true,"private":false,"client":true,"description":"\nGets the model of an entity","param":[]},{"ret":"Angles of the entity's eyes","comment":["--- Gets the entitiy's eye angles","-- @shared","-- @return Angles of the entity's eyes"],"code":["function ents_methods:getEyeAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:EyeAngles() )","end",""],"class":"function","summary":"\nGets the entitiy's eye angles ","classlib":"Entity","name":"ents_methods:getEyeAngles","server":true,"private":false,"client":true,"description":"\nGets the entitiy's eye angles","param":[]},{"ret":["Eye position of the entity","In case of a ragdoll, the position of the other eye"],"comment":["--- Gets the entity's eye position","-- @shared","-- @return Eye position of the entity","-- @return In case of a ragdoll, the position of the other eye"],"code":["function ents_methods:getEyePos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:EyePos() )","end",""],"class":"function","summary":"\nGets the entity's eye position ","classlib":"Entity","name":"ents_methods:getEyePos","server":true,"private":false,"client":true,"description":"\nGets the entity's eye position","param":[]},{"ret":"Material","comment":["--- Gets an entities' material","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterial ()","    local ent = unwrap( self )","    return ent:GetMaterial() or \"\"","end",""],"class":"function","summary":"\nGets an entities' material ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' material","param":[]},{"ret":"Material","comment":["--- Gets an entities' submaterial","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getSubMaterial ( index )","    local ent = unwrap( self )","    return ent:GetSubMaterial( index ) or \"\"","end",""],"class":"function","summary":"\nGets an entities' submaterial ","classForced":true,"classlib":"Entity","name":"ents_methods:getSubMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' submaterial","param":["index"]},{"ret":"Material","comment":["--- Gets an entities' material list","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterials ()","    local ent = unwrap( self )","    return ent:GetMaterials() or {}","end",""],"class":"function","summary":"\nGets an entities' material list ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterials","server":true,"private":false,"client":true,"description":"\nGets an entities' material list","param":[]},{"comment":["--- Gets the entities up vector"],"code":["function ents_methods:getUp ()","\treturn SF.WrapObject( unwrap( self ):GetUp() )","end",""],"class":"function","name":"ents_methods:getUp","summary":"\nGets the entities up vector ","private":false,"classlib":"Entity","description":"\nGets the entities up vector","param":[]},{"comment":["--- Gets the entities right vector"],"code":["function ents_methods:getRight ()","\treturn SF.WrapObject( unwrap( self ):GetRight() )","end",""],"class":"function","name":"ents_methods:getRight","summary":"\nGets the entities right vector ","private":false,"classlib":"Entity","description":"\nGets the entities right vector","param":[]},{"comment":["--- Gets the entities forward vector"],"code":["function ents_methods:getForward ()","\treturn SF.WrapObject( unwrap( self ):GetForward() )","end"],"class":"function","name":"ents_methods:getForward","summary":"\nGets the entities forward vector ","private":false,"classlib":"Entity","description":"\nGets the entities forward vector","param":[]}],"tables":[],"description":"\n \nShared entity library functions \n","summary":"\n \nShared entity library functions \n "},"permissions/core.lua":{"libraries":[],"type":"file","name":"permissions/core.lua","functions":{"1":"P.check","2":"P.registerPrivilege","3":"P.registerProvider","P.check":{"ret":"boolean whether the action is permitted","comment":["--- Checks whether a player may perform an action.","-- @param principal the player performing the action to be authorized","-- @param target the object on which the action is being performed","-- @param key a string identifying the action being performed","-- @return boolean whether the action is permitted"],"code":["function P.check ( principal, target, key )","\tif not P.privileges[ key ] then print( \"WARNING: Starfall privilege \" .. key .. \" was not registered!\" ) end","","\t-- server owners can do whatever they want","\tif have_owner then","\t\t-- this can't be merged into the check loop below because that","\t\tfor _, provider in pairs( providers ) do","\t\t\tif provider:isOwner( principal ) then return true end","\t\tend","\tend","","\tlocal allow = true","\tfor _, provider in pairs( providers ) do","\t\tlocal result = provider:check( principal, target, key )","\t\tif DENY == result then","\t\t\t-- a single deny overrides any allows, just deny it now","\t\t\treturn false","\t\telseif ALLOW == result then","\t\t\t-- an allow can be overridden by a deny, so remember and keep going","\t\t\tallow = true","\t\tend","\t\t-- otherwise, this provider has no opinion, just go on to the next one","\tend","","\treturn allow","end",""],"class":"function","name":"P.check","private":false,"summary":"\nChecks whether a player may perform an action.","description":"\nChecks whether a player may perform an action.","param":{"1":"principal","2":"target","3":"key","target":"the object on which the action is being performed","principal":"the player performing the action to be authorized","key":"a string identifying the action being performed"}},"P.registerProvider":{"summary":"\nAdds a provider implementation to the set used by this library.","description":"\nAdds a provider implementation to the set used by this library. \nProviders must implement the {@link SF.Permissions.Provider} interface.","comment":["--- Adds a provider implementation to the set used by this library.","-- Providers must implement the {@link SF.Permissions.Provider} interface.","-- @param provider the provider to be registered"],"code":["function P.registerProvider ( provider )","\tif type( provider ) ~= \"table\"","\t\t\tor type( provider.supportsOwner ) ~= \"function\"","\t\t\tor type( provider.isOwner ) ~= \"function\"","\t\t\tor type( provider.check ) ~= \"function\" then","\t\terror( \"given object does not implement the provider interface\", 2 )","\tend","","\tproviders[ provider ] = provider","","\tif provider:supportsOwner() then","\t\thave_owner = true","\tend","end",""],"private":false,"class":"function","name":"P.registerProvider","param":{"1":"provider","provider":"the provider to be registered"}},"P.registerPrivilege":{"summary":"\nRegisters a privilege ","description":"\nRegisters a privilege","comment":["--- Registers a privilege","-- @param id unique identifier of the privilege being registered","-- @param name Human readable name of the privilege","-- @param description a short description of the privilege"],"code":["function P.registerPrivilege ( id, name, description )","\tP.privileges[ id ] = { name = name, description = description }","","\t-- The second check is not really necessary, but since it will resolve to false most of the time, we can save some time","\tif SERVER and #player.GetAll() > 0 then","\t\tnet.Start( \"starfall_permissions_privileges\" )","\t\t\tnet.WriteInt( #P.privileges, 16 )","","\t\t\tfor k, v in pairs( P.privileges ) do","\t\t\t\tnet.WriteString( k )","\t\t\t\tnet.WriteString( v.name )","\t\t\t\tnet.WriteString( v.description )","\t\t\tend","\t\tnet.Broadcast()","\tend","end","","-- Find and include all provider files.","do","\tlocal function IncludeClientFile ( file )","\t\tif SERVER then","\t\t\tAddCSLuaFile( file )","\t\telse","\t\t\tinclude( file )","\t\tend","\tend","","\tif SERVER then","\t\tinclude( \"starfall/permissions/provider.lua\" )","\tend","","\tIncludeClientFile( \"starfall/permissions/provider.lua\" )","","\tif SERVER then","\t\tlocal files = file.Find( \"starfall/permissions/providers_sv/*.lua\", \"LUA\" )","","\t\tfor _, file in pairs( files ) do","\t\t\tinclude( \"starfall/permissions/providers_sv/\" .. file )","\t\tend","\tend","","\tlocal sh_files = file.Find( \"starfall/permissions/providers_sh/*.lua\", \"LUA\" )","","\tfor _, file in pairs( sh_files ) do","\t\tif SERVER then","\t\t\tAddCSLuaFile( \"starfall/permissions/providers_sh/\" .. file )","\t\tend","\t\tinclude( \"starfall/permissions/providers_sh/\" .. file )","\tend","","\tlocal cl_files = file.Find( \"starfall/permissions/providers_cl/*.lua\", \"LUA\" )","","\tfor _, file in pairs( cl_files ) do","\t\tIncludeClientFile( \"starfall/permissions/providers_cl/\" .. file )","\tend","end","","-- Send serverside privileges to client","","if SERVER then","\tlocal function sendPrivileges ( ply )","\t\tnet.Start( \"starfall_permissions_privileges\" )","\t\t\tnet.WriteInt( #P.privileges, 16 )","","\t\t\tfor k, v in pairs( P.privileges ) do","\t\t\t\tnet.WriteString( k )","\t\t\t\tnet.WriteString( v.name )","\t\t\t\tnet.WriteString( v.description )","\t\t\tend","\t\tif ply then","\t\t\tnet.Send( ply )","\t\telse","\t\t\tnet.Broadcast()","\t\tend","\tend","","\tsendPrivileges()","","\thook.Add( \"PlayerInitialSpawn\", \"starfall_permissions\", sendPrivileges )","else","\tnet.Receive( \"starfall_permissions_privileges\", function ()","\t\tlocal len = net.ReadInt( 16 )","\t\tfor i = 1, len do","\t\t\tP.serverPrivileges[ net.ReadString() ] = { name = net.ReadString(), description = net.ReadString() }","\t\tend","\tend )","end"],"private":false,"class":"function","name":"P.registerPrivilege","param":{"1":"id","2":"name","3":"description","id":"unique identifier of the privilege being registered","name":"Human readable name of the privilege","description":"a short description of the privilege"}}},"doc":[{"comment":["---------------------------------------------------------------------","-- SF Permissions management","---------------------------------------------------------------------"],"code":["","-- TODO: Client version",""],"summary":"\n \nSF Permissions management \n ","description":"\n \nSF Permissions management \n","param":[]},{"description":"\nPermission format","code":["","SF.Permissions = {}","","local P = SF.Permissions","P.__index = P","","P.privileges = {}","","if SERVER then","\tutil.AddNetworkString( \"starfall_permissions_privileges\" )","else","\tP.serverPrivileges = {}","end","","do","\tlocal lockmeta = {","\t\t__newindex = function ( table, key, value )","\t\t\terror( \"attempting to assign to a read-only table\", 2 )","\t\tend,","\t\t__metatable = \"constant\"","\t}","","\tlocal result_vals = {","\t\tDENY\t= setmetatable( {}, lockmeta ),","\t\tALLOW\t= setmetatable( {}, lockmeta ),","\t\tNEUTRAL\t= setmetatable( {}, lockmeta )","\t}","","\tP.Result = setmetatable( {}, {","\t\t__index = result_vals,","\t\t__newindex = lockmeta.__newindex,","\t\t__metatable = \"enum\"","\t} )","end","","local DENY = P.Result.DENY","local ALLOW = P.Result.ALLOW","local NEUTRAL = P.Result.NEUTRAL","","local providers = {}","","local have_owner = false",""],"class":"table","classForced":true,"name":"Permission","summary":"\nPermission format ","field":{"1":"name","2":"desc","3":"level","4":"value","value":"Boolean. True to allow, false to deny","level":"The abusability of the permission. 0 = low (print to console), \n1 = normal (modify entities), 2 = high (run arbitrary lua)","name":"The name of the permission","desc":"The description of the permission."},"comment":["--- Permission format","-- @name Permission","-- @class table","-- @field name The name of the permission","-- @field desc The description of the permission.","-- @field level The abusability of the permission. 0 = low (print to console),","--                1 = normal (modify entities), 2 = high (run arbitrary lua)","-- @field value Boolean. True to allow, false to deny"],"param":[]},{"summary":"\nAdds a provider implementation to the set used by this library.","description":"\nAdds a provider implementation to the set used by this library. \nProviders must implement the {@link SF.Permissions.Provider} interface.","comment":["--- Adds a provider implementation to the set used by this library.","-- Providers must implement the {@link SF.Permissions.Provider} interface.","-- @param provider the provider to be registered"],"code":["function P.registerProvider ( provider )","\tif type( provider ) ~= \"table\"","\t\t\tor type( provider.supportsOwner ) ~= \"function\"","\t\t\tor type( provider.isOwner ) ~= \"function\"","\t\t\tor type( provider.check ) ~= \"function\" then","\t\terror( \"given object does not implement the provider interface\", 2 )","\tend","","\tproviders[ provider ] = provider","","\tif provider:supportsOwner() then","\t\thave_owner = true","\tend","end",""],"private":false,"class":"function","name":"P.registerProvider","param":{"1":"provider","provider":"the provider to be registered"}},{"ret":"boolean whether the action is permitted","comment":["--- Checks whether a player may perform an action.","-- @param principal the player performing the action to be authorized","-- @param target the object on which the action is being performed","-- @param key a string identifying the action being performed","-- @return boolean whether the action is permitted"],"code":["function P.check ( principal, target, key )","\tif not P.privileges[ key ] then print( \"WARNING: Starfall privilege \" .. key .. \" was not registered!\" ) end","","\t-- server owners can do whatever they want","\tif have_owner then","\t\t-- this can't be merged into the check loop below because that","\t\tfor _, provider in pairs( providers ) do","\t\t\tif provider:isOwner( principal ) then return true end","\t\tend","\tend","","\tlocal allow = true","\tfor _, provider in pairs( providers ) do","\t\tlocal result = provider:check( principal, target, key )","\t\tif DENY == result then","\t\t\t-- a single deny overrides any allows, just deny it now","\t\t\treturn false","\t\telseif ALLOW == result then","\t\t\t-- an allow can be overridden by a deny, so remember and keep going","\t\t\tallow = true","\t\tend","\t\t-- otherwise, this provider has no opinion, just go on to the next one","\tend","","\treturn allow","end",""],"class":"function","name":"P.check","private":false,"summary":"\nChecks whether a player may perform an action.","description":"\nChecks whether a player may perform an action.","param":{"1":"principal","2":"target","3":"key","target":"the object on which the action is being performed","principal":"the player performing the action to be authorized","key":"a string identifying the action being performed"}},{"summary":"\nRegisters a privilege ","description":"\nRegisters a privilege","comment":["--- Registers a privilege","-- @param id unique identifier of the privilege being registered","-- @param name Human readable name of the privilege","-- @param description a short description of the privilege"],"code":["function P.registerPrivilege ( id, name, description )","\tP.privileges[ id ] = { name = name, description = description }","","\t-- The second check is not really necessary, but since it will resolve to false most of the time, we can save some time","\tif SERVER and #player.GetAll() > 0 then","\t\tnet.Start( \"starfall_permissions_privileges\" )","\t\t\tnet.WriteInt( #P.privileges, 16 )","","\t\t\tfor k, v in pairs( P.privileges ) do","\t\t\t\tnet.WriteString( k )","\t\t\t\tnet.WriteString( v.name )","\t\t\t\tnet.WriteString( v.description )","\t\t\tend","\t\tnet.Broadcast()","\tend","end","","-- Find and include all provider files.","do","\tlocal function IncludeClientFile ( file )","\t\tif SERVER then","\t\t\tAddCSLuaFile( file )","\t\telse","\t\t\tinclude( file )","\t\tend","\tend","","\tif SERVER then","\t\tinclude( \"starfall/permissions/provider.lua\" )","\tend","","\tIncludeClientFile( \"starfall/permissions/provider.lua\" )","","\tif SERVER then","\t\tlocal files = file.Find( \"starfall/permissions/providers_sv/*.lua\", \"LUA\" )","","\t\tfor _, file in pairs( files ) do","\t\t\tinclude( \"starfall/permissions/providers_sv/\" .. file )","\t\tend","\tend","","\tlocal sh_files = file.Find( \"starfall/permissions/providers_sh/*.lua\", \"LUA\" )","","\tfor _, file in pairs( sh_files ) do","\t\tif SERVER then","\t\t\tAddCSLuaFile( \"starfall/permissions/providers_sh/\" .. file )","\t\tend","\t\tinclude( \"starfall/permissions/providers_sh/\" .. file )","\tend","","\tlocal cl_files = file.Find( \"starfall/permissions/providers_cl/*.lua\", \"LUA\" )","","\tfor _, file in pairs( cl_files ) do","\t\tIncludeClientFile( \"starfall/permissions/providers_cl/\" .. file )","\tend","end","","-- Send serverside privileges to client","","if SERVER then","\tlocal function sendPrivileges ( ply )","\t\tnet.Start( \"starfall_permissions_privileges\" )","\t\t\tnet.WriteInt( #P.privileges, 16 )","","\t\t\tfor k, v in pairs( P.privileges ) do","\t\t\t\tnet.WriteString( k )","\t\t\t\tnet.WriteString( v.name )","\t\t\t\tnet.WriteString( v.description )","\t\t\tend","\t\tif ply then","\t\t\tnet.Send( ply )","\t\telse","\t\t\tnet.Broadcast()","\t\tend","\tend","","\tsendPrivileges()","","\thook.Add( \"PlayerInitialSpawn\", \"starfall_permissions\", sendPrivileges )","else","\tnet.Receive( \"starfall_permissions_privileges\", function ()","\t\tlocal len = net.ReadInt( 16 )","\t\tfor i = 1, len do","\t\t\tP.serverPrivileges[ net.ReadString() ] = { name = net.ReadString(), description = net.ReadString() }","\t\tend","\tend )","end"],"private":false,"class":"function","name":"P.registerPrivilege","param":{"1":"id","2":"name","3":"description","id":"unique identifier of the privilege being registered","name":"Human readable name of the privilege","description":"a short description of the privilege"}}],"tables":{"1":"Permission","Permission":{"description":"\nPermission format","code":["","SF.Permissions = {}","","local P = SF.Permissions","P.__index = P","","P.privileges = {}","","if SERVER then","\tutil.AddNetworkString( \"starfall_permissions_privileges\" )","else","\tP.serverPrivileges = {}","end","","do","\tlocal lockmeta = {","\t\t__newindex = function ( table, key, value )","\t\t\terror( \"attempting to assign to a read-only table\", 2 )","\t\tend,","\t\t__metatable = \"constant\"","\t}","","\tlocal result_vals = {","\t\tDENY\t= setmetatable( {}, lockmeta ),","\t\tALLOW\t= setmetatable( {}, lockmeta ),","\t\tNEUTRAL\t= setmetatable( {}, lockmeta )","\t}","","\tP.Result = setmetatable( {}, {","\t\t__index = result_vals,","\t\t__newindex = lockmeta.__newindex,","\t\t__metatable = \"enum\"","\t} )","end","","local DENY = P.Result.DENY","local ALLOW = P.Result.ALLOW","local NEUTRAL = P.Result.NEUTRAL","","local providers = {}","","local have_owner = false",""],"class":"table","classForced":true,"name":"Permission","summary":"\nPermission format ","field":{"1":"name","2":"desc","3":"level","4":"value","value":"Boolean. True to allow, false to deny","level":"The abusability of the permission. 0 = low (print to console), \n1 = normal (modify entities), 2 = high (run arbitrary lua)","name":"The name of the permission","desc":"The description of the permission."},"comment":["--- Permission format","-- @name Permission","-- @class table","-- @field name The name of the permission","-- @field desc The description of the permission.","-- @field level The abusability of the permission. 0 = low (print to console),","--                1 = normal (modify entities), 2 = high (run arbitrary lua)","-- @field value Boolean. True to allow, false to deny"],"param":[]}},"description":"\n \nSF Permissions management \n","summary":"\n \nSF Permissions management \n "},"database.lua":{"type":"file","name":"database.lua","functions":[],"doc":[],"libraries":[],"tables":[]},"libs_sh/physenv.lua":{"libraries":{"1":"physenv","physenv":{"comment":["--- Physenv functions","-- @shared"],"functions":{"1":"getAirDensity","2":"getGravity","3":"getPerformanceSettings","getAirDensity":{"ret":"number Air Density","comment":["--- Gets the air density.","-- @return number Air Density"],"code":["function physenv_lib.getAirDensity ()","\treturn physenv.GetAirDensity()","end",""],"class":"function","name":"physenv_lib.getAirDensity","summary":"\nGets the air density.","private":false,"library":"physenv","description":"\nGets the air density.","param":[]},"getPerformanceSettings":{"ret":"table Performance Settings Table.","comment":["--- Gets the performance settings.</br>","-- See <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","-- @return table Performance Settings Table."],"code":["function physenv_lib.getPerformanceSettings ()","\treturn SF.Sanitize( table.Copy( physenv.GetPerformanceSettings() ) )","end"],"class":"function","name":"physenv_lib.getPerformanceSettings","summary":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","private":false,"library":"physenv","description":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","param":[]},"getGravity":{"ret":"Vector Gravity Vector ( eg Vector(0,0,-600) )","comment":["--- Gets the gravity vector","-- @return Vector Gravity Vector ( eg Vector(0,0,-600) )"],"code":["function physenv_lib.getGravity ()","\treturn SF.WrapObject( physenv.GetGravity() )","end",""],"class":"function","name":"physenv_lib.getGravity","summary":"\nGets the gravity vector ","private":false,"library":"physenv","description":"\nGets the gravity vector","param":[]}},"class":"library","summary":"\nPhysenv functions ","code":["local physenv_lib, _ = SF.Libraries.Register( \"physenv\" )",""],"fields":[],"name":"physenv","client":true,"description":"\nPhysenv functions","libtbl":"physenv_lib","tables":[],"server":true}},"type":"file","name":"libs_sh/physenv.lua","functions":{"1":"physenv_lib.getAirDensity","2":"physenv_lib.getGravity","3":"physenv_lib.getPerformanceSettings","physenv_lib.getGravity":{"ret":"Vector Gravity Vector ( eg Vector(0,0,-600) )","comment":["--- Gets the gravity vector","-- @return Vector Gravity Vector ( eg Vector(0,0,-600) )"],"code":["function physenv_lib.getGravity ()","\treturn SF.WrapObject( physenv.GetGravity() )","end",""],"class":"function","name":"physenv_lib.getGravity","summary":"\nGets the gravity vector ","private":false,"library":"physenv","description":"\nGets the gravity vector","param":[]},"physenv_lib.getPerformanceSettings":{"ret":"table Performance Settings Table.","comment":["--- Gets the performance settings.</br>","-- See <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","-- @return table Performance Settings Table."],"code":["function physenv_lib.getPerformanceSettings ()","\treturn SF.Sanitize( table.Copy( physenv.GetPerformanceSettings() ) )","end"],"class":"function","name":"physenv_lib.getPerformanceSettings","summary":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","private":false,"library":"physenv","description":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","param":[]},"physenv_lib.getAirDensity":{"ret":"number Air Density","comment":["--- Gets the air density.","-- @return number Air Density"],"code":["function physenv_lib.getAirDensity ()","\treturn physenv.GetAirDensity()","end",""],"class":"function","name":"physenv_lib.getAirDensity","summary":"\nGets the air density.","private":false,"library":"physenv","description":"\nGets the air density.","param":[]}},"doc":[{"summary":"\n \nPhysenv library \n ","description":"\n \nPhysenv library \n","comment":["-------------------------------------------------------------------------------","-- Physenv library","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- Physenv functions","-- @shared"],"functions":{"1":"getAirDensity","2":"getGravity","3":"getPerformanceSettings","getAirDensity":{"ret":"number Air Density","comment":["--- Gets the air density.","-- @return number Air Density"],"code":["function physenv_lib.getAirDensity ()","\treturn physenv.GetAirDensity()","end",""],"class":"function","name":"physenv_lib.getAirDensity","summary":"\nGets the air density.","private":false,"library":"physenv","description":"\nGets the air density.","param":[]},"getPerformanceSettings":{"ret":"table Performance Settings Table.","comment":["--- Gets the performance settings.</br>","-- See <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","-- @return table Performance Settings Table."],"code":["function physenv_lib.getPerformanceSettings ()","\treturn SF.Sanitize( table.Copy( physenv.GetPerformanceSettings() ) )","end"],"class":"function","name":"physenv_lib.getPerformanceSettings","summary":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","private":false,"library":"physenv","description":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","param":[]},"getGravity":{"ret":"Vector Gravity Vector ( eg Vector(0,0,-600) )","comment":["--- Gets the gravity vector","-- @return Vector Gravity Vector ( eg Vector(0,0,-600) )"],"code":["function physenv_lib.getGravity ()","\treturn SF.WrapObject( physenv.GetGravity() )","end",""],"class":"function","name":"physenv_lib.getGravity","summary":"\nGets the gravity vector ","private":false,"library":"physenv","description":"\nGets the gravity vector","param":[]}},"class":"library","summary":"\nPhysenv functions ","code":["local physenv_lib, _ = SF.Libraries.Register( \"physenv\" )",""],"fields":[],"name":"physenv","client":true,"description":"\nPhysenv functions","libtbl":"physenv_lib","tables":[],"server":true},{"ret":"number Air Density","comment":["--- Gets the air density.","-- @return number Air Density"],"code":["function physenv_lib.getAirDensity ()","\treturn physenv.GetAirDensity()","end",""],"class":"function","name":"physenv_lib.getAirDensity","summary":"\nGets the air density.","private":false,"library":"physenv","description":"\nGets the air density.","param":[]},{"ret":"Vector Gravity Vector ( eg Vector(0,0,-600) )","comment":["--- Gets the gravity vector","-- @return Vector Gravity Vector ( eg Vector(0,0,-600) )"],"code":["function physenv_lib.getGravity ()","\treturn SF.WrapObject( physenv.GetGravity() )","end",""],"class":"function","name":"physenv_lib.getGravity","summary":"\nGets the gravity vector ","private":false,"library":"physenv","description":"\nGets the gravity vector","param":[]},{"ret":"table Performance Settings Table.","comment":["--- Gets the performance settings.</br>","-- See <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","-- @return table Performance Settings Table."],"code":["function physenv_lib.getPerformanceSettings ()","\treturn SF.Sanitize( table.Copy( physenv.GetPerformanceSettings() ) )","end"],"class":"function","name":"physenv_lib.getPerformanceSettings","summary":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","private":false,"library":"physenv","description":"\nGets the performance settings.</br> \nSee <a href=\"http://wiki.garrysmod.com/page/Structures/PhysEnvPerformanceSettings\">PhysEnvPerformance Settings Table Structure</a> for table structure.","param":[]}],"tables":[],"description":"\n \nPhysenv library \n","summary":"\n \nPhysenv library \n "},"libs_cl/bass.lua":{"libraries":{"1":"bass","bass":{"comment":["--- Bass library.","-- @client"],"functions":{"1":"loadFile","2":"loadURL","loadURL":{"comment":["--- Loads a sound object from a url","-- @param path url to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadURL ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tlocal instance = SF.instance","\t","\tsound.PlayURL( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadURL","summary":"\nLoads a sound object from a url ","private":false,"library":"bass","description":"\nLoads a sound object from a url","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"url to the sound file.","callback":"to run when the sound is loaded"}},"loadFile":{"comment":["--- Loads a sound object from a file","-- @param path Filepath to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadFile ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","\t","\tlocal instance = SF.instance","","\tsound.PlayFile( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadFile","summary":"\nLoads a sound object from a file ","private":false,"library":"bass","description":"\nLoads a sound object from a file","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"Filepath to the sound file.","callback":"to run when the sound is loaded"}}},"class":"library","summary":"\nBass library.","fields":[],"name":"bass","client":true,"description":"\nBass library.","libtbl":"bass_library","tables":[],"code":["local bass_library, _ = SF.Libraries.Register( \"bass\" )","","SF.Bass.Wrap = wrap","SF.Bass.Unwrap = unwrap","SF.Bass.Methods = bass_methods","SF.Bass.Metatable = bass_metamethods","","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.bass = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.bass.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tif s:IsValid() then","\t\t\ts:Stop()","\t\tend","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""]}},"type":"file","name":"libs_cl/bass.lua","functions":{"1":"bass_library.loadFile","2":"bass_library.loadURL","3":"bass_methods:getLength","4":"bass_methods:play","5":"bass_methods:setFade","6":"bass_methods:setLooping","7":"bass_methods:setPitch","8":"bass_methods:setPos","9":"bass_methods:setVolume","10":"bass_methods:stop","bass_library.loadURL":{"comment":["--- Loads a sound object from a url","-- @param path url to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadURL ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tlocal instance = SF.instance","\t","\tsound.PlayURL( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadURL","summary":"\nLoads a sound object from a url ","private":false,"library":"bass","description":"\nLoads a sound object from a url","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"url to the sound file.","callback":"to run when the sound is loaded"}},"bass_methods:setFade":{"comment":["--- Sets the fade distance of the sound","-- @param min The channel's volume is at maximum when the listener is within this distance","-- @param max The channel's volume stops decreasing when the listener is beyond this distance."],"code":["function bass_methods:setFade ( min, max )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:Set3DFadeDistance( math.Clamp(min,50,1000), math.Clamp(max,10000,200000) )","\tend","end",""],"class":"function","name":"bass_methods:setFade","summary":"\nSets the fade distance of the sound ","private":false,"classlib":"Bass","description":"\nSets the fade distance of the sound","param":{"1":"min","2":"max","min":"The channel's volume is at maximum when the listener is within this distance","max":"The channel's volume stops decreasing when the listener is beyond this distance."}},"bass_methods:stop":{"comment":["--- Stops playing the sound."],"code":["function bass_methods:stop ( )","\tlocal uw =  unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Stop()","\tend","end",""],"class":"function","name":"bass_methods:stop","summary":"\nStops playing the sound.","private":false,"classlib":"Bass","description":"\nStops playing the sound.","param":[]},"bass_library.loadFile":{"comment":["--- Loads a sound object from a file","-- @param path Filepath to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadFile ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","\t","\tlocal instance = SF.instance","","\tsound.PlayFile( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadFile","summary":"\nLoads a sound object from a file ","private":false,"library":"bass","description":"\nLoads a sound object from a file","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"Filepath to the sound file.","callback":"to run when the sound is loaded"}},"bass_methods:getLength":{"ret":"Length in seconds of the sound","comment":["--- Gets the length of a sound","-- @return Length in seconds of the sound"],"code":["function bass_methods:getLength ()","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetLength()","\tend","end","",""],"class":"function","name":"bass_methods:getLength","summary":"\nGets the length of a sound ","private":false,"classlib":"Bass","description":"\nGets the length of a sound","param":[]},"bass_methods:setLooping":{"comment":["--- Sets if the sound should loop or not.","-- @param loop Boolean if the sound should loop or not."],"code":["function bass_methods:setLooping ( loop )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:EnableLooping( loop )","\tend","end",""],"class":"function","name":"bass_methods:setLooping","summary":"\nSets if the sound should loop or not.","private":false,"classlib":"Bass","description":"\nSets if the sound should loop or not.","param":{"1":"loop","loop":"Boolean if the sound should loop or not."}},"bass_methods:setPos":{"comment":["--- Sets the position of the sound","-- @param pos Where to position the sound"],"code":["function bass_methods:setPos ( pos )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPos( SF.UnwrapObject( pos ) )","\tend","end",""],"class":"function","name":"bass_methods:setPos","summary":"\nSets the position of the sound ","private":false,"classlib":"Bass","description":"\nSets the position of the sound","param":{"1":"pos","pos":"Where to position the sound"}},"bass_methods:setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 3."],"code":["function bass_methods:setPitch ( pitch )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pitch, \"number\" )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPlaybackRate( math.Clamp( pitch, 0, 3 ) )","\tend","end",""],"class":"function","name":"bass_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Bass","description":"\nSets the pitch of the sound.","param":{"1":"pitch","pitch":"Pitch to set to, between 0 and 3."}},"bass_methods:setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1."],"code":["function bass_methods:setVolume ( vol )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( vol, \"number\" )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetVolume( math.Clamp( vol, 0, 1 ) )","\tend","end",""],"class":"function","name":"bass_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Bass","description":"\nSets the volume of the sound.","param":{"1":"vol","vol":"Volume to set to, between 0 and 1."}},"bass_methods:play":{"comment":["--- Starts to play the sound."],"code":["function bass_methods:play ()","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Play()","\tend","end",""],"class":"function","name":"bass_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Bass","description":"\nStarts to play the sound.","param":[]}},"doc":[{"comment":["--- Bass type","-- @client"],"code":["local bass_methods, bass_metamethods = SF.Typedef( \"Bass\" )","local wrap, unwrap = SF.CreateWrapper( bass_metamethods, true, false, debug.getregistry().IGModAudioChannel )",""],"typtbl":"bass_methods","fields":[],"name":"Bass","summary":"\nBass type ","description":"\nBass type","client":true,"class":"class","methods":{"1":"getLength","2":"play","3":"setFade","4":"setLooping","5":"setPitch","6":"setPos","7":"setVolume","8":"stop","getLength":{"ret":"Length in seconds of the sound","comment":["--- Gets the length of a sound","-- @return Length in seconds of the sound"],"code":["function bass_methods:getLength ()","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetLength()","\tend","end","",""],"class":"function","name":"bass_methods:getLength","summary":"\nGets the length of a sound ","private":false,"classlib":"Bass","description":"\nGets the length of a sound","param":[]},"setPos":{"comment":["--- Sets the position of the sound","-- @param pos Where to position the sound"],"code":["function bass_methods:setPos ( pos )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPos( SF.UnwrapObject( pos ) )","\tend","end",""],"class":"function","name":"bass_methods:setPos","summary":"\nSets the position of the sound ","private":false,"classlib":"Bass","description":"\nSets the position of the sound","param":{"1":"pos","pos":"Where to position the sound"}},"stop":{"comment":["--- Stops playing the sound."],"code":["function bass_methods:stop ( )","\tlocal uw =  unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Stop()","\tend","end",""],"class":"function","name":"bass_methods:stop","summary":"\nStops playing the sound.","private":false,"classlib":"Bass","description":"\nStops playing the sound.","param":[]},"setLooping":{"comment":["--- Sets if the sound should loop or not.","-- @param loop Boolean if the sound should loop or not."],"code":["function bass_methods:setLooping ( loop )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:EnableLooping( loop )","\tend","end",""],"class":"function","name":"bass_methods:setLooping","summary":"\nSets if the sound should loop or not.","private":false,"classlib":"Bass","description":"\nSets if the sound should loop or not.","param":{"1":"loop","loop":"Boolean if the sound should loop or not."}},"setFade":{"comment":["--- Sets the fade distance of the sound","-- @param min The channel's volume is at maximum when the listener is within this distance","-- @param max The channel's volume stops decreasing when the listener is beyond this distance."],"code":["function bass_methods:setFade ( min, max )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:Set3DFadeDistance( math.Clamp(min,50,1000), math.Clamp(max,10000,200000) )","\tend","end",""],"class":"function","name":"bass_methods:setFade","summary":"\nSets the fade distance of the sound ","private":false,"classlib":"Bass","description":"\nSets the fade distance of the sound","param":{"1":"min","2":"max","min":"The channel's volume is at maximum when the listener is within this distance","max":"The channel's volume stops decreasing when the listener is beyond this distance."}},"setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1."],"code":["function bass_methods:setVolume ( vol )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( vol, \"number\" )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetVolume( math.Clamp( vol, 0, 1 ) )","\tend","end",""],"class":"function","name":"bass_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Bass","description":"\nSets the volume of the sound.","param":{"1":"vol","vol":"Volume to set to, between 0 and 1."}},"play":{"comment":["--- Starts to play the sound."],"code":["function bass_methods:play ()","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Play()","\tend","end",""],"class":"function","name":"bass_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Bass","description":"\nStarts to play the sound.","param":[]},"setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 3."],"code":["function bass_methods:setPitch ( pitch )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pitch, \"number\" )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPlaybackRate( math.Clamp( pitch, 0, 3 ) )","\tend","end",""],"class":"function","name":"bass_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Bass","description":"\nSets the pitch of the sound.","param":{"1":"pitch","pitch":"Pitch to set to, between 0 and 3."}}}},{"comment":["--- Bass library.","-- @client"],"functions":{"1":"loadFile","2":"loadURL","loadURL":{"comment":["--- Loads a sound object from a url","-- @param path url to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadURL ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tlocal instance = SF.instance","\t","\tsound.PlayURL( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadURL","summary":"\nLoads a sound object from a url ","private":false,"library":"bass","description":"\nLoads a sound object from a url","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"url to the sound file.","callback":"to run when the sound is loaded"}},"loadFile":{"comment":["--- Loads a sound object from a file","-- @param path Filepath to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadFile ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","\t","\tlocal instance = SF.instance","","\tsound.PlayFile( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadFile","summary":"\nLoads a sound object from a file ","private":false,"library":"bass","description":"\nLoads a sound object from a file","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"Filepath to the sound file.","callback":"to run when the sound is loaded"}}},"class":"library","summary":"\nBass library.","fields":[],"name":"bass","client":true,"description":"\nBass library.","libtbl":"bass_library","tables":[],"code":["local bass_library, _ = SF.Libraries.Register( \"bass\" )","","SF.Bass.Wrap = wrap","SF.Bass.Unwrap = unwrap","SF.Bass.Methods = bass_methods","SF.Bass.Metatable = bass_metamethods","","","-- Register functions to be called when the chip is initialised and deinitialised","SF.Libraries.AddHook( \"initialize\", function ( inst )","\tinst.data.bass = {","\t\tsounds = {}","\t}","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( inst )","\tlocal sounds = inst.data.bass.sounds","\tlocal s = next( sounds )","\twhile s do","\t\tif s:IsValid() then","\t\t\ts:Stop()","\t\tend","\t\tsounds[ s ] = nil","\t\ts = next( sounds )","\tend","end )",""]},{"comment":["--- Loads a sound object from a file","-- @param path Filepath to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadFile ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tif path:match( '[\"?]' ) then","\t\tSF.throw( \"Invalid sound path: \" .. path, 2 )","\tend","\t","\tlocal instance = SF.instance","","\tsound.PlayFile( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadFile","summary":"\nLoads a sound object from a file ","private":false,"library":"bass","description":"\nLoads a sound object from a file","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"Filepath to the sound file.","callback":"to run when the sound is loaded"}},{"comment":["--- Loads a sound object from a url","-- @param path url to the sound file.","-- @param flags that will control the sound","-- @param callback to run when the sound is loaded"],"code":["function bass_library.loadURL ( path, flags, callback )","\tif not SF.Permissions.check( SF.instance.player, { ent, path }, \"sound.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( flags, \"string\" )","\tSF.CheckType( callback, \"function\" )","","\tlocal instance = SF.instance","\t","\tsound.PlayURL( path, flags, function(snd, er, name)","\t\tif er then","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, nil, er, name )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\telse","\t\t\tinstance.data.bass.sounds[ snd ] = true","\t\t\tlocal ok, msg, traceback = instance:runFunction( callback, wrap( snd ), 0, \"\" )","\t\t\tif not ok then","\t\t\t\tinstance:Error( msg, traceback )","\t\t\tend","\t\tend","\tend)","end",""],"class":"function","name":"bass_library.loadURL","summary":"\nLoads a sound object from a url ","private":false,"library":"bass","description":"\nLoads a sound object from a url","param":{"1":"path","2":"flags","3":"callback","flags":"that will control the sound","path":"url to the sound file.","callback":"to run when the sound is loaded"}},{"summary":"\n ","description":"\n","comment":["--------------------------------------------------"],"code":[""]},{"comment":["--- Starts to play the sound."],"code":["function bass_methods:play ()","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Play()","\tend","end",""],"class":"function","name":"bass_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Bass","description":"\nStarts to play the sound.","param":[]},{"comment":["--- Stops playing the sound."],"code":["function bass_methods:stop ( )","\tlocal uw =  unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Stop()","\tend","end",""],"class":"function","name":"bass_methods:stop","summary":"\nStops playing the sound.","private":false,"classlib":"Bass","description":"\nStops playing the sound.","param":[]},{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1."],"code":["function bass_methods:setVolume ( vol )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( vol, \"number\" )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetVolume( math.Clamp( vol, 0, 1 ) )","\tend","end",""],"class":"function","name":"bass_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Bass","description":"\nSets the volume of the sound.","param":{"1":"vol","vol":"Volume to set to, between 0 and 1."}},{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 3."],"code":["function bass_methods:setPitch ( pitch )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pitch, \"number\" )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPlaybackRate( math.Clamp( pitch, 0, 3 ) )","\tend","end",""],"class":"function","name":"bass_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Bass","description":"\nSets the pitch of the sound.","param":{"1":"pitch","pitch":"Pitch to set to, between 0 and 3."}},{"comment":["--- Sets the position of the sound","-- @param pos Where to position the sound"],"code":["function bass_methods:setPos ( pos )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPos( SF.UnwrapObject( pos ) )","\tend","end",""],"class":"function","name":"bass_methods:setPos","summary":"\nSets the position of the sound ","private":false,"classlib":"Bass","description":"\nSets the position of the sound","param":{"1":"pos","pos":"Where to position the sound"}},{"comment":["--- Sets the fade distance of the sound","-- @param min The channel's volume is at maximum when the listener is within this distance","-- @param max The channel's volume stops decreasing when the listener is beyond this distance."],"code":["function bass_methods:setFade ( min, max )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:Set3DFadeDistance( math.Clamp(min,50,1000), math.Clamp(max,10000,200000) )","\tend","end",""],"class":"function","name":"bass_methods:setFade","summary":"\nSets the fade distance of the sound ","private":false,"classlib":"Bass","description":"\nSets the fade distance of the sound","param":{"1":"min","2":"max","min":"The channel's volume is at maximum when the listener is within this distance","max":"The channel's volume stops decreasing when the listener is beyond this distance."}},{"comment":["--- Sets if the sound should loop or not.","-- @param loop Boolean if the sound should loop or not."],"code":["function bass_methods:setLooping ( loop )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:EnableLooping( loop )","\tend","end",""],"class":"function","name":"bass_methods:setLooping","summary":"\nSets if the sound should loop or not.","private":false,"classlib":"Bass","description":"\nSets if the sound should loop or not.","param":{"1":"loop","loop":"Boolean if the sound should loop or not."}},{"ret":"Length in seconds of the sound","comment":["--- Gets the length of a sound","-- @return Length in seconds of the sound"],"code":["function bass_methods:getLength ()","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetLength()","\tend","end","",""],"class":"function","name":"bass_methods:getLength","summary":"\nGets the length of a sound ","private":false,"classlib":"Bass","description":"\nGets the length of a sound","param":[]}],"tables":[],"description":"\nBass type","summary":"\nBass type "},"libs_sh/vehicles.lua":{"libraries":[],"type":"file","name":"libs_sh/vehicles.lua","functions":{"1":"vehicle_metamethods:__tostring","2":"vehicle_methods:ejectDriver","3":"vehicle_methods:getDriver","4":"vehicle_methods:getPassenger","vehicle_methods:ejectDriver":{"comment":["\t--- Ejects the driver of the vehicle","\t-- @server"],"code":["\tfunction vehicle_methods:ejectDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\tlocal driver = ent:GetDriver()","\t\tif driver:IsValid() then","\t\t\tdriver:ExitVehicle()","\t\tend","\tend",""],"class":"function","summary":"\nEjects the driver of the vehicle ","name":"vehicle_methods:ejectDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nEjects the driver of the vehicle","param":[]},"vehicle_metamethods:__tostring":{"comment":["--- To string","-- @shared"],"code":["function vehicle_metamethods:__tostring()","\tlocal ent = SF.Entities.Unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","if SERVER then"],"class":"function","summary":"\nTo string ","name":"vehicle_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},"vehicle_methods:getDriver":{"ret":"Driver of vehicle","comment":["\t--- Returns the driver of the vehicle","\t-- @server","\t-- @return Driver of vehicle"],"code":["\tfunction vehicle_methods:getDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\treturn SF.WrapObject( ent:GetDriver() )","\tend","\t"],"class":"function","summary":"\nReturns the driver of the vehicle ","name":"vehicle_methods:getDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns the driver of the vehicle","param":[]},"vehicle_methods:getPassenger":{"ret":"amount of ammo","comment":["\t--- Returns a passenger of a vehicle","\t-- @server","\t-- @param passenger The number of the passenger to get","\t-- @return amount of ammo"],"code":["\tfunction vehicle_methods:getPassenger ( n )","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tSF.CheckType( n, \"number\" )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn SF.WrapObject( ent:GetPassenger( n ) )","\tend","","end"],"class":"function","summary":"\nReturns a passenger of a vehicle ","name":"vehicle_methods:getPassenger","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns a passenger of a vehicle","param":{"1":"n","2":"passenger","passenger":"The number of the passenger to get"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Vehicle functions.","-------------------------------------------------------------------------------"],"code":["","SF.Vehicles = {}"],"summary":"\n \nVehicle functions.","description":"\n \nVehicle functions. \n","param":[]},{"comment":["--- Vehicle type"],"code":["local vehicle_methods, vehicle_metamethods = SF.Typedef(\"Vehicle\", SF.Entities.Metatable)","","SF.Vehicles.Methods = vehicle_methods","SF.Vehicles.Metatable = vehicle_metamethods",""],"typtbl":"vehicle_methods","fields":[],"name":"Vehicle","summary":"\nVehicle type ","description":"\nVehicle type","class":"class","methods":{"1":"ejectDriver","2":"getDriver","3":"getPassenger","getDriver":{"ret":"Driver of vehicle","comment":["\t--- Returns the driver of the vehicle","\t-- @server","\t-- @return Driver of vehicle"],"code":["\tfunction vehicle_methods:getDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\treturn SF.WrapObject( ent:GetDriver() )","\tend","\t"],"class":"function","summary":"\nReturns the driver of the vehicle ","name":"vehicle_methods:getDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns the driver of the vehicle","param":[]},"ejectDriver":{"comment":["\t--- Ejects the driver of the vehicle","\t-- @server"],"code":["\tfunction vehicle_methods:ejectDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\tlocal driver = ent:GetDriver()","\t\tif driver:IsValid() then","\t\t\tdriver:ExitVehicle()","\t\tend","\tend",""],"class":"function","summary":"\nEjects the driver of the vehicle ","name":"vehicle_methods:ejectDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nEjects the driver of the vehicle","param":[]},"getPassenger":{"ret":"amount of ammo","comment":["\t--- Returns a passenger of a vehicle","\t-- @server","\t-- @param passenger The number of the passenger to get","\t-- @return amount of ammo"],"code":["\tfunction vehicle_methods:getPassenger ( n )","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tSF.CheckType( n, \"number\" )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn SF.WrapObject( ent:GetPassenger( n ) )","\tend","","end"],"class":"function","summary":"\nReturns a passenger of a vehicle ","name":"vehicle_methods:getPassenger","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns a passenger of a vehicle","param":{"1":"n","2":"passenger","passenger":"The number of the passenger to get"}}}},{"comment":["--- Custom wrapper/unwrapper is necessary for vehicle objects","-- wrapper"],"code":["local dsetmeta = debug.setmetatable","local function wrap( object )","\tobject = SF.Entities.Wrap( object )","\tdsetmeta( object, vehicle_metamethods )","\treturn object","end","","SF.AddObjectWrapper( debug.getregistry().Vehicle, vehicle_metamethods, wrap )","SF.AddObjectUnwrapper( vehicle_metamethods, SF.Entities.Unwrap )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"vehicle.eject\", \"Vehicle eject\", \"Removes a driver from vehicle\" )","end",""],"summary":"\nCustom wrapper/unwrapper is necessary for vehicle objects \nwrapper ","description":"\nCustom wrapper/unwrapper is necessary for vehicle objects \nwrapper","param":[]},{"comment":["--- To string","-- @shared"],"code":["function vehicle_metamethods:__tostring()","\tlocal ent = SF.Entities.Unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","if SERVER then"],"class":"function","summary":"\nTo string ","name":"vehicle_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},{"ret":"Driver of vehicle","comment":["\t--- Returns the driver of the vehicle","\t-- @server","\t-- @return Driver of vehicle"],"code":["\tfunction vehicle_methods:getDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\treturn SF.WrapObject( ent:GetDriver() )","\tend","\t"],"class":"function","summary":"\nReturns the driver of the vehicle ","name":"vehicle_methods:getDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns the driver of the vehicle","param":[]},{"comment":["\t--- Ejects the driver of the vehicle","\t-- @server"],"code":["\tfunction vehicle_methods:ejectDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\tlocal driver = ent:GetDriver()","\t\tif driver:IsValid() then","\t\t\tdriver:ExitVehicle()","\t\tend","\tend",""],"class":"function","summary":"\nEjects the driver of the vehicle ","name":"vehicle_methods:ejectDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nEjects the driver of the vehicle","param":[]},{"ret":"amount of ammo","comment":["\t--- Returns a passenger of a vehicle","\t-- @server","\t-- @param passenger The number of the passenger to get","\t-- @return amount of ammo"],"code":["\tfunction vehicle_methods:getPassenger ( n )","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tSF.CheckType( n, \"number\" )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn SF.WrapObject( ent:GetPassenger( n ) )","\tend","","end"],"class":"function","summary":"\nReturns a passenger of a vehicle ","name":"vehicle_methods:getPassenger","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns a passenger of a vehicle","param":{"1":"n","2":"passenger","passenger":"The number of the passenger to get"}}],"tables":[],"description":"\n \nVehicle functions. \n","summary":"\n \nVehicle functions."},"compiler.lua":{"libraries":[],"type":"file","name":"compiler.lua","functions":{"1":"SF.Compiler.Compile","SF.Compiler.Compile":{"ret":["True if no errors, false if errors occured.","The compiled instance, or the error message."],"comment":["--- Preprocesses and Compiles code and returns an Instance","-- @param code Either a string of code, or a {path=source} table","-- @param context The context to use in the resulting Instance","-- @param mainfile If code is a table, this specifies the first file to parse.","-- @param player The \"owner\" of the instance","-- @param data The table to set instance.data to. Default is a new table.","-- @param dontpreprocess Set to true to skip preprocessing","-- @return True if no errors, false if errors occured.","-- @return The compiled instance, or the error message."],"code":["function SF.Compiler.Compile(code, context, mainfile, player, data, dontpreprocess)","\tif type(code) == \"string\" then","\t\tmainfile = mainfile or \"generic\"","\t\tcode = {mainfile=code}","\tend","\t","\tlocal instance = setmetatable({},SF.Instance)","\t","\tdata = data or {}","\t","\tinstance.player = player","\tinstance.env = setmetatable({},context.env)","\tinstance.env._G = instance.env","\tinstance.data = data","\tinstance.ppdata = {}","\tinstance.ops = 0","\tinstance.hooks = {}","\tinstance.scripts = {}","\tinstance.source = code","\tinstance.initialized = false","\tinstance.context = context","\tinstance.mainfile = mainfile","","\t-- Add local libraries","\tfor k, v in pairs( context.libs ) do instance.env[ k ] = setmetatable( {}, v ) end","","\t-- Call onLoad functions","\tfor k, v in pairs( context.env.__index ) do","\t\tif type( v ) == \"table\" then","\t\t\tlocal meta = debug.getmetatable( v )","\t\t\tif meta.onLoad then meta.onLoad( instance ) end","\t\tend","\tend","\tfor k, v in pairs( context.libs ) do","\t\tif type( v ) == \"table\" then","\t\t\tif v.onLoad then v.onLoad( instance ) end","\t\tend","\tend","\t","\tfor filename, source in pairs(code) do","\t\tif not dontpreprocess then","\t\t\tSF.Preprocessor.ParseDirectives(filename,source,context.directives,instance.ppdata)","\t\tend","\t\t","\t\tif string.match(source, \"^[%s\\n]*$\") then","\t\t\t-- Lua doesn't have empty statements, so an empty file gives a syntax error","\t\t\tinstance.scripts[filename] = function() end","\t\telse","\t\t\tlocal func = CompileString(source, \"SF:\"..filename, false)","\t\t\tif type(func) == \"string\" then","\t\t\t\treturn false, func","\t\t\tend","\t\t\tdebug.setfenv(func, instance.env)","\t\t\tinstance.scripts[filename] = func","\t\tend","\tend","\t","\treturn true, instance","end"],"class":"function","name":"SF.Compiler.Compile","private":false,"summary":"\nPreprocesses and Compiles code and returns an Instance ","description":"\nPreprocesses and Compiles code and returns an Instance","param":{"1":"code","2":"context","3":"mainfile","4":"player","5":"data","6":"dontpreprocess","mainfile":"If code is a table, this specifies the first file to parse.","player":"The \"owner\" of the instance","code":"Either a string of code, or a {path=source} table","dontpreprocess":"Set to true to skip preprocessing","context":"The context to use in the resulting Instance","data":"The table to set instance.data to. Default is a new table."}}},"doc":[{"comment":["---------------------------------------------------------------------","-- SF Compiler.","-- Compiles code into an uninitialized Instance.","---------------------------------------------------------------------"],"code":["","SF.Compiler = {}",""],"summary":"\n \nSF Compiler.","description":"\n \nSF Compiler. \nCompiles code into an uninitialized Instance. \n","param":[]},{"ret":["True if no errors, false if errors occured.","The compiled instance, or the error message."],"comment":["--- Preprocesses and Compiles code and returns an Instance","-- @param code Either a string of code, or a {path=source} table","-- @param context The context to use in the resulting Instance","-- @param mainfile If code is a table, this specifies the first file to parse.","-- @param player The \"owner\" of the instance","-- @param data The table to set instance.data to. Default is a new table.","-- @param dontpreprocess Set to true to skip preprocessing","-- @return True if no errors, false if errors occured.","-- @return The compiled instance, or the error message."],"code":["function SF.Compiler.Compile(code, context, mainfile, player, data, dontpreprocess)","\tif type(code) == \"string\" then","\t\tmainfile = mainfile or \"generic\"","\t\tcode = {mainfile=code}","\tend","\t","\tlocal instance = setmetatable({},SF.Instance)","\t","\tdata = data or {}","\t","\tinstance.player = player","\tinstance.env = setmetatable({},context.env)","\tinstance.env._G = instance.env","\tinstance.data = data","\tinstance.ppdata = {}","\tinstance.ops = 0","\tinstance.hooks = {}","\tinstance.scripts = {}","\tinstance.source = code","\tinstance.initialized = false","\tinstance.context = context","\tinstance.mainfile = mainfile","","\t-- Add local libraries","\tfor k, v in pairs( context.libs ) do instance.env[ k ] = setmetatable( {}, v ) end","","\t-- Call onLoad functions","\tfor k, v in pairs( context.env.__index ) do","\t\tif type( v ) == \"table\" then","\t\t\tlocal meta = debug.getmetatable( v )","\t\t\tif meta.onLoad then meta.onLoad( instance ) end","\t\tend","\tend","\tfor k, v in pairs( context.libs ) do","\t\tif type( v ) == \"table\" then","\t\t\tif v.onLoad then v.onLoad( instance ) end","\t\tend","\tend","\t","\tfor filename, source in pairs(code) do","\t\tif not dontpreprocess then","\t\t\tSF.Preprocessor.ParseDirectives(filename,source,context.directives,instance.ppdata)","\t\tend","\t\t","\t\tif string.match(source, \"^[%s\\n]*$\") then","\t\t\t-- Lua doesn't have empty statements, so an empty file gives a syntax error","\t\t\tinstance.scripts[filename] = function() end","\t\telse","\t\t\tlocal func = CompileString(source, \"SF:\"..filename, false)","\t\t\tif type(func) == \"string\" then","\t\t\t\treturn false, func","\t\t\tend","\t\t\tdebug.setfenv(func, instance.env)","\t\t\tinstance.scripts[filename] = func","\t\tend","\tend","\t","\treturn true, instance","end"],"class":"function","name":"SF.Compiler.Compile","private":false,"summary":"\nPreprocesses and Compiles code and returns an Instance ","description":"\nPreprocesses and Compiles code and returns an Instance","param":{"1":"code","2":"context","3":"mainfile","4":"player","5":"data","6":"dontpreprocess","mainfile":"If code is a table, this specifies the first file to parse.","player":"The \"owner\" of the instance","code":"Either a string of code, or a {path=source} table","dontpreprocess":"Set to true to skip preprocessing","context":"The context to use in the resulting Instance","data":"The table to set instance.data to. Default is a new table."}}],"tables":[],"description":"\n \nSF Compiler. \nCompiles code into an uninitialized Instance. \n","summary":"\n \nSF Compiler."},"permissions/providers_sv/default.lua":{"libraries":[],"type":"file","name":"permissions/providers_sv/default.lua","functions":[],"doc":[{"comment":["--- Default starfall permission provider"],"code":["","-- start the provider table and set it to inherit from the default provider","local P = {}","P.__index = SF.Permissions.Provider","setmetatable( P, P )","","-- localize the result set","local ALLOW = SF.Permissions.Result.ALLOW","local DENY = SF.Permissions.Result.DENY","local NEUTRAL = SF.Permissions.Result.NEUTRAL","","local ES = SF.DB.escape;","","local function getUsergroupID ( ply )","\tif ply:IsSuperAdmin() then","\t\treturn 2","\telseif ply:IsAdmin() then","\t\treturn 1","\tend","\treturn 0","end","","local function getUsergroupName ( ply )","\tif ply:IsSuperAdmin() then","\t\treturn \"superadmin\"","\telseif ply:IsAdmin() then","\t\treturn \"admin\"","\tend","\treturn \"user\"","end","","function P:check ( principal, target, key )","\tlocal result = SF.DB.query( [[","\t\tSELECT grant","\t\tFROM starfall_perms_grants","\t\tWHERE\trole = ]] .. ES( getUsergroupID( principal ) ) .. [[","\t\t\tAND key = \"]] .. ES( key ) .. [[\"]]","\t)","","\tif result == false then","\t\terror( \"error in default provider \" .. sql.LastError() )","\tend","","\tif result and #result >= 1 then","\t\tlocal row = result[ 1 ]","\t\tlocal grant = row[ 'grant' ]","","\t\tif \"0\" == grant then","\t\t\treturn NEUTRAL","\t\telseif \"1\" == grant then","\t\t\treturn ALLOW","\t\telseif \"2\" == grant then","\t\t\treturn DENY","\t\tend","\telse","\t\treturn NEUTRAL","\tend","end","","-- register the provider","SF.Permissions.registerProvider( P )"],"summary":"\nDefault starfall permission provider ","description":"\nDefault starfall permission provider","param":[]}],"tables":[],"description":"\nDefault starfall permission provider","summary":"\nDefault starfall permission provider "},"libs_sv/holograms.lua":{"libraries":{"1":"holograms","holograms":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Holograms\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"hologramsLeft","4":"spawnRate","spawnRate":{"ret":"Number of holograms per second the user can spawn","comment":["--- Returns how many holograms per second the user can spawn","-- @server","-- @return Number of holograms per second the user can spawn"],"code":["function holograms_library.spawnRate ()","","\treturn SF.Holograms.burstrate:GetFloat() or 4","\t","end"],"class":"function","summary":"\nReturns how many holograms per second the user can spawn ","name":"holograms_library.spawnRate","library":"holograms","private":false,"server":true,"description":"\nReturns how many holograms per second the user can spawn","param":[]},"canSpawn":{"ret":"True if user can spawn holograms, False if not.","comment":["--- Checks if a user can spawn anymore holograms.","-- @server","-- @return True if user can spawn holograms, False if not."],"code":["function holograms_library.canSpawn()","    local instance = SF.instance","    return not personal_max_reached( instance ) and not max_reached() and can_spawn( instance, true )","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore holograms.","name":"holograms_library.canSpawn","library":"holograms","private":false,"server":true,"description":"\nChecks if a user can spawn anymore holograms.","param":[]},"create":{"ret":"The hologram object","comment":["--- Creates a hologram.","-- @server","-- @return The hologram object"],"code":["function holograms_library.create ( pos, ang, model, scale )","    SF.CheckType( pos, SF.Types[ \"Vector\" ] )","    SF.CheckType( ang, SF.Types[ \"Angle\" ] )","    SF.CheckType( model, \"string\" )","    if scale then","\t\tSF.CheckType( scale, SF.Types[ \"Vector\" ] )","\t\tscale = vunwrap( scale )","\tend","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","    local instance = SF.instance","    if not can_spawn( instance ) then return SF.throw( \"Can't spawn holograms that often\", 2 )","    elseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn holograms, maximum personal limit of \" .. SF.Holograms.personalquota:GetInt() .. \" has been reached\", 2 )","    elseif max_reached() then return SF.throw( \"Can't spawn holograms, maximum limit of \" .. SF.Holograms.defaultquota:GetInt() .. \" has been reached\", 2 ) end","","    local holodata = instance.data.holograms","    local holoent = ents.Create( \"starfall_hologram\" )","    if holoent and holoent:IsValid() then","        holoent:SetPos( pos )","        holoent:SetAngles( ang )","        holoent:SetModel( model )","        holoent:CallOnRemove( \"starfall_hologram_delete\", hologramOnDestroy, holodata, instance.player )","        holoent:Spawn()","","        if scale then","            holoent:SetScale( scale )","        end","","        local holo = SF.Entities.Wrap( holoent )","","        holodata.holos[ holo ] = holo","","        plyCount[ instance.player ] = plyCount[ instance.player ] + 1","        return holo","        -- TODO: Need to fire a umsg here to assign clientside ownership(?)","    end","end",""],"class":"function","summary":"\nCreates a hologram.","name":"holograms_library.create","library":"holograms","private":false,"server":true,"description":"\nCreates a hologram.","param":["pos","ang","model","scale"]},"hologramsLeft":{"ret":"number of holograms able to be spawned","comment":["--- Checks how many holograms can be spawned","-- @server","-- @return number of holograms able to be spawned"],"code":["function holograms_library.hologramsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\treturn math.min( SF.Holograms.personalquota:GetInt() - plyCount[instance.player], instance.data.holos.burst )","\t","end",""],"class":"function","summary":"\nChecks how many holograms can be spawned ","name":"holograms_library.hologramsLeft","library":"holograms","private":false,"server":true,"description":"\nChecks how many holograms can be spawned","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","code":["local holograms_library, holograms_library_metamethods = SF.Libraries.Register(\"holograms\")",""],"fields":[],"name":"holograms","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","libtbl":"holograms_library","tables":[],"server":true}},"type":"file","name":"libs_sv/holograms.lua","functions":{"1":"can_spawn","2":"hologram_methods:getAnimationLength","3":"hologram_methods:getAnimationNumber","4":"hologram_methods:getFlexes","5":"hologram_methods:getPose","6":"hologram_methods:remove","7":"hologram_methods:setAng","8":"hologram_methods:setAngVel","9":"hologram_methods:setAnimation","10":"hologram_methods:setClip","11":"hologram_methods:setFlexScale","12":"hologram_methods:setFlexWeight","13":"hologram_methods:setModel","14":"hologram_methods:setParent","15":"hologram_methods:setPos","16":"hologram_methods:setPose","17":"hologram_methods:setScale","18":"hologram_methods:setVel","19":"hologram_methods:suppressEngineLighting","20":"holograms_library.canSpawn","21":"holograms_library.create","22":"holograms_library.hologramsLeft","23":"holograms_library.spawnRate","24":"max_reached","25":"personal_max_reached","hologram_methods:getFlexes":{"comment":["--- Returns a table of flexname -> flexid pairs for use in flex functions.","-- These IDs become invalid when the hologram's model changes."],"code":["function hologram_methods:getFlexes()","\tSF.CheckType(self, hologram_metamethods)","\tlocal holoent = SF.Entities.Unwrap(self)","\tlocal flexes = {}","\tfor i=0,holoent:GetFlexNum()-1 do","\t\tflexes[holoent:GetFlexName(i)] = i","\tend","\treturn flexes","end",""],"class":"function","name":"hologram_methods:getFlexes","summary":"\nReturns a table of flexname -> flexid pairs for use in flex functions.","private":false,"classlib":"Hologram","description":"\nReturns a table of flexname -> flexid pairs for use in flex functions. \nThese IDs become invalid when the hologram's model changes.","param":[]},"hologram_methods:setModel":{"comment":["--- Sets the model of a hologram","-- @server","-- @class function","-- @param model string model path"],"code":["function hologram_methods:setModel ( model )","    SF.CheckType( model, \"string\" )","","    local this = SF.Entities.Unwrap( self )","    if IsValid( this ) then","        this:SetModel( model )","    end","end",""],"class":"function","classForced":true,"summary":"\nSets the model of a hologram ","name":"hologram_methods:setModel","classlib":"Hologram","private":false,"server":true,"description":"\nSets the model of a hologram","param":{"1":"model","model":"string model path"}},"hologram_methods:setFlexWeight":{"comment":["--- Sets the weight (value) of a flex."],"code":["function hologram_methods:setFlexWeight(flexid, weight)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(flexid, \"number\")","\tSF.CheckType(weight, \"number\")","\tflexid = math.floor(flexid)","\tif flexid < 0 or flexid >= holoent:GetFlexNum() then","\t\tSF.throw( \"Invalid flex: \"..flexid, 2 )","\tend","\tlocal holoent = SF.Entities.Unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexWeight(self, weight)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexWeight","summary":"\nSets the weight (value) of a flex.","private":false,"classlib":"Hologram","description":"\nSets the weight (value) of a flex.","param":["flexid","weight"]},"hologram_methods:setClip":{"comment":["--- Updates a clip plane"],"code":["function hologram_methods:setClip ( index, enabled, origin, normal, islocal )","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(index, \"number\")","\tSF.CheckType(enabled, \"boolean\")","\tSF.CheckType(origin, SF.Types[ \"Vector\" ] )","\tSF.CheckType(normal, SF.Types[ \"Vector\" ] )","\tSF.CheckType(islocal, \"boolean\")","","\tlocal origin, normal = vunwrap( origin ), vunwrap( normal )","","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then","\t\tholo:UpdateClip( index, enabled, origin, normal, islocal )","\tend","end",""],"class":"function","name":"hologram_methods:setClip","summary":"\nUpdates a clip plane ","private":false,"classlib":"Hologram","description":"\nUpdates a clip plane","param":["index","enabled","origin","normal","islocal"]},"hologram_methods:setPose":{"comment":["--- Set the pose value of an animation. Turret/Head angles for example.","-- @server","-- @class function","-- @param pose Name of the pose parameter","-- @param value Value to set it to."],"code":["function hologram_methods:setPose( pose, value )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\tHolo:SetPoseParameter( pose, value )","end",""],"class":"function","classForced":true,"summary":"\nSet the pose value of an animation.","name":"hologram_methods:setPose","classlib":"Hologram","private":false,"server":true,"description":"\nSet the pose value of an animation. Turret/Head angles for example.","param":{"1":"pose","2":"value","pose":"Name of the pose parameter","value":"Value to set it to."}},"hologram_methods:suppressEngineLighting":{"comment":["--- Suppress Engine Lighting of a hologram. Disabled by default.","-- @server","-- @class function","-- @param suppress Boolean to represent if shading should be set or not."],"code":["function hologram_methods:suppressEngineLighting ( suppress )","    SF.CheckType( suppress, \"boolean\" )","","    local this = SF.Entities.Unwrap( self )","    if IsValid( this ) then","        this:SetNetworkedBool( \"suppressEngineLighting\", suppress )","    end","end",""],"class":"function","classForced":true,"summary":"\nSuppress Engine Lighting of a hologram.","name":"hologram_methods:suppressEngineLighting","classlib":"Hologram","private":false,"server":true,"description":"\nSuppress Engine Lighting of a hologram. Disabled by default.","param":{"1":"suppress","suppress":"Boolean to represent if shading should be set or not."}},"hologram_methods:setAnimation":{"comment":["--- Animates a hologram","-- @server","-- @class function","-- @param animation number or string name","-- @param frame The starting frame number","-- @param rate Frame speed. (1 is normal)"],"code":["function hologram_methods:setAnimation(animation, frame, rate)","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","","\tif type(animation)==\"string\" then","\t\tanimation = Holo:LookupSequence(animation)","\tend","\t","\tframe = frame or 0","\trate = rate or 1","\t","\tif not Holo.Animated then","\t\t-- This must be run once on entities that will be animated","\t\tHolo.Animated = true","\t\tHolo.AutomaticFrameAdvance = true","\t\t","\t\tlocal OldThink = Holo.Think","\t\tfunction Holo:Think()","\t\t\tOldThink(self)","\t\t\tself:NextThink( CurTime() )","\t\t\treturn true","\t\tend","\tend","\tHolo:ResetSequence(animation)","\tHolo:SetCycle(frame)","\tHolo:SetPlaybackRate(rate)","end",""],"class":"function","classForced":true,"summary":"\nAnimates a hologram ","name":"hologram_methods:setAnimation","classlib":"Hologram","private":false,"server":true,"description":"\nAnimates a hologram","param":{"1":"animation","2":"frame","3":"rate","frame":"The starting frame number","rate":"Frame speed. (1 is normal)","animation":"number or string name"}},"holograms_library.canSpawn":{"ret":"True if user can spawn holograms, False if not.","comment":["--- Checks if a user can spawn anymore holograms.","-- @server","-- @return True if user can spawn holograms, False if not."],"code":["function holograms_library.canSpawn()","    local instance = SF.instance","    return not personal_max_reached( instance ) and not max_reached() and can_spawn( instance, true )","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore holograms.","name":"holograms_library.canSpawn","library":"holograms","private":false,"server":true,"description":"\nChecks if a user can spawn anymore holograms.","param":[]},"hologram_methods:remove":{"comment":["--- Deletes the hologram","-- @server"],"code":["function hologram_methods:remove()","    SF.CheckType(self, hologram_metamethods)","    local holoent = SF.Entities.Unwrap(self)","    if IsValid(holoent) then","        holoent:Remove()","    end","end",""],"class":"function","summary":"\nDeletes the hologram ","name":"hologram_methods:remove","classlib":"Hologram","private":false,"server":true,"description":"\nDeletes the hologram","param":[]},"hologram_methods:setVel":{"comment":["--- Sets the hologram linear velocity","-- @param vel New velocity"],"code":["function hologram_methods:setVel ( vel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","\tlocal vel = vunwrap( vel )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetLocalVelocity( vel ) end","end",""],"class":"function","name":"hologram_methods:setVel","summary":"\nSets the hologram linear velocity ","private":false,"classlib":"Hologram","description":"\nSets the hologram linear velocity","param":{"1":"vel","vel":"New velocity"}},"hologram_methods:setFlexScale":{"comment":["--- Sets the scale of all flexes of a hologram"],"code":["function hologram_methods:setFlexScale(scale)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(scale, \"number\")","\tlocal holoent = SF.Entities.Unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexScale(scale)","\tend","end","",""],"class":"function","name":"hologram_methods:setFlexScale","summary":"\nSets the scale of all flexes of a hologram ","private":false,"classlib":"Hologram","description":"\nSets the scale of all flexes of a hologram","param":["scale"]},"holograms_library.spawnRate":{"ret":"Number of holograms per second the user can spawn","comment":["--- Returns how many holograms per second the user can spawn","-- @server","-- @return Number of holograms per second the user can spawn"],"code":["function holograms_library.spawnRate ()","","\treturn SF.Holograms.burstrate:GetFloat() or 4","\t","end"],"class":"function","summary":"\nReturns how many holograms per second the user can spawn ","name":"holograms_library.spawnRate","library":"holograms","private":false,"server":true,"description":"\nReturns how many holograms per second the user can spawn","param":[]},"hologram_methods:setAng":{"comment":["--- Sets the hologram angle","-- @param ang New angles"],"code":["function hologram_methods:setAng ( ang )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetAngles( SF.Angles.Unwrap( ang ) ) end","end",""],"class":"function","name":"hologram_methods:setAng","summary":"\nSets the hologram angle ","private":false,"classlib":"Hologram","description":"\nSets the hologram angle","param":{"1":"ang","ang":"New angles"}},"hologram_methods:setScale":{"comment":["--- Sets the hologram scale","-- @param scale New scale"],"code":["function hologram_methods:setScale ( scale )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( scale, SF.Types[ \"Vector\" ] )","\tlocal scale = vunwrap( scale )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then","\t\tholo:SetScale( scale )","\tend","end",""],"class":"function","name":"hologram_methods:setScale","summary":"\nSets the hologram scale ","private":false,"classlib":"Hologram","description":"\nSets the hologram scale","param":{"1":"scale","scale":"New scale"}},"max_reached":{"ret":"True/False depending on if limit has been reached for SF Holograms","comment":["--- Checks if the total number of holograms across all instances has reached the max limit.","-- @class function","-- @return True/False depending on if limit has been reached for SF Holograms"],"code":["local function max_reached()","    local c = 0","    for _, v in pairs( plyCount ) do","        c = c + v","    end","    if c >= SF.Holograms.defaultquota:GetInt() then return true else return false end","end",""],"class":"function","classForced":true,"name":"max_reached","private":false,"summary":"\nChecks if the total number of holograms across all instances has reached the max limit.","description":"\nChecks if the total number of holograms across all instances has reached the max limit.","param":[]},"holograms_library.hologramsLeft":{"ret":"number of holograms able to be spawned","comment":["--- Checks how many holograms can be spawned","-- @server","-- @return number of holograms able to be spawned"],"code":["function holograms_library.hologramsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\treturn math.min( SF.Holograms.personalquota:GetInt() - plyCount[instance.player], instance.data.holos.burst )","\t","end",""],"class":"function","summary":"\nChecks how many holograms can be spawned ","name":"holograms_library.hologramsLeft","library":"holograms","private":false,"server":true,"description":"\nChecks how many holograms can be spawned","param":[]},"holograms_library.create":{"ret":"The hologram object","comment":["--- Creates a hologram.","-- @server","-- @return The hologram object"],"code":["function holograms_library.create ( pos, ang, model, scale )","    SF.CheckType( pos, SF.Types[ \"Vector\" ] )","    SF.CheckType( ang, SF.Types[ \"Angle\" ] )","    SF.CheckType( model, \"string\" )","    if scale then","\t\tSF.CheckType( scale, SF.Types[ \"Vector\" ] )","\t\tscale = vunwrap( scale )","\tend","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","    local instance = SF.instance","    if not can_spawn( instance ) then return SF.throw( \"Can't spawn holograms that often\", 2 )","    elseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn holograms, maximum personal limit of \" .. SF.Holograms.personalquota:GetInt() .. \" has been reached\", 2 )","    elseif max_reached() then return SF.throw( \"Can't spawn holograms, maximum limit of \" .. SF.Holograms.defaultquota:GetInt() .. \" has been reached\", 2 ) end","","    local holodata = instance.data.holograms","    local holoent = ents.Create( \"starfall_hologram\" )","    if holoent and holoent:IsValid() then","        holoent:SetPos( pos )","        holoent:SetAngles( ang )","        holoent:SetModel( model )","        holoent:CallOnRemove( \"starfall_hologram_delete\", hologramOnDestroy, holodata, instance.player )","        holoent:Spawn()","","        if scale then","            holoent:SetScale( scale )","        end","","        local holo = SF.Entities.Wrap( holoent )","","        holodata.holos[ holo ] = holo","","        plyCount[ instance.player ] = plyCount[ instance.player ] + 1","        return holo","        -- TODO: Need to fire a umsg here to assign clientside ownership(?)","    end","end",""],"class":"function","summary":"\nCreates a hologram.","name":"holograms_library.create","library":"holograms","private":false,"server":true,"description":"\nCreates a hologram.","param":["pos","ang","model","scale"]},"hologram_methods:getPose":{"ret":"Value of the pose parameter","comment":["--- Get the pose value of an animation","-- @server","-- @class function","-- @param pose Pose parameter name","-- @return Value of the pose parameter"],"code":["function hologram_methods:getPose( pose )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\treturn Holo:GetPoseParameter( pose )","end","",""],"class":"function","classForced":true,"summary":"\nGet the pose value of an animation ","name":"hologram_methods:getPose","classlib":"Hologram","private":false,"server":true,"description":"\nGet the pose value of an animation","param":{"1":"pose","pose":"Pose parameter name"}},"can_spawn":{"comment":["--- Updates/Checks burst constraints","-- @class function","-- @param instance Instance table for the burst values related to current SF Instance / Player","-- @param noupdate False if updating the burst should be done."],"code":["local function can_spawn(instance, noupdate)","    if instance.data.holograms.burst > 0 then","        if not noupdate then instance.data.holograms.burst = instance.data.holograms.burst - 1 end","        return true","    else","        return false","    end","end",""],"class":"function","classForced":true,"name":"can_spawn","private":false,"summary":"\nUpdates/Checks burst constraints ","description":"\nUpdates/Checks burst constraints","param":{"1":"instance","2":"noupdate","instance":"Instance table for the burst values related to current SF Instance / Player","noupdate":"False if updating the burst should be done."}},"hologram_methods:getAnimationLength":{"ret":"Length of current animation in seconds","comment":["--- Get the length of the current animation","-- @server","-- @class function","-- @return Length of current animation in seconds"],"code":["function hologram_methods:getAnimationLength( )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return -1 end","\t","\treturn Holo:SequenceDuration()","end",""],"class":"function","classForced":true,"summary":"\nGet the length of the current animation ","name":"hologram_methods:getAnimationLength","classlib":"Hologram","private":false,"server":true,"description":"\nGet the length of the current animation","param":[]},"personal_max_reached":{"ret":"True/False depending on if the personal limit has been reached for SF Holograms","comment":["--- Checks if the users personal limit of holograms has been exhausted","-- @class function","-- @param i Instance to use, this will relate to the player in question","-- @return True/False depending on if the personal limit has been reached for SF Holograms"],"code":["local function personal_max_reached( i )","    return plyCount[i.player] >= SF.Holograms.personalquota:GetInt()","end","","local function regenerateBurst()","\tfor i, _ in pairs( insts ) do","\t\tif i.data.holograms.burst < SF.Holograms.burstmax:GetInt() or 10 then -- Should allow for dynamic changing of burst rate from the server.","\t\t\ti.data.holograms.burst = i.data.holograms.burst + 1","\t\tend","\tend","end","","timer.Create( \"SF_Hologram_BurstCounter\", 1 / math.max( SF.Holograms.burstrate:GetFloat() or 4, 0.0001 ), 0, regenerateBurst )","","cvars.AddChangeCallback( \"sf_holograms_burstrate\", function( convar_name, value_old, value_new )","\ttimer.Adjust( \"SF_Hologram_BurstCounter\", 1 / math.max( SF.Holograms.burstrate:GetFloat() or 4, 0.0001 ), 0, regenerateBurst )","end ) ",""],"class":"function","classForced":true,"name":"personal_max_reached","private":false,"summary":"\nChecks if the users personal limit of holograms has been exhausted ","description":"\nChecks if the users personal limit of holograms has been exhausted","param":{"1":"i","i":"Instance to use, this will relate to the player in question"}},"hologram_methods:setAngVel":{"comment":["--- Sets the hologram's angular velocity.","-- @param angvel *Vector* angular velocity."],"code":["function hologram_methods:setAngVel ( angvel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( angvel, SF.Types[ \"Angle\" ] )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetLocalAngularVelocity( SF.Angles.Unwrap( angvel ) ) end","end",""],"class":"function","name":"hologram_methods:setAngVel","summary":"\nSets the hologram's angular velocity.","private":false,"classlib":"Hologram","description":"\nSets the hologram's angular velocity.","param":{"1":"angvel","angvel":"*Vector* angular velocity."}},"hologram_methods:getAnimationNumber":{"ret":"Animation index","comment":["--- Convert animation name into animation number","-- @server","-- @param animation Name of the animation","-- @return Animation index"],"code":["function hologram_methods:getAnimationNumber( animation )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return 0 end","\t","\treturn Holo:LookupSequence(animation) or 0","end",""],"class":"function","summary":"\nConvert animation name into animation number ","name":"hologram_methods:getAnimationNumber","classlib":"Hologram","private":false,"server":true,"description":"\nConvert animation name into animation number","param":{"1":"animation","animation":"Name of the animation"}},"hologram_methods:setParent":{"comment":["--- Parents this hologram to the specified hologram"],"code":["function hologram_methods:setParent(parent, attachment)","\tSF.CheckType(self, hologram_metamethods)","\tlocal child = SF.Entities.Unwrap(self)","\tif not child then return end","\t","\tif parent then","\t\tSF.CheckType(parent, SF.Entities.Metatable)","\t\tlocal parent = SF.Entities.Unwrap(parent)","\t\tif not parent then return end","\t\t","\t\t-- Prevent cyclic parenting ( = crashes )","\t\tlocal checkparent = parent","\t\trepeat","\t\t\tif checkparent == child then return end","\t\t\tcheckparent = checkparent:GetParent()","\t\tuntil not IsValid(checkparent)","\t\t","\t\tchild:SetParent(parent)","\t\t","\t\tif attachment then","\t\t\tSF.CheckType(attachment, \"string\")","\t\t\tchild:Fire(\"SetParentAttachmentMaintainOffset\", attachment, 0.01)","\t\tend","\telse","\t\tchild:SetParent(nil)","\tend","end",""],"class":"function","name":"hologram_methods:setParent","summary":"\nParents this hologram to the specified hologram ","private":false,"classlib":"Hologram","description":"\nParents this hologram to the specified hologram","param":["parent","attachment"]},"hologram_methods:setPos":{"comment":["--- Sets the hologram position.","-- @param pos New position"],"code":["function hologram_methods:setPos ( pos )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tlocal pos = vunwrap( pos )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetPos( pos ) end","end",""],"class":"function","name":"hologram_methods:setPos","summary":"\nSets the hologram position.","private":false,"classlib":"Hologram","description":"\nSets the hologram position.","param":{"1":"pos","pos":"New position"}}},"doc":[{"comment":["--- Library for creating and manipulating physics-less models AKA \"Holograms\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"hologramsLeft","4":"spawnRate","spawnRate":{"ret":"Number of holograms per second the user can spawn","comment":["--- Returns how many holograms per second the user can spawn","-- @server","-- @return Number of holograms per second the user can spawn"],"code":["function holograms_library.spawnRate ()","","\treturn SF.Holograms.burstrate:GetFloat() or 4","\t","end"],"class":"function","summary":"\nReturns how many holograms per second the user can spawn ","name":"holograms_library.spawnRate","library":"holograms","private":false,"server":true,"description":"\nReturns how many holograms per second the user can spawn","param":[]},"canSpawn":{"ret":"True if user can spawn holograms, False if not.","comment":["--- Checks if a user can spawn anymore holograms.","-- @server","-- @return True if user can spawn holograms, False if not."],"code":["function holograms_library.canSpawn()","    local instance = SF.instance","    return not personal_max_reached( instance ) and not max_reached() and can_spawn( instance, true )","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore holograms.","name":"holograms_library.canSpawn","library":"holograms","private":false,"server":true,"description":"\nChecks if a user can spawn anymore holograms.","param":[]},"create":{"ret":"The hologram object","comment":["--- Creates a hologram.","-- @server","-- @return The hologram object"],"code":["function holograms_library.create ( pos, ang, model, scale )","    SF.CheckType( pos, SF.Types[ \"Vector\" ] )","    SF.CheckType( ang, SF.Types[ \"Angle\" ] )","    SF.CheckType( model, \"string\" )","    if scale then","\t\tSF.CheckType( scale, SF.Types[ \"Vector\" ] )","\t\tscale = vunwrap( scale )","\tend","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","    local instance = SF.instance","    if not can_spawn( instance ) then return SF.throw( \"Can't spawn holograms that often\", 2 )","    elseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn holograms, maximum personal limit of \" .. SF.Holograms.personalquota:GetInt() .. \" has been reached\", 2 )","    elseif max_reached() then return SF.throw( \"Can't spawn holograms, maximum limit of \" .. SF.Holograms.defaultquota:GetInt() .. \" has been reached\", 2 ) end","","    local holodata = instance.data.holograms","    local holoent = ents.Create( \"starfall_hologram\" )","    if holoent and holoent:IsValid() then","        holoent:SetPos( pos )","        holoent:SetAngles( ang )","        holoent:SetModel( model )","        holoent:CallOnRemove( \"starfall_hologram_delete\", hologramOnDestroy, holodata, instance.player )","        holoent:Spawn()","","        if scale then","            holoent:SetScale( scale )","        end","","        local holo = SF.Entities.Wrap( holoent )","","        holodata.holos[ holo ] = holo","","        plyCount[ instance.player ] = plyCount[ instance.player ] + 1","        return holo","        -- TODO: Need to fire a umsg here to assign clientside ownership(?)","    end","end",""],"class":"function","summary":"\nCreates a hologram.","name":"holograms_library.create","library":"holograms","private":false,"server":true,"description":"\nCreates a hologram.","param":["pos","ang","model","scale"]},"hologramsLeft":{"ret":"number of holograms able to be spawned","comment":["--- Checks how many holograms can be spawned","-- @server","-- @return number of holograms able to be spawned"],"code":["function holograms_library.hologramsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\treturn math.min( SF.Holograms.personalquota:GetInt() - plyCount[instance.player], instance.data.holos.burst )","\t","end",""],"class":"function","summary":"\nChecks how many holograms can be spawned ","name":"holograms_library.hologramsLeft","library":"holograms","private":false,"server":true,"description":"\nChecks how many holograms can be spawned","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","code":["local holograms_library, holograms_library_metamethods = SF.Libraries.Register(\"holograms\")",""],"fields":[],"name":"holograms","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","libtbl":"holograms_library","tables":[],"server":true},{"comment":["--- Hologram type"],"code":["local hologram_methods, hologram_metamethods = SF.Typedef(\"Hologram\", SF.Entities.Metatable)","","local vunwrap = SF.UnwrapObject","","SF.Holograms = {}","SF.Holograms.defaultquota = CreateConVar( \"sf_holograms_defaultquota\", \"7200\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of holograms allowed to spawn via Starfall scripts across all instances\" )","","SF.Holograms.personalquota = CreateConVar( \"sf_holograms_personalquota\", \"300\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of holograms allowed to spawn via Starfall scripts for a single instance\" )","","SF.Holograms.burstmax = CreateConVar( \"sf_holograms_burstmax\", \"10\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","    \"The number of holograms allowed to spawn in a short interval of time via Starfall scripts for a single instance ( burst )\" )","\t","SF.Holograms.burstrate = CreateConVar( \"sf_holograms_burstrate\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The rate at which the burst regenerates per second.\" )","","SF.Holograms.Methods = hologram_methods","SF.Holograms.Metatable = hologram_metamethods","","local dsetmeta = debug.setmetatable","local old_ent_wrap = SF.Entities.Wrap","function SF.Entities.Wrap(obj)","\tlocal w = old_ent_wrap(obj)","\tif IsValid(obj) and obj:IsValid() and obj:GetClass() == \"starfall_hologram\" then","\t\tdsetmeta(w, hologram_metamethods)","\tend","\treturn w","end","","local insts = {}","local plyCount = setmetatable({}, {__mode=\"k\"})","","SF.Libraries.AddHook(\"initialize\",function(inst)","\tinst.data.holograms = {","\t\tholos = {},","\t\tburst = SF.Holograms.burstmax:GetInt() or 10","\t}","","\tinsts[inst] = true","\tplyCount[inst.player] = plyCount[inst.player] or 0","end)","","SF.Libraries.AddHook(\"deinitialize\", function(inst)","\tlocal holos = inst.data.holograms.holos","\tlocal holo = next(holos)","\twhile holo do","\t\tlocal holoent = SF.Entities.Unwrap(holo)","\t\tif IsValid(holoent) then","\t\t\tholoent:Remove()","\t\tend","\t\tholos[holo] = nil","\t\tholo = next(holos)","\tend","\tinsts[inst]= nil","end)","","local function hologramOnDestroy(holoent, holodata, ply)","\tplyCount[ply] = plyCount[ply] - 1","\tif not holodata.holos then return end","\tlocal holo = SF.Entities.Wrap(holoent)","\tif holodata.holos[holo] then","\t\tholodata.holos[holo] = nil\t\t","\tend","end","","-- ------------------------------------------------------------------------- --",""],"typtbl":"hologram_methods","fields":[],"name":"Hologram","summary":"\nHologram type ","description":"\nHologram type","class":"class","methods":{"1":"getAnimationLength","2":"getAnimationNumber","3":"getFlexes","4":"getPose","5":"remove","6":"setAng","7":"setAngVel","8":"setAnimation","9":"setClip","10":"setFlexScale","11":"setFlexWeight","12":"setModel","13":"setParent","14":"setPos","15":"setPose","16":"setScale","17":"setVel","18":"suppressEngineLighting","getAnimationNumber":{"ret":"Animation index","comment":["--- Convert animation name into animation number","-- @server","-- @param animation Name of the animation","-- @return Animation index"],"code":["function hologram_methods:getAnimationNumber( animation )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return 0 end","\t","\treturn Holo:LookupSequence(animation) or 0","end",""],"class":"function","summary":"\nConvert animation name into animation number ","name":"hologram_methods:getAnimationNumber","classlib":"Hologram","private":false,"server":true,"description":"\nConvert animation name into animation number","param":{"1":"animation","animation":"Name of the animation"}},"setFlexWeight":{"comment":["--- Sets the weight (value) of a flex."],"code":["function hologram_methods:setFlexWeight(flexid, weight)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(flexid, \"number\")","\tSF.CheckType(weight, \"number\")","\tflexid = math.floor(flexid)","\tif flexid < 0 or flexid >= holoent:GetFlexNum() then","\t\tSF.throw( \"Invalid flex: \"..flexid, 2 )","\tend","\tlocal holoent = SF.Entities.Unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexWeight(self, weight)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexWeight","summary":"\nSets the weight (value) of a flex.","private":false,"classlib":"Hologram","description":"\nSets the weight (value) of a flex.","param":["flexid","weight"]},"setAnimation":{"comment":["--- Animates a hologram","-- @server","-- @class function","-- @param animation number or string name","-- @param frame The starting frame number","-- @param rate Frame speed. (1 is normal)"],"code":["function hologram_methods:setAnimation(animation, frame, rate)","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","","\tif type(animation)==\"string\" then","\t\tanimation = Holo:LookupSequence(animation)","\tend","\t","\tframe = frame or 0","\trate = rate or 1","\t","\tif not Holo.Animated then","\t\t-- This must be run once on entities that will be animated","\t\tHolo.Animated = true","\t\tHolo.AutomaticFrameAdvance = true","\t\t","\t\tlocal OldThink = Holo.Think","\t\tfunction Holo:Think()","\t\t\tOldThink(self)","\t\t\tself:NextThink( CurTime() )","\t\t\treturn true","\t\tend","\tend","\tHolo:ResetSequence(animation)","\tHolo:SetCycle(frame)","\tHolo:SetPlaybackRate(rate)","end",""],"class":"function","classForced":true,"summary":"\nAnimates a hologram ","name":"hologram_methods:setAnimation","classlib":"Hologram","private":false,"server":true,"description":"\nAnimates a hologram","param":{"1":"animation","2":"frame","3":"rate","frame":"The starting frame number","rate":"Frame speed. (1 is normal)","animation":"number or string name"}},"remove":{"comment":["--- Deletes the hologram","-- @server"],"code":["function hologram_methods:remove()","    SF.CheckType(self, hologram_metamethods)","    local holoent = SF.Entities.Unwrap(self)","    if IsValid(holoent) then","        holoent:Remove()","    end","end",""],"class":"function","summary":"\nDeletes the hologram ","name":"hologram_methods:remove","classlib":"Hologram","private":false,"server":true,"description":"\nDeletes the hologram","param":[]},"setAng":{"comment":["--- Sets the hologram angle","-- @param ang New angles"],"code":["function hologram_methods:setAng ( ang )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetAngles( SF.Angles.Unwrap( ang ) ) end","end",""],"class":"function","name":"hologram_methods:setAng","summary":"\nSets the hologram angle ","private":false,"classlib":"Hologram","description":"\nSets the hologram angle","param":{"1":"ang","ang":"New angles"}},"setVel":{"comment":["--- Sets the hologram linear velocity","-- @param vel New velocity"],"code":["function hologram_methods:setVel ( vel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","\tlocal vel = vunwrap( vel )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetLocalVelocity( vel ) end","end",""],"class":"function","name":"hologram_methods:setVel","summary":"\nSets the hologram linear velocity ","private":false,"classlib":"Hologram","description":"\nSets the hologram linear velocity","param":{"1":"vel","vel":"New velocity"}},"setClip":{"comment":["--- Updates a clip plane"],"code":["function hologram_methods:setClip ( index, enabled, origin, normal, islocal )","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(index, \"number\")","\tSF.CheckType(enabled, \"boolean\")","\tSF.CheckType(origin, SF.Types[ \"Vector\" ] )","\tSF.CheckType(normal, SF.Types[ \"Vector\" ] )","\tSF.CheckType(islocal, \"boolean\")","","\tlocal origin, normal = vunwrap( origin ), vunwrap( normal )","","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then","\t\tholo:UpdateClip( index, enabled, origin, normal, islocal )","\tend","end",""],"class":"function","name":"hologram_methods:setClip","summary":"\nUpdates a clip plane ","private":false,"classlib":"Hologram","description":"\nUpdates a clip plane","param":["index","enabled","origin","normal","islocal"]},"setScale":{"comment":["--- Sets the hologram scale","-- @param scale New scale"],"code":["function hologram_methods:setScale ( scale )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( scale, SF.Types[ \"Vector\" ] )","\tlocal scale = vunwrap( scale )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then","\t\tholo:SetScale( scale )","\tend","end",""],"class":"function","name":"hologram_methods:setScale","summary":"\nSets the hologram scale ","private":false,"classlib":"Hologram","description":"\nSets the hologram scale","param":{"1":"scale","scale":"New scale"}},"getFlexes":{"comment":["--- Returns a table of flexname -> flexid pairs for use in flex functions.","-- These IDs become invalid when the hologram's model changes."],"code":["function hologram_methods:getFlexes()","\tSF.CheckType(self, hologram_metamethods)","\tlocal holoent = SF.Entities.Unwrap(self)","\tlocal flexes = {}","\tfor i=0,holoent:GetFlexNum()-1 do","\t\tflexes[holoent:GetFlexName(i)] = i","\tend","\treturn flexes","end",""],"class":"function","name":"hologram_methods:getFlexes","summary":"\nReturns a table of flexname -> flexid pairs for use in flex functions.","private":false,"classlib":"Hologram","description":"\nReturns a table of flexname -> flexid pairs for use in flex functions. \nThese IDs become invalid when the hologram's model changes.","param":[]},"getAnimationLength":{"ret":"Length of current animation in seconds","comment":["--- Get the length of the current animation","-- @server","-- @class function","-- @return Length of current animation in seconds"],"code":["function hologram_methods:getAnimationLength( )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return -1 end","\t","\treturn Holo:SequenceDuration()","end",""],"class":"function","classForced":true,"summary":"\nGet the length of the current animation ","name":"hologram_methods:getAnimationLength","classlib":"Hologram","private":false,"server":true,"description":"\nGet the length of the current animation","param":[]},"setAngVel":{"comment":["--- Sets the hologram's angular velocity.","-- @param angvel *Vector* angular velocity."],"code":["function hologram_methods:setAngVel ( angvel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( angvel, SF.Types[ \"Angle\" ] )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetLocalAngularVelocity( SF.Angles.Unwrap( angvel ) ) end","end",""],"class":"function","name":"hologram_methods:setAngVel","summary":"\nSets the hologram's angular velocity.","private":false,"classlib":"Hologram","description":"\nSets the hologram's angular velocity.","param":{"1":"angvel","angvel":"*Vector* angular velocity."}},"setParent":{"comment":["--- Parents this hologram to the specified hologram"],"code":["function hologram_methods:setParent(parent, attachment)","\tSF.CheckType(self, hologram_metamethods)","\tlocal child = SF.Entities.Unwrap(self)","\tif not child then return end","\t","\tif parent then","\t\tSF.CheckType(parent, SF.Entities.Metatable)","\t\tlocal parent = SF.Entities.Unwrap(parent)","\t\tif not parent then return end","\t\t","\t\t-- Prevent cyclic parenting ( = crashes )","\t\tlocal checkparent = parent","\t\trepeat","\t\t\tif checkparent == child then return end","\t\t\tcheckparent = checkparent:GetParent()","\t\tuntil not IsValid(checkparent)","\t\t","\t\tchild:SetParent(parent)","\t\t","\t\tif attachment then","\t\t\tSF.CheckType(attachment, \"string\")","\t\t\tchild:Fire(\"SetParentAttachmentMaintainOffset\", attachment, 0.01)","\t\tend","\telse","\t\tchild:SetParent(nil)","\tend","end",""],"class":"function","name":"hologram_methods:setParent","summary":"\nParents this hologram to the specified hologram ","private":false,"classlib":"Hologram","description":"\nParents this hologram to the specified hologram","param":["parent","attachment"]},"getPose":{"ret":"Value of the pose parameter","comment":["--- Get the pose value of an animation","-- @server","-- @class function","-- @param pose Pose parameter name","-- @return Value of the pose parameter"],"code":["function hologram_methods:getPose( pose )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\treturn Holo:GetPoseParameter( pose )","end","",""],"class":"function","classForced":true,"summary":"\nGet the pose value of an animation ","name":"hologram_methods:getPose","classlib":"Hologram","private":false,"server":true,"description":"\nGet the pose value of an animation","param":{"1":"pose","pose":"Pose parameter name"}},"setPose":{"comment":["--- Set the pose value of an animation. Turret/Head angles for example.","-- @server","-- @class function","-- @param pose Name of the pose parameter","-- @param value Value to set it to."],"code":["function hologram_methods:setPose( pose, value )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\tHolo:SetPoseParameter( pose, value )","end",""],"class":"function","classForced":true,"summary":"\nSet the pose value of an animation.","name":"hologram_methods:setPose","classlib":"Hologram","private":false,"server":true,"description":"\nSet the pose value of an animation. Turret/Head angles for example.","param":{"1":"pose","2":"value","pose":"Name of the pose parameter","value":"Value to set it to."}},"setModel":{"comment":["--- Sets the model of a hologram","-- @server","-- @class function","-- @param model string model path"],"code":["function hologram_methods:setModel ( model )","    SF.CheckType( model, \"string\" )","","    local this = SF.Entities.Unwrap( self )","    if IsValid( this ) then","        this:SetModel( model )","    end","end",""],"class":"function","classForced":true,"summary":"\nSets the model of a hologram ","name":"hologram_methods:setModel","classlib":"Hologram","private":false,"server":true,"description":"\nSets the model of a hologram","param":{"1":"model","model":"string model path"}},"suppressEngineLighting":{"comment":["--- Suppress Engine Lighting of a hologram. Disabled by default.","-- @server","-- @class function","-- @param suppress Boolean to represent if shading should be set or not."],"code":["function hologram_methods:suppressEngineLighting ( suppress )","    SF.CheckType( suppress, \"boolean\" )","","    local this = SF.Entities.Unwrap( self )","    if IsValid( this ) then","        this:SetNetworkedBool( \"suppressEngineLighting\", suppress )","    end","end",""],"class":"function","classForced":true,"summary":"\nSuppress Engine Lighting of a hologram.","name":"hologram_methods:suppressEngineLighting","classlib":"Hologram","private":false,"server":true,"description":"\nSuppress Engine Lighting of a hologram. Disabled by default.","param":{"1":"suppress","suppress":"Boolean to represent if shading should be set or not."}},"setFlexScale":{"comment":["--- Sets the scale of all flexes of a hologram"],"code":["function hologram_methods:setFlexScale(scale)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(scale, \"number\")","\tlocal holoent = SF.Entities.Unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexScale(scale)","\tend","end","",""],"class":"function","name":"hologram_methods:setFlexScale","summary":"\nSets the scale of all flexes of a hologram ","private":false,"classlib":"Hologram","description":"\nSets the scale of all flexes of a hologram","param":["scale"]},"setPos":{"comment":["--- Sets the hologram position.","-- @param pos New position"],"code":["function hologram_methods:setPos ( pos )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tlocal pos = vunwrap( pos )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetPos( pos ) end","end",""],"class":"function","name":"hologram_methods:setPos","summary":"\nSets the hologram position.","private":false,"classlib":"Hologram","description":"\nSets the hologram position.","param":{"1":"pos","pos":"New position"}}}},{"comment":["--- Sets the hologram position.","-- @param pos New position"],"code":["function hologram_methods:setPos ( pos )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tlocal pos = vunwrap( pos )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetPos( pos ) end","end",""],"class":"function","name":"hologram_methods:setPos","summary":"\nSets the hologram position.","private":false,"classlib":"Hologram","description":"\nSets the hologram position.","param":{"1":"pos","pos":"New position"}},{"comment":["--- Sets the hologram angle","-- @param ang New angles"],"code":["function hologram_methods:setAng ( ang )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetAngles( SF.Angles.Unwrap( ang ) ) end","end",""],"class":"function","name":"hologram_methods:setAng","summary":"\nSets the hologram angle ","private":false,"classlib":"Hologram","description":"\nSets the hologram angle","param":{"1":"ang","ang":"New angles"}},{"comment":["--- Sets the hologram linear velocity","-- @param vel New velocity"],"code":["function hologram_methods:setVel ( vel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","\tlocal vel = vunwrap( vel )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetLocalVelocity( vel ) end","end",""],"class":"function","name":"hologram_methods:setVel","summary":"\nSets the hologram linear velocity ","private":false,"classlib":"Hologram","description":"\nSets the hologram linear velocity","param":{"1":"vel","vel":"New velocity"}},{"comment":["--- Sets the hologram's angular velocity.","-- @param angvel *Vector* angular velocity."],"code":["function hologram_methods:setAngVel ( angvel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( angvel, SF.Types[ \"Angle\" ] )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetLocalAngularVelocity( SF.Angles.Unwrap( angvel ) ) end","end",""],"class":"function","name":"hologram_methods:setAngVel","summary":"\nSets the hologram's angular velocity.","private":false,"classlib":"Hologram","description":"\nSets the hologram's angular velocity.","param":{"1":"angvel","angvel":"*Vector* angular velocity."}},{"comment":["--- Parents this hologram to the specified hologram"],"code":["function hologram_methods:setParent(parent, attachment)","\tSF.CheckType(self, hologram_metamethods)","\tlocal child = SF.Entities.Unwrap(self)","\tif not child then return end","\t","\tif parent then","\t\tSF.CheckType(parent, SF.Entities.Metatable)","\t\tlocal parent = SF.Entities.Unwrap(parent)","\t\tif not parent then return end","\t\t","\t\t-- Prevent cyclic parenting ( = crashes )","\t\tlocal checkparent = parent","\t\trepeat","\t\t\tif checkparent == child then return end","\t\t\tcheckparent = checkparent:GetParent()","\t\tuntil not IsValid(checkparent)","\t\t","\t\tchild:SetParent(parent)","\t\t","\t\tif attachment then","\t\t\tSF.CheckType(attachment, \"string\")","\t\t\tchild:Fire(\"SetParentAttachmentMaintainOffset\", attachment, 0.01)","\t\tend","\telse","\t\tchild:SetParent(nil)","\tend","end",""],"class":"function","name":"hologram_methods:setParent","summary":"\nParents this hologram to the specified hologram ","private":false,"classlib":"Hologram","description":"\nParents this hologram to the specified hologram","param":["parent","attachment"]},{"comment":["--- Sets the hologram scale","-- @param scale New scale"],"code":["function hologram_methods:setScale ( scale )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( scale, SF.Types[ \"Vector\" ] )","\tlocal scale = vunwrap( scale )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then","\t\tholo:SetScale( scale )","\tend","end",""],"class":"function","name":"hologram_methods:setScale","summary":"\nSets the hologram scale ","private":false,"classlib":"Hologram","description":"\nSets the hologram scale","param":{"1":"scale","scale":"New scale"}},{"comment":["--- Updates a clip plane"],"code":["function hologram_methods:setClip ( index, enabled, origin, normal, islocal )","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(index, \"number\")","\tSF.CheckType(enabled, \"boolean\")","\tSF.CheckType(origin, SF.Types[ \"Vector\" ] )","\tSF.CheckType(normal, SF.Types[ \"Vector\" ] )","\tSF.CheckType(islocal, \"boolean\")","","\tlocal origin, normal = vunwrap( origin ), vunwrap( normal )","","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then","\t\tholo:UpdateClip( index, enabled, origin, normal, islocal )","\tend","end",""],"class":"function","name":"hologram_methods:setClip","summary":"\nUpdates a clip plane ","private":false,"classlib":"Hologram","description":"\nUpdates a clip plane","param":["index","enabled","origin","normal","islocal"]},{"comment":["--- Returns a table of flexname -> flexid pairs for use in flex functions.","-- These IDs become invalid when the hologram's model changes."],"code":["function hologram_methods:getFlexes()","\tSF.CheckType(self, hologram_metamethods)","\tlocal holoent = SF.Entities.Unwrap(self)","\tlocal flexes = {}","\tfor i=0,holoent:GetFlexNum()-1 do","\t\tflexes[holoent:GetFlexName(i)] = i","\tend","\treturn flexes","end",""],"class":"function","name":"hologram_methods:getFlexes","summary":"\nReturns a table of flexname -> flexid pairs for use in flex functions.","private":false,"classlib":"Hologram","description":"\nReturns a table of flexname -> flexid pairs for use in flex functions. \nThese IDs become invalid when the hologram's model changes.","param":[]},{"comment":["--- Sets the weight (value) of a flex."],"code":["function hologram_methods:setFlexWeight(flexid, weight)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(flexid, \"number\")","\tSF.CheckType(weight, \"number\")","\tflexid = math.floor(flexid)","\tif flexid < 0 or flexid >= holoent:GetFlexNum() then","\t\tSF.throw( \"Invalid flex: \"..flexid, 2 )","\tend","\tlocal holoent = SF.Entities.Unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexWeight(self, weight)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexWeight","summary":"\nSets the weight (value) of a flex.","private":false,"classlib":"Hologram","description":"\nSets the weight (value) of a flex.","param":["flexid","weight"]},{"comment":["--- Sets the scale of all flexes of a hologram"],"code":["function hologram_methods:setFlexScale(scale)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(scale, \"number\")","\tlocal holoent = SF.Entities.Unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexScale(scale)","\tend","end","",""],"class":"function","name":"hologram_methods:setFlexScale","summary":"\nSets the scale of all flexes of a hologram ","private":false,"classlib":"Hologram","description":"\nSets the scale of all flexes of a hologram","param":["scale"]},{"comment":["--- Deletes the hologram","-- @server"],"code":["function hologram_methods:remove()","    SF.CheckType(self, hologram_metamethods)","    local holoent = SF.Entities.Unwrap(self)","    if IsValid(holoent) then","        holoent:Remove()","    end","end",""],"class":"function","summary":"\nDeletes the hologram ","name":"hologram_methods:remove","classlib":"Hologram","private":false,"server":true,"description":"\nDeletes the hologram","param":[]},{"comment":["--- Sets the model of a hologram","-- @server","-- @class function","-- @param model string model path"],"code":["function hologram_methods:setModel ( model )","    SF.CheckType( model, \"string\" )","","    local this = SF.Entities.Unwrap( self )","    if IsValid( this ) then","        this:SetModel( model )","    end","end",""],"class":"function","classForced":true,"summary":"\nSets the model of a hologram ","name":"hologram_methods:setModel","classlib":"Hologram","private":false,"server":true,"description":"\nSets the model of a hologram","param":{"1":"model","model":"string model path"}},{"comment":["--- Suppress Engine Lighting of a hologram. Disabled by default.","-- @server","-- @class function","-- @param suppress Boolean to represent if shading should be set or not."],"code":["function hologram_methods:suppressEngineLighting ( suppress )","    SF.CheckType( suppress, \"boolean\" )","","    local this = SF.Entities.Unwrap( self )","    if IsValid( this ) then","        this:SetNetworkedBool( \"suppressEngineLighting\", suppress )","    end","end",""],"class":"function","classForced":true,"summary":"\nSuppress Engine Lighting of a hologram.","name":"hologram_methods:suppressEngineLighting","classlib":"Hologram","private":false,"server":true,"description":"\nSuppress Engine Lighting of a hologram. Disabled by default.","param":{"1":"suppress","suppress":"Boolean to represent if shading should be set or not."}},{"comment":["--- Animates a hologram","-- @server","-- @class function","-- @param animation number or string name","-- @param frame The starting frame number","-- @param rate Frame speed. (1 is normal)"],"code":["function hologram_methods:setAnimation(animation, frame, rate)","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","","\tif type(animation)==\"string\" then","\t\tanimation = Holo:LookupSequence(animation)","\tend","\t","\tframe = frame or 0","\trate = rate or 1","\t","\tif not Holo.Animated then","\t\t-- This must be run once on entities that will be animated","\t\tHolo.Animated = true","\t\tHolo.AutomaticFrameAdvance = true","\t\t","\t\tlocal OldThink = Holo.Think","\t\tfunction Holo:Think()","\t\t\tOldThink(self)","\t\t\tself:NextThink( CurTime() )","\t\t\treturn true","\t\tend","\tend","\tHolo:ResetSequence(animation)","\tHolo:SetCycle(frame)","\tHolo:SetPlaybackRate(rate)","end",""],"class":"function","classForced":true,"summary":"\nAnimates a hologram ","name":"hologram_methods:setAnimation","classlib":"Hologram","private":false,"server":true,"description":"\nAnimates a hologram","param":{"1":"animation","2":"frame","3":"rate","frame":"The starting frame number","rate":"Frame speed. (1 is normal)","animation":"number or string name"}},{"ret":"Length of current animation in seconds","comment":["--- Get the length of the current animation","-- @server","-- @class function","-- @return Length of current animation in seconds"],"code":["function hologram_methods:getAnimationLength( )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return -1 end","\t","\treturn Holo:SequenceDuration()","end",""],"class":"function","classForced":true,"summary":"\nGet the length of the current animation ","name":"hologram_methods:getAnimationLength","classlib":"Hologram","private":false,"server":true,"description":"\nGet the length of the current animation","param":[]},{"ret":"Animation index","comment":["--- Convert animation name into animation number","-- @server","-- @param animation Name of the animation","-- @return Animation index"],"code":["function hologram_methods:getAnimationNumber( animation )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return 0 end","\t","\treturn Holo:LookupSequence(animation) or 0","end",""],"class":"function","summary":"\nConvert animation name into animation number ","name":"hologram_methods:getAnimationNumber","classlib":"Hologram","private":false,"server":true,"description":"\nConvert animation name into animation number","param":{"1":"animation","animation":"Name of the animation"}},{"comment":["--- Set the pose value of an animation. Turret/Head angles for example.","-- @server","-- @class function","-- @param pose Name of the pose parameter","-- @param value Value to set it to."],"code":["function hologram_methods:setPose( pose, value )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\tHolo:SetPoseParameter( pose, value )","end",""],"class":"function","classForced":true,"summary":"\nSet the pose value of an animation.","name":"hologram_methods:setPose","classlib":"Hologram","private":false,"server":true,"description":"\nSet the pose value of an animation. Turret/Head angles for example.","param":{"1":"pose","2":"value","pose":"Name of the pose parameter","value":"Value to set it to."}},{"ret":"Value of the pose parameter","comment":["--- Get the pose value of an animation","-- @server","-- @class function","-- @param pose Pose parameter name","-- @return Value of the pose parameter"],"code":["function hologram_methods:getPose( pose )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\treturn Holo:GetPoseParameter( pose )","end","",""],"class":"function","classForced":true,"summary":"\nGet the pose value of an animation ","name":"hologram_methods:getPose","classlib":"Hologram","private":false,"server":true,"description":"\nGet the pose value of an animation","param":{"1":"pose","pose":"Pose parameter name"}},{"comment":["--- Updates/Checks burst constraints","-- @class function","-- @param instance Instance table for the burst values related to current SF Instance / Player","-- @param noupdate False if updating the burst should be done."],"code":["local function can_spawn(instance, noupdate)","    if instance.data.holograms.burst > 0 then","        if not noupdate then instance.data.holograms.burst = instance.data.holograms.burst - 1 end","        return true","    else","        return false","    end","end",""],"class":"function","classForced":true,"name":"can_spawn","private":false,"summary":"\nUpdates/Checks burst constraints ","description":"\nUpdates/Checks burst constraints","param":{"1":"instance","2":"noupdate","instance":"Instance table for the burst values related to current SF Instance / Player","noupdate":"False if updating the burst should be done."}},{"ret":"True/False depending on if limit has been reached for SF Holograms","comment":["--- Checks if the total number of holograms across all instances has reached the max limit.","-- @class function","-- @return True/False depending on if limit has been reached for SF Holograms"],"code":["local function max_reached()","    local c = 0","    for _, v in pairs( plyCount ) do","        c = c + v","    end","    if c >= SF.Holograms.defaultquota:GetInt() then return true else return false end","end",""],"class":"function","classForced":true,"name":"max_reached","private":false,"summary":"\nChecks if the total number of holograms across all instances has reached the max limit.","description":"\nChecks if the total number of holograms across all instances has reached the max limit.","param":[]},{"ret":"True/False depending on if the personal limit has been reached for SF Holograms","comment":["--- Checks if the users personal limit of holograms has been exhausted","-- @class function","-- @param i Instance to use, this will relate to the player in question","-- @return True/False depending on if the personal limit has been reached for SF Holograms"],"code":["local function personal_max_reached( i )","    return plyCount[i.player] >= SF.Holograms.personalquota:GetInt()","end","","local function regenerateBurst()","\tfor i, _ in pairs( insts ) do","\t\tif i.data.holograms.burst < SF.Holograms.burstmax:GetInt() or 10 then -- Should allow for dynamic changing of burst rate from the server.","\t\t\ti.data.holograms.burst = i.data.holograms.burst + 1","\t\tend","\tend","end","","timer.Create( \"SF_Hologram_BurstCounter\", 1 / math.max( SF.Holograms.burstrate:GetFloat() or 4, 0.0001 ), 0, regenerateBurst )","","cvars.AddChangeCallback( \"sf_holograms_burstrate\", function( convar_name, value_old, value_new )","\ttimer.Adjust( \"SF_Hologram_BurstCounter\", 1 / math.max( SF.Holograms.burstrate:GetFloat() or 4, 0.0001 ), 0, regenerateBurst )","end ) ",""],"class":"function","classForced":true,"name":"personal_max_reached","private":false,"summary":"\nChecks if the users personal limit of holograms has been exhausted ","description":"\nChecks if the users personal limit of holograms has been exhausted","param":{"1":"i","i":"Instance to use, this will relate to the player in question"}},{"ret":"The hologram object","comment":["--- Creates a hologram.","-- @server","-- @return The hologram object"],"code":["function holograms_library.create ( pos, ang, model, scale )","    SF.CheckType( pos, SF.Types[ \"Vector\" ] )","    SF.CheckType( ang, SF.Types[ \"Angle\" ] )","    SF.CheckType( model, \"string\" )","    if scale then","\t\tSF.CheckType( scale, SF.Types[ \"Vector\" ] )","\t\tscale = vunwrap( scale )","\tend","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","    local instance = SF.instance","    if not can_spawn( instance ) then return SF.throw( \"Can't spawn holograms that often\", 2 )","    elseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn holograms, maximum personal limit of \" .. SF.Holograms.personalquota:GetInt() .. \" has been reached\", 2 )","    elseif max_reached() then return SF.throw( \"Can't spawn holograms, maximum limit of \" .. SF.Holograms.defaultquota:GetInt() .. \" has been reached\", 2 ) end","","    local holodata = instance.data.holograms","    local holoent = ents.Create( \"starfall_hologram\" )","    if holoent and holoent:IsValid() then","        holoent:SetPos( pos )","        holoent:SetAngles( ang )","        holoent:SetModel( model )","        holoent:CallOnRemove( \"starfall_hologram_delete\", hologramOnDestroy, holodata, instance.player )","        holoent:Spawn()","","        if scale then","            holoent:SetScale( scale )","        end","","        local holo = SF.Entities.Wrap( holoent )","","        holodata.holos[ holo ] = holo","","        plyCount[ instance.player ] = plyCount[ instance.player ] + 1","        return holo","        -- TODO: Need to fire a umsg here to assign clientside ownership(?)","    end","end",""],"class":"function","summary":"\nCreates a hologram.","name":"holograms_library.create","library":"holograms","private":false,"server":true,"description":"\nCreates a hologram.","param":["pos","ang","model","scale"]},{"ret":"True if user can spawn holograms, False if not.","comment":["--- Checks if a user can spawn anymore holograms.","-- @server","-- @return True if user can spawn holograms, False if not."],"code":["function holograms_library.canSpawn()","    local instance = SF.instance","    return not personal_max_reached( instance ) and not max_reached() and can_spawn( instance, true )","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore holograms.","name":"holograms_library.canSpawn","library":"holograms","private":false,"server":true,"description":"\nChecks if a user can spawn anymore holograms.","param":[]},{"ret":"number of holograms able to be spawned","comment":["--- Checks how many holograms can be spawned","-- @server","-- @return number of holograms able to be spawned"],"code":["function holograms_library.hologramsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"hologram.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\treturn math.min( SF.Holograms.personalquota:GetInt() - plyCount[instance.player], instance.data.holos.burst )","\t","end",""],"class":"function","summary":"\nChecks how many holograms can be spawned ","name":"holograms_library.hologramsLeft","library":"holograms","private":false,"server":true,"description":"\nChecks how many holograms can be spawned","param":[]},{"ret":"Number of holograms per second the user can spawn","comment":["--- Returns how many holograms per second the user can spawn","-- @server","-- @return Number of holograms per second the user can spawn"],"code":["function holograms_library.spawnRate ()","","\treturn SF.Holograms.burstrate:GetFloat() or 4","\t","end"],"class":"function","summary":"\nReturns how many holograms per second the user can spawn ","name":"holograms_library.spawnRate","library":"holograms","private":false,"server":true,"description":"\nReturns how many holograms per second the user can spawn","param":[]}],"tables":[],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\".","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Holograms\"."},"libs_sv/wire.lua":{"libraries":{"1":"wire","wire":{"comment":["--- Wire library. Handles wire inputs/outputs, wirelinks, etc."],"functions":{"1":"adjustInputs","2":"adjustOutputs","3":"create","4":"delete","5":"getInputs","6":"getOutputs","7":"getWirelink","8":"self","adjustOutputs":{"comment":["--- Creates/Modifies wire outputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of output names. May be modified by the function.","-- @param types An array of output types. May be modified by the function."],"code":["function wire_library.adjustOutputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setOutputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create outputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string output name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string output type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match(\"^[%u][%a%d]*$\") then SF.throw( \"Invalid output name: \" .. newname, 2 ) end","\t\tif not outputConverters[newtype] then SF.throw( \"Invalid/unsupported output type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._outputs = {names, types}\t","\tWireLib.AdjustSpecialOutputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustOutputs","summary":"\nCreates/Modifies wire outputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of output types. May be modified by the function.","names":"An array of output names. May be modified by the function."}},"delete":{"comment":["--- Unwires an entity's input","-- @param entI Entity with input","-- @param inputname Input to be un-wired"],"code":["function wire_library.delete ( entI, inputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\t","\tlocal entI = SF.Entities.Unwrap( entI )","\t","\tif not SF.Entities.IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.deleteWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs or not entI.Inputs[ inputname ] then SF.throw( \"Entity does not have input: \" .. inputname ) end","\tif not entI.Inputs[ inputname ].Src then SF.throw( \"Input \\\"\" .. inputname .. \"\\\" is not wired\" ) end","\t","\tWireLib.Link_Clear( entI, inputname )","end","","local function parseEntity( ent, io )","\t","\tif ent then","\t\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\t\tent = SF.Entities.Unwrap( ent )","\t\tif not SF.Permissions.check( SF.instance.player, ent, \"wire.get\" .. io ) then SF.throw( \"Insufficient permissions\", 2 ) end","\telse","\t\tent = SF.instance.data.entity or nil","\tend","\t","\tif not SF.Entities.IsValid( ent ) then SF.throw( \"Invalid source\" ) end","","\tlocal ret = {}","\tfor k, v in pairs( ent[ io ] ) do","\t\tif k ~= \"\" then","\t\t\ttable.insert( ret, k )","\t\tend","\tend\t","","\treturn ret","end",""],"class":"function","name":"wire_library.delete","summary":"\nUnwires an entity's input ","private":false,"library":"wire","description":"\nUnwires an entity's input","param":{"1":"entI","2":"inputname","entI":"Entity with input","inputname":"Input to be un-wired"}},"getWirelink":{"ret":"Wirelink of the entity","comment":["--- Returns a wirelink to a wire entity","-- @param ent Wire entity","-- @return Wirelink of the entity"],"code":["function wire_library.getWirelink ( ent )","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tent = SF.Entities.Unwrap( ent )","\tif not ent:IsValid() then return end","\t","\tif not ent.extended then","\t\tWireLib.CreateWirelinkOutput( SF.instance.player, ent, {true} )","\tend","\t","\treturn wlwrap(ent)","end","","-- ------------------------- Wirelink ------------------------- --",""],"class":"function","name":"wire_library.getWirelink","summary":"\nReturns a wirelink to a wire entity ","private":false,"library":"wire","description":"\nReturns a wirelink to a wire entity","param":{"1":"ent","ent":"Wire entity"}},"self":{"comment":["--- Returns the wirelink representing this entity."],"code":["function wire_library.self()","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","\treturn wlwrap(ent)","end",""],"class":"function","name":"wire_library.self","summary":"\nReturns the wirelink representing this entity.","private":false,"library":"wire","description":"\nReturns the wirelink representing this entity.","param":[]},"getInputs":{"ret":"Table of entity's inputs","comment":["--- Returns a table of entity's inputs","-- @param entI Entity with input(s)","-- @return Table of entity's inputs"],"code":["function wire_library.getInputs ( entI )","\treturn parseEntity( entI, \"Inputs\" )","end",""],"class":"function","name":"wire_library.getInputs","summary":"\nReturns a table of entity's inputs ","private":false,"library":"wire","description":"\nReturns a table of entity's inputs","param":{"1":"entI","entI":"Entity with input(s)"}},"getOutputs":{"ret":"Table of entity's outputs","comment":["--- Returns a table of entity's outputs","-- @param entO Entity with output(s)","-- @return Table of entity's outputs"],"code":["function wire_library.getOutputs ( entO )","\treturn parseEntity( entO, \"Outputs\" )","end",""],"class":"function","name":"wire_library.getOutputs","summary":"\nReturns a table of entity's outputs ","private":false,"library":"wire","description":"\nReturns a table of entity's outputs","param":{"1":"entO","entO":"Entity with output(s)"}},"create":{"comment":["--- Wires two entities together","-- @param entI Entity with input","-- @param entO Entity with output","-- @param inputname Input to be wired","-- @param outputname Output to be wired"],"code":["function wire_library.create ( entI, entO, inputname, outputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( entO, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\tSF.CheckType( outputname, \"string\" )","\t\t","\tlocal entI = SF.Entities.Unwrap( entI )","\tlocal entO = SF.Entities.Unwrap( entO )","\t","\tif not SF.Entities.IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\tif not SF.Entities.IsValid( entO ) then SF.throw( \"Invalid target\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.createWire\" ) or not SF.Permissions.check( SF.instance.player, entO, \"wire.createWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs then SF.throw( \"Source has no valid inputs\" ) end","\tif not entO.Outputs then SF.throw( \"Target has no valid outputs\" ) end","\t","\tif inputname == \"\" then SF.throw( \"Invalid input name\" ) end","\tif outputname == \"\" then SF.throw( \"Invalid output name\" ) end","\t","\tif not entI.Inputs[ inputname ] then SF.throw( \"Invalid source input: \" .. inputname ) end","\tif not entO.Outputs[ outputname ] then SF.throw( \"Invalid source output: \" .. outputname ) end","\tif entI.Inputs[ inputname ].Src then","\t\tlocal CheckInput = entI.Inputs[ inputname ]","\t\tif CheckInput.SrcId == outputname and CheckInput.Src == entO then SF.throw( \"Source \\\"\" .. inputname .. \"\\\" is already wired to target \\\"\" .. outputname .. \"\\\"\" ) end","\tend","\t\t","\tWireLib.Link_Start( SF.instance.player:UniqueID(), entI, entI:WorldToLocal( entI:GetPos() ), inputname, \"cable/rope\", Vector( 255, 255, 255 ), 0 )","\tWireLib.Link_End( SF.instance.player:UniqueID(), entO, entO:WorldToLocal( entO:GetPos() ), outputname, SF.instance.player )","end",""],"class":"function","name":"wire_library.create","summary":"\nWires two entities together ","private":false,"library":"wire","description":"\nWires two entities together","param":{"1":"entI","2":"entO","3":"inputname","4":"outputname","entI":"Entity with input","entO":"Entity with output","inputname":"Input to be wired","outputname":"Output to be wired"}},"adjustInputs":{"comment":["--- Creates/Modifies wire inputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of input names. May be modified by the function.","-- @param types An array of input types. May be modified by the function."],"code":["function wire_library.adjustInputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setInputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create inputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string input name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string input type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match( \"^[%u][%a%d]*$\" ) then SF.throw( \"Invalid input name: \" .. newname, 2 ) end","\t\tif not inputConverters[ newtype ] then SF.throw( \"Invalid/unsupported input type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._inputs = {names, types}","\tWireLib.AdjustSpecialInputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustInputs","summary":"\nCreates/Modifies wire inputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of input types. May be modified by the function.","names":"An array of input names. May be modified by the function."}}},"class":"library","fields":[],"name":"wire","summary":"\nWire library.","description":"\nWire library. Handles wire inputs/outputs, wirelinks, etc.","libtbl":"wire_library","tables":{"1":"ports","ports":{"description":"\nPorts table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.","code":["wire_library.ports = setmetatable({},wire_ports_metamethods)","","-- ------------------------- Hook Documentation ------------------------- --",""],"class":"table","classForced":true,"name":"wire_library.ports","summary":"\nPorts table.","library":"wire","comment":["--- Ports table. Reads from this table will read from the wire input","-- of the same name. Writes will write to the wire output of the same name.","-- @class table","-- @name wire_library.ports"],"param":[]}},"code":["local wire_library, wire_metamethods = SF.Libraries.Register( \"wire\" )","","function wire_metamethods.onLoad ( instance )","\tif not WireLib then return end","\tlocal ent = instance.data.entity","\tif ent.Inputs == nil then","\t\tWireLib.CreateInputs( ent, {} )","\tend","\tif ent.Outputs == nil then","\t\tWireLib.CreateOutputs( ent, {} )","\tend","","\tfunction ent:TriggerInput ( key, value )","\t\tlocal tmp = SF.instance","\t\tSF.instance = nil","\t\tself:runScriptHook( \"input\", key, SF.Wire.InputConverters[ self.Inputs[ key ].Type ]( value ) )","\t\tSF.instance = tmp","\tend","","\tfunction ent:ReadCell ( address )","\t\tlocal tmp = SF.instance","\t\tSF.instance = nil","\t\tlocal ret = tonumber( self:runScriptHookForResult( \"readcell\", address ) ) or 0","\t\tSF.instance = tmp","\t\treturn ret","\tend","","\tfunction ent:WriteCell ( address, data )","\t\tlocal tmp = SF.instance","\t\tSF.instance = nil","\t\tself:runScriptHook( \"writecell\", address, data )","\t\tSF.instance = tmp","\tend","","end","","SF.Wire = {}","SF.Wire.Library = wire_library",""]}},"type":"file","name":"libs_sv/wire.lua","functions":{"1":"SF.Wire.AddInputType","2":"SF.Wire.AddOutputType","3":"SF.Wire.WlUnwrap","4":"SF.Wire.WlWrap","5":"wire_library.adjustInputs","6":"wire_library.adjustOutputs","7":"wire_library.create","8":"wire_library.delete","9":"wire_library.getInputs","10":"wire_library.getOutputs","11":"wire_library.getWirelink","12":"wire_library.self","13":"wirelink_metatable.__index","14":"wirelink_metatable.__newindex","15":"wirelink_methods:entity","16":"wirelink_methods:inputType","17":"wirelink_methods:inputs","18":"wirelink_methods:isValid","19":"wirelink_methods:isWired","20":"wirelink_methods:outputType","21":"wirelink_methods:outputs","wirelink_methods:entity":{"comment":["--- Returns the entity that the wirelink represents"],"code":["function wirelink_methods:entity()","\tSF.CheckType(self,wirelink_metatable)","\treturn SF.Entities.Wrap(wlunwrap(self))","end",""],"class":"function","name":"wirelink_methods:entity","summary":"\nReturns the entity that the wirelink represents ","private":false,"classlib":"Wirelink","description":"\nReturns the entity that the wirelink represents","param":[]},"wirelink_metatable.__index":{"summary":"\nRetrieves an output.","description":"\nRetrieves an output. Returns nil if the output doesn't exist.","comment":["--- Retrieves an output. Returns nil if the output doesn't exist."],"code":["wirelink_metatable.__index = function(self,k)","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.wirelink.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(self,wirelink_metatable)","\tif wirelink_methods[k] then","\t\treturn wirelink_methods[k]","\telse","\t\tlocal wl = wlunwrap(self)","\t\tif not wl or not wl:IsValid() or not wl.extended then return end -- TODO: What is wl.extended?","\t\t","\t\tif type(k) == \"number\" then","\t\t\treturn wl.ReadCell and wl:ReadCell(k) or nil","\t\telse","\t\t\tlocal output = wl.Outputs and wl.Outputs[k]","\t\t\tif not output or not inputConverters[output.Type] then return end","\t\t\treturn inputConverters[output.Type](output.Value)","\t\tend","\tend","end",""],"private":false,"class":"function","name":"wirelink_metatable.__index","param":["self","k"]},"SF.Wire.WlUnwrap":{"classForced":true,"summary":"\n ","comment":["---","-- @class function","-- @name SF.Wire.WlUnwrap","-- @param wrapped"],"code":["SF.Wire.WlUnwrap = wlunwrap","","-- ------------------------- Internal Library ------------------------- --","","-- Allowed Expression2's types in tables and their short names","local expression2types = {","\tn = \"NORMAL\",","\ts = \"STRING\",","\tv = \"VECTOR\",","\ta = \"ANGLE\",","\txwl = \"WIRELINK\",","\te = \"ENTITY\",","\tt = \"TABLE\"","}","","local function convertFromExpression2(value, shortTypeName)","\tlocal typ = expression2types[shortTypeName]","\tif not typ or not SF.Wire.InputConverters[typ] then return nil end","","\treturn SF.Wire.InputConverters[typ](value)","end","","local function convertToExpression2(value)","\tlocal typ = type(value)","","\t-- Simple type?","\tif typ == \"number\" then return value, \"n\"","\telseif typ == \"string\" then return value, \"s\"","\telseif typ == \"Vector\" then return {value.x, value.y, value.z}, \"v\"","\telseif typ == \"Angle\" then return {value.p, value.y, value.r}, \"a\"","","\t-- We've got a table there. Is it wrapped object?","\telseif typ == \"table\" then","\t\tlocal value = SF.Unsanitize(value)","\t\ttyp = type(value)","","\t\tif typ == \"table\" then ","\t\t\t-- It is still table, do recursive convert","\t\t\treturn SF.Wire.OutputConverters.TABLE(value), \"t\"","","\t\t-- Unwrapped entity (wirelink goes to this, but it returns it as entity; don't think somebody needs to put wirelinks in table)","\t\telseif typ == \"Entity\" then return value, \"e\" end","\tend","","\t-- Nothing found / unallowed type","\treturn nil, nil","end","","local function identity(data) return data end","local inputConverters =","{","\tNORMAL = identity,","\tSTRING = identity,","\tVECTOR = identity,","\tANGLE = identity,","\tWIRELINK = wlwrap,","\tENTITY = vwrap,","","\tTABLE = function(tbl)","\t\tif not tbl.s or not tbl.stypes or not tbl.n or not tbl.ntypes or not tbl.size then return {} end","\t\tif tbl.size == 0 then return {} end -- Don't waste our time","\t\tlocal conv = {}","","\t\t-- Key-numeric part of table","\t\tfor key, typ in pairs(tbl.ntypes) do","\t\t\tconv[key] = convertFromExpression2(tbl.n[key], typ)","\t\tend","","\t\t-- Key-string part of table","\t\tfor key, typ in pairs(tbl.stypes) do","\t\t\tconv[key] = convertFromExpression2(tbl.s[key], typ)","\t\tend","","\t\treturn conv","\tend","}","","local outputConverters =","{","\tNORMAL = function(data)","\t\tSF.CheckType(data,\"number\",1)","\t\treturn data","\tend,","\tNUMBER = function(data)","\t\tSF.CheckType(data,\"number\",1)","\t\treturn data","\tend,","\tSTRING = function(data)","\t\tSF.CheckType(data,\"string\",1)","\t\treturn data","\tend,","\tVECTOR = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Vector\" ], 1 )","\t\treturn vunwrap( data )","\tend,","\tANGLE = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Angle\" ], 1 )","\t\treturn vunwrap( data )","\tend,","\tENTITY = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Entity\" ] )","\t\treturn vunwrap( data )","\tend,","","\tTABLE = function(data)","\t\tSF.CheckType(data,\"table\",1)","","\t\tlocal tbl = {istable=true, size=0, n={}, ntypes={}, s={}, stypes={}}","","\t\tfor key, value in pairs(data) do","\t\t\tlocal value, shortType = convertToExpression2(value)","","\t\t\tif shortType then","\t\t\t\tif type(key) == \"string\" then","\t\t\t\t\ttbl.s[key] = value","\t\t\t\t\ttbl.stypes[key] = shortType","\t\t\t\t\ttbl.size = tbl.size+1","","\t\t\t\telseif type(key) == \"number\" then","\t\t\t\t\ttbl.n[key] = value","\t\t\t\t\ttbl.ntypes[key] = shortType","\t\t\t\t\ttbl.size = tbl.size+1","\t\t\t\tend","\t\t\tend","\t\tend","","\t\treturn tbl","\tend","}","","SF.Wire.InputConverters = inputConverters","SF.Wire.OutputConverters = outputConverters",""],"name":"SF.Wire.WlUnwrap","class":"function","description":"\n","param":{"1":"wrapped","wrapped":""}},"SF.Wire.WlWrap":{"classForced":true,"summary":"\n ","comment":["---","-- @class function","-- @name SF.Wire.WlWrap","-- @param wirelink"],"code":["SF.Wire.WlWrap = wlwrap",""],"name":"SF.Wire.WlWrap","class":"function","description":"\n","param":{"1":"wirelink","wirelink":""}},"SF.Wire.AddOutputType":{"summary":"\nAdds an output type ","description":"\nAdds an output type","comment":["--- Adds an output type","-- @param name Output type name. Case insensitive.","-- @param deconverter The function used to check for the appropriate type and convert the SF data to wire data (eg, unwrapping)"],"code":["function SF.Wire.AddOutputType(name, deconverter)","\toutputConverters[name:upper()] = deconverter","end","","-- ------------------------- Basic Wire Functions ------------------------- --",""],"private":false,"class":"function","name":"SF.Wire.AddOutputType","param":{"1":"name","2":"deconverter","name":"Output type name. Case insensitive.","deconverter":"The function used to check for the appropriate type and convert the SF data to wire data (eg, unwrapping)"}},"wirelink_methods:isWired":{"comment":["--- Checks if an input is wired."],"code":["function wirelink_methods:isWired(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then return true","\telse return false end","end","","-- ------------------------- Ports Metatable ------------------------- --","local wire_ports_methods, wire_ports_metamethods = SF.Typedef(\"Ports\")","","function wire_ports_metamethods:__index ( name )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal input = ent.Inputs[name]","\tif not (input and input.Src and input.Src:IsValid()) then","\t\treturn nil","\tend","\treturn inputConverters[ent.Inputs[name].Type](ent.Inputs[name].Value)","end","","function wire_ports_metamethods:__newindex ( name, value )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.output\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal output = ent.Outputs[name]","\tif not output then return end","\t","\tWire_TriggerOutput(ent, name, outputConverters[output.Type](value))","end",""],"class":"function","name":"wirelink_methods:isWired","summary":"\nChecks if an input is wired.","private":false,"classlib":"Wirelink","description":"\nChecks if an input is wired.","param":["name"]},"wire_library.getWirelink":{"ret":"Wirelink of the entity","comment":["--- Returns a wirelink to a wire entity","-- @param ent Wire entity","-- @return Wirelink of the entity"],"code":["function wire_library.getWirelink ( ent )","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tent = SF.Entities.Unwrap( ent )","\tif not ent:IsValid() then return end","\t","\tif not ent.extended then","\t\tWireLib.CreateWirelinkOutput( SF.instance.player, ent, {true} )","\tend","\t","\treturn wlwrap(ent)","end","","-- ------------------------- Wirelink ------------------------- --",""],"class":"function","name":"wire_library.getWirelink","summary":"\nReturns a wirelink to a wire entity ","private":false,"library":"wire","description":"\nReturns a wirelink to a wire entity","param":{"1":"ent","ent":"Wire entity"}},"wire_library.adjustOutputs":{"comment":["--- Creates/Modifies wire outputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of output names. May be modified by the function.","-- @param types An array of output types. May be modified by the function."],"code":["function wire_library.adjustOutputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setOutputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create outputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string output name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string output type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match(\"^[%u][%a%d]*$\") then SF.throw( \"Invalid output name: \" .. newname, 2 ) end","\t\tif not outputConverters[newtype] then SF.throw( \"Invalid/unsupported output type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._outputs = {names, types}\t","\tWireLib.AdjustSpecialOutputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustOutputs","summary":"\nCreates/Modifies wire outputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of output types. May be modified by the function.","names":"An array of output names. May be modified by the function."}},"wirelink_methods:outputType":{"comment":["--- Returns the type of output name, or nil if it doesn't exist"],"code":["function wirelink_methods:outputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal output = wl.Outputs[name]","\treturn output and output.Type","end",""],"class":"function","name":"wirelink_methods:outputType","summary":"\nReturns the type of output name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of output name, or nil if it doesn't exist","param":["name"]},"wirelink_methods:outputs":{"comment":["--- Returns a table of all of the wirelink's outputs"],"code":["function wirelink_methods:outputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Outputs = wl.Outputs","\tif not Outputs then return {} end","\t","\tlocal outputNames = {}","\tfor _,port in pairs(Outputs) do","\t\toutputNames[#outputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Outputs[a].Num < Outputs[b].Num","\tend","\ttable.sort(outputNames, portsSorter)","\t","\treturn outputNames","end",""],"class":"function","name":"wirelink_methods:outputs","summary":"\nReturns a table of all of the wirelink's outputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's outputs","param":[]},"wire_library.create":{"comment":["--- Wires two entities together","-- @param entI Entity with input","-- @param entO Entity with output","-- @param inputname Input to be wired","-- @param outputname Output to be wired"],"code":["function wire_library.create ( entI, entO, inputname, outputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( entO, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\tSF.CheckType( outputname, \"string\" )","\t\t","\tlocal entI = SF.Entities.Unwrap( entI )","\tlocal entO = SF.Entities.Unwrap( entO )","\t","\tif not SF.Entities.IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\tif not SF.Entities.IsValid( entO ) then SF.throw( \"Invalid target\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.createWire\" ) or not SF.Permissions.check( SF.instance.player, entO, \"wire.createWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs then SF.throw( \"Source has no valid inputs\" ) end","\tif not entO.Outputs then SF.throw( \"Target has no valid outputs\" ) end","\t","\tif inputname == \"\" then SF.throw( \"Invalid input name\" ) end","\tif outputname == \"\" then SF.throw( \"Invalid output name\" ) end","\t","\tif not entI.Inputs[ inputname ] then SF.throw( \"Invalid source input: \" .. inputname ) end","\tif not entO.Outputs[ outputname ] then SF.throw( \"Invalid source output: \" .. outputname ) end","\tif entI.Inputs[ inputname ].Src then","\t\tlocal CheckInput = entI.Inputs[ inputname ]","\t\tif CheckInput.SrcId == outputname and CheckInput.Src == entO then SF.throw( \"Source \\\"\" .. inputname .. \"\\\" is already wired to target \\\"\" .. outputname .. \"\\\"\" ) end","\tend","\t\t","\tWireLib.Link_Start( SF.instance.player:UniqueID(), entI, entI:WorldToLocal( entI:GetPos() ), inputname, \"cable/rope\", Vector( 255, 255, 255 ), 0 )","\tWireLib.Link_End( SF.instance.player:UniqueID(), entO, entO:WorldToLocal( entO:GetPos() ), outputname, SF.instance.player )","end",""],"class":"function","name":"wire_library.create","summary":"\nWires two entities together ","private":false,"library":"wire","description":"\nWires two entities together","param":{"1":"entI","2":"entO","3":"inputname","4":"outputname","entI":"Entity with input","entO":"Entity with output","inputname":"Input to be wired","outputname":"Output to be wired"}},"SF.Wire.AddInputType":{"summary":"\nAdds an input type ","description":"\nAdds an input type","comment":["--- Adds an input type","-- @param name Input type name. Case insensitive.","-- @param converter The function used to convert the wire data to SF data (eg, wrapping)"],"code":["function SF.Wire.AddInputType(name, converter)","\tinputConverters[name:upper()] = converter","end",""],"private":false,"class":"function","name":"SF.Wire.AddInputType","param":{"1":"name","2":"converter","name":"Input type name. Case insensitive.","converter":"The function used to convert the wire data to SF data (eg, wrapping)"}},"wire_library.getInputs":{"ret":"Table of entity's inputs","comment":["--- Returns a table of entity's inputs","-- @param entI Entity with input(s)","-- @return Table of entity's inputs"],"code":["function wire_library.getInputs ( entI )","\treturn parseEntity( entI, \"Inputs\" )","end",""],"class":"function","name":"wire_library.getInputs","summary":"\nReturns a table of entity's inputs ","private":false,"library":"wire","description":"\nReturns a table of entity's inputs","param":{"1":"entI","entI":"Entity with input(s)"}},"wirelink_methods:inputs":{"comment":["--- Returns a table of all of the wirelink's inputs"],"code":["function wirelink_methods:inputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Inputs = wl.Inputs","\tif not Inputs then return {} end","\t","\tlocal inputNames = {}","\tfor _,port in pairs(Inputs) do","\t\tinputNames[#inputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Inputs[a].Num < Inputs[b].Num","\tend","\ttable.sort(inputNames, portsSorter)","\t","\treturn inputNames","end",""],"class":"function","name":"wirelink_methods:inputs","summary":"\nReturns a table of all of the wirelink's inputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's inputs","param":[]},"wire_library.delete":{"comment":["--- Unwires an entity's input","-- @param entI Entity with input","-- @param inputname Input to be un-wired"],"code":["function wire_library.delete ( entI, inputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\t","\tlocal entI = SF.Entities.Unwrap( entI )","\t","\tif not SF.Entities.IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.deleteWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs or not entI.Inputs[ inputname ] then SF.throw( \"Entity does not have input: \" .. inputname ) end","\tif not entI.Inputs[ inputname ].Src then SF.throw( \"Input \\\"\" .. inputname .. \"\\\" is not wired\" ) end","\t","\tWireLib.Link_Clear( entI, inputname )","end","","local function parseEntity( ent, io )","\t","\tif ent then","\t\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\t\tent = SF.Entities.Unwrap( ent )","\t\tif not SF.Permissions.check( SF.instance.player, ent, \"wire.get\" .. io ) then SF.throw( \"Insufficient permissions\", 2 ) end","\telse","\t\tent = SF.instance.data.entity or nil","\tend","\t","\tif not SF.Entities.IsValid( ent ) then SF.throw( \"Invalid source\" ) end","","\tlocal ret = {}","\tfor k, v in pairs( ent[ io ] ) do","\t\tif k ~= \"\" then","\t\t\ttable.insert( ret, k )","\t\tend","\tend\t","","\treturn ret","end",""],"class":"function","name":"wire_library.delete","summary":"\nUnwires an entity's input ","private":false,"library":"wire","description":"\nUnwires an entity's input","param":{"1":"entI","2":"inputname","entI":"Entity with input","inputname":"Input to be un-wired"}},"wire_library.getOutputs":{"ret":"Table of entity's outputs","comment":["--- Returns a table of entity's outputs","-- @param entO Entity with output(s)","-- @return Table of entity's outputs"],"code":["function wire_library.getOutputs ( entO )","\treturn parseEntity( entO, \"Outputs\" )","end",""],"class":"function","name":"wire_library.getOutputs","summary":"\nReturns a table of entity's outputs ","private":false,"library":"wire","description":"\nReturns a table of entity's outputs","param":{"1":"entO","entO":"Entity with output(s)"}},"wirelink_methods:isValid":{"comment":["--- Checks if a wirelink is valid. (ie. doesn't point to an invalid entity)"],"code":["function wirelink_methods:isValid()","\tSF.CheckType(self,wirelink_metatable)","\treturn wlunwrap(self) and true or false","end",""],"class":"function","name":"wirelink_methods:isValid","summary":"\nChecks if a wirelink is valid.","private":false,"classlib":"Wirelink","description":"\nChecks if a wirelink is valid. (ie. doesn't point to an invalid entity)","param":[]},"wire_library.self":{"comment":["--- Returns the wirelink representing this entity."],"code":["function wire_library.self()","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","\treturn wlwrap(ent)","end",""],"class":"function","name":"wire_library.self","summary":"\nReturns the wirelink representing this entity.","private":false,"library":"wire","description":"\nReturns the wirelink representing this entity.","param":[]},"wirelink_methods:inputType":{"comment":["--- Returns the type of input name, or nil if it doesn't exist"],"code":["function wirelink_methods:inputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal input = wl.Inputs[name]","\treturn input and input.Type","end",""],"class":"function","name":"wirelink_methods:inputType","summary":"\nReturns the type of input name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of input name, or nil if it doesn't exist","param":["name"]},"wire_library.adjustInputs":{"comment":["--- Creates/Modifies wire inputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of input names. May be modified by the function.","-- @param types An array of input types. May be modified by the function."],"code":["function wire_library.adjustInputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setInputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create inputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string input name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string input type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match( \"^[%u][%a%d]*$\" ) then SF.throw( \"Invalid input name: \" .. newname, 2 ) end","\t\tif not inputConverters[ newtype ] then SF.throw( \"Invalid/unsupported input type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._inputs = {names, types}","\tWireLib.AdjustSpecialInputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustInputs","summary":"\nCreates/Modifies wire inputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of input types. May be modified by the function.","names":"An array of input names. May be modified by the function."}},"wirelink_metatable.__newindex":{"summary":"\nWrites to an input.","description":"\nWrites to an input.","comment":["--- Writes to an input."],"code":["wirelink_metatable.__newindex = function(self,k,v)","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.wirelink.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl or not wl:IsValid() or not wl.extended then return end -- TODO: What is wl.extended?","\tif type(k) == \"number\" then","\t\tSF.CheckType(v,\"number\")","\t\tif not wl.WriteCell then return","\t\telse wl:WriteCell(k,v) end","\telse","\t\tlocal input = wl.Inputs and wl.Inputs[k]","\t\tif not input or not outputConverters[input.Type] then return end","\t\tWireLib.TriggerInput(wl,k,outputConverters[input.Type](v))","\tend","end",""],"private":false,"class":"function","name":"wirelink_metatable.__newindex","param":["self","k","v"]}},"doc":[{"summary":"\n \nWire library.","description":"\n \nWire library. \n","comment":["-------------------------------------------------------------------------------","-- Wire library.","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- Wire library. Handles wire inputs/outputs, wirelinks, etc."],"functions":{"1":"adjustInputs","2":"adjustOutputs","3":"create","4":"delete","5":"getInputs","6":"getOutputs","7":"getWirelink","8":"self","adjustOutputs":{"comment":["--- Creates/Modifies wire outputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of output names. May be modified by the function.","-- @param types An array of output types. May be modified by the function."],"code":["function wire_library.adjustOutputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setOutputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create outputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string output name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string output type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match(\"^[%u][%a%d]*$\") then SF.throw( \"Invalid output name: \" .. newname, 2 ) end","\t\tif not outputConverters[newtype] then SF.throw( \"Invalid/unsupported output type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._outputs = {names, types}\t","\tWireLib.AdjustSpecialOutputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustOutputs","summary":"\nCreates/Modifies wire outputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of output types. May be modified by the function.","names":"An array of output names. May be modified by the function."}},"delete":{"comment":["--- Unwires an entity's input","-- @param entI Entity with input","-- @param inputname Input to be un-wired"],"code":["function wire_library.delete ( entI, inputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\t","\tlocal entI = SF.Entities.Unwrap( entI )","\t","\tif not SF.Entities.IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.deleteWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs or not entI.Inputs[ inputname ] then SF.throw( \"Entity does not have input: \" .. inputname ) end","\tif not entI.Inputs[ inputname ].Src then SF.throw( \"Input \\\"\" .. inputname .. \"\\\" is not wired\" ) end","\t","\tWireLib.Link_Clear( entI, inputname )","end","","local function parseEntity( ent, io )","\t","\tif ent then","\t\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\t\tent = SF.Entities.Unwrap( ent )","\t\tif not SF.Permissions.check( SF.instance.player, ent, \"wire.get\" .. io ) then SF.throw( \"Insufficient permissions\", 2 ) end","\telse","\t\tent = SF.instance.data.entity or nil","\tend","\t","\tif not SF.Entities.IsValid( ent ) then SF.throw( \"Invalid source\" ) end","","\tlocal ret = {}","\tfor k, v in pairs( ent[ io ] ) do","\t\tif k ~= \"\" then","\t\t\ttable.insert( ret, k )","\t\tend","\tend\t","","\treturn ret","end",""],"class":"function","name":"wire_library.delete","summary":"\nUnwires an entity's input ","private":false,"library":"wire","description":"\nUnwires an entity's input","param":{"1":"entI","2":"inputname","entI":"Entity with input","inputname":"Input to be un-wired"}},"getWirelink":{"ret":"Wirelink of the entity","comment":["--- Returns a wirelink to a wire entity","-- @param ent Wire entity","-- @return Wirelink of the entity"],"code":["function wire_library.getWirelink ( ent )","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tent = SF.Entities.Unwrap( ent )","\tif not ent:IsValid() then return end","\t","\tif not ent.extended then","\t\tWireLib.CreateWirelinkOutput( SF.instance.player, ent, {true} )","\tend","\t","\treturn wlwrap(ent)","end","","-- ------------------------- Wirelink ------------------------- --",""],"class":"function","name":"wire_library.getWirelink","summary":"\nReturns a wirelink to a wire entity ","private":false,"library":"wire","description":"\nReturns a wirelink to a wire entity","param":{"1":"ent","ent":"Wire entity"}},"self":{"comment":["--- Returns the wirelink representing this entity."],"code":["function wire_library.self()","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","\treturn wlwrap(ent)","end",""],"class":"function","name":"wire_library.self","summary":"\nReturns the wirelink representing this entity.","private":false,"library":"wire","description":"\nReturns the wirelink representing this entity.","param":[]},"getInputs":{"ret":"Table of entity's inputs","comment":["--- Returns a table of entity's inputs","-- @param entI Entity with input(s)","-- @return Table of entity's inputs"],"code":["function wire_library.getInputs ( entI )","\treturn parseEntity( entI, \"Inputs\" )","end",""],"class":"function","name":"wire_library.getInputs","summary":"\nReturns a table of entity's inputs ","private":false,"library":"wire","description":"\nReturns a table of entity's inputs","param":{"1":"entI","entI":"Entity with input(s)"}},"getOutputs":{"ret":"Table of entity's outputs","comment":["--- Returns a table of entity's outputs","-- @param entO Entity with output(s)","-- @return Table of entity's outputs"],"code":["function wire_library.getOutputs ( entO )","\treturn parseEntity( entO, \"Outputs\" )","end",""],"class":"function","name":"wire_library.getOutputs","summary":"\nReturns a table of entity's outputs ","private":false,"library":"wire","description":"\nReturns a table of entity's outputs","param":{"1":"entO","entO":"Entity with output(s)"}},"create":{"comment":["--- Wires two entities together","-- @param entI Entity with input","-- @param entO Entity with output","-- @param inputname Input to be wired","-- @param outputname Output to be wired"],"code":["function wire_library.create ( entI, entO, inputname, outputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( entO, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\tSF.CheckType( outputname, \"string\" )","\t\t","\tlocal entI = SF.Entities.Unwrap( entI )","\tlocal entO = SF.Entities.Unwrap( entO )","\t","\tif not SF.Entities.IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\tif not SF.Entities.IsValid( entO ) then SF.throw( \"Invalid target\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.createWire\" ) or not SF.Permissions.check( SF.instance.player, entO, \"wire.createWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs then SF.throw( \"Source has no valid inputs\" ) end","\tif not entO.Outputs then SF.throw( \"Target has no valid outputs\" ) end","\t","\tif inputname == \"\" then SF.throw( \"Invalid input name\" ) end","\tif outputname == \"\" then SF.throw( \"Invalid output name\" ) end","\t","\tif not entI.Inputs[ inputname ] then SF.throw( \"Invalid source input: \" .. inputname ) end","\tif not entO.Outputs[ outputname ] then SF.throw( \"Invalid source output: \" .. outputname ) end","\tif entI.Inputs[ inputname ].Src then","\t\tlocal CheckInput = entI.Inputs[ inputname ]","\t\tif CheckInput.SrcId == outputname and CheckInput.Src == entO then SF.throw( \"Source \\\"\" .. inputname .. \"\\\" is already wired to target \\\"\" .. outputname .. \"\\\"\" ) end","\tend","\t\t","\tWireLib.Link_Start( SF.instance.player:UniqueID(), entI, entI:WorldToLocal( entI:GetPos() ), inputname, \"cable/rope\", Vector( 255, 255, 255 ), 0 )","\tWireLib.Link_End( SF.instance.player:UniqueID(), entO, entO:WorldToLocal( entO:GetPos() ), outputname, SF.instance.player )","end",""],"class":"function","name":"wire_library.create","summary":"\nWires two entities together ","private":false,"library":"wire","description":"\nWires two entities together","param":{"1":"entI","2":"entO","3":"inputname","4":"outputname","entI":"Entity with input","entO":"Entity with output","inputname":"Input to be wired","outputname":"Output to be wired"}},"adjustInputs":{"comment":["--- Creates/Modifies wire inputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of input names. May be modified by the function.","-- @param types An array of input types. May be modified by the function."],"code":["function wire_library.adjustInputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setInputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create inputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string input name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string input type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match( \"^[%u][%a%d]*$\" ) then SF.throw( \"Invalid input name: \" .. newname, 2 ) end","\t\tif not inputConverters[ newtype ] then SF.throw( \"Invalid/unsupported input type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._inputs = {names, types}","\tWireLib.AdjustSpecialInputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustInputs","summary":"\nCreates/Modifies wire inputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of input types. May be modified by the function.","names":"An array of input names. May be modified by the function."}}},"class":"library","fields":[],"name":"wire","summary":"\nWire library.","description":"\nWire library. Handles wire inputs/outputs, wirelinks, etc.","libtbl":"wire_library","tables":{"1":"ports","ports":{"description":"\nPorts table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.","code":["wire_library.ports = setmetatable({},wire_ports_metamethods)","","-- ------------------------- Hook Documentation ------------------------- --",""],"class":"table","classForced":true,"name":"wire_library.ports","summary":"\nPorts table.","library":"wire","comment":["--- Ports table. Reads from this table will read from the wire input","-- of the same name. Writes will write to the wire output of the same name.","-- @class table","-- @name wire_library.ports"],"param":[]}},"code":["local wire_library, wire_metamethods = SF.Libraries.Register( \"wire\" )","","function wire_metamethods.onLoad ( instance )","\tif not WireLib then return end","\tlocal ent = instance.data.entity","\tif ent.Inputs == nil then","\t\tWireLib.CreateInputs( ent, {} )","\tend","\tif ent.Outputs == nil then","\t\tWireLib.CreateOutputs( ent, {} )","\tend","","\tfunction ent:TriggerInput ( key, value )","\t\tlocal tmp = SF.instance","\t\tSF.instance = nil","\t\tself:runScriptHook( \"input\", key, SF.Wire.InputConverters[ self.Inputs[ key ].Type ]( value ) )","\t\tSF.instance = tmp","\tend","","\tfunction ent:ReadCell ( address )","\t\tlocal tmp = SF.instance","\t\tSF.instance = nil","\t\tlocal ret = tonumber( self:runScriptHookForResult( \"readcell\", address ) ) or 0","\t\tSF.instance = tmp","\t\treturn ret","\tend","","\tfunction ent:WriteCell ( address, data )","\t\tlocal tmp = SF.instance","\t\tSF.instance = nil","\t\tself:runScriptHook( \"writecell\", address, data )","\t\tSF.instance = tmp","\tend","","end","","SF.Wire = {}","SF.Wire.Library = wire_library",""]},{"comment":["--- Wirelink type","-- @server"],"code":["local wirelink_methods, wirelink_metatable = SF.Typedef(\"Wirelink\")","local wlwrap, wlunwrap = SF.CreateWrapper(wirelink_metatable,true,true)","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"wire.setOutputs\", \"Set outputs\", \"Allows the user to specify the set of outputs\" )","\tP.registerPrivilege( \"wire.setInputs\", \"Set inputs\", \"Allows the user to specify the set of inputs\" )","\tP.registerPrivilege( \"wire.output\", \"Output\", \"Allows the user to set the value of an output\" )","\tP.registerPrivilege( \"wire.input\", \"Input\", \"Allows the user to read the value of an input\" )","\tP.registerPrivilege( \"wire.wirelink.read\", \"Wirelink Read\", \"Allows the user to read from wirelink\" )","\tP.registerPrivilege( \"wire.wirelink.write\", \"Wirelink Write\", \"Allows the user to write to wirelink\" )","\tP.registerPrivilege( \"wire.createWire\", \"Create Wire\", \"Allows the user to create a wire between two entities\" )","\tP.registerPrivilege( \"wire.deleteWire\", \"Delete Wire\", \"Allows the user to delete a wire between two entities\" )","\tP.registerPrivilege( \"wire.getInputs\", \"Get Inputs\", \"Allows the user to get Inputs of an entity\" )","\tP.registerPrivilege( \"wire.getOutputs\", \"Get Outputs\", \"Allows the user to get Outputs of an entity\" )","end",""],"typtbl":"wirelink_methods","fields":[],"name":"Wirelink","summary":"\nWirelink type ","server":true,"description":"\nWirelink type","class":"class","methods":{"1":"entity","2":"inputType","3":"inputs","4":"isValid","5":"isWired","6":"outputType","7":"outputs","isValid":{"comment":["--- Checks if a wirelink is valid. (ie. doesn't point to an invalid entity)"],"code":["function wirelink_methods:isValid()","\tSF.CheckType(self,wirelink_metatable)","\treturn wlunwrap(self) and true or false","end",""],"class":"function","name":"wirelink_methods:isValid","summary":"\nChecks if a wirelink is valid.","private":false,"classlib":"Wirelink","description":"\nChecks if a wirelink is valid. (ie. doesn't point to an invalid entity)","param":[]},"inputType":{"comment":["--- Returns the type of input name, or nil if it doesn't exist"],"code":["function wirelink_methods:inputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal input = wl.Inputs[name]","\treturn input and input.Type","end",""],"class":"function","name":"wirelink_methods:inputType","summary":"\nReturns the type of input name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of input name, or nil if it doesn't exist","param":["name"]},"outputType":{"comment":["--- Returns the type of output name, or nil if it doesn't exist"],"code":["function wirelink_methods:outputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal output = wl.Outputs[name]","\treturn output and output.Type","end",""],"class":"function","name":"wirelink_methods:outputType","summary":"\nReturns the type of output name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of output name, or nil if it doesn't exist","param":["name"]},"entity":{"comment":["--- Returns the entity that the wirelink represents"],"code":["function wirelink_methods:entity()","\tSF.CheckType(self,wirelink_metatable)","\treturn SF.Entities.Wrap(wlunwrap(self))","end",""],"class":"function","name":"wirelink_methods:entity","summary":"\nReturns the entity that the wirelink represents ","private":false,"classlib":"Wirelink","description":"\nReturns the entity that the wirelink represents","param":[]},"isWired":{"comment":["--- Checks if an input is wired."],"code":["function wirelink_methods:isWired(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then return true","\telse return false end","end","","-- ------------------------- Ports Metatable ------------------------- --","local wire_ports_methods, wire_ports_metamethods = SF.Typedef(\"Ports\")","","function wire_ports_metamethods:__index ( name )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal input = ent.Inputs[name]","\tif not (input and input.Src and input.Src:IsValid()) then","\t\treturn nil","\tend","\treturn inputConverters[ent.Inputs[name].Type](ent.Inputs[name].Value)","end","","function wire_ports_metamethods:__newindex ( name, value )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.output\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal output = ent.Outputs[name]","\tif not output then return end","\t","\tWire_TriggerOutput(ent, name, outputConverters[output.Type](value))","end",""],"class":"function","name":"wirelink_methods:isWired","summary":"\nChecks if an input is wired.","private":false,"classlib":"Wirelink","description":"\nChecks if an input is wired.","param":["name"]},"inputs":{"comment":["--- Returns a table of all of the wirelink's inputs"],"code":["function wirelink_methods:inputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Inputs = wl.Inputs","\tif not Inputs then return {} end","\t","\tlocal inputNames = {}","\tfor _,port in pairs(Inputs) do","\t\tinputNames[#inputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Inputs[a].Num < Inputs[b].Num","\tend","\ttable.sort(inputNames, portsSorter)","\t","\treturn inputNames","end",""],"class":"function","name":"wirelink_methods:inputs","summary":"\nReturns a table of all of the wirelink's inputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's inputs","param":[]},"outputs":{"comment":["--- Returns a table of all of the wirelink's outputs"],"code":["function wirelink_methods:outputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Outputs = wl.Outputs","\tif not Outputs then return {} end","\t","\tlocal outputNames = {}","\tfor _,port in pairs(Outputs) do","\t\toutputNames[#outputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Outputs[a].Num < Outputs[b].Num","\tend","\ttable.sort(outputNames, portsSorter)","\t","\treturn outputNames","end",""],"class":"function","name":"wirelink_methods:outputs","summary":"\nReturns a table of all of the wirelink's outputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's outputs","param":[]}}},{"classForced":true,"summary":"\n ","comment":["---","-- @class table","-- @name SF.Wire.WlMetatable"],"code":["SF.Wire.WlMetatable = wirelink_metatable","SF.Wire.WlMethods = wirelink_methods",""],"name":"SF.Wire.WlMetatable","class":"table","description":"\n","param":[]},{"classForced":true,"summary":"\n ","comment":["---","-- @class function","-- @name SF.Wire.WlWrap","-- @param wirelink"],"code":["SF.Wire.WlWrap = wlwrap",""],"name":"SF.Wire.WlWrap","class":"function","description":"\n","param":{"1":"wirelink","wirelink":""}},{"classForced":true,"summary":"\n ","comment":["---","-- @class function","-- @name SF.Wire.WlUnwrap","-- @param wrapped"],"code":["SF.Wire.WlUnwrap = wlunwrap","","-- ------------------------- Internal Library ------------------------- --","","-- Allowed Expression2's types in tables and their short names","local expression2types = {","\tn = \"NORMAL\",","\ts = \"STRING\",","\tv = \"VECTOR\",","\ta = \"ANGLE\",","\txwl = \"WIRELINK\",","\te = \"ENTITY\",","\tt = \"TABLE\"","}","","local function convertFromExpression2(value, shortTypeName)","\tlocal typ = expression2types[shortTypeName]","\tif not typ or not SF.Wire.InputConverters[typ] then return nil end","","\treturn SF.Wire.InputConverters[typ](value)","end","","local function convertToExpression2(value)","\tlocal typ = type(value)","","\t-- Simple type?","\tif typ == \"number\" then return value, \"n\"","\telseif typ == \"string\" then return value, \"s\"","\telseif typ == \"Vector\" then return {value.x, value.y, value.z}, \"v\"","\telseif typ == \"Angle\" then return {value.p, value.y, value.r}, \"a\"","","\t-- We've got a table there. Is it wrapped object?","\telseif typ == \"table\" then","\t\tlocal value = SF.Unsanitize(value)","\t\ttyp = type(value)","","\t\tif typ == \"table\" then ","\t\t\t-- It is still table, do recursive convert","\t\t\treturn SF.Wire.OutputConverters.TABLE(value), \"t\"","","\t\t-- Unwrapped entity (wirelink goes to this, but it returns it as entity; don't think somebody needs to put wirelinks in table)","\t\telseif typ == \"Entity\" then return value, \"e\" end","\tend","","\t-- Nothing found / unallowed type","\treturn nil, nil","end","","local function identity(data) return data end","local inputConverters =","{","\tNORMAL = identity,","\tSTRING = identity,","\tVECTOR = identity,","\tANGLE = identity,","\tWIRELINK = wlwrap,","\tENTITY = vwrap,","","\tTABLE = function(tbl)","\t\tif not tbl.s or not tbl.stypes or not tbl.n or not tbl.ntypes or not tbl.size then return {} end","\t\tif tbl.size == 0 then return {} end -- Don't waste our time","\t\tlocal conv = {}","","\t\t-- Key-numeric part of table","\t\tfor key, typ in pairs(tbl.ntypes) do","\t\t\tconv[key] = convertFromExpression2(tbl.n[key], typ)","\t\tend","","\t\t-- Key-string part of table","\t\tfor key, typ in pairs(tbl.stypes) do","\t\t\tconv[key] = convertFromExpression2(tbl.s[key], typ)","\t\tend","","\t\treturn conv","\tend","}","","local outputConverters =","{","\tNORMAL = function(data)","\t\tSF.CheckType(data,\"number\",1)","\t\treturn data","\tend,","\tNUMBER = function(data)","\t\tSF.CheckType(data,\"number\",1)","\t\treturn data","\tend,","\tSTRING = function(data)","\t\tSF.CheckType(data,\"string\",1)","\t\treturn data","\tend,","\tVECTOR = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Vector\" ], 1 )","\t\treturn vunwrap( data )","\tend,","\tANGLE = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Angle\" ], 1 )","\t\treturn vunwrap( data )","\tend,","\tENTITY = function ( data )","\t\tSF.CheckType( data, SF.Types[ \"Entity\" ] )","\t\treturn vunwrap( data )","\tend,","","\tTABLE = function(data)","\t\tSF.CheckType(data,\"table\",1)","","\t\tlocal tbl = {istable=true, size=0, n={}, ntypes={}, s={}, stypes={}}","","\t\tfor key, value in pairs(data) do","\t\t\tlocal value, shortType = convertToExpression2(value)","","\t\t\tif shortType then","\t\t\t\tif type(key) == \"string\" then","\t\t\t\t\ttbl.s[key] = value","\t\t\t\t\ttbl.stypes[key] = shortType","\t\t\t\t\ttbl.size = tbl.size+1","","\t\t\t\telseif type(key) == \"number\" then","\t\t\t\t\ttbl.n[key] = value","\t\t\t\t\ttbl.ntypes[key] = shortType","\t\t\t\t\ttbl.size = tbl.size+1","\t\t\t\tend","\t\t\tend","\t\tend","","\t\treturn tbl","\tend","}","","SF.Wire.InputConverters = inputConverters","SF.Wire.OutputConverters = outputConverters",""],"name":"SF.Wire.WlUnwrap","class":"function","description":"\n","param":{"1":"wrapped","wrapped":""}},{"summary":"\nAdds an input type ","description":"\nAdds an input type","comment":["--- Adds an input type","-- @param name Input type name. Case insensitive.","-- @param converter The function used to convert the wire data to SF data (eg, wrapping)"],"code":["function SF.Wire.AddInputType(name, converter)","\tinputConverters[name:upper()] = converter","end",""],"private":false,"class":"function","name":"SF.Wire.AddInputType","param":{"1":"name","2":"converter","name":"Input type name. Case insensitive.","converter":"The function used to convert the wire data to SF data (eg, wrapping)"}},{"summary":"\nAdds an output type ","description":"\nAdds an output type","comment":["--- Adds an output type","-- @param name Output type name. Case insensitive.","-- @param deconverter The function used to check for the appropriate type and convert the SF data to wire data (eg, unwrapping)"],"code":["function SF.Wire.AddOutputType(name, deconverter)","\toutputConverters[name:upper()] = deconverter","end","","-- ------------------------- Basic Wire Functions ------------------------- --",""],"private":false,"class":"function","name":"SF.Wire.AddOutputType","param":{"1":"name","2":"deconverter","name":"Output type name. Case insensitive.","deconverter":"The function used to check for the appropriate type and convert the SF data to wire data (eg, unwrapping)"}},{"comment":["--- Creates/Modifies wire inputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of input names. May be modified by the function.","-- @param types An array of input types. May be modified by the function."],"code":["function wire_library.adjustInputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setInputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create inputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string input name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string input type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match( \"^[%u][%a%d]*$\" ) then SF.throw( \"Invalid input name: \" .. newname, 2 ) end","\t\tif not inputConverters[ newtype ] then SF.throw( \"Invalid/unsupported input type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._inputs = {names, types}","\tWireLib.AdjustSpecialInputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustInputs","summary":"\nCreates/Modifies wire inputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire inputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of input types. May be modified by the function.","names":"An array of input names. May be modified by the function."}},{"comment":["--- Creates/Modifies wire outputs. All wire ports must begin with an uppercase","-- letter and contain only alphabetical characters.","-- @param names An array of output names. May be modified by the function.","-- @param types An array of output types. May be modified by the function."],"code":["function wire_library.adjustOutputs ( names, types )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.setOutputs\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(names,\"table\")","\tSF.CheckType(types,\"table\")","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity to create outputs on\", 2 ) end","\t","\tif #names ~= #types then SF.throw( \"Table lengths not equal\", 2 ) end","\tfor i=1,#names do","\t\tlocal newname = names[i]","\t\tlocal newtype = types[i]","\t\tif type(newname) ~= \"string\" then SF.throw( \"Non-string output name: \" .. newname, 2 ) end","\t\tif type(newtype) ~= \"string\" then SF.throw( \"Non-string output type: \" .. newtype, 2 ) end","\t\tnewtype = newtype:upper()","\t\tif not newname:match(\"^[%u][%a%d]*$\") then SF.throw( \"Invalid output name: \" .. newname, 2 ) end","\t\tif not outputConverters[newtype] then SF.throw( \"Invalid/unsupported output type: \" .. newtype, 2 ) end","\t\tnames[i] = newname","\t\ttypes[i] = newtype","\tend","\tent._outputs = {names, types}\t","\tWireLib.AdjustSpecialOutputs(ent,names,types)","end",""],"class":"function","name":"wire_library.adjustOutputs","summary":"\nCreates/Modifies wire outputs.","private":false,"library":"wire","description":"\nCreates/Modifies wire outputs. All wire ports must begin with an uppercase \nletter and contain only alphabetical characters.","param":{"1":"names","2":"types","types":"An array of output types. May be modified by the function.","names":"An array of output names. May be modified by the function."}},{"comment":["--- Returns the wirelink representing this entity."],"code":["function wire_library.self()","\tlocal ent = SF.instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","\treturn wlwrap(ent)","end",""],"class":"function","name":"wire_library.self","summary":"\nReturns the wirelink representing this entity.","private":false,"library":"wire","description":"\nReturns the wirelink representing this entity.","param":[]},{"comment":["--- Wires two entities together","-- @param entI Entity with input","-- @param entO Entity with output","-- @param inputname Input to be wired","-- @param outputname Output to be wired"],"code":["function wire_library.create ( entI, entO, inputname, outputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( entO, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\tSF.CheckType( outputname, \"string\" )","\t\t","\tlocal entI = SF.Entities.Unwrap( entI )","\tlocal entO = SF.Entities.Unwrap( entO )","\t","\tif not SF.Entities.IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\tif not SF.Entities.IsValid( entO ) then SF.throw( \"Invalid target\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.createWire\" ) or not SF.Permissions.check( SF.instance.player, entO, \"wire.createWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs then SF.throw( \"Source has no valid inputs\" ) end","\tif not entO.Outputs then SF.throw( \"Target has no valid outputs\" ) end","\t","\tif inputname == \"\" then SF.throw( \"Invalid input name\" ) end","\tif outputname == \"\" then SF.throw( \"Invalid output name\" ) end","\t","\tif not entI.Inputs[ inputname ] then SF.throw( \"Invalid source input: \" .. inputname ) end","\tif not entO.Outputs[ outputname ] then SF.throw( \"Invalid source output: \" .. outputname ) end","\tif entI.Inputs[ inputname ].Src then","\t\tlocal CheckInput = entI.Inputs[ inputname ]","\t\tif CheckInput.SrcId == outputname and CheckInput.Src == entO then SF.throw( \"Source \\\"\" .. inputname .. \"\\\" is already wired to target \\\"\" .. outputname .. \"\\\"\" ) end","\tend","\t\t","\tWireLib.Link_Start( SF.instance.player:UniqueID(), entI, entI:WorldToLocal( entI:GetPos() ), inputname, \"cable/rope\", Vector( 255, 255, 255 ), 0 )","\tWireLib.Link_End( SF.instance.player:UniqueID(), entO, entO:WorldToLocal( entO:GetPos() ), outputname, SF.instance.player )","end",""],"class":"function","name":"wire_library.create","summary":"\nWires two entities together ","private":false,"library":"wire","description":"\nWires two entities together","param":{"1":"entI","2":"entO","3":"inputname","4":"outputname","entI":"Entity with input","entO":"Entity with output","inputname":"Input to be wired","outputname":"Output to be wired"}},{"comment":["--- Unwires an entity's input","-- @param entI Entity with input","-- @param inputname Input to be un-wired"],"code":["function wire_library.delete ( entI, inputname )","\tSF.CheckType( entI, SF.Types[ \"Entity\" ] )","\tSF.CheckType( inputname, \"string\" )","\t","\tlocal entI = SF.Entities.Unwrap( entI )","\t","\tif not SF.Entities.IsValid( entI ) then SF.throw( \"Invalid source\" ) end","\t","\tif not SF.Permissions.check( SF.instance.player, entI, \"wire.deleteWire\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif not entI.Inputs or not entI.Inputs[ inputname ] then SF.throw( \"Entity does not have input: \" .. inputname ) end","\tif not entI.Inputs[ inputname ].Src then SF.throw( \"Input \\\"\" .. inputname .. \"\\\" is not wired\" ) end","\t","\tWireLib.Link_Clear( entI, inputname )","end","","local function parseEntity( ent, io )","\t","\tif ent then","\t\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\t\tent = SF.Entities.Unwrap( ent )","\t\tif not SF.Permissions.check( SF.instance.player, ent, \"wire.get\" .. io ) then SF.throw( \"Insufficient permissions\", 2 ) end","\telse","\t\tent = SF.instance.data.entity or nil","\tend","\t","\tif not SF.Entities.IsValid( ent ) then SF.throw( \"Invalid source\" ) end","","\tlocal ret = {}","\tfor k, v in pairs( ent[ io ] ) do","\t\tif k ~= \"\" then","\t\t\ttable.insert( ret, k )","\t\tend","\tend\t","","\treturn ret","end",""],"class":"function","name":"wire_library.delete","summary":"\nUnwires an entity's input ","private":false,"library":"wire","description":"\nUnwires an entity's input","param":{"1":"entI","2":"inputname","entI":"Entity with input","inputname":"Input to be un-wired"}},{"ret":"Table of entity's inputs","comment":["--- Returns a table of entity's inputs","-- @param entI Entity with input(s)","-- @return Table of entity's inputs"],"code":["function wire_library.getInputs ( entI )","\treturn parseEntity( entI, \"Inputs\" )","end",""],"class":"function","name":"wire_library.getInputs","summary":"\nReturns a table of entity's inputs ","private":false,"library":"wire","description":"\nReturns a table of entity's inputs","param":{"1":"entI","entI":"Entity with input(s)"}},{"ret":"Table of entity's outputs","comment":["--- Returns a table of entity's outputs","-- @param entO Entity with output(s)","-- @return Table of entity's outputs"],"code":["function wire_library.getOutputs ( entO )","\treturn parseEntity( entO, \"Outputs\" )","end",""],"class":"function","name":"wire_library.getOutputs","summary":"\nReturns a table of entity's outputs ","private":false,"library":"wire","description":"\nReturns a table of entity's outputs","param":{"1":"entO","entO":"Entity with output(s)"}},{"ret":"Wirelink of the entity","comment":["--- Returns a wirelink to a wire entity","-- @param ent Wire entity","-- @return Wirelink of the entity"],"code":["function wire_library.getWirelink ( ent )","\tSF.CheckType( ent, SF.Types[ \"Entity\" ] )","\tent = SF.Entities.Unwrap( ent )","\tif not ent:IsValid() then return end","\t","\tif not ent.extended then","\t\tWireLib.CreateWirelinkOutput( SF.instance.player, ent, {true} )","\tend","\t","\treturn wlwrap(ent)","end","","-- ------------------------- Wirelink ------------------------- --",""],"class":"function","name":"wire_library.getWirelink","summary":"\nReturns a wirelink to a wire entity ","private":false,"library":"wire","description":"\nReturns a wirelink to a wire entity","param":{"1":"ent","ent":"Wire entity"}},{"summary":"\nRetrieves an output.","description":"\nRetrieves an output. Returns nil if the output doesn't exist.","comment":["--- Retrieves an output. Returns nil if the output doesn't exist."],"code":["wirelink_metatable.__index = function(self,k)","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.wirelink.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(self,wirelink_metatable)","\tif wirelink_methods[k] then","\t\treturn wirelink_methods[k]","\telse","\t\tlocal wl = wlunwrap(self)","\t\tif not wl or not wl:IsValid() or not wl.extended then return end -- TODO: What is wl.extended?","\t\t","\t\tif type(k) == \"number\" then","\t\t\treturn wl.ReadCell and wl:ReadCell(k) or nil","\t\telse","\t\t\tlocal output = wl.Outputs and wl.Outputs[k]","\t\t\tif not output or not inputConverters[output.Type] then return end","\t\t\treturn inputConverters[output.Type](output.Value)","\t\tend","\tend","end",""],"private":false,"class":"function","name":"wirelink_metatable.__index","param":["self","k"]},{"summary":"\nWrites to an input.","description":"\nWrites to an input.","comment":["--- Writes to an input."],"code":["wirelink_metatable.__newindex = function(self,k,v)","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.wirelink.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl or not wl:IsValid() or not wl.extended then return end -- TODO: What is wl.extended?","\tif type(k) == \"number\" then","\t\tSF.CheckType(v,\"number\")","\t\tif not wl.WriteCell then return","\t\telse wl:WriteCell(k,v) end","\telse","\t\tlocal input = wl.Inputs and wl.Inputs[k]","\t\tif not input or not outputConverters[input.Type] then return end","\t\tWireLib.TriggerInput(wl,k,outputConverters[input.Type](v))","\tend","end",""],"private":false,"class":"function","name":"wirelink_metatable.__newindex","param":["self","k","v"]},{"comment":["--- Checks if a wirelink is valid. (ie. doesn't point to an invalid entity)"],"code":["function wirelink_methods:isValid()","\tSF.CheckType(self,wirelink_metatable)","\treturn wlunwrap(self) and true or false","end",""],"class":"function","name":"wirelink_methods:isValid","summary":"\nChecks if a wirelink is valid.","private":false,"classlib":"Wirelink","description":"\nChecks if a wirelink is valid. (ie. doesn't point to an invalid entity)","param":[]},{"comment":["--- Returns the type of input name, or nil if it doesn't exist"],"code":["function wirelink_methods:inputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal input = wl.Inputs[name]","\treturn input and input.Type","end",""],"class":"function","name":"wirelink_methods:inputType","summary":"\nReturns the type of input name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of input name, or nil if it doesn't exist","param":["name"]},{"comment":["--- Returns the type of output name, or nil if it doesn't exist"],"code":["function wirelink_methods:outputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal output = wl.Outputs[name]","\treturn output and output.Type","end",""],"class":"function","name":"wirelink_methods:outputType","summary":"\nReturns the type of output name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of output name, or nil if it doesn't exist","param":["name"]},{"comment":["--- Returns the entity that the wirelink represents"],"code":["function wirelink_methods:entity()","\tSF.CheckType(self,wirelink_metatable)","\treturn SF.Entities.Wrap(wlunwrap(self))","end",""],"class":"function","name":"wirelink_methods:entity","summary":"\nReturns the entity that the wirelink represents ","private":false,"classlib":"Wirelink","description":"\nReturns the entity that the wirelink represents","param":[]},{"comment":["--- Returns a table of all of the wirelink's inputs"],"code":["function wirelink_methods:inputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Inputs = wl.Inputs","\tif not Inputs then return {} end","\t","\tlocal inputNames = {}","\tfor _,port in pairs(Inputs) do","\t\tinputNames[#inputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Inputs[a].Num < Inputs[b].Num","\tend","\ttable.sort(inputNames, portsSorter)","\t","\treturn inputNames","end",""],"class":"function","name":"wirelink_methods:inputs","summary":"\nReturns a table of all of the wirelink's inputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's inputs","param":[]},{"comment":["--- Returns a table of all of the wirelink's outputs"],"code":["function wirelink_methods:outputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Outputs = wl.Outputs","\tif not Outputs then return {} end","\t","\tlocal outputNames = {}","\tfor _,port in pairs(Outputs) do","\t\toutputNames[#outputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Outputs[a].Num < Outputs[b].Num","\tend","\ttable.sort(outputNames, portsSorter)","\t","\treturn outputNames","end",""],"class":"function","name":"wirelink_methods:outputs","summary":"\nReturns a table of all of the wirelink's outputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's outputs","param":[]},{"comment":["--- Checks if an input is wired."],"code":["function wirelink_methods:isWired(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then return true","\telse return false end","end","","-- ------------------------- Ports Metatable ------------------------- --","local wire_ports_methods, wire_ports_metamethods = SF.Typedef(\"Ports\")","","function wire_ports_metamethods:__index ( name )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal input = ent.Inputs[name]","\tif not (input and input.Src and input.Src:IsValid()) then","\t\treturn nil","\tend","\treturn inputConverters[ent.Inputs[name].Type](ent.Inputs[name].Value)","end","","function wire_ports_metamethods:__newindex ( name, value )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.output\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal output = ent.Outputs[name]","\tif not output then return end","\t","\tWire_TriggerOutput(ent, name, outputConverters[output.Type](value))","end",""],"class":"function","name":"wirelink_methods:isWired","summary":"\nChecks if an input is wired.","private":false,"classlib":"Wirelink","description":"\nChecks if an input is wired.","param":["name"]},{"description":"\nPorts table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.","code":["wire_library.ports = setmetatable({},wire_ports_metamethods)","","-- ------------------------- Hook Documentation ------------------------- --",""],"class":"table","classForced":true,"name":"wire_library.ports","summary":"\nPorts table.","library":"wire","comment":["--- Ports table. Reads from this table will read from the wire input","-- of the same name. Writes will write to the wire output of the same name.","-- @class table","-- @name wire_library.ports"],"param":[]},{"classForced":true,"summary":"\nCalled when an input on a wired SF chip is written to ","comment":["--- Called when an input on a wired SF chip is written to","-- @name input","-- @class hook","-- @param input The input name","-- @param value The value of the input"],"code":[""],"description":"\nCalled when an input on a wired SF chip is written to","class":"hook","name":"input","param":{"1":"input","2":"value","input":"The input name","value":"The value of the input"}},{"ret":"The value read","description":"\nCalled when a high speed device reads from a wired SF chip","code":[""],"class":"hook","classForced":true,"name":"readcell","summary":"\nCalled when a high speed device reads from a wired SF chip ","server":true,"comment":["--- Called when a high speed device reads from a wired SF chip","-- @name readcell","-- @class hook","-- @server","-- @param address The address requested","-- @return The value read"],"param":{"1":"address","address":"The address requested"}},{"classForced":true,"summary":"\nCalled when a high speed device writes to a wired SF chip ","comment":["--- Called when a high speed device writes to a wired SF chip","-- @name writecell","-- @class hook","-- @param address The address written to","-- @param data The data being written"],"code":[],"description":"\nCalled when a high speed device writes to a wired SF chip","class":"hook","name":"writecell","param":{"1":"address","2":"data","data":"The data being written","address":"The address written to"}}],"tables":{"1":"SF.Wire.WlMetatable","2":"wire_library.ports","wire_library.ports":{"description":"\nPorts table. Reads from this table will read from the wire input \nof the same name. Writes will write to the wire output of the same name.","code":["wire_library.ports = setmetatable({},wire_ports_metamethods)","","-- ------------------------- Hook Documentation ------------------------- --",""],"class":"table","classForced":true,"name":"wire_library.ports","summary":"\nPorts table.","library":"wire","comment":["--- Ports table. Reads from this table will read from the wire input","-- of the same name. Writes will write to the wire output of the same name.","-- @class table","-- @name wire_library.ports"],"param":[]},"SF.Wire.WlMetatable":{"classForced":true,"summary":"\n ","comment":["---","-- @class table","-- @name SF.Wire.WlMetatable"],"code":["SF.Wire.WlMetatable = wirelink_metatable","SF.Wire.WlMethods = wirelink_methods",""],"name":"SF.Wire.WlMetatable","class":"table","description":"\n","param":[]}},"description":"\n \nWire library. \n","summary":"\n \nWire library."},"sflib.lua":{"libraries":[],"type":"file","name":"sflib.lua","functions":{"1":"SF.AddObjectUnwrapper","2":"SF.AddObjectWrapper","3":"SF.CheckType","4":"SF.CreateContext","5":"SF.CreateWrapper","6":"SF.DeserializeCode","7":"SF.GetType","8":"SF.RequestCode","9":"SF.RunScriptHook","10":"SF.Sanitize","11":"SF.SerializeCode","12":"SF.Unsanitize","13":"SF.UnwrapObject","14":"SF.WrapFunction","15":"SF.WrapObject","16":"SF.WrappedFunctionInstance","17":"SF.throw","SF.AddObjectUnwrapper":{"summary":"\nHelper function for adding custom unwrappers ","description":"\nHelper function for adding custom unwrappers","comment":["--- Helper function for adding custom unwrappers","-- @param object_meta metatable of object","-- @param unwrapper function that unwraps object"],"code":["function SF.AddObjectUnwrapper( object_meta, unwrapper )","\tobject_meta.__unwrap = unwrapper","end",""],"private":false,"class":"function","name":"SF.AddObjectUnwrapper","param":{"1":"object_meta","2":"unwrapper","unwrapper":"function that unwraps object","object_meta":"metatable of object"}},"SF.CreateContext":{"summary":"\nCreates a new context.","description":"\nCreates a new context. A context is used to define what scripts will have access to.","comment":["--- Creates a new context. A context is used to define what scripts will have access to.","-- @param env The environment metatable to use for the script. Default is SF.DefaultEnvironmentMT","-- @param directives Additional Preprocessor directives to use. Default is an empty table","-- @param cpuTime Operations quota function. Default is specified by the convar \"sf_defaultquota\" and returned when calling ops()","-- @param libs Additional (local) libraries for the script to access. Default is an empty table."],"code":["function SF.CreateContext ( env, directives, cpuTime, libs )","\tlocal context = {}","\tcontext.env = env or SF.DefaultEnvironmentMT","\tcontext.directives = directives or {}","\tcontext.cpuTime = cpuTime or {","\t\tgetBufferN = function () return SF.cpuBufferN:GetInt() or 3 end,","\t\tgetMax = function () return SF.cpuQuota:GetFloat() end","\t}","\tcontext.libs = libs or {}","\treturn context","end",""],"private":false,"class":"function","name":"SF.CreateContext","param":{"1":"env","2":"directives","3":"cpuTime","4":"libs","env":"The environment metatable to use for the script. Default is SF.DefaultEnvironmentMT","directives":"Additional Preprocessor directives to use. Default is an empty table","cpuTime":"Operations quota function. Default is specified by the convar \"sf_defaultquota\" and returned when calling ops()","libs":"Additional (local) libraries for the script to access. Default is an empty table."}},"SF.SerializeCode":{"summary":"\nSerializes an instance's code in a format compatible with the duplicator library ","description":"\nSerializes an instance's code in a format compatible with the duplicator library","comment":["--- Serializes an instance's code in a format compatible with the duplicator library","-- @param sources The table of filename = source entries. Ususally instance.source","-- @param mainfile The main filename. Usually instance.mainfile"],"code":["function SF.SerializeCode(sources, mainfile)","\tlocal rt = {source = {}}","\tfor filename, source in pairs(sources) do","\t\trt.source[filename] = string.gsub(source, serialize_replace_regex, serialize_replace_tbl)","\tend","\trt.mainfile = mainfile","\treturn rt","end","","local deserialize_replace_regex = \"[\" .. string.char( 5 ) .. string.char( 4 ) .. \"]\"","local deserialize_replace_tbl = { [ string.char( 5 )[ 1 ] ] = \"\\n\", [ string.char( 4 )[ 1 ] ] = '\"' }"],"private":false,"class":"function","name":"SF.SerializeCode","param":{"1":"sources","2":"mainfile","mainfile":"The main filename. Usually instance.mainfile","sources":"The table of filename = source entries. Ususally instance.source"}},"SF.AddObjectWrapper":{"summary":"\nHelper function for adding custom wrappers ","description":"\nHelper function for adding custom wrappers","comment":["--- Helper function for adding custom wrappers","-- @param object_meta metatable of object","-- @param sf_object_meta starfall metatable of object","-- @param wrapper function that wraps object"],"code":["function SF.AddObjectWrapper( object_meta, sf_object_meta, wrapper )","\tsf_object_meta.__wrap = wrapper","\tobject_wrappers[object_meta] = wrapper","end",""],"private":false,"class":"function","name":"SF.AddObjectWrapper","param":{"1":"object_meta","2":"sf_object_meta","3":"wrapper","sf_object_meta":"starfall metatable of object","wrapper":"function that wraps object","object_meta":"metatable of object"}},"SF.Unsanitize":{"summary":"\nTakes output from starfall and does it's best to make the output \nfully usable outside of starfall environment ","description":"\nTakes output from starfall and does it's best to make the output \nfully usable outside of starfall environment","comment":["--- Takes output from starfall and does it's best to make the output","-- fully usable outside of starfall environment"],"code":["function SF.Unsanitize( ... )","\tlocal return_list = {}","\t","\tlocal args = {...}","\t","\tfor key, value in pairs( args ) do","\t\tlocal typ = type(value)","\t\tif typ == \"table\" and SF.UnwrapObject(value) then","\t\t\treturn_list[key] = SF.UnwrapObject(value)","\t\telseif typ == \"table\" then","\t\t\treturn_list[key] = {}","","\t\t\tfor k,v in pairs(value) do","\t\t\t\treturn_list[key][SF.Unsanitize(k)] = SF.Unsanitize(v)","\t\t\tend","\t\telse","\t\t\treturn_list[key] = value","\t\tend","\tend","","\treturn unpack( return_list )","end","","-- ------------------------------------------------------------------------- --","","local function isnan(n)","\treturn n ~= n","end","","-- Taken from E2Lib","","-- This function clamps the position before moving the entity","local minx, miny, minz = -16384, -16384, -16384","local maxx, maxy, maxz = 16384, 16384, 16384","local clamp = math.Clamp","local function clampPos(pos)","\tpos.x = clamp(pos.x, minx, maxx)","\tpos.y = clamp(pos.y, miny, maxy)","\tpos.z = clamp(pos.z, minz, maxz)","\treturn pos","end","","function SF.setPos(ent, pos)","\tif isnan(pos.x) or isnan(pos.y) or isnan(pos.z) then return end","\treturn ent:SetPos(clampPos(pos))","end","","local huge, abs = math.huge, math.abs","function SF.setAng(ent, ang)","\tif isnan(ang.pitch) or isnan(ang.yaw) or isnan(ang.roll) then return end","\tif abs(ang.pitch) == huge or abs(ang.yaw) == huge or abs(ang.roll) == huge then return false end -- SetAngles'ing inf crashes the server","\treturn ent:SetAngles(ang)","end","","-- ------------------------------------------------------------------------- --","","local serialize_replace_regex = \"[\\\"\\n]\"","local serialize_replace_tbl = { [ \"\\n\" ] = string.char( 5 ), [ '\"' ] = string.char( 4 ) }",""],"private":false,"class":"function","name":"SF.Unsanitize","param":["..."]},"SF.GetType":{"summary":"\nGets the type of val.","description":"\nGets the type of val.","comment":["--- Gets the type of val.","-- @param val The value to be checked."],"code":["function SF.GetType( val )","\tlocal mt = dgetmeta(val)","\treturn (mt and mt.__metatable and type(mt.__metatable) == \"string\") and mt.__metatable or type(val)","end","","-- ------------------------------------------------------------------------- --","","local object_wrappers = {}",""],"private":false,"class":"function","name":"SF.GetType","param":{"1":"val","val":"The value to be checked."}},"SF.throw":{"summary":"\nThrows an error like the throw function in builtins ","description":"\nThrows an error like the throw function in builtins","comment":["--- Throws an error like the throw function in builtins","-- @param msg Message","-- @param level Which level in the stacktrace to blame","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" ) or info.short_src","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"private":false,"class":"function","name":"SF.throw","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame"}},"SF.RunScriptHook":{"summary":"\nCalls a script hook on all processors.","description":"\nCalls a script hook on all processors.","comment":["--- Calls a script hook on all processors."],"code":["function SF.RunScriptHook(hook,...)","\tfor _,instance in pairs(SF.allInstances) do","\t\tif not instance.error then","\t\t\tlocal ok, err = instance:runScriptHook(hook,...)","\t\t\tif not ok then","\t\t\t\tinstance.error = true","\t\t\t\tif instance.runOnError then","\t\t\t\t\tinstance:runOnError( err )","\t\t\t\tend","\t\t\tend","\t\tend","\tend","end",""],"private":false,"class":"function","name":"SF.RunScriptHook","param":["hook","..."]},"SF.WrapObject":{"ret":"returns nil if the object doesn't have a known wrapper, \nor returns the wrapped object if it does have a wrapper.","comment":["--- Wraps the given object so that it is safe to pass into starfall","-- It will wrap it as long as we have the metatable of the object that is","-- getting wrapped.","-- @param object the object needing to get wrapped as it's passed into starfall","-- @return returns nil if the object doesn't have a known wrapper,","-- or returns the wrapped object if it does have a wrapper."],"code":["function SF.WrapObject( object )","\tlocal metatable = dgetmeta(object)","\t","\tlocal wrap = object_wrappers[metatable]","\treturn wrap and wrap(object)","end",""],"class":"function","name":"SF.WrapObject","private":false,"summary":"\nWraps the given object so that it is safe to pass into starfall \nIt will wrap it as long as we have the metatable of the object that is \ngetting wrapped.","description":"\nWraps the given object so that it is safe to pass into starfall \nIt will wrap it as long as we have the metatable of the object that is \ngetting wrapped.","param":{"1":"object","object":"the object needing to get wrapped as it's passed into starfall"}},"SF.Sanitize":{"summary":"\nSanitizes and returns its argument list.","description":"\nSanitizes and returns its argument list. \nBasic types are returned unchanged. Non-object tables will be \nrecursed into and their keys and values will be sanitized. Object \ntypes will be wrapped if a wrapper is available. When a wrapper is \nnot available objects will be replaced with nil, so as to prevent \nany possiblitiy of leakage. Functions will always be replaced with \nnil as there is no way to verify that they are safe.","comment":["--- Sanitizes and returns its argument list.","-- Basic types are returned unchanged. Non-object tables will be","-- recursed into and their keys and values will be sanitized. Object","-- types will be wrapped if a wrapper is available. When a wrapper is","-- not available objects will be replaced with nil, so as to prevent","-- any possiblitiy of leakage. Functions will always be replaced with","-- nil as there is no way to verify that they are safe."],"code":["function SF.Sanitize( ... )","\t-- Sanitize ALL the things.","\tlocal return_list = {}","\tlocal args = { ... }","\t","\tfor key, value in pairs( args ) do","\t\tlocal typmeta = getmetatable( value )","\t\tlocal typ = type( typmeta ) == \"string\" and typmeta or type( value )","\t\tif safe_types[ typ ] then","\t\t\treturn_list[ key ] = value","\t\telseif SF.WrapObject( value ) then","\t\t\treturn_list[ key ] = SF.WrapObject( value )","\t\telseif typ == \"table\" then","\t\t\tlocal tbl = {}","\t\t\tfor k,v in pairs( value ) do","\t\t\t\ttbl[ SF.Sanitize( k ) ] = SF.Sanitize( v )","\t\t\tend","\t\t\treturn_list[ key ] = tbl","\t\telse ","\t\t\treturn_list[ key ] = nil","\t\tend","\tend","\t","\treturn unpack( return_list )","end",""],"private":false,"class":"function","name":"SF.Sanitize","param":["..."]},"SF.CreateWrapper":{"ret":["The function to wrap sensitive values to a SF-safe table","The function to unwrap the SF-safe table to the sensitive table"],"comment":["--- Creates wrap/unwrap functions for sensitive values, by using a lookup table","-- (which is set to have weak keys and values)","-- @param metatable The metatable to assign the wrapped value.","-- @param weakwrapper Make the wrapper weak inside the internal lookup table. Default: True","-- @param weaksensitive Make the sensitive data weak inside the internal lookup table. Default: True","-- @param target_metatable (optional) The metatable of the object that will get","-- \t\twrapped by these wrapper functions.  This is required if you want to","-- \t\thave the object be auto-recognized by the generic SF.WrapObject","--\t\tfunction.","-- @return The function to wrap sensitive values to a SF-safe table","-- @return The function to unwrap the SF-safe table to the sensitive table"],"code":["function SF.CreateWrapper(metatable, weakwrapper, weaksensitive, target_metatable)","\tlocal s2sfmode = \"\"","\tlocal sf2smode = \"\"","\t","\tif weakwrapper == nil or weakwrapper then","\t\tsf2smode = \"k\"","\t\ts2sfmode = \"v\"","\tend","\tif weaksensitive then","\t\tsf2smode = sf2smode..\"v\"","\t\ts2sfmode = s2sfmode..\"k\"","\tend ","","\tlocal sensitive2sf = setmetatable({},{__mode=s2sfmode})","\tlocal sf2sensitive = setmetatable({},{__mode=sf2smode})","\t","\tlocal function wrap(value)","\t\tif value == nil then return nil end","\t\tif sensitive2sf[value] then return sensitive2sf[value] end","\t\tlocal tbl = setmetatable({},metatable)","\t\tsensitive2sf[value] = tbl","\t\tsf2sensitive[tbl] = value","\t\treturn tbl","\tend","\t","\tlocal function unwrap(value)","\t\treturn sf2sensitive[value]","\tend","\t","\tif target_metatable ~= nil then","\t\tobject_wrappers[target_metatable] = wrap","\t\tmetatable.__wrap = wrap","\tend","\t","\tmetatable.__unwrap = unwrap","\t","\treturn wrap, unwrap","end",""],"class":"function","name":"SF.CreateWrapper","private":false,"summary":"\nCreates wrap/unwrap functions for sensitive values, by using a lookup table \n(which is set to have weak keys and values) ","description":"\nCreates wrap/unwrap functions for sensitive values, by using a lookup table \n(which is set to have weak keys and values)","param":{"1":"metatable","2":"weakwrapper","3":"weaksensitive","4":"target_metatable","target_metatable":"(optional) The metatable of the object that will get \nwrapped by these wrapper functions.  This is required if you want to \nhave the object be auto-recognized by the generic SF.WrapObject \nfunction.","metatable":"The metatable to assign the wrapped value.","weaksensitive":"Make the sensitive data weak inside the internal lookup table. Default: True","weakwrapper":"Make the wrapper weak inside the internal lookup table. Default: True"}},"SF.RequestCode":{"ret":"True if the code was requested, false if an incomplete request is still in progress for that player","comment":["\t--- Requests a player to send whatever code they have open in his/her editor to","\t-- the server.","\t-- @server","\t-- @param ply Player to request code from","\t-- @param callback Called when all of the code is recieved. Arguments are either the main filename and a table","\t-- of filename->code pairs, or nil if the client couldn't handle the request (due to bad includes, etc)","\t-- @return True if the code was requested, false if an incomplete request is still in progress for that player"],"code":["\tfunction SF.RequestCode(ply, callback)","\t\tif uploaddata[ply] and uploaddata[ply].timeout > CurTime() then return false end","\t\t","\t\tnet.Start(\"starfall_requpload\")","\t\tnet.Send(ply)","","\t\tuploaddata[ply] = {","\t\t\tfiles={},","\t\t\tmainfile = nil,","\t\t\tneedHeader=true,","\t\t\tcallback = callback,","\t\t\ttimeout = CurTime() + 1","\t\t}","\t\treturn true","\tend","","\thook.Add(\"PlayerDisconnected\", \"SF_requestcode_cleanup\", function(ply)","\t\tuploaddata[ply] = nil","\tend)","\t","\tnet.Receive(\"starfall_upload\", function(len, ply)","\t\tlocal updata = uploaddata[ply]","\t\tif not updata then","\t\t\tErrorNoHalt(\"SF: Player \"..ply:GetName()..\" tried to upload code without being requested (expect this message multiple times)\\n\")","\t\t\treturn","\t\tend","\t\t","\t\tif updata.needHeader then","\t\t\tif net.ReadBit() == 0 then","\t\t\t\t--print(\"Recieved cancel packet\")","\t\t\t\tupdata.callback(nil, nil)","\t\t\t\tuploaddata[ply] = nil","\t\t\t\treturn","\t\t\tend","\t\t\tupdata.mainfile = net.ReadString()","\t\t\tupdata.needHeader = nil","\t\t\t--print(\"Begin recieving, mainfile:\", updata.mainfile)","\t\telse","\t\t\tif net.ReadBit() ~= 0 then","\t\t\t\t--print(\"End recieving data\")","\t\t\t\tupdata.callback(updata.mainfile, updata.files)","\t\t\t\tuploaddata[ply] = nil","\t\t\t\treturn","\t\t\tend","\t\t\tlocal filename = net.ReadString()","\t\t\tlocal filedata = net.ReadString()","\t\t\t--print(\"\\tRecieved data for:\", filename, \"len:\", #filedata)","\t\t\tupdata.files[filename] = updata.files[filename] and updata.files[filename]..filedata or filedata","\t\tend","","\tend)","","\tfunction SF.AddNotify ( ply, msg, notifyType, duration, sound )","","\t\t-- If the first arg is a string, it can't be a player, so shift all values.","\t\tif type( ply ) == \"string\" then","\t\t\tply, msg, notifyType, duration, sound = nil, ply, msg, notifyType, duration","\t\tend","","\t\tif ply and not IsValid( ply ) then return end","","\t\tnet.Start( \"starfall_addnotify\" )","\t\tnet.WriteString( msg )","\t\tnet.WriteUInt( notifyType, 8 or 0, 8 )","\t\tnet.WriteFloat( duration )","\t\tnet.WriteUInt( sound, 8 or 0, 8 )","\t\tif ply then","\t\t\tnet.Send( ply )","\t\telse","\t\t\tnet.Broadcast()","\t\tend","\tend","","\tfunction SF.Print ( ply, msg )","\t\tif type( ply ) == \"string\" then","\t\t\tply, msg = nil, ply","\t\tend","","\t\tnet.Start( \"starfall_console_print\" )","\t\t\tnet.WriteString( msg )","\t\tif ply then","\t\t\tnet.Send( ply )","\t\telse","\t\t\tnet.Broadcast()","\t\tend","\tend","else","\tnet.Receive(\"starfall_openeditor\",function(len)\t\t","\t\tif not SF.Editor.open() then return end","\t\t","\t\tlocal gate = net.ReadEntity()","\t\t","\t\tif IsValid(gate) then","\t\t\tfor name, code in pairs(gate.files) do","\t\t\t\tSF.Editor.addTab( name, code )","\t\t\tend","\t\tend","\tend)","\t","\tnet.Receive(\"starfall_requpload\", function(len)","\t\tlocal ok, list = SF.Editor.BuildIncludesTable()","\t\tif ok then","\t\t\t--print(\"Uploading SF code\")","\t\t\tnet.Start(\"starfall_upload\")","\t\t\tnet.WriteBit(true)","\t\t\tnet.WriteString(list.mainfile)","\t\t\tnet.SendToServer()","\t\t\t--print(\"\\tHeader sent\")","","\t\t\tlocal fname = next(list.files)","\t\t\twhile fname do","\t\t\t\t--print(\"\\tSending data for:\", fname)","\t\t\t\tlocal fdata = list.files[fname]","\t\t\t\tlocal offset = 1","\t\t\t\trepeat","\t\t\t\t\tnet.Start(\"starfall_upload\")","\t\t\t\t\tnet.WriteBit(false)","\t\t\t\t\tnet.WriteString(fname)","\t\t\t\t\tlocal data = fdata:sub(offset, offset+60000)","\t\t\t\t\tnet.WriteString(data)","\t\t\t\t\tnet.SendToServer()","","\t\t\t\t\t--print(\"\\t\\tSent data from\", offset, \"to\", offset + #data)","\t\t\t\t\toffset = offset + #data + 1","\t\t\t\tuntil offset > #fdata","\t\t\t\tfname = next(list.files, fname)","\t\t\tend","","\t\t\tnet.Start(\"starfall_upload\")","\t\t\tnet.WriteBit(true)","\t\t\tnet.SendToServer()","\t\t\t--print(\"Done sending\")","\t\telse","\t\t\tnet.Start(\"starfall_upload\")","\t\t\tnet.WriteBit(false)","\t\t\tnet.SendToServer()","\t\t\tif list then","\t\t\t\tSF.AddNotify( LocalPlayer(), list, NOTIFY_ERROR, 7, NOTIFYSOUND_ERROR1 )","\t\t\tend","\t\tend","\tend)","","\tlocal sounds = {","\t\t[ NOTIFYSOUND_DRIP1 ] = \"ambient/water/drip1.wav\",","\t\t[ NOTIFYSOUND_DRIP2 ] = \"ambient/water/drip2.wav\",","\t\t[ NOTIFYSOUND_DRIP3 ] = \"ambient/water/drip3.wav\",","\t\t[ NOTIFYSOUND_DRIP4 ] = \"ambient/water/drip4.wav\",","\t\t[ NOTIFYSOUND_DRIP5 ] = \"ambient/water/drip5.wav\",","\t\t[ NOTIFYSOUND_ERROR1 ] = \"buttons/button10.wav\",","\t\t[ NOTIFYSOUND_CONFIRM1 ] = \"buttons/button3.wav\",","\t\t[ NOTIFYSOUND_CONFIRM2 ] = \"buttons/button14.wav\",","\t\t[ NOTIFYSOUND_CONFIRM3 ] = \"buttons/button15.wav\",","\t\t[ NOTIFYSOUND_CONFIRM4 ] = \"buttons/button17.wav\"","\t}","","\tfunction SF.AddNotify ( ply, msg, type, duration, sound )","\t\tif not IsValid( ply ) then return end","","\t\tif ply ~= LocalPlayer() then","\t\t\treturn","\t\tend","","\t\tprint( msg )","","\t\tlocal newline = string.find( msg, \"\\n\" )","\t\tif newline then","\t\t\tmsg = string.sub( msg, 1, newline - 1 )","\t\tend","\t\t","\t\tGAMEMODE:AddNotify( msg, type, duration )","","\t\tif sound and sounds[ sound ] then","\t\t\tsurface.PlaySound( sounds[ sound ] )","\t\tend","\tend","","\tnet.Receive( \"starfall_addnotify\", function ()","\t\tSF.AddNotify( LocalPlayer(), net.ReadString(), net.ReadUInt( 8 ), net.ReadFloat(), net.ReadUInt( 8 ) )","\tend )","","\tnet.Receive( \"starfall_console_print\", function ()","\t\tprint( net.ReadString() )","\tend )","end","","-- ------------------------------------------------------------------------- --","","if SERVER then","\tlocal l","\tMsgN(\"-SF - Loading Libraries\")","","\tMsgN(\"- Loading shared libraries\")","\tl = file.Find(\"starfall/libs_sh/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sh/\"..filename)","\t\tAddCSLuaFile(\"starfall/libs_sh/\"..filename)","\tend","\tMsgN(\"- End loading shared libraries\")","\t","\tMsgN(\"- Loading SF server-side libraries\")","\tl = file.Find(\"starfall/libs_sv/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sv/\"..filename)","\tend","\tMsgN(\"- End loading server-side libraries\")","","\t","\tMsgN(\"- Adding client-side libraries to send list\")","\tl = file.Find(\"starfall/libs_cl/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Adding \"..filename)","\t\tAddCSLuaFile(\"starfall/libs_cl/\"..filename)","\tend","\tMsgN(\"- End loading client-side libraries\")","\t","\tMsgN(\"-End Loading SF Libraries\")","else","\tlocal l","\tMsgN(\"-SF - Loading Libraries\")","","\tMsgN(\"- Loading shared libraries\")","\tl = file.Find(\"starfall/libs_sh/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sh/\"..filename)","\tend","\tMsgN(\"- End loading shared libraries\")","\t","\tMsgN(\"- Loading client-side libraries\")","\tl = file.Find(\"starfall/libs_cl/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_cl/\"..filename)","\tend","\tMsgN(\"- End loading client-side libraries\")","","\t","\tMsgN(\"-End Loading SF Libraries\")","end","","SF.Libraries.CallHook(\"postload\")"],"class":"function","name":"SF.RequestCode","summary":"\nRequests a player to send whatever code they have open in his/her editor to \nthe server.","private":false,"server":true,"description":"\nRequests a player to send whatever code they have open in his/her editor to \nthe server.","param":{"1":"ply","2":"callback","ply":"Player to request code from","callback":"Called when all of the code is recieved. Arguments are either the main filename and a table \nof filename->code pairs, or nil if the client couldn't handle the request (due to bad includes, etc)"}},"SF.DeserializeCode":{"ret":["The table of filename = source entries","The main filename"],"comment":["--- Deserializes an instance's code.","-- @return The table of filename = source entries","-- @return The main filename"],"code":["function SF.DeserializeCode(tbl)","\tlocal sources = {}","\tfor filename, source in pairs(tbl.source) do","\t\tsources[filename] = string.gsub(source, deserialize_replace_regex, deserialize_replace_tbl)","\tend","\treturn sources, tbl.mainfile","end","","-- ------------------------------------------------------------------------- --","","if SERVER then","\tutil.AddNetworkString(\"starfall_requpload\")","\tutil.AddNetworkString(\"starfall_upload\")","\tutil.AddNetworkString( \"starfall_addnotify\" )","\tutil.AddNetworkString( \"starfall_console_print\" )","\tutil.AddNetworkString( \"starfall_openeditor\" )","\t","\tlocal uploaddata = {}","\t-- Packet structure:","\t-- ","\t-- Initialize packet:","\t--   Bit: False to cancel transfer","\t--   String: Main filename","\t-- Payload packets:","\t--   Bit: End transmission. If true, no other data is included","\t--   String: Filename. Multiple packets with the same filename are to be concactenated onto each other in the order they were sent","\t--   String: File data",""],"class":"function","name":"SF.DeserializeCode","private":false,"summary":"\nDeserializes an instance's code.","description":"\nDeserializes an instance's code.","param":["tbl"]},"SF.WrappedFunctionInstance":{"ret":"Instance","comment":["--- Gets the instance a wrapped function is bound to","-- @param func Function","-- @return Instance"],"code":["function SF.WrappedFunctionInstance(func)","\treturn wrappedfunctions2instance[func]","end","","-- A list of safe data types","local safe_types = {","\t[\"number\"  ] = true,","\t[\"string\"  ] = true,","\t[\"Vector\"  ] = false,","\t[\"Color\"   ] = false,","\t[\"Angle\"   ] = false,","\t[\"Entity\"  ] = false,","\t[\"VMatrix\" ] = false,","\t[\"boolean\" ] = true,","\t[\"nil\"     ] = true,","}",""],"class":"function","name":"SF.WrappedFunctionInstance","private":false,"summary":"\nGets the instance a wrapped function is bound to ","description":"\nGets the instance a wrapped function is bound to","param":{"1":"func","func":"Function"}},"SF.UnwrapObject":{"ret":"the unwrapped starfall object","comment":["--- Takes a wrapped starfall object and returns the unwrapped version","-- @param object the wrapped starfall object, should work on any starfall","-- wrapped object.","-- @return the unwrapped starfall object"],"code":["function SF.UnwrapObject( object )","\tlocal metatable = dgetmeta(object)","\t","\tif metatable and metatable.__unwrap then","\t\treturn metatable.__unwrap( object )","\tend","end","","local wrappedfunctions = setmetatable({},{__mode=\"kv\"})","local wrappedfunctions2instance = setmetatable({},{__mode=\"kv\"})"],"class":"function","name":"SF.UnwrapObject","private":false,"summary":"\nTakes a wrapped starfall object and returns the unwrapped version ","description":"\nTakes a wrapped starfall object and returns the unwrapped version","param":{"1":"object","object":"the wrapped starfall object, should work on any starfall \nwrapped object."}},"SF.WrapFunction":{"ret":"a function That when called will call the wrapped starfall function","comment":["--- Wraps the given starfall function so that it may called directly by GMLua","-- @param func The starfall function getting wrapped","-- @param instance The instance the function originated from","-- @return a function That when called will call the wrapped starfall function"],"code":["function SF.WrapFunction( func, instance )","\tif wrappedfunctions[func] then return wrappedfunctions[func] end","\t","\tlocal function returned_func( ... )","\t\treturn SF.Unsanitize( instance:runFunction( func, SF.Sanitize(...) ) )","\tend","\twrappedfunctions[func] = returned_func","\twrappedfunctions2instance[returned_func] = instance","\t","\treturn returned_func","end",""],"class":"function","name":"SF.WrapFunction","private":false,"summary":"\nWraps the given starfall function so that it may called directly by GMLua ","description":"\nWraps the given starfall function so that it may called directly by GMLua","param":{"1":"func","2":"instance","func":"The starfall function getting wrapped","instance":"The instance the function originated from"}},"SF.CheckType":{"summary":"\nChecks the type of val.","description":"\nChecks the type of val. Errors if the types don't match","comment":["--- Checks the type of val. Errors if the types don't match","-- @param val The value to be checked.","-- @param typ A string type or metatable.","-- @param level Level at which to error at. 3 is added to this value. Default is 0.","-- @param default A value to return if val is nil."],"code":["function SF.CheckType(val, typ, level, default)","\tif val == nil and default then return default","\telseif type(val) == typ then return val","\telse","\t\tlocal meta = dgetmeta(val)","\t\tif meta == typ or (meta and meta.__supertypes and meta.__supertypes[typ]) then return val end","\t\t","\t\t-- Failed, throw error","\t\tlevel = (level or 0) + 3","\t\t","\t\tlocal typname","\t\tif type(typ) == \"table\" then","\t\t\tassert(typ.__metatable and type(typ.__metatable) == \"string\")","\t\t\ttypname = typ.__metatable","\t\telse","\t\t\ttypname = typ","\t\tend","\t\t","\t\tlocal funcname = debug.getinfo(level-1, \"n\").name or \"<unnamed>\"","\t\tlocal mt = getmetatable(val)","\t\tSF.throw( \"Type mismatch (Expected \" .. typname .. \", got \" .. ( type( mt ) == \"string\" and mt or type( val ) ) .. \") in function \" .. funcname, level )","\tend","end",""],"private":false,"class":"function","name":"SF.CheckType","param":{"1":"val","2":"typ","3":"level","4":"default","level":"Level at which to error at. 3 is added to this value. Default is 0.","typ":"A string type or metatable.","default":"A value to return if val is nil.","val":"The value to be checked."}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- The main Starfall library","-------------------------------------------------------------------------------"],"code":["","if SF ~= nil then return end","SF = {}","","jit.off() -- Needed so ops counting will work reliably.","","-- Do a couple of checks for retarded mods that disable the debug table","-- and run it after all addons load","do","\tlocal function zassert(cond, str)","\t\tif not cond then error(\"STARFALL LOAD ABORT: \"..str,0) end","\tend","","\tzassert(debug, \"debug table removed\")","","\t-- Check for modified getinfo","\tlocal info = debug.getinfo(0,\"S\")","\tzassert(info, \"debug.getinfo modified to return nil\")","\tzassert(info.what == \"C\", \"debug.getinfo modified\")","","\t-- Check for modified setfenv","\tinfo = debug.getinfo(debug.setfenv, \"S\")","\tzassert(info.what == \"C\", \"debug.setfenv modified\")","","\t-- Check get/setmetatable","\tinfo = debug.getinfo(debug.getmetatable)","\tzassert(info.what == \"C\", \"debug.getmetatable modified\")","\tinfo = debug.getinfo(debug.setmetatable)","\tzassert(info.what == \"C\", \"debug.setmetatable modified\")","","\t-- Lock the debug table","\tlocal olddebug = debug","\tdebug = setmetatable({}, {","\t\t__index = olddebug,","\t\t__newindex = function(self,k,v) print(\"Addon tried to modify debug table\") end,","\t\t__metatable = \"nope.avi\",","\t})","end","","-- Send files to client","if SERVER then","\tAddCSLuaFile( \"sflib.lua\" )","\tAddCSLuaFile( \"compiler.lua\" )","\tAddCSLuaFile( \"instance.lua\" )","\tAddCSLuaFile( \"libraries.lua\" )","\tAddCSLuaFile( \"preprocessor.lua\" )","\tAddCSLuaFile( \"database.lua\" )","\tAddCSLuaFile( \"permissions/core.lua\" )","\tAddCSLuaFile( \"editor.lua\" )","\tAddCSLuaFile( \"sfderma.lua\" )","\tAddCSLuaFile( \"callback.lua\" )","\tAddCSLuaFile( \"sfhelper.lua\" )","end","","-- Load files","include( \"compiler.lua\" )","include( \"instance.lua\" )","include( \"libraries.lua\" )","include( \"preprocessor.lua\" )","include( \"database.lua\" )","include( \"permissions/core.lua\" )","include( \"editor.lua\" )","include( \"sfhelper.lua\" )","","SF.cpuBufferN = CreateConVar( \"sf_timebuffersize\", 16, { FCVAR_REPLICATED }, \"Default number of elements for the CPU Quota Buffer.\" )","","if SERVER then","\tSF.cpuQuota = CreateConVar( \"sf_timebuffer\", 0.004, {}, \"Default CPU Time Quota for serverside.\" )","else","\tSF.cpuQuota = CreateClientConVar( \"sf_timebuffer\", 0.015, false, false )","end","","","local dgetmeta = debug.getmetatable",""],"summary":"\n \nThe main Starfall library \n ","description":"\n \nThe main Starfall library \n","param":[]},{"summary":"\nThrows an error like the throw function in builtins ","description":"\nThrows an error like the throw function in builtins","comment":["--- Throws an error like the throw function in builtins","-- @param msg Message","-- @param level Which level in the stacktrace to blame","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" ) or info.short_src","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"private":false,"class":"function","name":"SF.throw","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame"}},{"ret":["The table to store normal methods","The table to store metamethods"],"comment":["--- Creates a type that is safe for SF scripts to use. Instances of the type","-- cannot access the type's metatable or metamethods.","-- @param name Name of table","-- @param supermeta The metatable to inheret from","-- @return The table to store normal methods","-- @return The table to store metamethods"],"code":["SF.Types = {}","function SF.Typedef(name, supermeta)","\tlocal methods, metamethods = {}, {}","\tmetamethods.__metatable = name","\tmetamethods.__index = methods","\t","\tmetamethods.__supertypes = {[metamethods] = true}","\t","\tif supermeta then","\t\tsetmetatable(methods, {__index=supermeta.__index})","\t\tmetamethods.__supertypes[supermeta] = true","\t\tif supermeta.__supertypes then","\t\t\tfor k,_ in pairs(supermeta.__supertypes) do","\t\t\t\tmetamethods.__supertypes[k] = true","\t\t\tend","\t\tend","\tend","","\tSF.Types[name] = metamethods","\treturn methods, metamethods","end","","function SF.GetTypeDef( name )","\treturn SF.Types[name]","end","","-- Include this file after Typedef as this file relies on it.","include(\"callback.lua\")","","do","\tlocal env, metatable = SF.Typedef(\"Environment\")"],"summary":"\nCreates a type that is safe for SF scripts to use.","description":"\nCreates a type that is safe for SF scripts to use. Instances of the type \ncannot access the type's metatable or metamethods.","param":{"1":"name","2":"supermeta","name":"Name of table","supermeta":"The metatable to inheret from"}},{"comment":["\t--- The default environment metatable"],"code":["\tSF.DefaultEnvironmentMT = metatable"],"summary":"\nThe default environment metatable ","description":"\nThe default environment metatable","param":[]},{"comment":["\t--- The default environment contents"],"code":["\tSF.DefaultEnvironment = env","end",""],"summary":"\nThe default environment contents ","description":"\nThe default environment contents","param":[]},{"comment":["--- A set of all instances that have been created. It has weak keys and values.","-- Instances are put here after initialization."],"code":["SF.allInstances = setmetatable({},{__mode=\"kv\"})",""],"summary":"\nA set of all instances that have been created.","description":"\nA set of all instances that have been created. It has weak keys and values. \nInstances are put here after initialization.","param":[]},{"summary":"\nCalls a script hook on all processors.","description":"\nCalls a script hook on all processors.","comment":["--- Calls a script hook on all processors."],"code":["function SF.RunScriptHook(hook,...)","\tfor _,instance in pairs(SF.allInstances) do","\t\tif not instance.error then","\t\t\tlocal ok, err = instance:runScriptHook(hook,...)","\t\t\tif not ok then","\t\t\t\tinstance.error = true","\t\t\t\tif instance.runOnError then","\t\t\t\t\tinstance:runOnError( err )","\t\t\t\tend","\t\t\tend","\t\tend","\tend","end",""],"private":false,"class":"function","name":"SF.RunScriptHook","param":["hook","..."]},{"summary":"\nCreates a new context.","description":"\nCreates a new context. A context is used to define what scripts will have access to.","comment":["--- Creates a new context. A context is used to define what scripts will have access to.","-- @param env The environment metatable to use for the script. Default is SF.DefaultEnvironmentMT","-- @param directives Additional Preprocessor directives to use. Default is an empty table","-- @param cpuTime Operations quota function. Default is specified by the convar \"sf_defaultquota\" and returned when calling ops()","-- @param libs Additional (local) libraries for the script to access. Default is an empty table."],"code":["function SF.CreateContext ( env, directives, cpuTime, libs )","\tlocal context = {}","\tcontext.env = env or SF.DefaultEnvironmentMT","\tcontext.directives = directives or {}","\tcontext.cpuTime = cpuTime or {","\t\tgetBufferN = function () return SF.cpuBufferN:GetInt() or 3 end,","\t\tgetMax = function () return SF.cpuQuota:GetFloat() end","\t}","\tcontext.libs = libs or {}","\treturn context","end",""],"private":false,"class":"function","name":"SF.CreateContext","param":{"1":"env","2":"directives","3":"cpuTime","4":"libs","env":"The environment metatable to use for the script. Default is SF.DefaultEnvironmentMT","directives":"Additional Preprocessor directives to use. Default is an empty table","cpuTime":"Operations quota function. Default is specified by the convar \"sf_defaultquota\" and returned when calling ops()","libs":"Additional (local) libraries for the script to access. Default is an empty table."}},{"summary":"\nChecks the type of val.","description":"\nChecks the type of val. Errors if the types don't match","comment":["--- Checks the type of val. Errors if the types don't match","-- @param val The value to be checked.","-- @param typ A string type or metatable.","-- @param level Level at which to error at. 3 is added to this value. Default is 0.","-- @param default A value to return if val is nil."],"code":["function SF.CheckType(val, typ, level, default)","\tif val == nil and default then return default","\telseif type(val) == typ then return val","\telse","\t\tlocal meta = dgetmeta(val)","\t\tif meta == typ or (meta and meta.__supertypes and meta.__supertypes[typ]) then return val end","\t\t","\t\t-- Failed, throw error","\t\tlevel = (level or 0) + 3","\t\t","\t\tlocal typname","\t\tif type(typ) == \"table\" then","\t\t\tassert(typ.__metatable and type(typ.__metatable) == \"string\")","\t\t\ttypname = typ.__metatable","\t\telse","\t\t\ttypname = typ","\t\tend","\t\t","\t\tlocal funcname = debug.getinfo(level-1, \"n\").name or \"<unnamed>\"","\t\tlocal mt = getmetatable(val)","\t\tSF.throw( \"Type mismatch (Expected \" .. typname .. \", got \" .. ( type( mt ) == \"string\" and mt or type( val ) ) .. \") in function \" .. funcname, level )","\tend","end",""],"private":false,"class":"function","name":"SF.CheckType","param":{"1":"val","2":"typ","3":"level","4":"default","level":"Level at which to error at. 3 is added to this value. Default is 0.","typ":"A string type or metatable.","default":"A value to return if val is nil.","val":"The value to be checked."}},{"summary":"\nGets the type of val.","description":"\nGets the type of val.","comment":["--- Gets the type of val.","-- @param val The value to be checked."],"code":["function SF.GetType( val )","\tlocal mt = dgetmeta(val)","\treturn (mt and mt.__metatable and type(mt.__metatable) == \"string\") and mt.__metatable or type(val)","end","","-- ------------------------------------------------------------------------- --","","local object_wrappers = {}",""],"private":false,"class":"function","name":"SF.GetType","param":{"1":"val","val":"The value to be checked."}},{"ret":["The function to wrap sensitive values to a SF-safe table","The function to unwrap the SF-safe table to the sensitive table"],"comment":["--- Creates wrap/unwrap functions for sensitive values, by using a lookup table","-- (which is set to have weak keys and values)","-- @param metatable The metatable to assign the wrapped value.","-- @param weakwrapper Make the wrapper weak inside the internal lookup table. Default: True","-- @param weaksensitive Make the sensitive data weak inside the internal lookup table. Default: True","-- @param target_metatable (optional) The metatable of the object that will get","-- \t\twrapped by these wrapper functions.  This is required if you want to","-- \t\thave the object be auto-recognized by the generic SF.WrapObject","--\t\tfunction.","-- @return The function to wrap sensitive values to a SF-safe table","-- @return The function to unwrap the SF-safe table to the sensitive table"],"code":["function SF.CreateWrapper(metatable, weakwrapper, weaksensitive, target_metatable)","\tlocal s2sfmode = \"\"","\tlocal sf2smode = \"\"","\t","\tif weakwrapper == nil or weakwrapper then","\t\tsf2smode = \"k\"","\t\ts2sfmode = \"v\"","\tend","\tif weaksensitive then","\t\tsf2smode = sf2smode..\"v\"","\t\ts2sfmode = s2sfmode..\"k\"","\tend ","","\tlocal sensitive2sf = setmetatable({},{__mode=s2sfmode})","\tlocal sf2sensitive = setmetatable({},{__mode=sf2smode})","\t","\tlocal function wrap(value)","\t\tif value == nil then return nil end","\t\tif sensitive2sf[value] then return sensitive2sf[value] end","\t\tlocal tbl = setmetatable({},metatable)","\t\tsensitive2sf[value] = tbl","\t\tsf2sensitive[tbl] = value","\t\treturn tbl","\tend","\t","\tlocal function unwrap(value)","\t\treturn sf2sensitive[value]","\tend","\t","\tif target_metatable ~= nil then","\t\tobject_wrappers[target_metatable] = wrap","\t\tmetatable.__wrap = wrap","\tend","\t","\tmetatable.__unwrap = unwrap","\t","\treturn wrap, unwrap","end",""],"class":"function","name":"SF.CreateWrapper","private":false,"summary":"\nCreates wrap/unwrap functions for sensitive values, by using a lookup table \n(which is set to have weak keys and values) ","description":"\nCreates wrap/unwrap functions for sensitive values, by using a lookup table \n(which is set to have weak keys and values)","param":{"1":"metatable","2":"weakwrapper","3":"weaksensitive","4":"target_metatable","target_metatable":"(optional) The metatable of the object that will get \nwrapped by these wrapper functions.  This is required if you want to \nhave the object be auto-recognized by the generic SF.WrapObject \nfunction.","metatable":"The metatable to assign the wrapped value.","weaksensitive":"Make the sensitive data weak inside the internal lookup table. Default: True","weakwrapper":"Make the wrapper weak inside the internal lookup table. Default: True"}},{"summary":"\nHelper function for adding custom wrappers ","description":"\nHelper function for adding custom wrappers","comment":["--- Helper function for adding custom wrappers","-- @param object_meta metatable of object","-- @param sf_object_meta starfall metatable of object","-- @param wrapper function that wraps object"],"code":["function SF.AddObjectWrapper( object_meta, sf_object_meta, wrapper )","\tsf_object_meta.__wrap = wrapper","\tobject_wrappers[object_meta] = wrapper","end",""],"private":false,"class":"function","name":"SF.AddObjectWrapper","param":{"1":"object_meta","2":"sf_object_meta","3":"wrapper","sf_object_meta":"starfall metatable of object","wrapper":"function that wraps object","object_meta":"metatable of object"}},{"summary":"\nHelper function for adding custom unwrappers ","description":"\nHelper function for adding custom unwrappers","comment":["--- Helper function for adding custom unwrappers","-- @param object_meta metatable of object","-- @param unwrapper function that unwraps object"],"code":["function SF.AddObjectUnwrapper( object_meta, unwrapper )","\tobject_meta.__unwrap = unwrapper","end",""],"private":false,"class":"function","name":"SF.AddObjectUnwrapper","param":{"1":"object_meta","2":"unwrapper","unwrapper":"function that unwraps object","object_meta":"metatable of object"}},{"ret":"returns nil if the object doesn't have a known wrapper, \nor returns the wrapped object if it does have a wrapper.","comment":["--- Wraps the given object so that it is safe to pass into starfall","-- It will wrap it as long as we have the metatable of the object that is","-- getting wrapped.","-- @param object the object needing to get wrapped as it's passed into starfall","-- @return returns nil if the object doesn't have a known wrapper,","-- or returns the wrapped object if it does have a wrapper."],"code":["function SF.WrapObject( object )","\tlocal metatable = dgetmeta(object)","\t","\tlocal wrap = object_wrappers[metatable]","\treturn wrap and wrap(object)","end",""],"class":"function","name":"SF.WrapObject","private":false,"summary":"\nWraps the given object so that it is safe to pass into starfall \nIt will wrap it as long as we have the metatable of the object that is \ngetting wrapped.","description":"\nWraps the given object so that it is safe to pass into starfall \nIt will wrap it as long as we have the metatable of the object that is \ngetting wrapped.","param":{"1":"object","object":"the object needing to get wrapped as it's passed into starfall"}},{"ret":"the unwrapped starfall object","comment":["--- Takes a wrapped starfall object and returns the unwrapped version","-- @param object the wrapped starfall object, should work on any starfall","-- wrapped object.","-- @return the unwrapped starfall object"],"code":["function SF.UnwrapObject( object )","\tlocal metatable = dgetmeta(object)","\t","\tif metatable and metatable.__unwrap then","\t\treturn metatable.__unwrap( object )","\tend","end","","local wrappedfunctions = setmetatable({},{__mode=\"kv\"})","local wrappedfunctions2instance = setmetatable({},{__mode=\"kv\"})"],"class":"function","name":"SF.UnwrapObject","private":false,"summary":"\nTakes a wrapped starfall object and returns the unwrapped version ","description":"\nTakes a wrapped starfall object and returns the unwrapped version","param":{"1":"object","object":"the wrapped starfall object, should work on any starfall \nwrapped object."}},{"ret":"a function That when called will call the wrapped starfall function","comment":["--- Wraps the given starfall function so that it may called directly by GMLua","-- @param func The starfall function getting wrapped","-- @param instance The instance the function originated from","-- @return a function That when called will call the wrapped starfall function"],"code":["function SF.WrapFunction( func, instance )","\tif wrappedfunctions[func] then return wrappedfunctions[func] end","\t","\tlocal function returned_func( ... )","\t\treturn SF.Unsanitize( instance:runFunction( func, SF.Sanitize(...) ) )","\tend","\twrappedfunctions[func] = returned_func","\twrappedfunctions2instance[returned_func] = instance","\t","\treturn returned_func","end",""],"class":"function","name":"SF.WrapFunction","private":false,"summary":"\nWraps the given starfall function so that it may called directly by GMLua ","description":"\nWraps the given starfall function so that it may called directly by GMLua","param":{"1":"func","2":"instance","func":"The starfall function getting wrapped","instance":"The instance the function originated from"}},{"ret":"Instance","comment":["--- Gets the instance a wrapped function is bound to","-- @param func Function","-- @return Instance"],"code":["function SF.WrappedFunctionInstance(func)","\treturn wrappedfunctions2instance[func]","end","","-- A list of safe data types","local safe_types = {","\t[\"number\"  ] = true,","\t[\"string\"  ] = true,","\t[\"Vector\"  ] = false,","\t[\"Color\"   ] = false,","\t[\"Angle\"   ] = false,","\t[\"Entity\"  ] = false,","\t[\"VMatrix\" ] = false,","\t[\"boolean\" ] = true,","\t[\"nil\"     ] = true,","}",""],"class":"function","name":"SF.WrappedFunctionInstance","private":false,"summary":"\nGets the instance a wrapped function is bound to ","description":"\nGets the instance a wrapped function is bound to","param":{"1":"func","func":"Function"}},{"summary":"\nSanitizes and returns its argument list.","description":"\nSanitizes and returns its argument list. \nBasic types are returned unchanged. Non-object tables will be \nrecursed into and their keys and values will be sanitized. Object \ntypes will be wrapped if a wrapper is available. When a wrapper is \nnot available objects will be replaced with nil, so as to prevent \nany possiblitiy of leakage. Functions will always be replaced with \nnil as there is no way to verify that they are safe.","comment":["--- Sanitizes and returns its argument list.","-- Basic types are returned unchanged. Non-object tables will be","-- recursed into and their keys and values will be sanitized. Object","-- types will be wrapped if a wrapper is available. When a wrapper is","-- not available objects will be replaced with nil, so as to prevent","-- any possiblitiy of leakage. Functions will always be replaced with","-- nil as there is no way to verify that they are safe."],"code":["function SF.Sanitize( ... )","\t-- Sanitize ALL the things.","\tlocal return_list = {}","\tlocal args = { ... }","\t","\tfor key, value in pairs( args ) do","\t\tlocal typmeta = getmetatable( value )","\t\tlocal typ = type( typmeta ) == \"string\" and typmeta or type( value )","\t\tif safe_types[ typ ] then","\t\t\treturn_list[ key ] = value","\t\telseif SF.WrapObject( value ) then","\t\t\treturn_list[ key ] = SF.WrapObject( value )","\t\telseif typ == \"table\" then","\t\t\tlocal tbl = {}","\t\t\tfor k,v in pairs( value ) do","\t\t\t\ttbl[ SF.Sanitize( k ) ] = SF.Sanitize( v )","\t\t\tend","\t\t\treturn_list[ key ] = tbl","\t\telse ","\t\t\treturn_list[ key ] = nil","\t\tend","\tend","\t","\treturn unpack( return_list )","end",""],"private":false,"class":"function","name":"SF.Sanitize","param":["..."]},{"summary":"\nTakes output from starfall and does it's best to make the output \nfully usable outside of starfall environment ","description":"\nTakes output from starfall and does it's best to make the output \nfully usable outside of starfall environment","comment":["--- Takes output from starfall and does it's best to make the output","-- fully usable outside of starfall environment"],"code":["function SF.Unsanitize( ... )","\tlocal return_list = {}","\t","\tlocal args = {...}","\t","\tfor key, value in pairs( args ) do","\t\tlocal typ = type(value)","\t\tif typ == \"table\" and SF.UnwrapObject(value) then","\t\t\treturn_list[key] = SF.UnwrapObject(value)","\t\telseif typ == \"table\" then","\t\t\treturn_list[key] = {}","","\t\t\tfor k,v in pairs(value) do","\t\t\t\treturn_list[key][SF.Unsanitize(k)] = SF.Unsanitize(v)","\t\t\tend","\t\telse","\t\t\treturn_list[key] = value","\t\tend","\tend","","\treturn unpack( return_list )","end","","-- ------------------------------------------------------------------------- --","","local function isnan(n)","\treturn n ~= n","end","","-- Taken from E2Lib","","-- This function clamps the position before moving the entity","local minx, miny, minz = -16384, -16384, -16384","local maxx, maxy, maxz = 16384, 16384, 16384","local clamp = math.Clamp","local function clampPos(pos)","\tpos.x = clamp(pos.x, minx, maxx)","\tpos.y = clamp(pos.y, miny, maxy)","\tpos.z = clamp(pos.z, minz, maxz)","\treturn pos","end","","function SF.setPos(ent, pos)","\tif isnan(pos.x) or isnan(pos.y) or isnan(pos.z) then return end","\treturn ent:SetPos(clampPos(pos))","end","","local huge, abs = math.huge, math.abs","function SF.setAng(ent, ang)","\tif isnan(ang.pitch) or isnan(ang.yaw) or isnan(ang.roll) then return end","\tif abs(ang.pitch) == huge or abs(ang.yaw) == huge or abs(ang.roll) == huge then return false end -- SetAngles'ing inf crashes the server","\treturn ent:SetAngles(ang)","end","","-- ------------------------------------------------------------------------- --","","local serialize_replace_regex = \"[\\\"\\n]\"","local serialize_replace_tbl = { [ \"\\n\" ] = string.char( 5 ), [ '\"' ] = string.char( 4 ) }",""],"private":false,"class":"function","name":"SF.Unsanitize","param":["..."]},{"summary":"\nSerializes an instance's code in a format compatible with the duplicator library ","description":"\nSerializes an instance's code in a format compatible with the duplicator library","comment":["--- Serializes an instance's code in a format compatible with the duplicator library","-- @param sources The table of filename = source entries. Ususally instance.source","-- @param mainfile The main filename. Usually instance.mainfile"],"code":["function SF.SerializeCode(sources, mainfile)","\tlocal rt = {source = {}}","\tfor filename, source in pairs(sources) do","\t\trt.source[filename] = string.gsub(source, serialize_replace_regex, serialize_replace_tbl)","\tend","\trt.mainfile = mainfile","\treturn rt","end","","local deserialize_replace_regex = \"[\" .. string.char( 5 ) .. string.char( 4 ) .. \"]\"","local deserialize_replace_tbl = { [ string.char( 5 )[ 1 ] ] = \"\\n\", [ string.char( 4 )[ 1 ] ] = '\"' }"],"private":false,"class":"function","name":"SF.SerializeCode","param":{"1":"sources","2":"mainfile","mainfile":"The main filename. Usually instance.mainfile","sources":"The table of filename = source entries. Ususally instance.source"}},{"ret":["The table of filename = source entries","The main filename"],"comment":["--- Deserializes an instance's code.","-- @return The table of filename = source entries","-- @return The main filename"],"code":["function SF.DeserializeCode(tbl)","\tlocal sources = {}","\tfor filename, source in pairs(tbl.source) do","\t\tsources[filename] = string.gsub(source, deserialize_replace_regex, deserialize_replace_tbl)","\tend","\treturn sources, tbl.mainfile","end","","-- ------------------------------------------------------------------------- --","","if SERVER then","\tutil.AddNetworkString(\"starfall_requpload\")","\tutil.AddNetworkString(\"starfall_upload\")","\tutil.AddNetworkString( \"starfall_addnotify\" )","\tutil.AddNetworkString( \"starfall_console_print\" )","\tutil.AddNetworkString( \"starfall_openeditor\" )","\t","\tlocal uploaddata = {}","\t-- Packet structure:","\t-- ","\t-- Initialize packet:","\t--   Bit: False to cancel transfer","\t--   String: Main filename","\t-- Payload packets:","\t--   Bit: End transmission. If true, no other data is included","\t--   String: Filename. Multiple packets with the same filename are to be concactenated onto each other in the order they were sent","\t--   String: File data",""],"class":"function","name":"SF.DeserializeCode","private":false,"summary":"\nDeserializes an instance's code.","description":"\nDeserializes an instance's code.","param":["tbl"]},{"ret":"True if the code was requested, false if an incomplete request is still in progress for that player","comment":["\t--- Requests a player to send whatever code they have open in his/her editor to","\t-- the server.","\t-- @server","\t-- @param ply Player to request code from","\t-- @param callback Called when all of the code is recieved. Arguments are either the main filename and a table","\t-- of filename->code pairs, or nil if the client couldn't handle the request (due to bad includes, etc)","\t-- @return True if the code was requested, false if an incomplete request is still in progress for that player"],"code":["\tfunction SF.RequestCode(ply, callback)","\t\tif uploaddata[ply] and uploaddata[ply].timeout > CurTime() then return false end","\t\t","\t\tnet.Start(\"starfall_requpload\")","\t\tnet.Send(ply)","","\t\tuploaddata[ply] = {","\t\t\tfiles={},","\t\t\tmainfile = nil,","\t\t\tneedHeader=true,","\t\t\tcallback = callback,","\t\t\ttimeout = CurTime() + 1","\t\t}","\t\treturn true","\tend","","\thook.Add(\"PlayerDisconnected\", \"SF_requestcode_cleanup\", function(ply)","\t\tuploaddata[ply] = nil","\tend)","\t","\tnet.Receive(\"starfall_upload\", function(len, ply)","\t\tlocal updata = uploaddata[ply]","\t\tif not updata then","\t\t\tErrorNoHalt(\"SF: Player \"..ply:GetName()..\" tried to upload code without being requested (expect this message multiple times)\\n\")","\t\t\treturn","\t\tend","\t\t","\t\tif updata.needHeader then","\t\t\tif net.ReadBit() == 0 then","\t\t\t\t--print(\"Recieved cancel packet\")","\t\t\t\tupdata.callback(nil, nil)","\t\t\t\tuploaddata[ply] = nil","\t\t\t\treturn","\t\t\tend","\t\t\tupdata.mainfile = net.ReadString()","\t\t\tupdata.needHeader = nil","\t\t\t--print(\"Begin recieving, mainfile:\", updata.mainfile)","\t\telse","\t\t\tif net.ReadBit() ~= 0 then","\t\t\t\t--print(\"End recieving data\")","\t\t\t\tupdata.callback(updata.mainfile, updata.files)","\t\t\t\tuploaddata[ply] = nil","\t\t\t\treturn","\t\t\tend","\t\t\tlocal filename = net.ReadString()","\t\t\tlocal filedata = net.ReadString()","\t\t\t--print(\"\\tRecieved data for:\", filename, \"len:\", #filedata)","\t\t\tupdata.files[filename] = updata.files[filename] and updata.files[filename]..filedata or filedata","\t\tend","","\tend)","","\tfunction SF.AddNotify ( ply, msg, notifyType, duration, sound )","","\t\t-- If the first arg is a string, it can't be a player, so shift all values.","\t\tif type( ply ) == \"string\" then","\t\t\tply, msg, notifyType, duration, sound = nil, ply, msg, notifyType, duration","\t\tend","","\t\tif ply and not IsValid( ply ) then return end","","\t\tnet.Start( \"starfall_addnotify\" )","\t\tnet.WriteString( msg )","\t\tnet.WriteUInt( notifyType, 8 or 0, 8 )","\t\tnet.WriteFloat( duration )","\t\tnet.WriteUInt( sound, 8 or 0, 8 )","\t\tif ply then","\t\t\tnet.Send( ply )","\t\telse","\t\t\tnet.Broadcast()","\t\tend","\tend","","\tfunction SF.Print ( ply, msg )","\t\tif type( ply ) == \"string\" then","\t\t\tply, msg = nil, ply","\t\tend","","\t\tnet.Start( \"starfall_console_print\" )","\t\t\tnet.WriteString( msg )","\t\tif ply then","\t\t\tnet.Send( ply )","\t\telse","\t\t\tnet.Broadcast()","\t\tend","\tend","else","\tnet.Receive(\"starfall_openeditor\",function(len)\t\t","\t\tif not SF.Editor.open() then return end","\t\t","\t\tlocal gate = net.ReadEntity()","\t\t","\t\tif IsValid(gate) then","\t\t\tfor name, code in pairs(gate.files) do","\t\t\t\tSF.Editor.addTab( name, code )","\t\t\tend","\t\tend","\tend)","\t","\tnet.Receive(\"starfall_requpload\", function(len)","\t\tlocal ok, list = SF.Editor.BuildIncludesTable()","\t\tif ok then","\t\t\t--print(\"Uploading SF code\")","\t\t\tnet.Start(\"starfall_upload\")","\t\t\tnet.WriteBit(true)","\t\t\tnet.WriteString(list.mainfile)","\t\t\tnet.SendToServer()","\t\t\t--print(\"\\tHeader sent\")","","\t\t\tlocal fname = next(list.files)","\t\t\twhile fname do","\t\t\t\t--print(\"\\tSending data for:\", fname)","\t\t\t\tlocal fdata = list.files[fname]","\t\t\t\tlocal offset = 1","\t\t\t\trepeat","\t\t\t\t\tnet.Start(\"starfall_upload\")","\t\t\t\t\tnet.WriteBit(false)","\t\t\t\t\tnet.WriteString(fname)","\t\t\t\t\tlocal data = fdata:sub(offset, offset+60000)","\t\t\t\t\tnet.WriteString(data)","\t\t\t\t\tnet.SendToServer()","","\t\t\t\t\t--print(\"\\t\\tSent data from\", offset, \"to\", offset + #data)","\t\t\t\t\toffset = offset + #data + 1","\t\t\t\tuntil offset > #fdata","\t\t\t\tfname = next(list.files, fname)","\t\t\tend","","\t\t\tnet.Start(\"starfall_upload\")","\t\t\tnet.WriteBit(true)","\t\t\tnet.SendToServer()","\t\t\t--print(\"Done sending\")","\t\telse","\t\t\tnet.Start(\"starfall_upload\")","\t\t\tnet.WriteBit(false)","\t\t\tnet.SendToServer()","\t\t\tif list then","\t\t\t\tSF.AddNotify( LocalPlayer(), list, NOTIFY_ERROR, 7, NOTIFYSOUND_ERROR1 )","\t\t\tend","\t\tend","\tend)","","\tlocal sounds = {","\t\t[ NOTIFYSOUND_DRIP1 ] = \"ambient/water/drip1.wav\",","\t\t[ NOTIFYSOUND_DRIP2 ] = \"ambient/water/drip2.wav\",","\t\t[ NOTIFYSOUND_DRIP3 ] = \"ambient/water/drip3.wav\",","\t\t[ NOTIFYSOUND_DRIP4 ] = \"ambient/water/drip4.wav\",","\t\t[ NOTIFYSOUND_DRIP5 ] = \"ambient/water/drip5.wav\",","\t\t[ NOTIFYSOUND_ERROR1 ] = \"buttons/button10.wav\",","\t\t[ NOTIFYSOUND_CONFIRM1 ] = \"buttons/button3.wav\",","\t\t[ NOTIFYSOUND_CONFIRM2 ] = \"buttons/button14.wav\",","\t\t[ NOTIFYSOUND_CONFIRM3 ] = \"buttons/button15.wav\",","\t\t[ NOTIFYSOUND_CONFIRM4 ] = \"buttons/button17.wav\"","\t}","","\tfunction SF.AddNotify ( ply, msg, type, duration, sound )","\t\tif not IsValid( ply ) then return end","","\t\tif ply ~= LocalPlayer() then","\t\t\treturn","\t\tend","","\t\tprint( msg )","","\t\tlocal newline = string.find( msg, \"\\n\" )","\t\tif newline then","\t\t\tmsg = string.sub( msg, 1, newline - 1 )","\t\tend","\t\t","\t\tGAMEMODE:AddNotify( msg, type, duration )","","\t\tif sound and sounds[ sound ] then","\t\t\tsurface.PlaySound( sounds[ sound ] )","\t\tend","\tend","","\tnet.Receive( \"starfall_addnotify\", function ()","\t\tSF.AddNotify( LocalPlayer(), net.ReadString(), net.ReadUInt( 8 ), net.ReadFloat(), net.ReadUInt( 8 ) )","\tend )","","\tnet.Receive( \"starfall_console_print\", function ()","\t\tprint( net.ReadString() )","\tend )","end","","-- ------------------------------------------------------------------------- --","","if SERVER then","\tlocal l","\tMsgN(\"-SF - Loading Libraries\")","","\tMsgN(\"- Loading shared libraries\")","\tl = file.Find(\"starfall/libs_sh/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sh/\"..filename)","\t\tAddCSLuaFile(\"starfall/libs_sh/\"..filename)","\tend","\tMsgN(\"- End loading shared libraries\")","\t","\tMsgN(\"- Loading SF server-side libraries\")","\tl = file.Find(\"starfall/libs_sv/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sv/\"..filename)","\tend","\tMsgN(\"- End loading server-side libraries\")","","\t","\tMsgN(\"- Adding client-side libraries to send list\")","\tl = file.Find(\"starfall/libs_cl/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Adding \"..filename)","\t\tAddCSLuaFile(\"starfall/libs_cl/\"..filename)","\tend","\tMsgN(\"- End loading client-side libraries\")","\t","\tMsgN(\"-End Loading SF Libraries\")","else","\tlocal l","\tMsgN(\"-SF - Loading Libraries\")","","\tMsgN(\"- Loading shared libraries\")","\tl = file.Find(\"starfall/libs_sh/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_sh/\"..filename)","\tend","\tMsgN(\"- End loading shared libraries\")","\t","\tMsgN(\"- Loading client-side libraries\")","\tl = file.Find(\"starfall/libs_cl/*.lua\", \"LUA\")","\tfor _,filename in pairs(l) do","\t\tprint(\"-  Loading \"..filename)","\t\tinclude(\"starfall/libs_cl/\"..filename)","\tend","\tMsgN(\"- End loading client-side libraries\")","","\t","\tMsgN(\"-End Loading SF Libraries\")","end","","SF.Libraries.CallHook(\"postload\")"],"class":"function","name":"SF.RequestCode","summary":"\nRequests a player to send whatever code they have open in his/her editor to \nthe server.","private":false,"server":true,"description":"\nRequests a player to send whatever code they have open in his/her editor to \nthe server.","param":{"1":"ply","2":"callback","ply":"Player to request code from","callback":"Called when all of the code is recieved. Arguments are either the main filename and a table \nof filename->code pairs, or nil if the client couldn't handle the request (due to bad includes, etc)"}}],"tables":[],"description":"\n \nThe main Starfall library \n","summary":"\n \nThe main Starfall library \n "},"libs_sh/coroutine.lua":{"libraries":{"1":"coroutine","coroutine":{"comment":["--- Coroutine library","-- @shared"],"functions":{"1":"create","2":"resume","3":"running","4":"status","5":"wait","6":"wrap","7":"yield","resume":{"ret":"Any values the coroutine is returning to the main thread","comment":["--- Resumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","-- @param thread coroutine to resume","-- @param ... optional parameters that will be passed to the coroutine","-- @return Any values the coroutine is returning to the main thread"],"code":["function coroutine_library.resume ( thread, ... )","\tSF.CheckType( thread, thread_metamethods )","\tlocal func = unwrap( thread ).func","\treturn func( ... )","end",""],"class":"function","name":"coroutine_library.resume","summary":"\nResumes a suspended coroutine.","private":false,"library":"coroutine","description":"\nResumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","param":{"1":"thread","2":"...","...":"optional parameters that will be passed to the coroutine","thread":"coroutine to resume"}},"yield":{"ret":"Any values passed to the coroutine","comment":["--- Suspends the currently running coroutine. May not be called outside a coroutine.","-- @param ... optional parameters that will be returned to the main thread","-- @return Any values passed to the coroutine"],"code":["function coroutine_library.yield ( ... )","\treturn coroutine.yield( ... )","end",""],"class":"function","name":"coroutine_library.yield","summary":"\nSuspends the currently running coroutine.","private":false,"library":"coroutine","description":"\nSuspends the currently running coroutine. May not be called outside a coroutine.","param":{"1":"...","...":"optional parameters that will be returned to the main thread"}},"running":{"ret":"Currently running coroutine","comment":["--- Returns the coroutine that is currently running.","-- @return Currently running coroutine"],"code":["function coroutine_library.running ()","\tlocal thread = coroutine.running()","\treturn wrap( { thread = thread, func = coroutines[ thread ] } )","end",""],"class":"function","name":"coroutine_library.running","summary":"\nReturns the coroutine that is currently running.","private":false,"library":"coroutine","description":"\nReturns the coroutine that is currently running.","param":[]},"status":{"ret":"Either \"suspended\", \"running\", \"normal\" or \"dead\"","comment":["--- Returns the status of the coroutine.","-- @param thread The coroutine","-- @return Either \"suspended\", \"running\", \"normal\" or \"dead\""],"code":["function coroutine_library.status ( thread )","\tSF.CheckType( thread, thread_metamethods )","\tlocal thread = unwrap( thread ).thread","\treturn coroutine.status( thread )","end",""],"class":"function","name":"coroutine_library.status","summary":"\nReturns the status of the coroutine.","private":false,"library":"coroutine","description":"\nReturns the status of the coroutine.","param":{"1":"thread","thread":"The coroutine"}},"wrap":{"ret":"A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine.","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine."],"code":["function coroutine_library.wrap ( func )","\tSF.CheckType( func, \"function\" )","\t","\tlocal wrappedFunc, thread = createCoroutine( func )","","\treturn wrappedFunc","end",""],"class":"function","name":"coroutine_library.wrap","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"create":{"ret":"coroutine","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return coroutine"],"code":["function coroutine_library.create ( func )","\tSF.CheckType( func, \"function\" )","","\tlocal wrappedFunc, thread = createCoroutine( func )","","\tlocal ret = { func = wrappedFunc, thread = thread }","","\treturn wrap( ret )","end",""],"class":"function","name":"coroutine_library.create","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"wait":{"comment":["--- Suspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","-- @param time Time in seconds to suspend the coroutine"],"code":["function coroutine_library.wait ( time )","\tcoroutine.wait( time )","\tSF.CheckType( time, \"number\" )","end"],"class":"function","name":"coroutine_library.wait","summary":"\nSuspends the coroutine for a number of seconds.","private":false,"library":"coroutine","description":"\nSuspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","param":{"1":"time","time":"Time in seconds to suspend the coroutine"}}},"class":"library","summary":"\nCoroutine library ","code":["local coroutine_library, _ = SF.Libraries.Register( \"coroutine\" )","local coroutine = coroutine","","local _, thread_metamethods = SF.Typedef( \"thread\" )","local wrap, unwrap = SF.CreateWrapper( thread_metamethods, true, false )","","local coroutines = setmetatable( {}, { __mode = \"v\" } )","","local function createCoroutine ( func )","\t-- Can't use coroutine.create, because of a bug that prevents halting the program when it exceeds quota","","\t-- Hack to get the coroutine from a wrapped function. Necessary because coroutine.create is not available","\tlocal wrappedFunc = coroutine.wrap( function() return func( coroutine.yield( coroutine.running() ) ) end ) ","\t","\tlocal thread = wrappedFunc()","","\tcoroutines[ thread ] = wrappedFunc","\t","\treturn wrappedFunc, thread","end",""],"fields":[],"name":"coroutine","client":true,"description":"\nCoroutine library","libtbl":"coroutine_library","tables":[],"server":true}},"type":"file","name":"libs_sh/coroutine.lua","functions":{"1":"coroutine_library.create","2":"coroutine_library.resume","3":"coroutine_library.running","4":"coroutine_library.status","5":"coroutine_library.wait","6":"coroutine_library.wrap","7":"coroutine_library.yield","coroutine_library.running":{"ret":"Currently running coroutine","comment":["--- Returns the coroutine that is currently running.","-- @return Currently running coroutine"],"code":["function coroutine_library.running ()","\tlocal thread = coroutine.running()","\treturn wrap( { thread = thread, func = coroutines[ thread ] } )","end",""],"class":"function","name":"coroutine_library.running","summary":"\nReturns the coroutine that is currently running.","private":false,"library":"coroutine","description":"\nReturns the coroutine that is currently running.","param":[]},"coroutine_library.wait":{"comment":["--- Suspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","-- @param time Time in seconds to suspend the coroutine"],"code":["function coroutine_library.wait ( time )","\tcoroutine.wait( time )","\tSF.CheckType( time, \"number\" )","end"],"class":"function","name":"coroutine_library.wait","summary":"\nSuspends the coroutine for a number of seconds.","private":false,"library":"coroutine","description":"\nSuspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","param":{"1":"time","time":"Time in seconds to suspend the coroutine"}},"coroutine_library.status":{"ret":"Either \"suspended\", \"running\", \"normal\" or \"dead\"","comment":["--- Returns the status of the coroutine.","-- @param thread The coroutine","-- @return Either \"suspended\", \"running\", \"normal\" or \"dead\""],"code":["function coroutine_library.status ( thread )","\tSF.CheckType( thread, thread_metamethods )","\tlocal thread = unwrap( thread ).thread","\treturn coroutine.status( thread )","end",""],"class":"function","name":"coroutine_library.status","summary":"\nReturns the status of the coroutine.","private":false,"library":"coroutine","description":"\nReturns the status of the coroutine.","param":{"1":"thread","thread":"The coroutine"}},"coroutine_library.resume":{"ret":"Any values the coroutine is returning to the main thread","comment":["--- Resumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","-- @param thread coroutine to resume","-- @param ... optional parameters that will be passed to the coroutine","-- @return Any values the coroutine is returning to the main thread"],"code":["function coroutine_library.resume ( thread, ... )","\tSF.CheckType( thread, thread_metamethods )","\tlocal func = unwrap( thread ).func","\treturn func( ... )","end",""],"class":"function","name":"coroutine_library.resume","summary":"\nResumes a suspended coroutine.","private":false,"library":"coroutine","description":"\nResumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","param":{"1":"thread","2":"...","...":"optional parameters that will be passed to the coroutine","thread":"coroutine to resume"}},"coroutine_library.create":{"ret":"coroutine","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return coroutine"],"code":["function coroutine_library.create ( func )","\tSF.CheckType( func, \"function\" )","","\tlocal wrappedFunc, thread = createCoroutine( func )","","\tlocal ret = { func = wrappedFunc, thread = thread }","","\treturn wrap( ret )","end",""],"class":"function","name":"coroutine_library.create","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"coroutine_library.wrap":{"ret":"A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine.","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine."],"code":["function coroutine_library.wrap ( func )","\tSF.CheckType( func, \"function\" )","\t","\tlocal wrappedFunc, thread = createCoroutine( func )","","\treturn wrappedFunc","end",""],"class":"function","name":"coroutine_library.wrap","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"coroutine_library.yield":{"ret":"Any values passed to the coroutine","comment":["--- Suspends the currently running coroutine. May not be called outside a coroutine.","-- @param ... optional parameters that will be returned to the main thread","-- @return Any values passed to the coroutine"],"code":["function coroutine_library.yield ( ... )","\treturn coroutine.yield( ... )","end",""],"class":"function","name":"coroutine_library.yield","summary":"\nSuspends the currently running coroutine.","private":false,"library":"coroutine","description":"\nSuspends the currently running coroutine. May not be called outside a coroutine.","param":{"1":"...","...":"optional parameters that will be returned to the main thread"}}},"doc":[{"summary":"\nCoroutine library ","description":"\nCoroutine library","comment":["--- Coroutine library"],"code":[""]},{"comment":["--- Coroutine library","-- @shared"],"functions":{"1":"create","2":"resume","3":"running","4":"status","5":"wait","6":"wrap","7":"yield","resume":{"ret":"Any values the coroutine is returning to the main thread","comment":["--- Resumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","-- @param thread coroutine to resume","-- @param ... optional parameters that will be passed to the coroutine","-- @return Any values the coroutine is returning to the main thread"],"code":["function coroutine_library.resume ( thread, ... )","\tSF.CheckType( thread, thread_metamethods )","\tlocal func = unwrap( thread ).func","\treturn func( ... )","end",""],"class":"function","name":"coroutine_library.resume","summary":"\nResumes a suspended coroutine.","private":false,"library":"coroutine","description":"\nResumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","param":{"1":"thread","2":"...","...":"optional parameters that will be passed to the coroutine","thread":"coroutine to resume"}},"yield":{"ret":"Any values passed to the coroutine","comment":["--- Suspends the currently running coroutine. May not be called outside a coroutine.","-- @param ... optional parameters that will be returned to the main thread","-- @return Any values passed to the coroutine"],"code":["function coroutine_library.yield ( ... )","\treturn coroutine.yield( ... )","end",""],"class":"function","name":"coroutine_library.yield","summary":"\nSuspends the currently running coroutine.","private":false,"library":"coroutine","description":"\nSuspends the currently running coroutine. May not be called outside a coroutine.","param":{"1":"...","...":"optional parameters that will be returned to the main thread"}},"running":{"ret":"Currently running coroutine","comment":["--- Returns the coroutine that is currently running.","-- @return Currently running coroutine"],"code":["function coroutine_library.running ()","\tlocal thread = coroutine.running()","\treturn wrap( { thread = thread, func = coroutines[ thread ] } )","end",""],"class":"function","name":"coroutine_library.running","summary":"\nReturns the coroutine that is currently running.","private":false,"library":"coroutine","description":"\nReturns the coroutine that is currently running.","param":[]},"status":{"ret":"Either \"suspended\", \"running\", \"normal\" or \"dead\"","comment":["--- Returns the status of the coroutine.","-- @param thread The coroutine","-- @return Either \"suspended\", \"running\", \"normal\" or \"dead\""],"code":["function coroutine_library.status ( thread )","\tSF.CheckType( thread, thread_metamethods )","\tlocal thread = unwrap( thread ).thread","\treturn coroutine.status( thread )","end",""],"class":"function","name":"coroutine_library.status","summary":"\nReturns the status of the coroutine.","private":false,"library":"coroutine","description":"\nReturns the status of the coroutine.","param":{"1":"thread","thread":"The coroutine"}},"wrap":{"ret":"A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine.","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine."],"code":["function coroutine_library.wrap ( func )","\tSF.CheckType( func, \"function\" )","\t","\tlocal wrappedFunc, thread = createCoroutine( func )","","\treturn wrappedFunc","end",""],"class":"function","name":"coroutine_library.wrap","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"create":{"ret":"coroutine","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return coroutine"],"code":["function coroutine_library.create ( func )","\tSF.CheckType( func, \"function\" )","","\tlocal wrappedFunc, thread = createCoroutine( func )","","\tlocal ret = { func = wrappedFunc, thread = thread }","","\treturn wrap( ret )","end",""],"class":"function","name":"coroutine_library.create","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},"wait":{"comment":["--- Suspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","-- @param time Time in seconds to suspend the coroutine"],"code":["function coroutine_library.wait ( time )","\tcoroutine.wait( time )","\tSF.CheckType( time, \"number\" )","end"],"class":"function","name":"coroutine_library.wait","summary":"\nSuspends the coroutine for a number of seconds.","private":false,"library":"coroutine","description":"\nSuspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","param":{"1":"time","time":"Time in seconds to suspend the coroutine"}}},"class":"library","summary":"\nCoroutine library ","code":["local coroutine_library, _ = SF.Libraries.Register( \"coroutine\" )","local coroutine = coroutine","","local _, thread_metamethods = SF.Typedef( \"thread\" )","local wrap, unwrap = SF.CreateWrapper( thread_metamethods, true, false )","","local coroutines = setmetatable( {}, { __mode = \"v\" } )","","local function createCoroutine ( func )","\t-- Can't use coroutine.create, because of a bug that prevents halting the program when it exceeds quota","","\t-- Hack to get the coroutine from a wrapped function. Necessary because coroutine.create is not available","\tlocal wrappedFunc = coroutine.wrap( function() return func( coroutine.yield( coroutine.running() ) ) end ) ","\t","\tlocal thread = wrappedFunc()","","\tcoroutines[ thread ] = wrappedFunc","\t","\treturn wrappedFunc, thread","end",""],"fields":[],"name":"coroutine","client":true,"description":"\nCoroutine library","libtbl":"coroutine_library","tables":[],"server":true},{"ret":"coroutine","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return coroutine"],"code":["function coroutine_library.create ( func )","\tSF.CheckType( func, \"function\" )","","\tlocal wrappedFunc, thread = createCoroutine( func )","","\tlocal ret = { func = wrappedFunc, thread = thread }","","\treturn wrap( ret )","end",""],"class":"function","name":"coroutine_library.create","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},{"ret":"A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine.","comment":["--- Creates a new coroutine.","-- @param func Function of the coroutine","-- @return A function that, when called, resumes the created coroutine. Any parameters to that function will be passed to the coroutine."],"code":["function coroutine_library.wrap ( func )","\tSF.CheckType( func, \"function\" )","\t","\tlocal wrappedFunc, thread = createCoroutine( func )","","\treturn wrappedFunc","end",""],"class":"function","name":"coroutine_library.wrap","summary":"\nCreates a new coroutine.","private":false,"library":"coroutine","description":"\nCreates a new coroutine.","param":{"1":"func","func":"Function of the coroutine"}},{"ret":"Any values the coroutine is returning to the main thread","comment":["--- Resumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","-- @param thread coroutine to resume","-- @param ... optional parameters that will be passed to the coroutine","-- @return Any values the coroutine is returning to the main thread"],"code":["function coroutine_library.resume ( thread, ... )","\tSF.CheckType( thread, thread_metamethods )","\tlocal func = unwrap( thread ).func","\treturn func( ... )","end",""],"class":"function","name":"coroutine_library.resume","summary":"\nResumes a suspended coroutine.","private":false,"library":"coroutine","description":"\nResumes a suspended coroutine. Note that, in contrast to Lua's native coroutine.resume function, it will not run in protected mode and can throw an error.","param":{"1":"thread","2":"...","...":"optional parameters that will be passed to the coroutine","thread":"coroutine to resume"}},{"ret":"Any values passed to the coroutine","comment":["--- Suspends the currently running coroutine. May not be called outside a coroutine.","-- @param ... optional parameters that will be returned to the main thread","-- @return Any values passed to the coroutine"],"code":["function coroutine_library.yield ( ... )","\treturn coroutine.yield( ... )","end",""],"class":"function","name":"coroutine_library.yield","summary":"\nSuspends the currently running coroutine.","private":false,"library":"coroutine","description":"\nSuspends the currently running coroutine. May not be called outside a coroutine.","param":{"1":"...","...":"optional parameters that will be returned to the main thread"}},{"ret":"Either \"suspended\", \"running\", \"normal\" or \"dead\"","comment":["--- Returns the status of the coroutine.","-- @param thread The coroutine","-- @return Either \"suspended\", \"running\", \"normal\" or \"dead\""],"code":["function coroutine_library.status ( thread )","\tSF.CheckType( thread, thread_metamethods )","\tlocal thread = unwrap( thread ).thread","\treturn coroutine.status( thread )","end",""],"class":"function","name":"coroutine_library.status","summary":"\nReturns the status of the coroutine.","private":false,"library":"coroutine","description":"\nReturns the status of the coroutine.","param":{"1":"thread","thread":"The coroutine"}},{"ret":"Currently running coroutine","comment":["--- Returns the coroutine that is currently running.","-- @return Currently running coroutine"],"code":["function coroutine_library.running ()","\tlocal thread = coroutine.running()","\treturn wrap( { thread = thread, func = coroutines[ thread ] } )","end",""],"class":"function","name":"coroutine_library.running","summary":"\nReturns the coroutine that is currently running.","private":false,"library":"coroutine","description":"\nReturns the coroutine that is currently running.","param":[]},{"comment":["--- Suspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","-- @param time Time in seconds to suspend the coroutine"],"code":["function coroutine_library.wait ( time )","\tcoroutine.wait( time )","\tSF.CheckType( time, \"number\" )","end"],"class":"function","name":"coroutine_library.wait","summary":"\nSuspends the coroutine for a number of seconds.","private":false,"library":"coroutine","description":"\nSuspends the coroutine for a number of seconds. Note that the coroutine will not resume automatically, but any attempts to resume the coroutine while it is waiting will not resume the coroutine and act as if the coroutine suspended itself immediately.","param":{"1":"time","time":"Time in seconds to suspend the coroutine"}}],"tables":[],"description":"\nCoroutine library","summary":"\nCoroutine library "},"libs_sh/fastlz.lua":{"libraries":{"1":"fastlz","fastlz":{"comment":["--- FastLZ library","-- @shared"],"functions":{"1":"compress","2":"decompress","decompress":{"ret":"Decompressed string","comment":["--- Decompress using FastLZ","-- @param s FastLZ compressed string to decode","-- @return Decompressed string"],"code":["function fastlz_library.decompress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Decompress( s )","end"],"class":"function","name":"fastlz_library.decompress","summary":"\nDecompress using FastLZ ","private":false,"library":"fastlz","description":"\nDecompress using FastLZ","param":{"1":"s","s":"FastLZ compressed string to decode"}},"compress":{"ret":"FastLZ compressed string","comment":["--- Compress string using FastLZ","--@param s String to compress","--@return FastLZ compressed string"],"code":["function fastlz_library.compress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Compress( s )","end",""],"class":"function","name":"fastlz_library.compress","summary":"\nCompress string using FastLZ ","private":false,"library":"fastlz","description":"\nCompress string using FastLZ","param":{"1":"s","s":"String to compress"}}},"class":"library","summary":"\nFastLZ library ","code":["local fastlz_library, _ = SF.Libraries.Register( \"fastlz\" )","local util = util",""],"fields":[],"name":"fastlz","client":true,"description":"\nFastLZ library","libtbl":"fastlz_library","tables":[],"server":true}},"type":"file","name":"libs_sh/fastlz.lua","functions":{"1":"fastlz_library.compress","2":"fastlz_library.decompress","fastlz_library.compress":{"ret":"FastLZ compressed string","comment":["--- Compress string using FastLZ","--@param s String to compress","--@return FastLZ compressed string"],"code":["function fastlz_library.compress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Compress( s )","end",""],"class":"function","name":"fastlz_library.compress","summary":"\nCompress string using FastLZ ","private":false,"library":"fastlz","description":"\nCompress string using FastLZ","param":{"1":"s","s":"String to compress"}},"fastlz_library.decompress":{"ret":"Decompressed string","comment":["--- Decompress using FastLZ","-- @param s FastLZ compressed string to decode","-- @return Decompressed string"],"code":["function fastlz_library.decompress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Decompress( s )","end"],"class":"function","name":"fastlz_library.decompress","summary":"\nDecompress using FastLZ ","private":false,"library":"fastlz","description":"\nDecompress using FastLZ","param":{"1":"s","s":"FastLZ compressed string to decode"}}},"doc":[{"comment":["--- FastLZ library","-- @shared"],"functions":{"1":"compress","2":"decompress","decompress":{"ret":"Decompressed string","comment":["--- Decompress using FastLZ","-- @param s FastLZ compressed string to decode","-- @return Decompressed string"],"code":["function fastlz_library.decompress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Decompress( s )","end"],"class":"function","name":"fastlz_library.decompress","summary":"\nDecompress using FastLZ ","private":false,"library":"fastlz","description":"\nDecompress using FastLZ","param":{"1":"s","s":"FastLZ compressed string to decode"}},"compress":{"ret":"FastLZ compressed string","comment":["--- Compress string using FastLZ","--@param s String to compress","--@return FastLZ compressed string"],"code":["function fastlz_library.compress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Compress( s )","end",""],"class":"function","name":"fastlz_library.compress","summary":"\nCompress string using FastLZ ","private":false,"library":"fastlz","description":"\nCompress string using FastLZ","param":{"1":"s","s":"String to compress"}}},"class":"library","summary":"\nFastLZ library ","code":["local fastlz_library, _ = SF.Libraries.Register( \"fastlz\" )","local util = util",""],"fields":[],"name":"fastlz","client":true,"description":"\nFastLZ library","libtbl":"fastlz_library","tables":[],"server":true},{"ret":"FastLZ compressed string","comment":["--- Compress string using FastLZ","--@param s String to compress","--@return FastLZ compressed string"],"code":["function fastlz_library.compress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Compress( s )","end",""],"class":"function","name":"fastlz_library.compress","summary":"\nCompress string using FastLZ ","private":false,"library":"fastlz","description":"\nCompress string using FastLZ","param":{"1":"s","s":"String to compress"}},{"ret":"Decompressed string","comment":["--- Decompress using FastLZ","-- @param s FastLZ compressed string to decode","-- @return Decompressed string"],"code":["function fastlz_library.decompress ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.Decompress( s )","end"],"class":"function","name":"fastlz_library.decompress","summary":"\nDecompress using FastLZ ","private":false,"library":"fastlz","description":"\nDecompress using FastLZ","param":{"1":"s","s":"FastLZ compressed string to decode"}}],"tables":[],"description":"\nFastLZ library","summary":"\nFastLZ library "},"permissions/providers_sh/placeholder.lua":{"libraries":[],"type":"file","name":"permissions/providers_sh/placeholder.lua","functions":[],"doc":[{"comment":["--- Placeholder for the default provider. Allows a bunch of permissions for everyone"],"code":["","local P = setmetatable( {}, { __index = SF.Permissions.Provider } )","","local ALLOW = SF.Permissions.Result.ALLOW","local DENY = SF.Permissions.Result.DENY","local NEUTRAL = SF.Permissions.Result.NEUTRAL","","local allow = {","\t[ \"find\" ] = true,","\t[ \"sound.create\" ] = true,","\t[ \"sound.modify\" ] = true,","\t[ \"wire.setOutputs\" ] = true,","\t[ \"wire.setInputs\" ] = true,","\t[ \"wire.output\" ] = true,","\t[ \"wire.input\" ] = true,","\t[ \"wire.wirelink.read\" ] = true,","\t[ \"wire.wirelink.write\" ] = true,","\t[ \"trace\" ] = true,","\t[ \"find\" ] = true","}","","function P:check ( principal, target, key )","\tif allow[ key ] then return ALLOW end","\treturn NEUTRAL","end","","SF.Permissions.registerProvider( P )"],"summary":"\nPlaceholder for the default provider.","description":"\nPlaceholder for the default provider. Allows a bunch of permissions for everyone","param":[]}],"tables":[],"description":"\nPlaceholder for the default provider. Allows a bunch of permissions for everyone","summary":"\nPlaceholder for the default provider."},"libs_sv/constraint.lua":{"libraries":{"1":"constraint","constraint":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @server"],"functions":{"1":"axis","2":"ballsocket","3":"ballsocketadv","4":"breakAll","5":"breakType","6":"elastic","7":"getTable","8":"nocollide","9":"rope","10":"setElasticLength","11":"setRopeLength","12":"slider","13":"weld","ballsocketadv":{"comment":["--- Advanced Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocketadv(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, minv, maxv, frictionv, rotateonly, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal mins = vunwrap( minv ) or Vector ( 0, 0, 0 )","\tlocal maxs = vunwrap( maxv ) or Vector ( 0, 0, 0 )","\tlocal frictions = vunwrap( frictionv ) or Vector ( 0, 0, 0 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocketadv\" )","\tcheckConstraint( ent2, \"constraints.ballsocketadv\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\trotateonly = rotateonly and 1 or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.AdvBallsocket(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, mins.x, mins.y, mins.z, maxs.x, maxs.y, maxs.z, frictions.x, frictions.y, frictions.z, rotateonly, nocollide)","end",""],"class":"function","summary":"\nAdvanced Ballsocket two entities ","name":"constraint_library.ballsocketadv","library":"constraint","private":false,"server":true,"description":"\nAdvanced Ballsocket two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","minv","maxv","frictionv","rotateonly","nocollide"]},"nocollide":{"comment":["--- Nocollides two entities","-- @server "],"code":["function constraint_library.nocollide(e1, e2, bone1, bone2)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.nocollide\" )","\tcheckConstraint( ent2, \"constraints.nocollide\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\t","\tconstraint.NoCollide(ent1, ent2, bone1, bone2)","end",""],"class":"function","summary":"\nNocollides two entities ","name":"constraint_library.nocollide","library":"constraint","private":false,"server":true,"description":"\nNocollides two entities","param":["e1","e2","bone1","bone2"]},"elastic":{"comment":["--- Elastic two entities","-- @server "],"code":["function constraint_library.elastic(index, e1, e2, bone1, bone2, v1, v2, const, damp, rdamp, width, strech)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.elastic\" )","\tcheckConstraint( ent2, \"constraints.elastic\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tconst = const or 1000","\tdamp = damp or 100","\trdamp = rdamp or 0","\twidth = math.Clamp( width or 0, 0, 50)","\tstrech = strech and true or false","\t","\te1.Elastics = e1.Elastics or {}","\te2.Elastics = e2.Elastics or {}","\t","\tlocal e = constraint.Elastic( ent1, ent2, bone1, bone2, vec1, vec2, const, damp, rdamp, \"cable/cable2\", width, strech )","\t","\te1.Elastics[index] = e","\te2.Elastics[index] = e","end",""],"class":"function","summary":"\nElastic two entities ","name":"constraint_library.elastic","library":"constraint","private":false,"server":true,"description":"\nElastic two entities","param":["index","e1","e2","bone1","bone2","v1","v2","const","damp","rdamp","width","strech"]},"getTable":{"ret":"Table of entity constraints","comment":["--- Returns the table of constraints on an entity","-- @param ent The entity","-- @return Table of entity constraints"],"code":["function constraint_library.getTable( ent )","\tSF.CheckType( ent, ents_metatable )","","\tent = eunwrap( ent )","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn SF.Sanitize(constraint.GetTable( ent ))","end"],"class":"function","name":"constraint_library.getTable","summary":"\nReturns the table of constraints on an entity ","private":false,"library":"constraint","description":"\nReturns the table of constraints on an entity","param":{"1":"ent","ent":"The entity"}},"axis":{"comment":["--- Axis two entities","-- @server"],"code":["function constraint_library.axis(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, friction, nocollide, laxis)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal axis = laxis and vunwrap( laxis ) or nil","\t","\tcheckConstraint( ent1, \"constraints.axis\" )","\tcheckConstraint( ent2, \"constraints.axis\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tfriction = friction or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.Axis(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, friction, nocollide, axis)","end",""],"class":"function","summary":"\nAxis two entities ","name":"constraint_library.axis","library":"constraint","private":false,"server":true,"description":"\nAxis two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","friction","nocollide","laxis"]},"setElasticLength":{"comment":["--- Sets the length of an elastic attached to the entity","-- @server "],"code":["function constraint_library.setElasticLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.elastic\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlength = math.max( length or 0, 0)","","\tif e.Elastics then","\t\tlocal con = e.Elastics[index]","\t\tif IsValid(con) then","\t\t\tcon:Fire(\"SetSpringLength\", length, 0)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of an elastic attached to the entity ","name":"constraint_library.setElasticLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of an elastic attached to the entity","param":["index","e","length"]},"breakType":{"comment":["--- Breaks all constraints of a certain type on an entity","-- @server "],"code":["function constraint_library.breakType(e, typename)","\tSF.CheckType( e, ents_metatable )","    SF.CheckType( typename, \"string\" )","\t","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveConstraints(ent1, typename)","end","",""],"class":"function","summary":"\nBreaks all constraints of a certain type on an entity ","name":"constraint_library.breakType","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints of a certain type on an entity","param":["e","typename"]},"weld":{"comment":["--- Welds two entities","-- @param e1 The first entity","-- @param e2 The second entity","-- @param bone1 Number bone of the first entity","-- @param bone2 Number bone of the second entity","-- @param force_lim Max force the weld can take before breaking","-- @param nocollide Bool whether or not to nocollide the two entities","-- @server"],"code":["function constraint_library.weld(e1, e2, bone1, bone2, force_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.weld\" )","\tcheckConstraint( ent2, \"constraints.weld\" )","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\tnocollide = nocollide and true or false","\t","\tconstraint.Weld(ent1, ent2, bone1, bone2, force_lim, nocollide)","end",""],"class":"function","summary":"\nWelds two entities ","name":"constraint_library.weld","library":"constraint","private":false,"server":true,"description":"\nWelds two entities","param":{"1":"e1","2":"e2","3":"bone1","4":"bone2","5":"force_lim","6":"nocollide","e2":"The second entity","e1":"The first entity","bone2":"Number bone of the second entity","nocollide":"Bool whether or not to nocollide the two entities","bone1":"Number bone of the first entity","force_lim":"Max force the weld can take before breaking"}},"rope":{"comment":["--- Ropes two entities","-- @server "],"code":["function constraint_library.rope(index, e1, e2, bone1, bone2, v1, v2, length, addlength, force_lim, width, material, rigid)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.rope\" )","\tcheckConstraint( ent2, \"constraints.rope\" )","","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tlength = length or 0","\taddlength = addlength or 0","\tforce_lim = force_lim or 0","\twidth = math.Clamp( width or 0, 0, 50)","\trigid = rigid and true or false","\t","\te1.Ropes = e1.Ropes or {}","\te2.Ropes = e2.Ropes or {}","\t","\tlocal e = constraint.Rope( ent1, ent2, bone1, bone2, vec1, vec2, length, addlength, force_lim, width, material, rigid )","\t","\te1.Ropes[index] = e","\te2.Ropes[index] = e","end",""],"class":"function","summary":"\nRopes two entities ","name":"constraint_library.rope","library":"constraint","private":false,"server":true,"description":"\nRopes two entities","param":["index","e1","e2","bone1","bone2","v1","v2","length","addlength","force_lim","width","material","rigid"]},"breakAll":{"comment":["--- Breaks all constraints on an entity","-- @server "],"code":["function constraint_library.breakAll(e)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveAll(ent1)","end",""],"class":"function","summary":"\nBreaks all constraints on an entity ","name":"constraint_library.breakAll","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints on an entity","param":["e"]},"setRopeLength":{"comment":["--- Sets the length of a rope attached to the entity","-- @server "],"code":["function constraint_library.setRopeLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.rope\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlength = math.max( length or 0, 0)","","\t","\tif e.Ropes then","\t\tlocal con = e.Ropes[index]","\t\tif IsValid(con) then","\t\t\tcon:SetKeyValue(\"addlength\", length)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of a rope attached to the entity ","name":"constraint_library.setRopeLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of a rope attached to the entity","param":["index","e","length"]},"ballsocket":{"comment":["--- Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocket(e1, e2, bone1, bone2, v1, force_lim, torque_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocket\" )","\tcheckConstraint( ent2, \"constraints.ballsocket\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.Ballsocket(ent1, ent2, bone1, bone2, vec1, force_lim, torque_lim, nocollide)","end",""],"class":"function","summary":"\nBallsocket two entities ","name":"constraint_library.ballsocket","library":"constraint","private":false,"server":true,"description":"\nBallsocket two entities","param":["e1","e2","bone1","bone2","v1","force_lim","torque_lim","nocollide"]},"slider":{"comment":["--- Sliders two entities","-- @server "],"code":["function constraint_library.slider(e1, e2, bone1, bone2, v1, v2, width)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.slider\" )","\tcheckConstraint( ent2, \"constraints.slider\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\twidth = math.Clamp( width or 0, 0, 50)","","\tconstraint.Slider(ent1, ent2, bone1, bone2, vec1, vec2, width, \"cable/cable2\")","end",""],"class":"function","summary":"\nSliders two entities ","name":"constraint_library.slider","library":"constraint","private":false,"server":true,"description":"\nSliders two entities","param":["e1","e2","bone1","bone2","v1","v2","width"]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","fields":[],"name":"constraint","code":["local constraint_library, constraint_library_metamethods = SF.Libraries.Register(\"constraint\")","","local ents_metatable = SF.Entities.Metatable","local vunwrap = SF.UnwrapObject","local eunwrap = SF.Entities.Unwrap","local vwrap = SF.WrapObject","local ewrap = SF.Entities.Wrap","","local function checkConstraint(e, t)","\tif e then","\t\tif e:IsValid() then","\t\t\tif not SF.Permissions.check( SF.instance.player, e, t ) then","\t\t\t\tSF.throw( \"Insufficient permissions\", 3 )","\t\t\tend","\t\telseif not e:IsWorld() then","\t\t\tSF.throw( \"Invalid Entity\", 3 )","\t\tend","\telse","\t\tSF.throw( \"Invalid Entity\", 3 )","\tend","end","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"constraints.weld\", \"Weld\", \"Allows the user to weld two entities\" )","\tP.registerPrivilege( \"constraints.axis\", \"Axis\", \"Allows the user to axis two entities\" )","\tP.registerPrivilege( \"constraints.ballsocket\", \"Ballsocket\", \"Allows the user to ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.ballsocketadv\", \"BallsocketAdv\", \"Allows the user to advanced ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.slider\", \"Slider\", \"Allows the user to slider two entities\" )","\tP.registerPrivilege( \"constraints.rope\", \"Rope\", \"Allows the user to rope two entities\" )","\tP.registerPrivilege( \"constraints.elastic\", \"Elastic\", \"Allows the user to elastic two entities\" )","\tP.registerPrivilege( \"constraints.nocollide\", \"Nocollide\", \"Allows the user to nocollide two entities\" )","\tP.registerPrivilege( \"constraints.any\", \"Any\", \"General constraint functions\" )","end",""],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"constraint_library","tables":[],"server":true}},"type":"file","name":"libs_sv/constraint.lua","functions":{"1":"constraint_library.axis","2":"constraint_library.ballsocket","3":"constraint_library.ballsocketadv","4":"constraint_library.breakAll","5":"constraint_library.breakType","6":"constraint_library.elastic","7":"constraint_library.getTable","8":"constraint_library.nocollide","9":"constraint_library.rope","10":"constraint_library.setElasticLength","11":"constraint_library.setRopeLength","12":"constraint_library.slider","13":"constraint_library.weld","constraint_library.weld":{"comment":["--- Welds two entities","-- @param e1 The first entity","-- @param e2 The second entity","-- @param bone1 Number bone of the first entity","-- @param bone2 Number bone of the second entity","-- @param force_lim Max force the weld can take before breaking","-- @param nocollide Bool whether or not to nocollide the two entities","-- @server"],"code":["function constraint_library.weld(e1, e2, bone1, bone2, force_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.weld\" )","\tcheckConstraint( ent2, \"constraints.weld\" )","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\tnocollide = nocollide and true or false","\t","\tconstraint.Weld(ent1, ent2, bone1, bone2, force_lim, nocollide)","end",""],"class":"function","summary":"\nWelds two entities ","name":"constraint_library.weld","library":"constraint","private":false,"server":true,"description":"\nWelds two entities","param":{"1":"e1","2":"e2","3":"bone1","4":"bone2","5":"force_lim","6":"nocollide","e2":"The second entity","e1":"The first entity","bone2":"Number bone of the second entity","nocollide":"Bool whether or not to nocollide the two entities","bone1":"Number bone of the first entity","force_lim":"Max force the weld can take before breaking"}},"constraint_library.ballsocket":{"comment":["--- Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocket(e1, e2, bone1, bone2, v1, force_lim, torque_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocket\" )","\tcheckConstraint( ent2, \"constraints.ballsocket\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.Ballsocket(ent1, ent2, bone1, bone2, vec1, force_lim, torque_lim, nocollide)","end",""],"class":"function","summary":"\nBallsocket two entities ","name":"constraint_library.ballsocket","library":"constraint","private":false,"server":true,"description":"\nBallsocket two entities","param":["e1","e2","bone1","bone2","v1","force_lim","torque_lim","nocollide"]},"constraint_library.ballsocketadv":{"comment":["--- Advanced Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocketadv(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, minv, maxv, frictionv, rotateonly, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal mins = vunwrap( minv ) or Vector ( 0, 0, 0 )","\tlocal maxs = vunwrap( maxv ) or Vector ( 0, 0, 0 )","\tlocal frictions = vunwrap( frictionv ) or Vector ( 0, 0, 0 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocketadv\" )","\tcheckConstraint( ent2, \"constraints.ballsocketadv\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\trotateonly = rotateonly and 1 or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.AdvBallsocket(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, mins.x, mins.y, mins.z, maxs.x, maxs.y, maxs.z, frictions.x, frictions.y, frictions.z, rotateonly, nocollide)","end",""],"class":"function","summary":"\nAdvanced Ballsocket two entities ","name":"constraint_library.ballsocketadv","library":"constraint","private":false,"server":true,"description":"\nAdvanced Ballsocket two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","minv","maxv","frictionv","rotateonly","nocollide"]},"constraint_library.nocollide":{"comment":["--- Nocollides two entities","-- @server "],"code":["function constraint_library.nocollide(e1, e2, bone1, bone2)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.nocollide\" )","\tcheckConstraint( ent2, \"constraints.nocollide\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\t","\tconstraint.NoCollide(ent1, ent2, bone1, bone2)","end",""],"class":"function","summary":"\nNocollides two entities ","name":"constraint_library.nocollide","library":"constraint","private":false,"server":true,"description":"\nNocollides two entities","param":["e1","e2","bone1","bone2"]},"constraint_library.breakType":{"comment":["--- Breaks all constraints of a certain type on an entity","-- @server "],"code":["function constraint_library.breakType(e, typename)","\tSF.CheckType( e, ents_metatable )","    SF.CheckType( typename, \"string\" )","\t","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveConstraints(ent1, typename)","end","",""],"class":"function","summary":"\nBreaks all constraints of a certain type on an entity ","name":"constraint_library.breakType","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints of a certain type on an entity","param":["e","typename"]},"constraint_library.getTable":{"ret":"Table of entity constraints","comment":["--- Returns the table of constraints on an entity","-- @param ent The entity","-- @return Table of entity constraints"],"code":["function constraint_library.getTable( ent )","\tSF.CheckType( ent, ents_metatable )","","\tent = eunwrap( ent )","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn SF.Sanitize(constraint.GetTable( ent ))","end"],"class":"function","name":"constraint_library.getTable","summary":"\nReturns the table of constraints on an entity ","private":false,"library":"constraint","description":"\nReturns the table of constraints on an entity","param":{"1":"ent","ent":"The entity"}},"constraint_library.elastic":{"comment":["--- Elastic two entities","-- @server "],"code":["function constraint_library.elastic(index, e1, e2, bone1, bone2, v1, v2, const, damp, rdamp, width, strech)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.elastic\" )","\tcheckConstraint( ent2, \"constraints.elastic\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tconst = const or 1000","\tdamp = damp or 100","\trdamp = rdamp or 0","\twidth = math.Clamp( width or 0, 0, 50)","\tstrech = strech and true or false","\t","\te1.Elastics = e1.Elastics or {}","\te2.Elastics = e2.Elastics or {}","\t","\tlocal e = constraint.Elastic( ent1, ent2, bone1, bone2, vec1, vec2, const, damp, rdamp, \"cable/cable2\", width, strech )","\t","\te1.Elastics[index] = e","\te2.Elastics[index] = e","end",""],"class":"function","summary":"\nElastic two entities ","name":"constraint_library.elastic","library":"constraint","private":false,"server":true,"description":"\nElastic two entities","param":["index","e1","e2","bone1","bone2","v1","v2","const","damp","rdamp","width","strech"]},"constraint_library.breakAll":{"comment":["--- Breaks all constraints on an entity","-- @server "],"code":["function constraint_library.breakAll(e)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveAll(ent1)","end",""],"class":"function","summary":"\nBreaks all constraints on an entity ","name":"constraint_library.breakAll","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints on an entity","param":["e"]},"constraint_library.setElasticLength":{"comment":["--- Sets the length of an elastic attached to the entity","-- @server "],"code":["function constraint_library.setElasticLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.elastic\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlength = math.max( length or 0, 0)","","\tif e.Elastics then","\t\tlocal con = e.Elastics[index]","\t\tif IsValid(con) then","\t\t\tcon:Fire(\"SetSpringLength\", length, 0)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of an elastic attached to the entity ","name":"constraint_library.setElasticLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of an elastic attached to the entity","param":["index","e","length"]},"constraint_library.rope":{"comment":["--- Ropes two entities","-- @server "],"code":["function constraint_library.rope(index, e1, e2, bone1, bone2, v1, v2, length, addlength, force_lim, width, material, rigid)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.rope\" )","\tcheckConstraint( ent2, \"constraints.rope\" )","","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tlength = length or 0","\taddlength = addlength or 0","\tforce_lim = force_lim or 0","\twidth = math.Clamp( width or 0, 0, 50)","\trigid = rigid and true or false","\t","\te1.Ropes = e1.Ropes or {}","\te2.Ropes = e2.Ropes or {}","\t","\tlocal e = constraint.Rope( ent1, ent2, bone1, bone2, vec1, vec2, length, addlength, force_lim, width, material, rigid )","\t","\te1.Ropes[index] = e","\te2.Ropes[index] = e","end",""],"class":"function","summary":"\nRopes two entities ","name":"constraint_library.rope","library":"constraint","private":false,"server":true,"description":"\nRopes two entities","param":["index","e1","e2","bone1","bone2","v1","v2","length","addlength","force_lim","width","material","rigid"]},"constraint_library.axis":{"comment":["--- Axis two entities","-- @server"],"code":["function constraint_library.axis(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, friction, nocollide, laxis)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal axis = laxis and vunwrap( laxis ) or nil","\t","\tcheckConstraint( ent1, \"constraints.axis\" )","\tcheckConstraint( ent2, \"constraints.axis\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tfriction = friction or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.Axis(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, friction, nocollide, axis)","end",""],"class":"function","summary":"\nAxis two entities ","name":"constraint_library.axis","library":"constraint","private":false,"server":true,"description":"\nAxis two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","friction","nocollide","laxis"]},"constraint_library.slider":{"comment":["--- Sliders two entities","-- @server "],"code":["function constraint_library.slider(e1, e2, bone1, bone2, v1, v2, width)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.slider\" )","\tcheckConstraint( ent2, \"constraints.slider\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\twidth = math.Clamp( width or 0, 0, 50)","","\tconstraint.Slider(ent1, ent2, bone1, bone2, vec1, vec2, width, \"cable/cable2\")","end",""],"class":"function","summary":"\nSliders two entities ","name":"constraint_library.slider","library":"constraint","private":false,"server":true,"description":"\nSliders two entities","param":["e1","e2","bone1","bone2","v1","v2","width"]},"constraint_library.setRopeLength":{"comment":["--- Sets the length of a rope attached to the entity","-- @server "],"code":["function constraint_library.setRopeLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.rope\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlength = math.max( length or 0, 0)","","\t","\tif e.Ropes then","\t\tlocal con = e.Ropes[index]","\t\tif IsValid(con) then","\t\t\tcon:SetKeyValue(\"addlength\", length)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of a rope attached to the entity ","name":"constraint_library.setRopeLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of a rope attached to the entity","param":["index","e","length"]}},"doc":[{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @server"],"functions":{"1":"axis","2":"ballsocket","3":"ballsocketadv","4":"breakAll","5":"breakType","6":"elastic","7":"getTable","8":"nocollide","9":"rope","10":"setElasticLength","11":"setRopeLength","12":"slider","13":"weld","ballsocketadv":{"comment":["--- Advanced Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocketadv(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, minv, maxv, frictionv, rotateonly, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal mins = vunwrap( minv ) or Vector ( 0, 0, 0 )","\tlocal maxs = vunwrap( maxv ) or Vector ( 0, 0, 0 )","\tlocal frictions = vunwrap( frictionv ) or Vector ( 0, 0, 0 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocketadv\" )","\tcheckConstraint( ent2, \"constraints.ballsocketadv\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\trotateonly = rotateonly and 1 or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.AdvBallsocket(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, mins.x, mins.y, mins.z, maxs.x, maxs.y, maxs.z, frictions.x, frictions.y, frictions.z, rotateonly, nocollide)","end",""],"class":"function","summary":"\nAdvanced Ballsocket two entities ","name":"constraint_library.ballsocketadv","library":"constraint","private":false,"server":true,"description":"\nAdvanced Ballsocket two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","minv","maxv","frictionv","rotateonly","nocollide"]},"nocollide":{"comment":["--- Nocollides two entities","-- @server "],"code":["function constraint_library.nocollide(e1, e2, bone1, bone2)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.nocollide\" )","\tcheckConstraint( ent2, \"constraints.nocollide\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\t","\tconstraint.NoCollide(ent1, ent2, bone1, bone2)","end",""],"class":"function","summary":"\nNocollides two entities ","name":"constraint_library.nocollide","library":"constraint","private":false,"server":true,"description":"\nNocollides two entities","param":["e1","e2","bone1","bone2"]},"elastic":{"comment":["--- Elastic two entities","-- @server "],"code":["function constraint_library.elastic(index, e1, e2, bone1, bone2, v1, v2, const, damp, rdamp, width, strech)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.elastic\" )","\tcheckConstraint( ent2, \"constraints.elastic\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tconst = const or 1000","\tdamp = damp or 100","\trdamp = rdamp or 0","\twidth = math.Clamp( width or 0, 0, 50)","\tstrech = strech and true or false","\t","\te1.Elastics = e1.Elastics or {}","\te2.Elastics = e2.Elastics or {}","\t","\tlocal e = constraint.Elastic( ent1, ent2, bone1, bone2, vec1, vec2, const, damp, rdamp, \"cable/cable2\", width, strech )","\t","\te1.Elastics[index] = e","\te2.Elastics[index] = e","end",""],"class":"function","summary":"\nElastic two entities ","name":"constraint_library.elastic","library":"constraint","private":false,"server":true,"description":"\nElastic two entities","param":["index","e1","e2","bone1","bone2","v1","v2","const","damp","rdamp","width","strech"]},"getTable":{"ret":"Table of entity constraints","comment":["--- Returns the table of constraints on an entity","-- @param ent The entity","-- @return Table of entity constraints"],"code":["function constraint_library.getTable( ent )","\tSF.CheckType( ent, ents_metatable )","","\tent = eunwrap( ent )","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn SF.Sanitize(constraint.GetTable( ent ))","end"],"class":"function","name":"constraint_library.getTable","summary":"\nReturns the table of constraints on an entity ","private":false,"library":"constraint","description":"\nReturns the table of constraints on an entity","param":{"1":"ent","ent":"The entity"}},"axis":{"comment":["--- Axis two entities","-- @server"],"code":["function constraint_library.axis(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, friction, nocollide, laxis)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal axis = laxis and vunwrap( laxis ) or nil","\t","\tcheckConstraint( ent1, \"constraints.axis\" )","\tcheckConstraint( ent2, \"constraints.axis\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tfriction = friction or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.Axis(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, friction, nocollide, axis)","end",""],"class":"function","summary":"\nAxis two entities ","name":"constraint_library.axis","library":"constraint","private":false,"server":true,"description":"\nAxis two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","friction","nocollide","laxis"]},"setElasticLength":{"comment":["--- Sets the length of an elastic attached to the entity","-- @server "],"code":["function constraint_library.setElasticLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.elastic\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlength = math.max( length or 0, 0)","","\tif e.Elastics then","\t\tlocal con = e.Elastics[index]","\t\tif IsValid(con) then","\t\t\tcon:Fire(\"SetSpringLength\", length, 0)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of an elastic attached to the entity ","name":"constraint_library.setElasticLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of an elastic attached to the entity","param":["index","e","length"]},"breakType":{"comment":["--- Breaks all constraints of a certain type on an entity","-- @server "],"code":["function constraint_library.breakType(e, typename)","\tSF.CheckType( e, ents_metatable )","    SF.CheckType( typename, \"string\" )","\t","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveConstraints(ent1, typename)","end","",""],"class":"function","summary":"\nBreaks all constraints of a certain type on an entity ","name":"constraint_library.breakType","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints of a certain type on an entity","param":["e","typename"]},"weld":{"comment":["--- Welds two entities","-- @param e1 The first entity","-- @param e2 The second entity","-- @param bone1 Number bone of the first entity","-- @param bone2 Number bone of the second entity","-- @param force_lim Max force the weld can take before breaking","-- @param nocollide Bool whether or not to nocollide the two entities","-- @server"],"code":["function constraint_library.weld(e1, e2, bone1, bone2, force_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.weld\" )","\tcheckConstraint( ent2, \"constraints.weld\" )","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\tnocollide = nocollide and true or false","\t","\tconstraint.Weld(ent1, ent2, bone1, bone2, force_lim, nocollide)","end",""],"class":"function","summary":"\nWelds two entities ","name":"constraint_library.weld","library":"constraint","private":false,"server":true,"description":"\nWelds two entities","param":{"1":"e1","2":"e2","3":"bone1","4":"bone2","5":"force_lim","6":"nocollide","e2":"The second entity","e1":"The first entity","bone2":"Number bone of the second entity","nocollide":"Bool whether or not to nocollide the two entities","bone1":"Number bone of the first entity","force_lim":"Max force the weld can take before breaking"}},"rope":{"comment":["--- Ropes two entities","-- @server "],"code":["function constraint_library.rope(index, e1, e2, bone1, bone2, v1, v2, length, addlength, force_lim, width, material, rigid)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.rope\" )","\tcheckConstraint( ent2, \"constraints.rope\" )","","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tlength = length or 0","\taddlength = addlength or 0","\tforce_lim = force_lim or 0","\twidth = math.Clamp( width or 0, 0, 50)","\trigid = rigid and true or false","\t","\te1.Ropes = e1.Ropes or {}","\te2.Ropes = e2.Ropes or {}","\t","\tlocal e = constraint.Rope( ent1, ent2, bone1, bone2, vec1, vec2, length, addlength, force_lim, width, material, rigid )","\t","\te1.Ropes[index] = e","\te2.Ropes[index] = e","end",""],"class":"function","summary":"\nRopes two entities ","name":"constraint_library.rope","library":"constraint","private":false,"server":true,"description":"\nRopes two entities","param":["index","e1","e2","bone1","bone2","v1","v2","length","addlength","force_lim","width","material","rigid"]},"breakAll":{"comment":["--- Breaks all constraints on an entity","-- @server "],"code":["function constraint_library.breakAll(e)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveAll(ent1)","end",""],"class":"function","summary":"\nBreaks all constraints on an entity ","name":"constraint_library.breakAll","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints on an entity","param":["e"]},"setRopeLength":{"comment":["--- Sets the length of a rope attached to the entity","-- @server "],"code":["function constraint_library.setRopeLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.rope\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlength = math.max( length or 0, 0)","","\t","\tif e.Ropes then","\t\tlocal con = e.Ropes[index]","\t\tif IsValid(con) then","\t\t\tcon:SetKeyValue(\"addlength\", length)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of a rope attached to the entity ","name":"constraint_library.setRopeLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of a rope attached to the entity","param":["index","e","length"]},"ballsocket":{"comment":["--- Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocket(e1, e2, bone1, bone2, v1, force_lim, torque_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocket\" )","\tcheckConstraint( ent2, \"constraints.ballsocket\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.Ballsocket(ent1, ent2, bone1, bone2, vec1, force_lim, torque_lim, nocollide)","end",""],"class":"function","summary":"\nBallsocket two entities ","name":"constraint_library.ballsocket","library":"constraint","private":false,"server":true,"description":"\nBallsocket two entities","param":["e1","e2","bone1","bone2","v1","force_lim","torque_lim","nocollide"]},"slider":{"comment":["--- Sliders two entities","-- @server "],"code":["function constraint_library.slider(e1, e2, bone1, bone2, v1, v2, width)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.slider\" )","\tcheckConstraint( ent2, \"constraints.slider\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\twidth = math.Clamp( width or 0, 0, 50)","","\tconstraint.Slider(ent1, ent2, bone1, bone2, vec1, vec2, width, \"cable/cable2\")","end",""],"class":"function","summary":"\nSliders two entities ","name":"constraint_library.slider","library":"constraint","private":false,"server":true,"description":"\nSliders two entities","param":["e1","e2","bone1","bone2","v1","v2","width"]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","fields":[],"name":"constraint","code":["local constraint_library, constraint_library_metamethods = SF.Libraries.Register(\"constraint\")","","local ents_metatable = SF.Entities.Metatable","local vunwrap = SF.UnwrapObject","local eunwrap = SF.Entities.Unwrap","local vwrap = SF.WrapObject","local ewrap = SF.Entities.Wrap","","local function checkConstraint(e, t)","\tif e then","\t\tif e:IsValid() then","\t\t\tif not SF.Permissions.check( SF.instance.player, e, t ) then","\t\t\t\tSF.throw( \"Insufficient permissions\", 3 )","\t\t\tend","\t\telseif not e:IsWorld() then","\t\t\tSF.throw( \"Invalid Entity\", 3 )","\t\tend","\telse","\t\tSF.throw( \"Invalid Entity\", 3 )","\tend","end","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"constraints.weld\", \"Weld\", \"Allows the user to weld two entities\" )","\tP.registerPrivilege( \"constraints.axis\", \"Axis\", \"Allows the user to axis two entities\" )","\tP.registerPrivilege( \"constraints.ballsocket\", \"Ballsocket\", \"Allows the user to ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.ballsocketadv\", \"BallsocketAdv\", \"Allows the user to advanced ballsocket two entities\" )","\tP.registerPrivilege( \"constraints.slider\", \"Slider\", \"Allows the user to slider two entities\" )","\tP.registerPrivilege( \"constraints.rope\", \"Rope\", \"Allows the user to rope two entities\" )","\tP.registerPrivilege( \"constraints.elastic\", \"Elastic\", \"Allows the user to elastic two entities\" )","\tP.registerPrivilege( \"constraints.nocollide\", \"Nocollide\", \"Allows the user to nocollide two entities\" )","\tP.registerPrivilege( \"constraints.any\", \"Any\", \"General constraint functions\" )","end",""],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"constraint_library","tables":[],"server":true},{"comment":["--- Welds two entities","-- @param e1 The first entity","-- @param e2 The second entity","-- @param bone1 Number bone of the first entity","-- @param bone2 Number bone of the second entity","-- @param force_lim Max force the weld can take before breaking","-- @param nocollide Bool whether or not to nocollide the two entities","-- @server"],"code":["function constraint_library.weld(e1, e2, bone1, bone2, force_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.weld\" )","\tcheckConstraint( ent2, \"constraints.weld\" )","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\tnocollide = nocollide and true or false","\t","\tconstraint.Weld(ent1, ent2, bone1, bone2, force_lim, nocollide)","end",""],"class":"function","summary":"\nWelds two entities ","name":"constraint_library.weld","library":"constraint","private":false,"server":true,"description":"\nWelds two entities","param":{"1":"e1","2":"e2","3":"bone1","4":"bone2","5":"force_lim","6":"nocollide","e2":"The second entity","e1":"The first entity","bone2":"Number bone of the second entity","nocollide":"Bool whether or not to nocollide the two entities","bone1":"Number bone of the first entity","force_lim":"Max force the weld can take before breaking"}},{"comment":["--- Axis two entities","-- @server"],"code":["function constraint_library.axis(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, friction, nocollide, laxis)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal axis = laxis and vunwrap( laxis ) or nil","\t","\tcheckConstraint( ent1, \"constraints.axis\" )","\tcheckConstraint( ent2, \"constraints.axis\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tfriction = friction or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.Axis(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, friction, nocollide, axis)","end",""],"class":"function","summary":"\nAxis two entities ","name":"constraint_library.axis","library":"constraint","private":false,"server":true,"description":"\nAxis two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","friction","nocollide","laxis"]},{"comment":["--- Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocket(e1, e2, bone1, bone2, v1, force_lim, torque_lim, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocket\" )","\tcheckConstraint( ent2, \"constraints.ballsocket\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.Ballsocket(ent1, ent2, bone1, bone2, vec1, force_lim, torque_lim, nocollide)","end",""],"class":"function","summary":"\nBallsocket two entities ","name":"constraint_library.ballsocket","library":"constraint","private":false,"server":true,"description":"\nBallsocket two entities","param":["e1","e2","bone1","bone2","v1","force_lim","torque_lim","nocollide"]},{"comment":["--- Advanced Ballsocket two entities","-- @server"],"code":["function constraint_library.ballsocketadv(e1, e2, bone1, bone2, v1, v2, force_lim, torque_lim, minv, maxv, frictionv, rotateonly, nocollide)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\tlocal mins = vunwrap( minv ) or Vector ( 0, 0, 0 )","\tlocal maxs = vunwrap( maxv ) or Vector ( 0, 0, 0 )","\tlocal frictions = vunwrap( frictionv ) or Vector ( 0, 0, 0 )","\t","\tcheckConstraint( ent1, \"constraints.ballsocketadv\" )","\tcheckConstraint( ent2, \"constraints.ballsocketadv\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tforce_lim = force_lim or 0","\ttorque_lim = torque_lim or 0","\trotateonly = rotateonly and 1 or 0","\tnocollide = nocollide and 1 or 0","\t","\tconstraint.AdvBallsocket(ent1, ent2, bone1, bone2, vec1, vec2, force_lim, torque_lim, mins.x, mins.y, mins.z, maxs.x, maxs.y, maxs.z, frictions.x, frictions.y, frictions.z, rotateonly, nocollide)","end",""],"class":"function","summary":"\nAdvanced Ballsocket two entities ","name":"constraint_library.ballsocketadv","library":"constraint","private":false,"server":true,"description":"\nAdvanced Ballsocket two entities","param":["e1","e2","bone1","bone2","v1","v2","force_lim","torque_lim","minv","maxv","frictionv","rotateonly","nocollide"]},{"comment":["--- Elastic two entities","-- @server "],"code":["function constraint_library.elastic(index, e1, e2, bone1, bone2, v1, v2, const, damp, rdamp, width, strech)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.elastic\" )","\tcheckConstraint( ent2, \"constraints.elastic\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tconst = const or 1000","\tdamp = damp or 100","\trdamp = rdamp or 0","\twidth = math.Clamp( width or 0, 0, 50)","\tstrech = strech and true or false","\t","\te1.Elastics = e1.Elastics or {}","\te2.Elastics = e2.Elastics or {}","\t","\tlocal e = constraint.Elastic( ent1, ent2, bone1, bone2, vec1, vec2, const, damp, rdamp, \"cable/cable2\", width, strech )","\t","\te1.Elastics[index] = e","\te2.Elastics[index] = e","end",""],"class":"function","summary":"\nElastic two entities ","name":"constraint_library.elastic","library":"constraint","private":false,"server":true,"description":"\nElastic two entities","param":["index","e1","e2","bone1","bone2","v1","v2","const","damp","rdamp","width","strech"]},{"comment":["--- Ropes two entities","-- @server "],"code":["function constraint_library.rope(index, e1, e2, bone1, bone2, v1, v2, length, addlength, force_lim, width, material, rigid)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.rope\" )","\tcheckConstraint( ent2, \"constraints.rope\" )","","","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\tlength = length or 0","\taddlength = addlength or 0","\tforce_lim = force_lim or 0","\twidth = math.Clamp( width or 0, 0, 50)","\trigid = rigid and true or false","\t","\te1.Ropes = e1.Ropes or {}","\te2.Ropes = e2.Ropes or {}","\t","\tlocal e = constraint.Rope( ent1, ent2, bone1, bone2, vec1, vec2, length, addlength, force_lim, width, material, rigid )","\t","\te1.Ropes[index] = e","\te2.Ropes[index] = e","end",""],"class":"function","summary":"\nRopes two entities ","name":"constraint_library.rope","library":"constraint","private":false,"server":true,"description":"\nRopes two entities","param":["index","e1","e2","bone1","bone2","v1","v2","length","addlength","force_lim","width","material","rigid"]},{"comment":["--- Sliders two entities","-- @server "],"code":["function constraint_library.slider(e1, e2, bone1, bone2, v1, v2, width)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\tlocal vec1 = vunwrap( v1 )","\tlocal vec2 = vunwrap( v2 )","\t","\tcheckConstraint( ent1, \"constraints.slider\" )","\tcheckConstraint( ent2, \"constraints.slider\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\twidth = math.Clamp( width or 0, 0, 50)","","\tconstraint.Slider(ent1, ent2, bone1, bone2, vec1, vec2, width, \"cable/cable2\")","end",""],"class":"function","summary":"\nSliders two entities ","name":"constraint_library.slider","library":"constraint","private":false,"server":true,"description":"\nSliders two entities","param":["e1","e2","bone1","bone2","v1","v2","width"]},{"comment":["--- Nocollides two entities","-- @server "],"code":["function constraint_library.nocollide(e1, e2, bone1, bone2)","\tSF.CheckType( e1, ents_metatable )","\tSF.CheckType( e2, ents_metatable )","\t","\tlocal ent1 = eunwrap( e1 )","\tlocal ent2 = eunwrap( e2 )","\t","\tcheckConstraint( ent1, \"constraints.nocollide\" )","\tcheckConstraint( ent2, \"constraints.nocollide\" )","\t","\tbone1 = bone1 or 0","\tbone2 = bone2 or 0","\t","\tconstraint.NoCollide(ent1, ent2, bone1, bone2)","end",""],"class":"function","summary":"\nNocollides two entities ","name":"constraint_library.nocollide","library":"constraint","private":false,"server":true,"description":"\nNocollides two entities","param":["e1","e2","bone1","bone2"]},{"comment":["--- Sets the length of a rope attached to the entity","-- @server "],"code":["function constraint_library.setRopeLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.rope\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlength = math.max( length or 0, 0)","","\t","\tif e.Ropes then","\t\tlocal con = e.Ropes[index]","\t\tif IsValid(con) then","\t\t\tcon:SetKeyValue(\"addlength\", length)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of a rope attached to the entity ","name":"constraint_library.setRopeLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of a rope attached to the entity","param":["index","e","length"]},{"comment":["--- Sets the length of an elastic attached to the entity","-- @server "],"code":["function constraint_library.setElasticLength(index, e, length)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.elastic\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlength = math.max( length or 0, 0)","","\tif e.Elastics then","\t\tlocal con = e.Elastics[index]","\t\tif IsValid(con) then","\t\t\tcon:Fire(\"SetSpringLength\", length, 0)","\t\tend","\tend","end",""],"class":"function","summary":"\nSets the length of an elastic attached to the entity ","name":"constraint_library.setElasticLength","library":"constraint","private":false,"server":true,"description":"\nSets the length of an elastic attached to the entity","param":["index","e","length"]},{"comment":["--- Breaks all constraints on an entity","-- @server "],"code":["function constraint_library.breakAll(e)","\tSF.CheckType( e, ents_metatable )","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveAll(ent1)","end",""],"class":"function","summary":"\nBreaks all constraints on an entity ","name":"constraint_library.breakAll","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints on an entity","param":["e"]},{"comment":["--- Breaks all constraints of a certain type on an entity","-- @server "],"code":["function constraint_library.breakType(e, typename)","\tSF.CheckType( e, ents_metatable )","    SF.CheckType( typename, \"string\" )","\t","\tlocal ent1 = eunwrap( e )","\t","\tif not IsValid( ent1 ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent1, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tconstraint.RemoveConstraints(ent1, typename)","end","",""],"class":"function","summary":"\nBreaks all constraints of a certain type on an entity ","name":"constraint_library.breakType","library":"constraint","private":false,"server":true,"description":"\nBreaks all constraints of a certain type on an entity","param":["e","typename"]},{"ret":"Table of entity constraints","comment":["--- Returns the table of constraints on an entity","-- @param ent The entity","-- @return Table of entity constraints"],"code":["function constraint_library.getTable( ent )","\tSF.CheckType( ent, ents_metatable )","","\tent = eunwrap( ent )","\t","\tif not IsValid( ent ) then SF.throw( \"Invalid entity\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"constraints.any\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn SF.Sanitize(constraint.GetTable( ent ))","end"],"class":"function","name":"constraint_library.getTable","summary":"\nReturns the table of constraints on an entity ","private":false,"library":"constraint","description":"\nReturns the table of constraints on an entity","param":{"1":"ent","ent":"The entity"}}],"tables":[],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\"."},"sfderma.lua":{"libraries":[],"type":"file","name":"sfderma.lua","functions":[],"doc":[{"comment":["--------------------------------------------------------------","--------------------------------------------------------------"],"code":["","-- Starfall Button","PANEL = {}","","function PANEL:Init ()","\tself:SetText( \"\" )","\tself:SetSize( 22, 22 )","end","function PANEL:SetIcon ( icon )","\tself.icon = SF.Editor.icons[ icon ]","end","function PANEL:PerformLayout ()","\tif self:GetText() ~= \"\" then","\t\tself:SizeToContentsX()","\t\tself:SetWide( self:GetWide() + 14 )","\tend","end","PANEL.Paint = function ( button, w, h )","\tif button.Hovered or button.active then","\t\tdraw.RoundedBox( 0, 0, 0, w, h, button.backgroundHoverCol or SF.Editor.colors.med )","\telse","\t\tdraw.RoundedBox( 0, 0, 0, w, h, button.backgroundCol or SF.Editor.colors.meddark )","\tend","\tif button.icon then","\t\tsurface.SetDrawColor( SF.Editor.colors.medlight )","\t\tsurface.SetMaterial( button.icon )","\t\tsurface.DrawTexturedRect( 2, 2, w - 4, h - 4 )","\tend","end","function PANEL:UpdateColours ( skin )","\treturn self:SetTextStyleColor( self.labelCol or SF.Editor.colors.light )","end","function PANEL:SetHoverColor ( col )","\tself.backgroundHoverCol = col","end","function PANEL:SetColor ( col )","\tself.backgroundCol = col","end","function PANEL:SetLabelColor ( col )","\tself.labelCol = col","end","function PANEL:DoClick ()","","end","","vgui.Register( \"StarfallButton\", PANEL, \"DButton\" )","-- End Starfall Button",""],"summary":"\n \n ","description":"\n \n","param":[]},{"comment":["--------------------------------------------------------------","--------------------------------------------------------------"],"code":["","-- Starfall Panel","PANEL = {}","PANEL.Paint = function ( panel, w, h )","\tdraw.RoundedBox( 0, 0, 0, w, h, SF.Editor.colors.medlight )","end","vgui.Register( \"StarfallPanel\", PANEL, \"DPanel\" )","-- End Starfall Panel",""],"summary":"\n \n ","description":"\n \n","param":[]},{"comment":["--------------------------------------------------------------","--------------------------------------------------------------"],"code":["","-- Tab Holder","PANEL = {}","","function PANEL:Init ()","\tself:SetTall( 22 )","\tself.offsetTabs = 0","\tself.tabs = {}","","\tlocal parent = self","","\tself.offsetRight = vgui.Create( \"StarfallButton\", self )","\tself.offsetRight:SetVisible( false )","\tself.offsetRight:SetSize( 22, 22 )","\tself.offsetRight:SetIcon( \"arrowr\" )","\tfunction self.offsetRight:PerformLayout ()","\t\tlocal wide = 0","\t\tif parent.offsetLeft:IsVisible() then ","\t\t\twide = parent.offsetLeft:GetWide() + 2 ","\t\tend","\t\tfor i = parent.offsetTabs + 1, #parent.tabs do","\t\t\tif wide + parent.tabs[ i ]:GetWide() > parent:GetWide() - self:GetWide() - 2 then ","\t\t\t\tbreak ","\t\t\telse","\t\t\t\twide = wide + parent.tabs[ i ]:GetWide() + 2","\t\t\tend","\t\tend","\t\tself:SetPos( wide, 0 )","\tend","\tfunction self.offsetRight:DoClick ()","\t\tparent.offsetTabs = parent.offsetTabs + 1","\t\tif parent.offsetTabs > #parent.tabs - 1 then","\t\t\tparent.offsetTabs = #parent.tabs - 1","\t\tend","\t\tparent:InvalidateLayout()","\tend","","\tself.offsetLeft = vgui.Create( \"StarfallButton\", self )","\tself.offsetLeft:SetVisible( false )","\tself.offsetLeft:SetSize( 22, 22 )","\tself.offsetLeft:SetIcon( \"arrowl\" )","\tfunction self.offsetLeft:DoClick ()","\t\tparent.offsetTabs = parent.offsetTabs - 1","\t\tif parent.offsetTabs < 0 then","\t\t\tparent.offsetTabs = 0","\t\tend","\t\tparent:InvalidateLayout()","\tend","","\tself.menuoptions = {}","","\tself.menuoptions[ #self.menuoptions + 1 ] = { \"Close\", function ()","\t\tif not self.targetTab then return end","\t\tself:removeTab( self.targetTab )","\t\tself.targetTab = nil","\tend }","\tself.menuoptions[ #self.menuoptions + 1 ] = { \"Close Other Tabs\", function ()","\t\tif not self.targetTab then return end","\t\tlocal n = 1","\t\twhile #self.tabs ~= 1 do","\t\t\tv = self.tabs[ n ]","\t\t\tif v ~= self.targetTab then ","\t\t\t\tself:removeTab( v )","\t\t\telse","\t\t\t\tn = 2","\t\t\tend","\t\tend","\t\tself.targetTab = nil","\tend }","end ","PANEL.Paint = function () end","function PANEL:PerformLayout ()","\tlocal parent = self:GetParent()","\tself:SetWide( parent:GetWide() - 10 )","\tself.offsetRight:PerformLayout()","\tself.offsetLeft:PerformLayout()","","\tlocal offset = 0","\tif self.offsetLeft:IsVisible() then","\t\toffset = self.offsetLeft:GetWide() + 2","\tend","\tfor i = 1, self.offsetTabs do","\t\toffset = offset - self.tabs[ i ]:GetWide() - 2","\tend","\tlocal bool = false","\tfor k, v in pairs( self.tabs ) do","\t\tv:SetPos( offset, 0 )","\t\tif offset < 0 then","\t\t\tv:SetVisible( false )","\t\telseif offset + v:GetWide() > self:GetWide() - self.offsetRight:GetWide() - 2 then","\t\t\tv:SetVisible( false )","\t\t\tbool = true","\t\telse","\t\t\tv:SetVisible( true )","\t\tend","\t\toffset = offset + v:GetWide() + 2","\tend","","\tif bool then","\t\tself.offsetRight:SetVisible( true )","\telse","\t\tself.offsetRight:SetVisible( false )","\tend","\tif self.offsetTabs > 0 then","\t\tself.offsetLeft:SetVisible( true )","\telse","\t\tself.offsetLeft:SetVisible( false )","\tend","end","function PANEL:addTab ( text )","\tlocal panel = self","\tlocal tab = vgui.Create( \"StarfallButton\", self )","\ttab:SetText( text )","\ttab.isTab = true","","\tfunction tab:DoClick ()","\t\tpanel:selectTab( self )","\tend","","\tfunction tab:DoRightClick ()","\t\tpanel.targetTab = self","\t\tlocal menu = vgui.Create( \"DMenu\", panel:GetParent() )","\t\tfor k, v in pairs( panel.menuoptions ) do","\t\t\tlocal option, func = v[ 1 ], v[ 2 ]","\t\t\tif func == \"SPACER\" then","\t\t\t\tmenu:AddSpacer()","\t\t\telse","\t\t\t\tmenu:AddOption( option, func )","\t\t\tend","\t\tend","\t\tmenu:Open()","\tend","","\tfunction tab:DoMiddleClick ()","\t\tpanel:removeTab( self )","\tend","","\tself.tabs[ #self.tabs + 1 ] = tab","","\treturn tab","end","function PANEL:removeTab ( tab )","\tlocal tabIndex ","\tif type( tab ) == \"number\" then","\t\ttabIndex = tab","\t\ttab = self.tabs[ tab ]  ","\telse","\t\ttabIndex = self:getTabIndex( tab )","\tend","","\ttable.remove( self.tabs, tabIndex )","\ttab:Remove()","","\tself:OnRemoveTab( tabIndex )","end","function PANEL:getActiveTab ()","\tfor k,v in pairs( self.tabs ) do","\t\tif v.active then return v end","\tend","end","function PANEL:getTabIndex ( tab )","\treturn table.KeyFromValue( self.tabs, tab )","end","function PANEL:selectTab ( tab )","\tif type( tab ) == \"number\" then","\t\ttab = self.tabs[ tab ]  ","\tend","\tif tab == nil then return end","","\tif self:getActiveTab() == tab then return end","","\tfor k,v in pairs( self.tabs ) do","\t\tv.active = false","\tend","\ttab.active = true","","\tif self:getTabIndex( tab ) <= self.offsetTabs then","\t\tself.offsetTabs = self:getTabIndex( tab ) - 1","\telseif not tab:IsVisible() then","\t\twhile not tab:IsVisible() do","\t\t\tself.offsetTabs = self.offsetTabs + 1","\t\t\tself:PerformLayout()","\t\tend","\tend","end","function PANEL:OnRemoveTab ( tabIndex )","","end","vgui.Register( \"StarfallTabHolder\", PANEL, \"DPanel\" )","-- End Tab Holder",""],"summary":"\n \n ","description":"\n \n","param":[]},{"comment":["--------------------------------------------------------------","--------------------------------------------------------------"],"code":["","-- File Tree","local invalid_filename_chars = {","\t[\"*\"] = \"\",","\t[\"?\"] = \"\",","\t[\">\"] = \"\",","\t[\"<\"] = \"\",","\t[\"|\"] = \"\",","\t[\"\\\\\"] = \"\",","\t['\"'] = \"\",","}","","PANEL = {}","","function PANEL:Init ()","","end","function PANEL:setup ( folder )","\tself.folder = folder","\tself.Root = self.RootNode:AddFolder( folder, folder, \"DATA\", true )","\tself.Root:SetExpanded( true )","end","function PANEL:reloadTree ()","\tself.Root:Remove()","\tself:setup( self.folder )","end","function PANEL:DoRightClick ( node )","\tself:openMenu( node )","end","function PANEL:openMenu ( node )","\tlocal menu","\tif node:GetFileName() then","\t\tmenu = \"file\"","\telseif node:GetFolder() then","\t\tmenu = \"folder\"","\tend","\tself.menu = vgui.Create( \"DMenu\", self:GetParent() )","\tif menu == \"file\" then","\t\tself.menu:AddOption( \"Open\", function ()","\t\t\tself:OnNodeSelected( node )","\t\tend )","\t\tself.menu:AddSpacer()","\t\tself.menu:AddOption( \"Rename\", function ()","\t\t\tDerma_StringRequestNoBlur(","\t\t\t\t\"Rename file\",","\t\t\t\t\"\",","\t\t\t\tstring.StripExtension( node:GetText() ),","\t\t\t\tfunction ( text )","\t\t\t\t\tif text == \"\" then return end","\t\t\t\t\ttext = string.gsub( text, \".\", invalid_filename_chars )","\t\t\t\t\tlocal saveFile = \"starfall/\"..text..\".txt\"","\t\t\t\t\tlocal contents = file.Read( node:GetFileName() )","\t\t\t\t\tfile.Delete( node:GetFileName() )","\t\t\t\t\tfile.Write( saveFile, contents )","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"File renamed as \" .. saveFile .. \".\", NOTIFY_GENERIC, 7, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tself:reloadTree()","\t\t\t\tend","\t\t\t)","\t\tend )","\t\tself.menu:AddSpacer()","\t\tself.menu:AddOption( \"Delete\", function ()","\t\t\tDerma_Query(","\t\t\t\t\"Are you sure you want to delete this file?\",","\t\t\t\t\"Delete file\",","\t\t\t\t\"Delete\",","\t\t\t\tfunction ()","\t\t\t\t\tfile.Delete( node:GetFileName() )","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"File deleted: \" .. node:GetFileName(), NOTIFY_GENERIC, 7, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tself:reloadTree()","\t\t\t\tend,","\t\t\t\t\"Cancel\"","\t\t\t)","\t\tend )","\telseif menu == \"folder\" then","\t\tself.menu:AddOption( \"New file\", function ()","\t\t\tDerma_StringRequestNoBlur(","\t\t\t\t\"New file\",","\t\t\t\t\"\",","\t\t\t\t\"\",","\t\t\t\tfunction ( text )","\t\t\t\t\tif text == \"\" then return end","\t\t\t\t\ttext = string.gsub( text, \".\", invalid_filename_chars )","\t\t\t\t\tlocal saveFile = node:GetFolder()..\"/\"..text..\".txt\"","\t\t\t\t\tfile.Write( saveFile, \"\" )","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"New file: \" .. saveFile, NOTIFY_GENERIC, 7, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tself:reloadTree()","\t\t\t\tend","\t\t\t)","\t\tend )","\t\tself.menu:AddSpacer()","\t\tself.menu:AddOption( \"New folder\", function ()","\t\t\tDerma_StringRequestNoBlur(","\t\t\t\t\"New folder\",","\t\t\t\t\"\",","\t\t\t\t\"\",","\t\t\t\tfunction ( text )","\t\t\t\t\tif text == \"\" then return end","\t\t\t\t\ttext = string.gsub( text, \".\", invalid_filename_chars )","\t\t\t\t\tlocal saveFile = node:GetFolder()..\"/\"..text","\t\t\t\t\tfile.CreateDir( saveFile )","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"New folder: \" .. saveFile, NOTIFY_GENERIC, 7, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tself:reloadTree()","\t\t\t\tend","\t\t\t)","\t\tend )","\tend","\tself.menu:Open()","end","","","derma.DefineControl( \"StarfallFileTree\", \"\", PANEL, \"DTree\" )","-- End File Tree",""],"summary":"\n \n ","description":"\n \n","param":[]},{"comment":["--------------------------------------------------------------","--------------------------------------------------------------"],"code":["","-- File Browser","PANEL = {}","","function PANEL:Init ()","","\tself:Dock( FILL )","\tself:DockMargin( 0, 5, 0, 0 )","","\tlocal tree = vgui.Create( \"StarfallFileTree\", self )","\ttree:Dock( FILL )","","\tself.tree = tree","","\tlocal searchBox = vgui.Create( \"DTextEntry\", self )","\tsearchBox:Dock( TOP )","\tsearchBox:SetValue( \"Search...\" )","","\tsearchBox._OnGetFocus = searchBox.OnGetFocus","\tfunction searchBox:OnGetFocus ()","\t\tif self:GetValue() == \"Search...\" then","\t\t\tself:SetValue( \"\" )","\t\tend","\t\tsearchBox:_OnGetFocus()","\tend","","\tsearchBox._OnLoseFocus = searchBox.OnLoseFocus","\tfunction searchBox:OnLoseFocus ()","\t\tif self:GetValue() == \"\" then","\t\t\tself:SetText( \"Search...\" )","\t\tend","\t\tsearchBox:_OnLoseFocus()","\tend","","\tfunction searchBox:OnChange ()","","\t\tif self:GetValue() == \"\" then","\t\t\ttree:reloadTree()","\t\t\treturn","\t\tend","","\t\ttree.Root.ChildNodes:Clear()","\t\tlocal function containsFile ( dir, search )","\t\t\tlocal files, folders = file.Find( dir .. \"/*\", \"DATA\" )","\t\t\tfor k, file in pairs( files ) do","\t\t\t\tif string.find( string.lower( file ), string.lower( search ) ) then return true end","\t\t\tend","\t\t\tfor k, folder in pairs( folders ) do","\t\t\t\tif containsFile( dir .. \"/\" .. folder, search ) then return true end","\t\t\tend","\t\t\treturn false","\t\tend","\t\tlocal function addFiles ( search, dir, node )","\t\t\tlocal allFiles, allFolders = file.Find( dir .. \"/*\", \"DATA\" )","\t\t\tfor k, v in pairs( allFolders ) do","\t\t\t\tif containsFile( dir .. \"/\" .. v, search ) then","\t\t\t\t\tlocal newNode = node:AddNode( v )","\t\t\t\t\tnewNode:SetExpanded( true )","\t\t\t\t\taddFiles( search, dir .. \"/\" .. v, newNode )","\t\t\t\tend","\t\t\tend","\t\t\tfor k, v in pairs( allFiles ) do","\t\t\t\tif string.find( string.lower( v ), string.lower( search ) ) then","\t\t\t\t\tnode:AddNode( v, \"icon16/page_white.png\" )","\t\t\t\tend","\t\t\tend","\t\tend","\t\taddFiles( self:GetValue(), \"starfall\", tree.Root )","\t\ttree.Root:SetExpanded( true )","\tend","\tself.searchBox = searchBox","","end","function PANEL:getComponents ()","\treturn self.searchBox, self.tree","end","","derma.DefineControl( \"StarfallFileBrowser\", \"\", PANEL, \"DPanel\" )","-- End File Browser"],"summary":"\n \n ","description":"\n \n","param":[]}],"tables":[],"description":"\n \n","summary":"\n \n "},"permissions/providers_sv/CPPI.lua":{"libraries":[],"type":"file","name":"permissions/providers_sv/CPPI.lua","functions":[],"doc":[{"comment":["--- Provides permissions for entities based on CPPI if present"],"code":["","local P = setmetatable( {}, { __index = SF.Permissions.Provider } )","","local ALLOW = SF.Permissions.Result.ALLOW","local DENY = SF.Permissions.Result.DENY","local NEUTRAL = SF.Permissions.Result.NEUTRAL","","local canTool = {","\t[ \"entities.parent\" ] = true,","\t[ \"entities.unparent\" ] = true,","\t[ \"entities.setSolid\" ] = true,","\t[ \"entities.setMass\" ] = true,","\t[ \"entities.enableGravity\" ] = true,","\t[ \"entities.enableMotion\" ] = true,","\t[ \"entities.enableDrag\" ] = true,","\t[ \"entities.setColor\" ] = true,","\t[ \"entities.remove\" ] = true,","\t[ \"entities.emitSound\" ] = true,","\t[ \"wire.createWire\" ] = true,","\t[ \"wire.deleteWire\" ] = true,","\t[ \"constraints.weld\" ] = true,","\t[ \"constraints.axis\" ] = true,","\t[ \"constraints.ballsocket\" ] = true,","\t[ \"constraints.ballsocketadv\" ] = true,","\t[ \"constraints.slider\" ] = true,","\t[ \"constraints.rope\" ] = true,","\t[ \"constraints.elastic\" ] = true,","\t[ \"constraints.nocollide\" ] = true,","\t[ \"constraints.any\" ] = true","}","","local canPhysgun = {","\t[ \"entities.applyForce\" ] = true,","\t[ \"entities.setPos\" ] = true,","\t[ \"entities.setAngles\" ] = true,","\t[ \"entities.setVelocity\" ] = true,","\t[ \"entities.setFrozen\" ] = true","}","","function P:check ( principal, target, key )","\tif not CPPI then return NEUTRAL end","\t","\tif canTool[ key ] then","\t\tif not IsValid( target:CPPIGetOwner() ) then return DENY end","\t\tif target:CPPICanTool( principal, \"starfall_ent_lib\" ) then return ALLOW end","\t\treturn DENY","\telseif canPhysgun[ key ] then","\t\tif target:IsPlayer() then","\t\t\treturn (hook.Call( \"PhysgunPickup\", GAMEMODE, principal, target ) ~= false) and ALLOW or DENY","\t\telse","\t\t\tif not IsValid( target:CPPIGetOwner() ) then return DENY end","\t\t\tif target:CPPICanPhysgun( principal ) then return ALLOW end","\t\tend","\t\treturn DENY","\tend","","\treturn NEUTRAL","end","","SF.Permissions.registerProvider( P )"],"summary":"\nProvides permissions for entities based on CPPI if present ","description":"\nProvides permissions for entities based on CPPI if present","param":[]}],"tables":[],"description":"\nProvides permissions for entities based on CPPI if present","summary":"\nProvides permissions for entities based on CPPI if present "},"sfhelper.lua":{"libraries":[],"type":"file","name":"sfhelper.lua","functions":{"1":"helper.updateDocView","2":"helper.updateInfoPanel","helper.updateDocView":{"summary":"\nDoc View ---- \n ","description":"\nDoc View ---- \n","comment":["\t---- Doc View ----","\t------------------"],"code":["\tfunction helper.updateDocView( Line, Type )","\t\tlocal view = helper.DocView","\t\tview.DocName = Line:GetColumnText( 1 )","","\t\tview:GetVBar():SetScroll( 0 )","","\t\tif Type == 1 then","\t\t\tview.Title:SetText( \"Library - \" .. view.DocName )","\t\t\tview.Doc = SF.Docs.libraries[ view.DocName ]","\t\telseif Type == 2 then","\t\t\tview.Title:SetText( \"Type - \" .. view.DocName )","\t\t\tview.Doc = SF.Docs.classes[ view.DocName ]","\t\telseif Type == 3 then","\t\t\tview.Title:SetText( \"Hooks\" )","\t\t\tview.Doc = {}","\t\t\tview.Doc.hooks = SF.Docs.hooks","\t\t\tview.Doc.description = \"List of hooks available to SF scripts\"","\t\telseif Type == 4 then","\t\t\tview.Title:SetText( \"Preprocessor directives\" )","\t\t\tview.Doc = {}","\t\t\tview.Doc.directives = SF.Docs.directives","\t\t\tview.Doc.description = \"List of preprocessor directives\"","\t\tend","\t\tlocal doc = view.Doc","\t\tview.Title:SizeToContents()","","\t\tview.Description:SetText( string.Replace( doc.description, \"\\n\", \"\" ) )","\t\tview.Description:SizeToContents()","\t\tview.Description:SetWrap( true )","\t\tview.Description:SetAutoStretchVertical( true )","","\t\tif doc.deprecated then","\t\t\tview.Deprecated:SetVisible( true )","\t\t\tview.Deprecated.Enabled = true","\t\telse","\t\t\tview.Deprecated:SetVisible( false )","\t\t\tview.Deprecated.Enabled = false","\t\tend","\t\tfor _, labellist in pairs( helper.LabelLists ) do","\t\t\tif doc[ labellist.name ] and #doc[ labellist.name ] > 0 then","\t\t\t\tlabellist.label:SetVisible( true )","\t\t\t\tlabellist.label.Enabled = true","\t\t\t\tlabellist.label:SizeToContents()","\t\t\t\tlabellist.list:SetVisible( true )","\t\t\t\tlabellist.list:Clear()","\t\t\t\tlocal height = labellist.func( view, doc )","\t\t\t\tlabellist.list:SetTall( height )","\t\t\telse","\t\t\t\tlabellist.label:SetVisible( false )","\t\t\t\tlabellist.label.Enabled = false","\t\t\t\tlabellist.list:SetVisible( false )","\t\t\tend","\t\tend","","\t\ttimer.Create( \"update\", 0.1, 1, helper.resize )","\tend","","\thelper.DocView = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.DocView:SetPos( 166, 30 )","\thelper.DocView:SetVisible( false )","\thelper.Views.Doc = helper.DocView","","\thelper.DocView.Panel = vgui.Create( \"DPanel\", helper.DocView )","","\thelper.DocView.Title = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Title:SetPos( 10, 5 )","\thelper.DocView.Title:SetFont( \"HelperTitle\" )","\thelper.DocView.Title.m_colText = Color( 60, 60, 60 )","","\thelper.DocView.Description = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Description:SetPos( 25, 40 )","\thelper.DocView.Description:SetFont( \"HelperText\" )","\thelper.DocView.Description.m_colText = Color( 60, 60, 60 )","","\thelper.DocView.Deprecated = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Deprecated:SetText( \"This library/type has been deprecated and will be removed in the future for the following reason: Pure Lua implementation. This can be done with a user library.\" )","\thelper.DocView.Deprecated:SetPos( 25, 40 )","\thelper.DocView.Deprecated:SetFont( \"HelperTextBold\" )","\thelper.DocView.Deprecated:SizeToContents()","\thelper.DocView.Deprecated:SetWrap( true )","\thelper.DocView.Deprecated:SetAutoStretchVertical( true )","\thelper.DocView.Deprecated.m_colText = Color( 210, 0, 0 )","","\thelper.LabelLists = {}","\tlocal function createDocList( name, func, update )","\t\tlocal label = Label( name, helper.DocView.Panel )","\t\tlabel:SetPos( 10, 40 )","\t\tlabel:SetFont( \"HelperTitle\" )","\t\tlabel.m_colText = Color( 60, 60, 60 )","\t\thelper.DocView[ name .. \"Label\" ] = label","","\t\tlocal list = vgui.Create( \"DListView\", helper.DocView.Panel )","\t\tlist:SetPos( 25, 40 )","\t\tlist:SetMultiSelect( false )","\t\tlist:AddColumn( name ):SetFixedWidth( 150 )","\t\tlist:AddColumn( \"Description\" )","\t\thelper.DocView[ name .. \"List\" ] = list","\t\thelper.LabelLists[ #helper.LabelLists + 1 ] = { label=label, list=list, func=func, name=string.lower( name ) }","","\t\tfunction list:OnRowSelected( LineID, Line )","\t\t\tfor _, labellist in pairs( helper.LabelLists ) do ","\t\t\t\tif labellist.list ~= list then","\t\t\t\t\tlabellist.list:ClearSelection()","\t\t\t\tend","\t\t\tend","\t\t\tupdate( LineID, Line )","\t\tend","\tend","\tcreateDocList( \"Functions\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, func in ipairs( doc.functions ) do","\t\t\tlocal func_data = doc.functions[ func ]","\t\t\tlocal description = string.Replace( string.Trim( func_data.summary ), \"\\n\", \"\" )","\t\t\tdescription = string.Replace( description, \"<a href=\\\"\", \"( \" )","\t\t\tdescription = string.Replace( description, \"\\\">\", \", \" )","\t\t\tdescription = string.Replace( description, \"</br>\", \"\" )","\t\t\tdescription = string.Replace( description, \"</a>\", \" )\" )","\t\t\tlocal line = view.FunctionsList:AddLine( func .. \" (\" .. table.concat( func_data.param, \", \" ) .. \")\" , description )","\t\t\tline.func = func","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.functions[ Line.func ] )","\tend )","\tcreateDocList( \"Tables\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, table in ipairs( doc.tables ) do","\t\t\tlocal table_data = doc.tables[ table ]","\t\t\tlocal line = view.TablesList:AddLine( table , string.Replace( string.Trim( table_data.summary ), \"\\n\", \"\" ) )","\t\t\tline.table = table","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.tables[ Line.table ] )","\tend  )","\tcreateDocList( \"Fields\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, field in ipairs( doc.fields ) do","\t\t\tlocal field_data = doc.fields[ field ]","\t\t\tview.FieldsList:AddLine( field , string.Replace( string.Trim( field_data.summary ), \"\\n\", \"\" ) )","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line)  end )","\tcreateDocList( \"Methods\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, func in ipairs( doc.methods ) do","\t\t\tlocal func_data = doc.methods[ func ]","\t\t\tlocal description = string.Replace( string.Trim( func_data.summary ), \"\\n\", \"\" )","\t\t\tdescription = string.Replace( description, \"<a href=\\\"\", \"( \" )","\t\t\tdescription = string.Replace( description, \"\\\">\", \", \" )","\t\t\tdescription = string.Replace( description, \"</br>\", \"\" )","\t\t\tdescription = string.Replace( description, \"</a>\", \" )\" )","\t\t\tlocal line = view.MethodsList:AddLine( func .. \" (\" .. table.concat( func_data.param, \", \" ) .. \")\" , description )","\t\t\tline.func = func","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.methods[ Line.func ] )","\tend  )","\tcreateDocList( \"Hooks\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, hook in ipairs( doc.hooks ) do","\t\t\tlocal hook_data = doc.hooks[ hook ]","\t\t\tlocal line = view.HooksList:AddLine( hook , string.Replace( string.Trim( hook_data.summary ), \"\\n\", \"\" ) )","\t\t\tline.hook = hook","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.hooks[ Line.hook ] )","\tend  )","\tcreateDocList( \"Directives\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, directive in ipairs( doc.directives ) do","\t\t\tlocal directive_data = doc.directives[ directive ]","\t\t\tlocal line = view.DirectivesList:AddLine( directive , string.Replace( string.Trim( directive_data.summary ), \"\\n\", \"\" ) )","\t\t\tline.directive = directive","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.directives[ Line.directive ], true )","\tend  )","",""],"private":false,"class":"function","name":"helper.updateDocView","param":["Line","Type"]},"helper.updateInfoPanel":{"summary":"\nInfoPanel ---- \n ","description":"\nInfoPanel ---- \n","comment":["\t---- InfoPanel ----","\t-------------------"],"code":["\tfunction helper.updateInfoPanel( func, directive )","\t\tlocal infopanel = helper.DocView.InfoPanel","\t\thelper.DocView.Info:GetVBar():SetScroll( 0 )","","\t\tdirective = nil or directive ","","\t\tif not directive then","\t\t\tinfopanel.funcName:SetText( string.Replace( func.name .. \"( \" .. table.concat( func.param, \", \" ) .. \" )\", \"\\n\", \"\" ) )","\t\telse","\t\t\tinfopanel.funcName:SetText( string.Replace( \"--@\" .. func.name .. \" \" .. table.concat( func.param, \", \" ), \"\\n\", \"\" ) )","\t\tend","\t\tinfopanel.funcName.Enabled = true","","\t\tinfopanel.description:SetText( string.Replace( func.description or \"\", \"\\n\", \"\" ) )","\t\tinfopanel.description.Enabled = true","","\t\tif func.deprecated then ","\t\t\tinfopanel.deprecated:SetText( \"Deprecated: \" .. string.Replace( func.deprecated, \"\\n\", \"\" ) ) ","\t\t\tinfopanel.deprecated.Enabled = true","\t\telse ","\t\t\tinfopanel.deprecated.Enabled = false","\t\tend","","\t\tif type( func.param ) == \"table\" and #func.param > 0 then","\t\t\tlocal params = \"\"","\t\t\tfor p = 1, #func.param do","\t\t\t\tparams = params .. \" \" .. func.param[ p ] .. \": \" .. ( func.param[ func.param[ p ] ] or \"\" ) .. ( p ~= #func.param and \"\\n\" or \"\" ) ","\t\t\tend","\t\t\tinfopanel.parameters:SetText( \"Parameters: \" )","\t\t\tinfopanel.parameterList:SetText( params )","\t\t\tinfopanel.parameters.Enabled = true","\t\t\tinfopanel.parameterList.Enabled = true","\t\telseif #func.param == 0 then","\t\t\tinfopanel.parameters.Enabled = false","\t\t\tinfopanel.parameterList.Enabled = false","\t\tend","","\t\tif type( func.ret ) == \"string\" then","\t\t\tinfopanel.returnvalue:SetText( \"Return value: \" )","\t\t\tinfopanel.returnvalueList:SetText( func.ret )","\t\t\tinfopanel.returnvalue.Enabled = true","\t\t\tinfopanel.returnvalueList.Enabled = true","\t\telseif type( func.ret ) == \"table\" then","\t\t\tinfopanel.returnvalue:SetText( \"Return values: \" )","\t\t\tlocal rets = \"\"","\t\t\tlocal count = 1","\t\t\tfor _, ret in ipairs( func.ret ) do","\t\t\t\trets = rets .. count .. \". \" .. ret .. \"\\n\"","\t\t\t\tcount = count + 1","\t\t\tend","\t\t\tinfopanel.returnvalueList:SetText( rets )","\t\t\tinfopanel.returnvalue.Enabled = true","\t\t\tinfopanel.returnvalueList.Enabled = true","\t\telse","\t\t\tinfopanel.returnvalue.Enabled = false","\t\t\tinfopanel.returnvalueList.Enabled = false","\t\tend","","\t\tif type( func.usage ) == \"string\" then","\t\t\tinfopanel.usage:SetText( \"Usage:\" )","\t\t\tinfopanel.usage.Enabled = true","\t\t\tinfopanel.usageBlock:SetText( string.gsub( string.Replace( func.usage , string.char( 9 ), \"    \" ), \"\\n\", \"\", 1 ) )","\t\t\tinfopanel.usageBlock.Enabled = true","\t\telseif not func.usage then","\t\t\tinfopanel.usage.Enabled = false","\t\t\tinfopanel.usageBlock.Enabled = false","\t\tend","","\t\tfor _, label in pairs( infopanel.labels ) do\t\t","\t\t\tlabel:SizeToContents()","\t\t\tlabel:SetWrap( true )","\t\t\tlabel:SetAutoStretchVertical( true )\t","\t\tend\t","\t\ttimer.Create( \"update\", 0.1, 1, helper.resize )","\tend","","\thelper.DocView.Info = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.DocView.Info:SetTall( 150 )","\thelper.DocView.Info:SetVisible( false )","","\thelper.DocView.InfoPanel = vgui.Create( \"DPanel\", helper.DocView.Info )","\thelper.DocView.InfoPanel:SetSize( 200, 100 )","\tlocal infopanel = helper.DocView.InfoPanel","","\thelper.DocView.Div = vgui.Create( \"DVerticalDivider\", helper.Frame )","\thelper.DocView.Div:SetPos( 166, 30 )","\thelper.DocView.Div:SetTop( helper.DocView )","\thelper.DocView.Div:SetBottom( helper.DocView.Info )","\thelper.DocView.Div:SetTopMin( 100 )","\thelper.DocView.Div:SetBottomMin( 100 )","\thelper.DocView.Div:SetDividerHeight( 5 )","\thelper.DocView.Div:SetVisible( false )","\thelper.DocView.Div._PerformLayout = helper.DocView.Div.PerformLayout","\tfunction helper.DocView.Div:PerformLayout()","\t\thelper.DocView.Div:_PerformLayout()","\t\thelper.resize()","\tend","","\tinfopanel.labels = {}","","\tinfopanel.funcName = Label( \"Nothing selected\", infopanel )","\tinfopanel.funcName:SetFont( \"HelperTextBold\" )","\tinfopanel.funcName:SizeToContents()","\tinfopanel.funcName.m_colText = Color( 60, 60, 60 )","\tinfopanel.funcName.indent = 0","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.funcName","","\tinfopanel.description = Label( \"\", infopanel )","\tinfopanel.description:SetFont( \"HelperText\" )","\tinfopanel.description.m_colText = Color( 60, 60, 60 )","\tinfopanel.description.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.description","","\tinfopanel.deprecated = Label( \"\", infopanel )","\tinfopanel.deprecated:SetText( \"\" )","\tinfopanel.deprecated:SetFont( \"HelperTextBold\" )","\tinfopanel.deprecated:SizeToContents()","\tinfopanel.deprecated:SetWrap( true )","\tinfopanel.deprecated:SetAutoStretchVertical( true )","\tinfopanel.deprecated.m_colText = Color( 210, 0, 0 )","\tinfopanel.deprecated.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.deprecated","","\tinfopanel.parameters = Label( \"Parameters:\", infopanel )","\tinfopanel.parameters:SetFont( \"HelperTextBold\" )","\tinfopanel.parameters.m_colText = Color( 60, 60, 60 )","\tinfopanel.parameters.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.parameters","","\tinfopanel.parameterList = Label( \"\", infopanel )","\tinfopanel.parameterList:SetFont( \"HelperText\" )","\tinfopanel.parameterList.m_colText = Color( 60, 60, 60 )","\tinfopanel.parameterList.indent = 2","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.parameterList","","\tinfopanel.returnvalue = Label( \"Return Value:\", infopanel )","\tinfopanel.returnvalue:SetFont( \"HelperTextBold\" )","\tinfopanel.returnvalue.m_colText = Color( 60, 60, 60 )","\tinfopanel.returnvalue.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.returnvalue","","\tinfopanel.returnvalueList = Label( \"\", infopanel )","\tinfopanel.returnvalueList:SetFont( \"HelperText\" )","\tinfopanel.returnvalueList.m_colText = Color( 60, 60, 60 )","\tinfopanel.returnvalueList.indent = 2","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.returnvalueList","","\tinfopanel.usage = Label( \"Usage:\", infopanel )","\tinfopanel.usage:SetFont( \"HelperTextBold\" )","\tinfopanel.usage.m_colText = Color( 60, 60, 60 )","\tinfopanel.usage.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.usage","","\tinfopanel.usageBlock = Label( \"\", infopanel )","\tinfopanel.usageBlock:SetFont( \"CodeBlock\" )","\tinfopanel.usageBlock.m_colText = Color( 60, 60, 60 )","\tinfopanel.usageBlock.indent = 3","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.usageBlock",""],"private":false,"class":"function","name":"helper.updateInfoPanel","param":["func","directive"]}},"doc":[{"summary":"\n \nSF Helper for Starfall \nBy Jazzelhawk \n ","description":"\n \nSF Helper for Starfall \nBy Jazzelhawk \n","comment":["-------------------------------------------------------------------------------","-- SF Helper for Starfall","-- By Jazzelhawk","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- TO DO ---","--- search page"],"code":["","SF.Helper = {}","SF.Docs = {}","local helper = SF.Helper","local docs_set = false","local docs_downloading = false","local settings_set = false","","if CLIENT then","\tCreateClientConVar( \"sf_helper_width\", 930, true, false )","\tCreateClientConVar( \"sf_helper_height\", 615, true, false )","\tCreateClientConVar( \"sf_helper_posx\", ( ScrW() - 930 ) / 2, true, false )","\tCreateClientConVar( \"sf_helper_posy\", ( ScrH() - 615 ) / 2, true, false )","\tCreateClientConVar( \"sf_helper_divheight\", 400, true, false )","end","","local function saveSettings()","\tRunConsoleCommand( \"sf_helper_width\", helper.Frame:GetWide() )","\tRunConsoleCommand( \"sf_helper_height\", helper.Frame:GetTall() )","\tlocal x, y = helper.Frame:GetPos()","\tRunConsoleCommand( \"sf_helper_posx\", x )","\tRunConsoleCommand( \"sf_helper_posy\", y )","\tRunConsoleCommand( \"sf_helper_divheight\", helper.DocView.Div:GetTopHeight() )","end","","function helper.create()","","\thelper.Views = {}","","\thelper.Frame = vgui.Create( \"DFrame\" )","\thelper.Frame:SetSize( 930, 615 )","\thelper.Frame:Center( )","\thelper.Frame:SetSizable( true )","\thelper.Frame:SetScreenLock( true )","\thelper.Frame:SetDeleteOnClose( false )","\thelper.Frame:SetVisible( false )","\thelper.Frame:SetTitle( \"SF Helper\" )","\thelper.Frame._PerformLayout = helper.Frame.PerformLayout","\tfunction helper.Frame:PerformLayout( ... )","\t\tlocal w, h = helper.Frame:GetSize()","\t\tif w < 620 then w = 620 end","\t\tif h < 410 then h = 410 end","\t\thelper.Frame:SetSize( w, h )","","\t\tself:_PerformLayout( ... )","\t\thelper.resize( )","\tend   ","\tfunction helper.Frame:OnClose()","\t\tsaveSettings()","\tend           ","","\thelper.ScrollPanel = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.ScrollPanel:SetPos( 5, 30 )","","\thelper.CatList = vgui.Create( \"DCategoryList\", helper.ScrollPanel )","","\tlocal lists = {}","\tlocal panels = {}","","\tlocal function createList( name, listfunc )","\t\tlocal Cat = helper.CatList:Add( name )","\t\tif name ~= \"SF Helper\" then Cat:SetExpanded( false ) end","\t\tlocal DPanel = vgui.Create( \"DPanel\", Cat )","\t\tDPanel:SetPos( 2, 22 )","","\t\tlocal List = vgui.Create( \"DListView\", DPanel )","\t\tList:SetHideHeaders( true )","\t\tList:SetMultiSelect( false )","\t\tList:DisableScrollbar()","\t\tList:AddColumn( \"\" )","","\t\tlocal height = listfunc( List ) - 15","","\t\tDPanel:SetSize( 113, height )","\t\tList:SetSize( 113, height )","","\t\tList._OnRowSelected = List.OnRowSelected","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\tfor k, v in pairs( lists ) do","\t\t\t\tif v ~= List then","\t\t\t\t\tv:ClearSelection()","\t\t\t\tend","\t\t\tend","\t\t\tList:_OnRowSelected( LineID, Line )","\t\tend","","\t\tlists[ name ] = List","\t\ttable.insert( panels, DPanel )","\tend","","\thelper.CatList._PerformLayout = helper.CatList.PerformLayout","\tfunction helper.CatList:PerformLayout( ... )","\t\tself:_PerformLayout( ... )","\t\tfor k, v in pairs( panels ) do","\t\t\tv:SetSize( self:GetCanvas():GetWide() - 8, v:GetTall() )","\t\tend","\t\tfor k, v in pairs( lists ) do","\t\t\tv:SetSize( self:GetCanvas():GetWide() - 8, v:GetTall() )","\t\tend","\tend","","\tcreateList( \"SF Helper\", function( List ) ","\t\tlocal height = 16;","\t\tList:AddLine( \"Index\" )","\t\theight = height + 17","\t\tList:AddLine( \"About\" )","\t\theight = height + 17","\t\tList:SelectFirstItem()","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\tif LineID == 1 then","\t\t\t\thelper.openView( \"Index\" )","\t\t\telse","\t\t\t\thelper.openView( \"About\" )","\t\t\tend","\t\tend","","\t\treturn height","\tend )","","\tcreateList( \"Preprocessor directives\", function( List )","\t\tlocal height = 16","\t\tfor _, directive in ipairs(SF.Docs.directives) do","\t\t\tList:AddLine( \"--@\" .. directive )","\t\t\theight = height + 17","\t\tend","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\thelper.openView( \"Doc\" )","\t\t\thelper.updateDocView( Line, 4 )","\t\t\thelper.DocView.DirectivesList:SelectItem( helper.DocView.DirectivesList:GetLine( LineID ) )","\t\tend","","\t\treturn height","\tend )","","\tcreateList( \"Libraries\", function( List )","\t\tlocal height = 16","\t\tfor _, modulename in ipairs(SF.Docs.libraries) do","\t\t\tList:AddLine( modulename )","\t\t\theight = height + 17","\t\tend","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\thelper.openView( \"Doc\" )","\t\t\thelper.updateDocView( Line, 1 )","\t\tend","","\t\treturn height","\tend )","\t","\tcreateList( \"Types\", function( List )","\t\tlocal height = 16","\t\tfor _, typename in ipairs(SF.Docs.classes) do","\t\t\tList:AddLine( typename )","\t\t\theight = height + 17","\t\tend","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\thelper.openView( \"Doc\" )","\t\t\thelper.updateDocView( Line, 2 )","\t\tend","","\t\treturn height","\tend )","\t","\tcreateList( \"Hooks\", function( List )","\t\tlocal height = 16","\t\tfor _, hookname in ipairs(SF.Docs.hooks) do","\t\t\tList:AddLine( hookname )","\t\t\theight = height + 17","\t\tend","","\t\tfunction List:OnRowSelected( LineID, Line )","\t\t\thelper.openView( \"Doc\" )","\t\t\thelper.updateDocView( Line, 3 )","\t\t\thelper.DocView.HooksList:SelectItem( helper.DocView.HooksList:GetLine( LineID ) )","\t\tend","","\t\treturn height","\tend )","","\tfunction helper.clearViews()","\t\tfor _, View in pairs( helper.Views ) do","\t\t\tView:SetVisible( false )","\t\t\tif View.Info then","\t\t\t\tView.Info:SetVisible( false )","\t\t\t\tView.Div:SetVisible( false )","\t\t\tend","\t\tend","\tend","","\tfunction helper.openView( view )","\t\thelper.clearViews()","\t\tif helper.Views[ view ] then","\t\t\thelper.Views[ view ]:SetVisible( true )","\t\t\tif helper.Views[ view ].Info then","\t\t\t\thelper.Views[ view ].Info:SetVisible( true )","\t\t\t\thelper.Views[ view ].Div:SetVisible( true )","\t\t\tend","\t\tend","\tend","","\tsurface.CreateFont( \"HelperTitle\", {","\t\tfont = \"Tahoma\",","\t\tsize = 30,","\t\tweight = 1000","\t} )","","\tsurface.CreateFont( \"HelperText\", {","\t\tfont = \"Tahoma\",","\t\tsize = 22,","\t\tweight = 500","\t} )","","\tsurface.CreateFont( \"HelperTextBold\", {","\t\tfont = \"Tahoma\",","\t\tsize = 22,","\t\tweight = 1000","\t} )","","\tsurface.CreateFont( \"CodeBlock\", {","\t\tfont = \"Courier New\",","\t\tsize = 16,","\t\tweight = 540","\t} )",""],"summary":"\nTO DO --- \nsearch page ","description":"\nTO DO --- \nsearch page","param":[]},{"comment":["\t---- Index View ----","\t--------------------"],"code":["\thelper.IndexView = vgui.Create( \"DPanel\", helper.Frame )","\thelper.IndexView:SetPos( 166, 30 )","\thelper.Views.Index = helper.IndexView","","\thelper.IndexLibs = vgui.Create( \"DListView\", helper.IndexView )","\thelper.IndexLibs:SetPos( 5, 5 )","\thelper.IndexLibs:SetMultiSelect( false )","\thelper.IndexLibs:AddColumn( \"Libraries\" ):SetFixedWidth( 100 )","\thelper.IndexLibs:AddColumn( \"Description\" )","\tfor _, modulename in ipairs( SF.Docs.libraries ) do","\t\thelper.IndexLibs:AddLine( modulename, string.Trim( SF.Docs.libraries[ modulename ].summary ) )","\tend","\tfunction helper.IndexLibs:OnRowSelected( LineID, Line )","\t\thelper.IndexHooks:ClearSelection()","\t\tlists[ \"Libraries\" ]:GetParent():GetParent():DoExpansion( true )","\t\tlists[ \"Libraries\" ]:SelectItem( lists[ \"Libraries\" ]:GetLine( LineID ) )","\tend","","\thelper.IndexHooks = vgui.Create( \"DListView\", helper.IndexView )","\thelper.IndexHooks:SetMultiSelect( false )","\thelper.IndexHooks:AddColumn( \"Hooks\" ):SetFixedWidth( 100 )","\thelper.IndexHooks:AddColumn( \"Description\" )","\tfor _, hookname in ipairs(SF.Docs.hooks) do","\t\thelper.IndexHooks:AddLine( hookname, string.Trim( SF.Docs.hooks[ hookname ].summary ) )","\tend","\tfunction helper.IndexHooks:OnRowSelected( LineID, Line )","\t\thelper.IndexLibs:ClearSelection()","\t\tlists[ \"Hooks\" ]:GetParent():GetParent():DoExpansion( true )","\t\tlists[ \"Hooks\" ]:SelectItem( lists[ \"Hooks\" ]:GetLine( LineID ) )","\tend",""],"summary":"\nIndex View ---- \n ","description":"\nIndex View ---- \n","param":[]},{"summary":"\nDoc View ---- \n ","description":"\nDoc View ---- \n","comment":["\t---- Doc View ----","\t------------------"],"code":["\tfunction helper.updateDocView( Line, Type )","\t\tlocal view = helper.DocView","\t\tview.DocName = Line:GetColumnText( 1 )","","\t\tview:GetVBar():SetScroll( 0 )","","\t\tif Type == 1 then","\t\t\tview.Title:SetText( \"Library - \" .. view.DocName )","\t\t\tview.Doc = SF.Docs.libraries[ view.DocName ]","\t\telseif Type == 2 then","\t\t\tview.Title:SetText( \"Type - \" .. view.DocName )","\t\t\tview.Doc = SF.Docs.classes[ view.DocName ]","\t\telseif Type == 3 then","\t\t\tview.Title:SetText( \"Hooks\" )","\t\t\tview.Doc = {}","\t\t\tview.Doc.hooks = SF.Docs.hooks","\t\t\tview.Doc.description = \"List of hooks available to SF scripts\"","\t\telseif Type == 4 then","\t\t\tview.Title:SetText( \"Preprocessor directives\" )","\t\t\tview.Doc = {}","\t\t\tview.Doc.directives = SF.Docs.directives","\t\t\tview.Doc.description = \"List of preprocessor directives\"","\t\tend","\t\tlocal doc = view.Doc","\t\tview.Title:SizeToContents()","","\t\tview.Description:SetText( string.Replace( doc.description, \"\\n\", \"\" ) )","\t\tview.Description:SizeToContents()","\t\tview.Description:SetWrap( true )","\t\tview.Description:SetAutoStretchVertical( true )","","\t\tif doc.deprecated then","\t\t\tview.Deprecated:SetVisible( true )","\t\t\tview.Deprecated.Enabled = true","\t\telse","\t\t\tview.Deprecated:SetVisible( false )","\t\t\tview.Deprecated.Enabled = false","\t\tend","\t\tfor _, labellist in pairs( helper.LabelLists ) do","\t\t\tif doc[ labellist.name ] and #doc[ labellist.name ] > 0 then","\t\t\t\tlabellist.label:SetVisible( true )","\t\t\t\tlabellist.label.Enabled = true","\t\t\t\tlabellist.label:SizeToContents()","\t\t\t\tlabellist.list:SetVisible( true )","\t\t\t\tlabellist.list:Clear()","\t\t\t\tlocal height = labellist.func( view, doc )","\t\t\t\tlabellist.list:SetTall( height )","\t\t\telse","\t\t\t\tlabellist.label:SetVisible( false )","\t\t\t\tlabellist.label.Enabled = false","\t\t\t\tlabellist.list:SetVisible( false )","\t\t\tend","\t\tend","","\t\ttimer.Create( \"update\", 0.1, 1, helper.resize )","\tend","","\thelper.DocView = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.DocView:SetPos( 166, 30 )","\thelper.DocView:SetVisible( false )","\thelper.Views.Doc = helper.DocView","","\thelper.DocView.Panel = vgui.Create( \"DPanel\", helper.DocView )","","\thelper.DocView.Title = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Title:SetPos( 10, 5 )","\thelper.DocView.Title:SetFont( \"HelperTitle\" )","\thelper.DocView.Title.m_colText = Color( 60, 60, 60 )","","\thelper.DocView.Description = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Description:SetPos( 25, 40 )","\thelper.DocView.Description:SetFont( \"HelperText\" )","\thelper.DocView.Description.m_colText = Color( 60, 60, 60 )","","\thelper.DocView.Deprecated = Label( \"\", helper.DocView.Panel )","\thelper.DocView.Deprecated:SetText( \"This library/type has been deprecated and will be removed in the future for the following reason: Pure Lua implementation. This can be done with a user library.\" )","\thelper.DocView.Deprecated:SetPos( 25, 40 )","\thelper.DocView.Deprecated:SetFont( \"HelperTextBold\" )","\thelper.DocView.Deprecated:SizeToContents()","\thelper.DocView.Deprecated:SetWrap( true )","\thelper.DocView.Deprecated:SetAutoStretchVertical( true )","\thelper.DocView.Deprecated.m_colText = Color( 210, 0, 0 )","","\thelper.LabelLists = {}","\tlocal function createDocList( name, func, update )","\t\tlocal label = Label( name, helper.DocView.Panel )","\t\tlabel:SetPos( 10, 40 )","\t\tlabel:SetFont( \"HelperTitle\" )","\t\tlabel.m_colText = Color( 60, 60, 60 )","\t\thelper.DocView[ name .. \"Label\" ] = label","","\t\tlocal list = vgui.Create( \"DListView\", helper.DocView.Panel )","\t\tlist:SetPos( 25, 40 )","\t\tlist:SetMultiSelect( false )","\t\tlist:AddColumn( name ):SetFixedWidth( 150 )","\t\tlist:AddColumn( \"Description\" )","\t\thelper.DocView[ name .. \"List\" ] = list","\t\thelper.LabelLists[ #helper.LabelLists + 1 ] = { label=label, list=list, func=func, name=string.lower( name ) }","","\t\tfunction list:OnRowSelected( LineID, Line )","\t\t\tfor _, labellist in pairs( helper.LabelLists ) do ","\t\t\t\tif labellist.list ~= list then","\t\t\t\t\tlabellist.list:ClearSelection()","\t\t\t\tend","\t\t\tend","\t\t\tupdate( LineID, Line )","\t\tend","\tend","\tcreateDocList( \"Functions\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, func in ipairs( doc.functions ) do","\t\t\tlocal func_data = doc.functions[ func ]","\t\t\tlocal description = string.Replace( string.Trim( func_data.summary ), \"\\n\", \"\" )","\t\t\tdescription = string.Replace( description, \"<a href=\\\"\", \"( \" )","\t\t\tdescription = string.Replace( description, \"\\\">\", \", \" )","\t\t\tdescription = string.Replace( description, \"</br>\", \"\" )","\t\t\tdescription = string.Replace( description, \"</a>\", \" )\" )","\t\t\tlocal line = view.FunctionsList:AddLine( func .. \" (\" .. table.concat( func_data.param, \", \" ) .. \")\" , description )","\t\t\tline.func = func","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.functions[ Line.func ] )","\tend )","\tcreateDocList( \"Tables\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, table in ipairs( doc.tables ) do","\t\t\tlocal table_data = doc.tables[ table ]","\t\t\tlocal line = view.TablesList:AddLine( table , string.Replace( string.Trim( table_data.summary ), \"\\n\", \"\" ) )","\t\t\tline.table = table","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.tables[ Line.table ] )","\tend  )","\tcreateDocList( \"Fields\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, field in ipairs( doc.fields ) do","\t\t\tlocal field_data = doc.fields[ field ]","\t\t\tview.FieldsList:AddLine( field , string.Replace( string.Trim( field_data.summary ), \"\\n\", \"\" ) )","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line)  end )","\tcreateDocList( \"Methods\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, func in ipairs( doc.methods ) do","\t\t\tlocal func_data = doc.methods[ func ]","\t\t\tlocal description = string.Replace( string.Trim( func_data.summary ), \"\\n\", \"\" )","\t\t\tdescription = string.Replace( description, \"<a href=\\\"\", \"( \" )","\t\t\tdescription = string.Replace( description, \"\\\">\", \", \" )","\t\t\tdescription = string.Replace( description, \"</br>\", \"\" )","\t\t\tdescription = string.Replace( description, \"</a>\", \" )\" )","\t\t\tlocal line = view.MethodsList:AddLine( func .. \" (\" .. table.concat( func_data.param, \", \" ) .. \")\" , description )","\t\t\tline.func = func","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.methods[ Line.func ] )","\tend  )","\tcreateDocList( \"Hooks\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, hook in ipairs( doc.hooks ) do","\t\t\tlocal hook_data = doc.hooks[ hook ]","\t\t\tlocal line = view.HooksList:AddLine( hook , string.Replace( string.Trim( hook_data.summary ), \"\\n\", \"\" ) )","\t\t\tline.hook = hook","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.hooks[ Line.hook ] )","\tend  )","\tcreateDocList( \"Directives\", function( view, doc )","\t\tlocal height = 16","\t\tfor _, directive in ipairs( doc.directives ) do","\t\t\tlocal directive_data = doc.directives[ directive ]","\t\t\tlocal line = view.DirectivesList:AddLine( directive , string.Replace( string.Trim( directive_data.summary ), \"\\n\", \"\" ) )","\t\t\tline.directive = directive","\t\t\theight = height + 17","\t\tend","\t\treturn height","\tend, function( LineID, Line )","\t\thelper.updateInfoPanel( helper.DocView.Doc.directives[ Line.directive ], true )","\tend  )","",""],"private":false,"class":"function","name":"helper.updateDocView","param":["Line","Type"]},{"summary":"\nInfoPanel ---- \n ","description":"\nInfoPanel ---- \n","comment":["\t---- InfoPanel ----","\t-------------------"],"code":["\tfunction helper.updateInfoPanel( func, directive )","\t\tlocal infopanel = helper.DocView.InfoPanel","\t\thelper.DocView.Info:GetVBar():SetScroll( 0 )","","\t\tdirective = nil or directive ","","\t\tif not directive then","\t\t\tinfopanel.funcName:SetText( string.Replace( func.name .. \"( \" .. table.concat( func.param, \", \" ) .. \" )\", \"\\n\", \"\" ) )","\t\telse","\t\t\tinfopanel.funcName:SetText( string.Replace( \"--@\" .. func.name .. \" \" .. table.concat( func.param, \", \" ), \"\\n\", \"\" ) )","\t\tend","\t\tinfopanel.funcName.Enabled = true","","\t\tinfopanel.description:SetText( string.Replace( func.description or \"\", \"\\n\", \"\" ) )","\t\tinfopanel.description.Enabled = true","","\t\tif func.deprecated then ","\t\t\tinfopanel.deprecated:SetText( \"Deprecated: \" .. string.Replace( func.deprecated, \"\\n\", \"\" ) ) ","\t\t\tinfopanel.deprecated.Enabled = true","\t\telse ","\t\t\tinfopanel.deprecated.Enabled = false","\t\tend","","\t\tif type( func.param ) == \"table\" and #func.param > 0 then","\t\t\tlocal params = \"\"","\t\t\tfor p = 1, #func.param do","\t\t\t\tparams = params .. \" \" .. func.param[ p ] .. \": \" .. ( func.param[ func.param[ p ] ] or \"\" ) .. ( p ~= #func.param and \"\\n\" or \"\" ) ","\t\t\tend","\t\t\tinfopanel.parameters:SetText( \"Parameters: \" )","\t\t\tinfopanel.parameterList:SetText( params )","\t\t\tinfopanel.parameters.Enabled = true","\t\t\tinfopanel.parameterList.Enabled = true","\t\telseif #func.param == 0 then","\t\t\tinfopanel.parameters.Enabled = false","\t\t\tinfopanel.parameterList.Enabled = false","\t\tend","","\t\tif type( func.ret ) == \"string\" then","\t\t\tinfopanel.returnvalue:SetText( \"Return value: \" )","\t\t\tinfopanel.returnvalueList:SetText( func.ret )","\t\t\tinfopanel.returnvalue.Enabled = true","\t\t\tinfopanel.returnvalueList.Enabled = true","\t\telseif type( func.ret ) == \"table\" then","\t\t\tinfopanel.returnvalue:SetText( \"Return values: \" )","\t\t\tlocal rets = \"\"","\t\t\tlocal count = 1","\t\t\tfor _, ret in ipairs( func.ret ) do","\t\t\t\trets = rets .. count .. \". \" .. ret .. \"\\n\"","\t\t\t\tcount = count + 1","\t\t\tend","\t\t\tinfopanel.returnvalueList:SetText( rets )","\t\t\tinfopanel.returnvalue.Enabled = true","\t\t\tinfopanel.returnvalueList.Enabled = true","\t\telse","\t\t\tinfopanel.returnvalue.Enabled = false","\t\t\tinfopanel.returnvalueList.Enabled = false","\t\tend","","\t\tif type( func.usage ) == \"string\" then","\t\t\tinfopanel.usage:SetText( \"Usage:\" )","\t\t\tinfopanel.usage.Enabled = true","\t\t\tinfopanel.usageBlock:SetText( string.gsub( string.Replace( func.usage , string.char( 9 ), \"    \" ), \"\\n\", \"\", 1 ) )","\t\t\tinfopanel.usageBlock.Enabled = true","\t\telseif not func.usage then","\t\t\tinfopanel.usage.Enabled = false","\t\t\tinfopanel.usageBlock.Enabled = false","\t\tend","","\t\tfor _, label in pairs( infopanel.labels ) do\t\t","\t\t\tlabel:SizeToContents()","\t\t\tlabel:SetWrap( true )","\t\t\tlabel:SetAutoStretchVertical( true )\t","\t\tend\t","\t\ttimer.Create( \"update\", 0.1, 1, helper.resize )","\tend","","\thelper.DocView.Info = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.DocView.Info:SetTall( 150 )","\thelper.DocView.Info:SetVisible( false )","","\thelper.DocView.InfoPanel = vgui.Create( \"DPanel\", helper.DocView.Info )","\thelper.DocView.InfoPanel:SetSize( 200, 100 )","\tlocal infopanel = helper.DocView.InfoPanel","","\thelper.DocView.Div = vgui.Create( \"DVerticalDivider\", helper.Frame )","\thelper.DocView.Div:SetPos( 166, 30 )","\thelper.DocView.Div:SetTop( helper.DocView )","\thelper.DocView.Div:SetBottom( helper.DocView.Info )","\thelper.DocView.Div:SetTopMin( 100 )","\thelper.DocView.Div:SetBottomMin( 100 )","\thelper.DocView.Div:SetDividerHeight( 5 )","\thelper.DocView.Div:SetVisible( false )","\thelper.DocView.Div._PerformLayout = helper.DocView.Div.PerformLayout","\tfunction helper.DocView.Div:PerformLayout()","\t\thelper.DocView.Div:_PerformLayout()","\t\thelper.resize()","\tend","","\tinfopanel.labels = {}","","\tinfopanel.funcName = Label( \"Nothing selected\", infopanel )","\tinfopanel.funcName:SetFont( \"HelperTextBold\" )","\tinfopanel.funcName:SizeToContents()","\tinfopanel.funcName.m_colText = Color( 60, 60, 60 )","\tinfopanel.funcName.indent = 0","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.funcName","","\tinfopanel.description = Label( \"\", infopanel )","\tinfopanel.description:SetFont( \"HelperText\" )","\tinfopanel.description.m_colText = Color( 60, 60, 60 )","\tinfopanel.description.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.description","","\tinfopanel.deprecated = Label( \"\", infopanel )","\tinfopanel.deprecated:SetText( \"\" )","\tinfopanel.deprecated:SetFont( \"HelperTextBold\" )","\tinfopanel.deprecated:SizeToContents()","\tinfopanel.deprecated:SetWrap( true )","\tinfopanel.deprecated:SetAutoStretchVertical( true )","\tinfopanel.deprecated.m_colText = Color( 210, 0, 0 )","\tinfopanel.deprecated.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.deprecated","","\tinfopanel.parameters = Label( \"Parameters:\", infopanel )","\tinfopanel.parameters:SetFont( \"HelperTextBold\" )","\tinfopanel.parameters.m_colText = Color( 60, 60, 60 )","\tinfopanel.parameters.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.parameters","","\tinfopanel.parameterList = Label( \"\", infopanel )","\tinfopanel.parameterList:SetFont( \"HelperText\" )","\tinfopanel.parameterList.m_colText = Color( 60, 60, 60 )","\tinfopanel.parameterList.indent = 2","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.parameterList","","\tinfopanel.returnvalue = Label( \"Return Value:\", infopanel )","\tinfopanel.returnvalue:SetFont( \"HelperTextBold\" )","\tinfopanel.returnvalue.m_colText = Color( 60, 60, 60 )","\tinfopanel.returnvalue.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.returnvalue","","\tinfopanel.returnvalueList = Label( \"\", infopanel )","\tinfopanel.returnvalueList:SetFont( \"HelperText\" )","\tinfopanel.returnvalueList.m_colText = Color( 60, 60, 60 )","\tinfopanel.returnvalueList.indent = 2","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.returnvalueList","","\tinfopanel.usage = Label( \"Usage:\", infopanel )","\tinfopanel.usage:SetFont( \"HelperTextBold\" )","\tinfopanel.usage.m_colText = Color( 60, 60, 60 )","\tinfopanel.usage.indent = 1","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.usage","","\tinfopanel.usageBlock = Label( \"\", infopanel )","\tinfopanel.usageBlock:SetFont( \"CodeBlock\" )","\tinfopanel.usageBlock.m_colText = Color( 60, 60, 60 )","\tinfopanel.usageBlock.indent = 3","\tinfopanel.labels[ #infopanel.labels + 1 ] = infopanel.usageBlock",""],"private":false,"class":"function","name":"helper.updateInfoPanel","param":["func","directive"]},{"comment":["\t---- About View ----","\t--------------------"],"code":["\thelper.AboutView = vgui.Create( \"DScrollPanel\", helper.Frame )","\thelper.AboutView:SetPos( 166, 30 )","\thelper.AboutView:SetVisible( false )","\thelper.Views.About = helper.AboutView","","\thelper.AboutView.Panel = vgui.Create( \"DPanel\", helper.AboutView )","","\thelper.AboutView.About = Label( \"Starfall is a Lua sandbox for Garry's mod. It allows players to write Lua scripts for the server without exposing server functionality that could be used maliciously. Since it works with Lua code directly, it's much faster than similar projects like E2 or Lemongate.\\n\\nStarfall by default includes a 'processor' entity, which is a purely server-side environment with an entity representation, and can have Wiremod inputs/outputs. It also includes a 'screen' entity, which runs code both on the server and each client to allow for fast, lag-free drawing that was previously only possible with GPU.\\n\\nThis Starfall Helper was originally made by Jazzelhawk.\", helper.AboutView.Panel )","\thelper.AboutView.About:SetPos( 10, 10 )","\thelper.AboutView.About:SetFont( \"HelperText\" )","\thelper.AboutView.About:SizeToContents()","\thelper.AboutView.About:SetWrap( true )","\thelper.AboutView.About:SetAutoStretchVertical( true )","\thelper.AboutView.About.m_colText = Color( 60, 60, 60 )","","end","","function helper.show()","\tif docs_downloading then return end","\tif not docs_set then","\t\tdocs_downloading = true","\t\tSF.AddNotify( LocalPlayer(), \"Loading starfall helper now...\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\t\t","\t\thttp.Fetch( \"http://thegrb93.github.io/StarfallEx/doc.json\", ","\t\tfunction( body, len, headers, code )","\t\t\tSF.Docs = util.JSONToTable( body )","\t\t\tdocs_set = true","\t\t\tdocs_downloading = false","\t\t\thelper.show()","\t\tend, ","\t\tfunction( error ) ","\t\t\tprint(\"Starfall failed to load documentation, Error: \", error) ","\t\t\tSF.AddNotify( LocalPlayer(), \"Failed to load the helper...\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 ) ","\t\t\tdocs_downloading = false","\t\tend )","\t\t","\t\treturn","\tend","","\tif not helper.Frame then helper.create() end","\thelper.Frame:MakePopup()","\thelper.Frame:SetVisible(true)","end","","local lastw, lasth = 0, 0","function helper.resize()","\tlocal w, h = helper.Frame:GetSize()","","\tlocal changew, changeh = w - lastw, h - lasth","","\thelper.CatList:SetSize( 155, 375 + h - 410)","\thelper.ScrollPanel:SetSize( 155, 375 + h - 410)","","\thelper.IndexView:SetSize( w - 173, h - 37 )","\thelper.IndexLibs:SetSize( w - 183, h / 2 - 26 )","\thelper.IndexHooks:SetPos( 5, 10 + helper.IndexLibs:GetTall() )","\thelper.IndexHooks:SetSize( w - 183, h / 2 - 27 )","","\thelper.DocView:SetSize( w - 173, h - 37 - helper.DocView.Info:GetTall() - 5 )","\tlocal w2 = helper.DocView:GetCanvas():GetWide()","\thelper.DocView.Description:SetWide( w2 - 50 )","\thelper.DocView.Deprecated:SetWide( w2 - 50 )","","\t--helper.DocView.Info:SetPos( 166, 30 + helper.DocView:GetTall() + 6 )","\thelper.DocView.Info:SetWide( w - 173 )","\thelper.DocView.InfoPanel:SetWide( w - 173 )","","\thelper.DocView.Div:SetSize( w - 173, h - 37 )","\thelper.DocView.Div:SetTopHeight( helper.DocView.Div:GetTopHeight() + changeh )","","\thelper.AboutView:SetSize( w - 173, h - 37 )","\thelper.AboutView.About:SetWide( helper.AboutView:GetWide() - 20 )","\thelper.AboutView.Panel:SetSize( helper.AboutView:GetWide(), math.max( helper.AboutView.About:GetTall() + 10, helper.AboutView:GetTall() ) )","","\tlocal runningHeight = 40","\trunningHeight = runningHeight + helper.DocView.Description:GetTall() + 10","\tif helper.DocView.Deprecated.Enabled then","\t\thelper.DocView.Deprecated:SetPos( 25, runningHeight )","\t\trunningHeight = runningHeight + helper.DocView.Deprecated:GetTall() + 10","\tend","\tfor _, labellist in pairs( helper.LabelLists ) do ","\t\tlabellist.list:SetWide( w2 - 50 )","\t\tif labellist.label.Enabled then","\t\t\tlabellist.label:SetPos( 10, runningHeight )","\t\t\trunningHeight = runningHeight + labellist.label:GetTall() + 10","\t\t\tlabellist.list:SetPos( 25, runningHeight )","\t\t\trunningHeight = runningHeight + labellist.list:GetTall() + 10","\t\tend","\tend","","\thelper.DocView.Panel:SetSize( helper.DocView:GetWide(), math.max( runningHeight, helper.DocView:GetTall() ) )","","\tlocal infopanel = helper.DocView.InfoPanel","\tlocal runningHeight = 10","\tfor _, label in pairs( infopanel.labels ) do","\t\tlabel:SetWide( w2 - 50 )","\t\tif label.Enabled then","\t\t\tlabel:SetVisible( true )","\t\t\tlabel:SetPos( 10 + label.indent*20, runningHeight )","\t\t\trunningHeight = runningHeight + label:GetTall() + 10","\t\telse","\t\t\tlabel:SetVisible( false )","\t\tend","\tend","","\tinfopanel:SetSize( infopanel:GetWide(), math.max( runningHeight, helper.DocView.Info:GetTall() ) )","","\thelper.DocView:GetVBar():SetScroll( helper.DocView:GetVBar():GetScroll() )","\thelper.CatList:GetVBar():SetScroll( helper.CatList:GetVBar():GetScroll() )","\thelper.IndexLibs.VBar:SetScroll( helper.IndexLibs.VBar:GetScroll() )","\thelper.IndexHooks.VBar:SetScroll( helper.IndexHooks.VBar:GetScroll() )","\thelper.DocView.Info.VBar:SetScroll( helper.DocView.Info.VBar:GetScroll() )","\thelper.AboutView.VBar:SetScroll( helper.AboutView.VBar:GetScroll() )","","\tif not settings_set then","\t\thelper.Frame:SetSize( GetConVarNumber( \"sf_helper_width\" ), GetConVarNumber( \"sf_helper_height\" ) )","\t\thelper.Frame:SetPos( GetConVarNumber( \"sf_helper_posx\" ), GetConVarNumber( \"sf_helper_posy\" ) )","\t\ttimer.Simple( 0.5, function () helper.DocView.Div:SetTopHeight( GetConVarNumber( \"sf_helper_divheight\" ) ) end )","\t\tsettings_set = true","\tend","","\tlastw, lasth = w, h","end"],"summary":"\nAbout View ---- \n ","description":"\nAbout View ---- \n","param":[]}],"tables":[],"description":"\n \nSF Helper for Starfall \nBy Jazzelhawk \n","summary":"\n \nSF Helper for Starfall \nBy Jazzelhawk \n "},"permissions/providers_cl/files.lua":{"libraries":[],"type":"file","name":"permissions/providers_cl/files.lua","functions":[],"doc":[{"comment":["--- Starfall file library permission provider"],"code":["","-- start the provider table and set it to inherit from the default provider","local P = {}","P.__index = SF.Permissions.Provider","setmetatable( P, P )","","-- localize the result set","local ALLOW = SF.Permissions.Result.ALLOW","local DENY = SF.Permissions.Result.DENY","local NEUTRAL = SF.Permissions.Result.NEUTRAL","","-- define what permission keys we will allow","local keys = {","\t[ \"file.read\" ] = true,","\t[ \"file.write\" ] = true,","\t[ \"file.exists\" ] = true","}","","function P:check ( principal, target, key )","\tif type( target ) ~= \"string\" then return NEUTRAL end","","\t-- allow if the localplayer is trying to write a file to their computer","\tif keys[ key ] and principal == LocalPlayer() then","\t\treturn ALLOW","\telse","\t\treturn NEUTRAL","\tend","end","","-- register the provider","SF.Permissions.registerProvider( P )"],"summary":"\nStarfall file library permission provider ","description":"\nStarfall file library permission provider","param":[]}],"tables":[],"description":"\nStarfall file library permission provider","summary":"\nStarfall file library permission provider "},"permissions/provider.lua":{"libraries":[],"type":"file","name":"permissions/provider.lua","functions":{"1":"P:check","2":"P:isOwner","3":"P:supportsOwner","P:check":{"ret":"one of the SF.Permissions.Role values","comment":["--- Checks whether a player may perform an action.","-- @param principal the player performing the action to be authorized","-- @param target the object on which the action is being performed","-- @param key a string identifying the action being performed","-- @return one of the SF.Permissions.Role values"],"code":["function P:check ( principal, target, key )","\treturn NEUTRAL","end"],"class":"function","name":"P:check","private":false,"summary":"\nChecks whether a player may perform an action.","description":"\nChecks whether a player may perform an action.","param":{"1":"principal","2":"target","3":"key","target":"the object on which the action is being performed","principal":"the player performing the action to be authorized","key":"a string identifying the action being performed"}},"P:supportsOwner":{"ret":"boolean whether this provider supports the isOwner method","comment":["--- Checks whether this provider knows who the server owners are.","-- @return boolean whether this provider supports the isOwner method"],"code":["function P:supportsOwner ()","\treturn false","end",""],"class":"function","name":"P:supportsOwner","private":false,"summary":"\nChecks whether this provider knows who the server owners are.","description":"\nChecks whether this provider knows who the server owners are.","param":[]},"P:isOwner":{"ret":"boolean whether the player is in the owners group","comment":["--- Checks whether a player is considered the owner of the server.","-- @param principal the player to examine","-- @return boolean whether the player is in the owners group"],"code":["function P:isOwner ( principal )","\treturn false","end",""],"class":"function","name":"P:isOwner","private":false,"summary":"\nChecks whether a player is considered the owner of the server.","description":"\nChecks whether a player is considered the owner of the server.","param":{"1":"principal","principal":"the player to examine"}}},"doc":[{"comment":["--- Sf Provider Interface","-- TODO: Need to document the shit out of this.","--"],"code":["SF.Permissions.Provider = {}","","local P = SF.Permissions.Provider","P.__index = P","","-- localize the Result enum","local NEUTRAL = SF.Permissions.Result.NEUTRAL",""],"summary":"\nSf Provider Interface \nTODO: Need to document the shit out of this.","description":"\nSf Provider Interface \nTODO: Need to document the shit out of this. \n","param":[]},{"ret":"boolean whether this provider supports the isOwner method","comment":["--- Checks whether this provider knows who the server owners are.","-- @return boolean whether this provider supports the isOwner method"],"code":["function P:supportsOwner ()","\treturn false","end",""],"class":"function","name":"P:supportsOwner","private":false,"summary":"\nChecks whether this provider knows who the server owners are.","description":"\nChecks whether this provider knows who the server owners are.","param":[]},{"ret":"boolean whether the player is in the owners group","comment":["--- Checks whether a player is considered the owner of the server.","-- @param principal the player to examine","-- @return boolean whether the player is in the owners group"],"code":["function P:isOwner ( principal )","\treturn false","end",""],"class":"function","name":"P:isOwner","private":false,"summary":"\nChecks whether a player is considered the owner of the server.","description":"\nChecks whether a player is considered the owner of the server.","param":{"1":"principal","principal":"the player to examine"}},{"ret":"one of the SF.Permissions.Role values","comment":["--- Checks whether a player may perform an action.","-- @param principal the player performing the action to be authorized","-- @param target the object on which the action is being performed","-- @param key a string identifying the action being performed","-- @return one of the SF.Permissions.Role values"],"code":["function P:check ( principal, target, key )","\treturn NEUTRAL","end"],"class":"function","name":"P:check","private":false,"summary":"\nChecks whether a player may perform an action.","description":"\nChecks whether a player may perform an action.","param":{"1":"principal","2":"target","3":"key","target":"the object on which the action is being performed","principal":"the player performing the action to be authorized","key":"a string identifying the action being performed"}}],"tables":[],"description":"\nSf Provider Interface \nTODO: Need to document the shit out of this. \n","summary":"\nSf Provider Interface \nTODO: Need to document the shit out of this."},"libs_sv/prop.lua":{"libraries":{"1":"prop","prop":{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"createSent","4":"propsLeft","5":"spawnRate","canSpawn":{"ret":"True if user can spawn props, False if not.","comment":["--- Checks if a user can spawn anymore props.","-- @server","-- @return True if user can spawn props, False if not."],"code":["function props_library.canSpawn ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return false end","\t","\tlocal instance = SF.instance","\treturn not personal_max_reached( instance ) and not max_reached() and can_spawn( instance, true )","\t","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore props.","name":"props_library.canSpawn","library":"prop","private":false,"server":true,"description":"\nChecks if a user can spawn anymore props.","param":[]},"createSent":{"ret":"The sent object","comment":["--- Creates a sent.","-- @server","-- @return The sent object"],"code":["function props_library.createSent ( pos, ang, class, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( class, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not can_spawn( instance ) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 )","\telseif max_reached() then return SF.throw( \"Can't spawn props, maximum limit of \" .. SF.Props.defaultquota:GetInt() .. \" has been reached\", 2 ) end","\tif not IsValid( instance.player ) then return end","\t","","\tlocal swep = list.Get( \"Weapon\" )[ class ]","\tlocal sent = list.Get( \"SpawnableEntities\" )[ class ]","","\tlocal propdata = instance.data.props","\tlocal entity","\tlocal hookcall","\t","\tif swep then","\t","\t\tif ( ( !swep.Spawnable && !instance.player:IsAdmin() ) || ","\t\t      ( swep.AdminOnly && !instance.player:IsAdmin() ) ) then return end","\t\tif ( !gamemode.Call( \"PlayerSpawnSWEP\", instance.player, class, swep ) ) then return end","","","\t\tentity = ents.Create( swep.ClassName )","\t\t","\t\thookcall = \"PlayerSpawnedSWEP\"","\t","\telseif sent then","\t","\t\tif ( sent.AdminOnly && !instance.player:IsAdmin() ) then return false end","\t\tif ( !gamemode.Call( \"PlayerSpawnSENT\", instance.player, class ) ) then return end","\t","\t\tentity = ents.Create( sent.ClassName )","\t","\t\thookcall = \"PlayerSpawnedSENT\"","\t","\tend","\t","\tif ( IsValid( entity ) ) then","\t\t","\t\tentity:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\t\tentity:SetPos( pos )","\t\tentity:SetAngles( ang )","\t\t","\t\tentity:Spawn()","\t\tentity:Activate()","\t\t","\t\tlocal phys = entity:GetPhysicsObject()","\t\tif phys:IsValid() then","\t\t\tphys:EnableMotion(not frozen)","\t\tend","\t\t","\t\tinstance.player:AddCleanup( \"props\", entity )","\t\tgamemode.Call( hookcall, instance.player, entity )","\t","\t\tlocal wrapped = SF.Entities.Wrap( entity )","","\t\tpropdata.props[ wrapped ] = wrapped","","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\t\treturn wrapped","\tend","end",""],"class":"function","summary":"\nCreates a sent.","name":"props_library.createSent","library":"prop","private":false,"server":true,"description":"\nCreates a sent.","param":["pos","ang","class","frozen"]},"propsLeft":{"ret":"number of props able to be spawned","comment":["--- Checks how many props can be spawned","-- @server","-- @return number of props able to be spawned"],"code":["function props_library.propsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\treturn math.min( SF.Props.personalquota:GetInt() - plyCount[instance.player], instance.data.props.burst )","\t","end",""],"class":"function","summary":"\nChecks how many props can be spawned ","name":"props_library.propsLeft","library":"prop","private":false,"server":true,"description":"\nChecks how many props can be spawned","param":[]},"create":{"ret":"The prop object","comment":["--- Creates a prop.","-- @server","-- @return The prop object"],"code":["function props_library.create ( pos, ang, model, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( model, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not can_spawn( instance ) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 )","\telseif max_reached() then return SF.throw( \"Can't spawn props, maximum limit of \" .. SF.Props.defaultquota:GetInt() .. \" has been reached\", 2 ) end","\tif not IsValid( instance.player ) then return end","\tif not gamemode.Call( \"PlayerSpawnProp\", instance.player, model ) then return end","","\tlocal propdata = instance.data.props","\tlocal propent = ents.Create( \"prop_physics\" )","\t","\tpropent:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\tpropent:SetPos( pos )","\tpropent:SetAngles( ang )","\tpropent:SetModel( model )","\tpropent:Spawn()","\t","\tfor I = 0,  propent:GetPhysicsObjectCount() - 1 do","\t\tlocal obj = propent:GetPhysicsObjectNum( I )","\t\tif obj:IsValid() then","\t\t\tobj:EnableMotion(not frozen)","\t\tend","\tend","\t","\tinstance.player:AddCleanup( \"props\", propent )","\t","\tgamemode.Call( \"PlayerSpawnedProp\", instance.player, model, propent )","\tFixInvalidPhysicsObject( propent )","","\tlocal prop = SF.Entities.Wrap( propent )","","\tpropdata.props[ prop ] = prop","\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\treturn prop","end",""],"class":"function","summary":"\nCreates a prop.","name":"props_library.create","library":"prop","private":false,"server":true,"description":"\nCreates a prop.","param":["pos","ang","model","frozen"]},"spawnRate":{"ret":"Number of props per second the user can spawn","comment":["--- Returns how many props per second the user can spawn","-- @server","-- @return Number of props per second the user can spawn"],"code":["function props_library.spawnRate ()","","\treturn SF.Props.burstrate:GetFloat() or 4","\t","end"],"class":"function","summary":"\nReturns how many props per second the user can spawn ","name":"props_library.spawnRate","library":"prop","private":false,"server":true,"description":"\nReturns how many props per second the user can spawn","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","code":["local props_library, props_library_metamethods = SF.Libraries.Register(\"prop\")","","local vunwrap = SF.UnwrapObject","","SF.Props = {}","SF.Props.defaultquota = CreateConVar( \"sf_props_defaultquota\", \"200\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn via Starfall scripts across all instances\" )","","SF.Props.personalquota = CreateConVar( \"sf_props_personalquota\", \"100\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn via Starfall scripts for a single instance\" )","","SF.Props.burstmax = CreateConVar( \"sf_props_burstmax\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn in a short interval of time via Starfall scripts for a single instance ( burst )\" )","\t","SF.Props.burstrate = CreateConVar( \"sf_props_burstrate\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The rate at which the burst regenerates per second.\" )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"prop.create\", \"Create prop\", \"Allows the user to create props\" )","end","","local insts = {}","local plyCount = setmetatable({}, {__mode=\"k\"})","","SF.Libraries.AddHook(\"initialize\",function(inst)","\tinst.data.props = {","\t\tprops = {},","\t\tburst = SF.Props.burstmax:GetInt() or 4","\t}","","\tinsts[inst] = true","\tplyCount[inst.player] = plyCount[inst.player] or 0","end)","","SF.Libraries.AddHook(\"deinitialize\", function(inst)","\tlocal props = inst.data.props.props","\tlocal prop = next(props)","\twhile prop do","\t\tlocal propent = SF.Entities.Unwrap(prop)","\t\tif IsValid(propent) then","\t\t\tpropent:Remove()","\t\tend","\t\tprops[prop] = nil","\t\tprop = next(props)","\tend","","\tinsts[inst]= nil","end)","","local function propOnDestroy(propent, propdata, ply)","\tplyCount[ply] = plyCount[ply] - 1","\tif not propdata.props then return end","\tlocal prop = SF.Entities.Wrap(propent)","\tif propdata.props[prop] then","\t\tpropdata.props[prop] = nil","\tend","end","",""],"fields":[],"name":"prop","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"props_library","tables":[],"server":true}},"type":"file","name":"libs_sv/prop.lua","functions":{"1":"can_spawn","2":"max_reached","3":"personal_max_reached","4":"props_library.canSpawn","5":"props_library.create","6":"props_library.createSent","7":"props_library.propsLeft","8":"props_library.spawnRate","props_library.createSent":{"ret":"The sent object","comment":["--- Creates a sent.","-- @server","-- @return The sent object"],"code":["function props_library.createSent ( pos, ang, class, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( class, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not can_spawn( instance ) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 )","\telseif max_reached() then return SF.throw( \"Can't spawn props, maximum limit of \" .. SF.Props.defaultquota:GetInt() .. \" has been reached\", 2 ) end","\tif not IsValid( instance.player ) then return end","\t","","\tlocal swep = list.Get( \"Weapon\" )[ class ]","\tlocal sent = list.Get( \"SpawnableEntities\" )[ class ]","","\tlocal propdata = instance.data.props","\tlocal entity","\tlocal hookcall","\t","\tif swep then","\t","\t\tif ( ( !swep.Spawnable && !instance.player:IsAdmin() ) || ","\t\t      ( swep.AdminOnly && !instance.player:IsAdmin() ) ) then return end","\t\tif ( !gamemode.Call( \"PlayerSpawnSWEP\", instance.player, class, swep ) ) then return end","","","\t\tentity = ents.Create( swep.ClassName )","\t\t","\t\thookcall = \"PlayerSpawnedSWEP\"","\t","\telseif sent then","\t","\t\tif ( sent.AdminOnly && !instance.player:IsAdmin() ) then return false end","\t\tif ( !gamemode.Call( \"PlayerSpawnSENT\", instance.player, class ) ) then return end","\t","\t\tentity = ents.Create( sent.ClassName )","\t","\t\thookcall = \"PlayerSpawnedSENT\"","\t","\tend","\t","\tif ( IsValid( entity ) ) then","\t\t","\t\tentity:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\t\tentity:SetPos( pos )","\t\tentity:SetAngles( ang )","\t\t","\t\tentity:Spawn()","\t\tentity:Activate()","\t\t","\t\tlocal phys = entity:GetPhysicsObject()","\t\tif phys:IsValid() then","\t\t\tphys:EnableMotion(not frozen)","\t\tend","\t\t","\t\tinstance.player:AddCleanup( \"props\", entity )","\t\tgamemode.Call( hookcall, instance.player, entity )","\t","\t\tlocal wrapped = SF.Entities.Wrap( entity )","","\t\tpropdata.props[ wrapped ] = wrapped","","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\t\treturn wrapped","\tend","end",""],"class":"function","summary":"\nCreates a sent.","name":"props_library.createSent","library":"prop","private":false,"server":true,"description":"\nCreates a sent.","param":["pos","ang","class","frozen"]},"props_library.spawnRate":{"ret":"Number of props per second the user can spawn","comment":["--- Returns how many props per second the user can spawn","-- @server","-- @return Number of props per second the user can spawn"],"code":["function props_library.spawnRate ()","","\treturn SF.Props.burstrate:GetFloat() or 4","\t","end"],"class":"function","summary":"\nReturns how many props per second the user can spawn ","name":"props_library.spawnRate","library":"prop","private":false,"server":true,"description":"\nReturns how many props per second the user can spawn","param":[]},"can_spawn":{"comment":["--- Updates/Checks burst constraints","-- @class function","-- @param instance Instance table for the burst values related to current SF Instance / Player","-- @param noupdate False if updating the burst should be done."],"code":["local function can_spawn(instance, noupdate)","\tif instance.data.props.burst > 0 then","\t\tif not noupdate then instance.data.props.burst = instance.data.props.burst - 1 end","\t\treturn true","\telse","\t\treturn false","\tend","end",""],"class":"function","classForced":true,"name":"can_spawn","private":false,"summary":"\nUpdates/Checks burst constraints ","description":"\nUpdates/Checks burst constraints","param":{"1":"instance","2":"noupdate","instance":"Instance table for the burst values related to current SF Instance / Player","noupdate":"False if updating the burst should be done."}},"personal_max_reached":{"ret":"True/False depending on if the personal limit has been reached for SF Props","comment":["--- Checks if the users personal limit of props has been exhausted","-- @class function","-- @param i Instance to use, this will relate to the player in question","-- @return True/False depending on if the personal limit has been reached for SF Props"],"code":["local function personal_max_reached( i )","\treturn plyCount[i.player] >= SF.Props.personalquota:GetInt()","end","","local function regenerateBurst()","\tfor i, _ in pairs( insts ) do","\t\tif i.data.props.burst < SF.Props.burstmax:GetInt() or 4 then -- Should allow for dynamic changing of burst rate from the server.","\t\t\ti.data.props.burst = i.data.props.burst + 1","\t\tend","\tend","end","","timer.Create( \"SF_Prop_BurstCounter\", 1 / math.max( SF.Props.burstrate:GetFloat() or 4, 0.0001 ), 0, regenerateBurst )","","cvars.AddChangeCallback( \"sf_props_burstrate\", function( convar_name, value_old, value_new )","\ttimer.Adjust( \"SF_Prop_BurstCounter\", 1 / math.max( SF.Props.burstrate:GetFloat() or 4, 0.0001 ), 0, regenerateBurst )","end ) ",""],"class":"function","classForced":true,"name":"personal_max_reached","private":false,"summary":"\nChecks if the users personal limit of props has been exhausted ","description":"\nChecks if the users personal limit of props has been exhausted","param":{"1":"i","i":"Instance to use, this will relate to the player in question"}},"props_library.propsLeft":{"ret":"number of props able to be spawned","comment":["--- Checks how many props can be spawned","-- @server","-- @return number of props able to be spawned"],"code":["function props_library.propsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\treturn math.min( SF.Props.personalquota:GetInt() - plyCount[instance.player], instance.data.props.burst )","\t","end",""],"class":"function","summary":"\nChecks how many props can be spawned ","name":"props_library.propsLeft","library":"prop","private":false,"server":true,"description":"\nChecks how many props can be spawned","param":[]},"max_reached":{"ret":"True/False depending on if limit has been reached for SF Props","comment":["--- Checks if the total number of props across all instances has reached the max limit.","-- @class function","-- @return True/False depending on if limit has been reached for SF Props"],"code":["local function max_reached()","\tlocal c = 0","\tfor _, v in pairs( plyCount ) do","\t\tc = c + v","\tend","\tif c >= SF.Props.defaultquota:GetInt() then return true else return false end","end",""],"class":"function","classForced":true,"name":"max_reached","private":false,"summary":"\nChecks if the total number of props across all instances has reached the max limit.","description":"\nChecks if the total number of props across all instances has reached the max limit.","param":[]},"props_library.canSpawn":{"ret":"True if user can spawn props, False if not.","comment":["--- Checks if a user can spawn anymore props.","-- @server","-- @return True if user can spawn props, False if not."],"code":["function props_library.canSpawn ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return false end","\t","\tlocal instance = SF.instance","\treturn not personal_max_reached( instance ) and not max_reached() and can_spawn( instance, true )","\t","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore props.","name":"props_library.canSpawn","library":"prop","private":false,"server":true,"description":"\nChecks if a user can spawn anymore props.","param":[]},"props_library.create":{"ret":"The prop object","comment":["--- Creates a prop.","-- @server","-- @return The prop object"],"code":["function props_library.create ( pos, ang, model, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( model, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not can_spawn( instance ) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 )","\telseif max_reached() then return SF.throw( \"Can't spawn props, maximum limit of \" .. SF.Props.defaultquota:GetInt() .. \" has been reached\", 2 ) end","\tif not IsValid( instance.player ) then return end","\tif not gamemode.Call( \"PlayerSpawnProp\", instance.player, model ) then return end","","\tlocal propdata = instance.data.props","\tlocal propent = ents.Create( \"prop_physics\" )","\t","\tpropent:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\tpropent:SetPos( pos )","\tpropent:SetAngles( ang )","\tpropent:SetModel( model )","\tpropent:Spawn()","\t","\tfor I = 0,  propent:GetPhysicsObjectCount() - 1 do","\t\tlocal obj = propent:GetPhysicsObjectNum( I )","\t\tif obj:IsValid() then","\t\t\tobj:EnableMotion(not frozen)","\t\tend","\tend","\t","\tinstance.player:AddCleanup( \"props\", propent )","\t","\tgamemode.Call( \"PlayerSpawnedProp\", instance.player, model, propent )","\tFixInvalidPhysicsObject( propent )","","\tlocal prop = SF.Entities.Wrap( propent )","","\tpropdata.props[ prop ] = prop","\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\treturn prop","end",""],"class":"function","summary":"\nCreates a prop.","name":"props_library.create","library":"prop","private":false,"server":true,"description":"\nCreates a prop.","param":["pos","ang","model","frozen"]}},"doc":[{"comment":["--- Library for creating and manipulating physics-less models AKA \"Props\".","-- @shared"],"functions":{"1":"canSpawn","2":"create","3":"createSent","4":"propsLeft","5":"spawnRate","canSpawn":{"ret":"True if user can spawn props, False if not.","comment":["--- Checks if a user can spawn anymore props.","-- @server","-- @return True if user can spawn props, False if not."],"code":["function props_library.canSpawn ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return false end","\t","\tlocal instance = SF.instance","\treturn not personal_max_reached( instance ) and not max_reached() and can_spawn( instance, true )","\t","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore props.","name":"props_library.canSpawn","library":"prop","private":false,"server":true,"description":"\nChecks if a user can spawn anymore props.","param":[]},"createSent":{"ret":"The sent object","comment":["--- Creates a sent.","-- @server","-- @return The sent object"],"code":["function props_library.createSent ( pos, ang, class, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( class, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not can_spawn( instance ) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 )","\telseif max_reached() then return SF.throw( \"Can't spawn props, maximum limit of \" .. SF.Props.defaultquota:GetInt() .. \" has been reached\", 2 ) end","\tif not IsValid( instance.player ) then return end","\t","","\tlocal swep = list.Get( \"Weapon\" )[ class ]","\tlocal sent = list.Get( \"SpawnableEntities\" )[ class ]","","\tlocal propdata = instance.data.props","\tlocal entity","\tlocal hookcall","\t","\tif swep then","\t","\t\tif ( ( !swep.Spawnable && !instance.player:IsAdmin() ) || ","\t\t      ( swep.AdminOnly && !instance.player:IsAdmin() ) ) then return end","\t\tif ( !gamemode.Call( \"PlayerSpawnSWEP\", instance.player, class, swep ) ) then return end","","","\t\tentity = ents.Create( swep.ClassName )","\t\t","\t\thookcall = \"PlayerSpawnedSWEP\"","\t","\telseif sent then","\t","\t\tif ( sent.AdminOnly && !instance.player:IsAdmin() ) then return false end","\t\tif ( !gamemode.Call( \"PlayerSpawnSENT\", instance.player, class ) ) then return end","\t","\t\tentity = ents.Create( sent.ClassName )","\t","\t\thookcall = \"PlayerSpawnedSENT\"","\t","\tend","\t","\tif ( IsValid( entity ) ) then","\t\t","\t\tentity:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\t\tentity:SetPos( pos )","\t\tentity:SetAngles( ang )","\t\t","\t\tentity:Spawn()","\t\tentity:Activate()","\t\t","\t\tlocal phys = entity:GetPhysicsObject()","\t\tif phys:IsValid() then","\t\t\tphys:EnableMotion(not frozen)","\t\tend","\t\t","\t\tinstance.player:AddCleanup( \"props\", entity )","\t\tgamemode.Call( hookcall, instance.player, entity )","\t","\t\tlocal wrapped = SF.Entities.Wrap( entity )","","\t\tpropdata.props[ wrapped ] = wrapped","","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\t\treturn wrapped","\tend","end",""],"class":"function","summary":"\nCreates a sent.","name":"props_library.createSent","library":"prop","private":false,"server":true,"description":"\nCreates a sent.","param":["pos","ang","class","frozen"]},"propsLeft":{"ret":"number of props able to be spawned","comment":["--- Checks how many props can be spawned","-- @server","-- @return number of props able to be spawned"],"code":["function props_library.propsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\treturn math.min( SF.Props.personalquota:GetInt() - plyCount[instance.player], instance.data.props.burst )","\t","end",""],"class":"function","summary":"\nChecks how many props can be spawned ","name":"props_library.propsLeft","library":"prop","private":false,"server":true,"description":"\nChecks how many props can be spawned","param":[]},"create":{"ret":"The prop object","comment":["--- Creates a prop.","-- @server","-- @return The prop object"],"code":["function props_library.create ( pos, ang, model, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( model, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not can_spawn( instance ) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 )","\telseif max_reached() then return SF.throw( \"Can't spawn props, maximum limit of \" .. SF.Props.defaultquota:GetInt() .. \" has been reached\", 2 ) end","\tif not IsValid( instance.player ) then return end","\tif not gamemode.Call( \"PlayerSpawnProp\", instance.player, model ) then return end","","\tlocal propdata = instance.data.props","\tlocal propent = ents.Create( \"prop_physics\" )","\t","\tpropent:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\tpropent:SetPos( pos )","\tpropent:SetAngles( ang )","\tpropent:SetModel( model )","\tpropent:Spawn()","\t","\tfor I = 0,  propent:GetPhysicsObjectCount() - 1 do","\t\tlocal obj = propent:GetPhysicsObjectNum( I )","\t\tif obj:IsValid() then","\t\t\tobj:EnableMotion(not frozen)","\t\tend","\tend","\t","\tinstance.player:AddCleanup( \"props\", propent )","\t","\tgamemode.Call( \"PlayerSpawnedProp\", instance.player, model, propent )","\tFixInvalidPhysicsObject( propent )","","\tlocal prop = SF.Entities.Wrap( propent )","","\tpropdata.props[ prop ] = prop","\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\treturn prop","end",""],"class":"function","summary":"\nCreates a prop.","name":"props_library.create","library":"prop","private":false,"server":true,"description":"\nCreates a prop.","param":["pos","ang","model","frozen"]},"spawnRate":{"ret":"Number of props per second the user can spawn","comment":["--- Returns how many props per second the user can spawn","-- @server","-- @return Number of props per second the user can spawn"],"code":["function props_library.spawnRate ()","","\treturn SF.Props.burstrate:GetFloat() or 4","\t","end"],"class":"function","summary":"\nReturns how many props per second the user can spawn ","name":"props_library.spawnRate","library":"prop","private":false,"server":true,"description":"\nReturns how many props per second the user can spawn","param":[]}},"class":"library","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","code":["local props_library, props_library_metamethods = SF.Libraries.Register(\"prop\")","","local vunwrap = SF.UnwrapObject","","SF.Props = {}","SF.Props.defaultquota = CreateConVar( \"sf_props_defaultquota\", \"200\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn via Starfall scripts across all instances\" )","","SF.Props.personalquota = CreateConVar( \"sf_props_personalquota\", \"100\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn via Starfall scripts for a single instance\" )","","SF.Props.burstmax = CreateConVar( \"sf_props_burstmax\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of props allowed to spawn in a short interval of time via Starfall scripts for a single instance ( burst )\" )","\t","SF.Props.burstrate = CreateConVar( \"sf_props_burstrate\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The rate at which the burst regenerates per second.\" )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"prop.create\", \"Create prop\", \"Allows the user to create props\" )","end","","local insts = {}","local plyCount = setmetatable({}, {__mode=\"k\"})","","SF.Libraries.AddHook(\"initialize\",function(inst)","\tinst.data.props = {","\t\tprops = {},","\t\tburst = SF.Props.burstmax:GetInt() or 4","\t}","","\tinsts[inst] = true","\tplyCount[inst.player] = plyCount[inst.player] or 0","end)","","SF.Libraries.AddHook(\"deinitialize\", function(inst)","\tlocal props = inst.data.props.props","\tlocal prop = next(props)","\twhile prop do","\t\tlocal propent = SF.Entities.Unwrap(prop)","\t\tif IsValid(propent) then","\t\t\tpropent:Remove()","\t\tend","\t\tprops[prop] = nil","\t\tprop = next(props)","\tend","","\tinsts[inst]= nil","end)","","local function propOnDestroy(propent, propdata, ply)","\tplyCount[ply] = plyCount[ply] - 1","\tif not propdata.props then return end","\tlocal prop = SF.Entities.Wrap(propent)","\tif propdata.props[prop] then","\t\tpropdata.props[prop] = nil","\tend","end","",""],"fields":[],"name":"prop","client":true,"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","libtbl":"props_library","tables":[],"server":true},{"comment":["--- Updates/Checks burst constraints","-- @class function","-- @param instance Instance table for the burst values related to current SF Instance / Player","-- @param noupdate False if updating the burst should be done."],"code":["local function can_spawn(instance, noupdate)","\tif instance.data.props.burst > 0 then","\t\tif not noupdate then instance.data.props.burst = instance.data.props.burst - 1 end","\t\treturn true","\telse","\t\treturn false","\tend","end",""],"class":"function","classForced":true,"name":"can_spawn","private":false,"summary":"\nUpdates/Checks burst constraints ","description":"\nUpdates/Checks burst constraints","param":{"1":"instance","2":"noupdate","instance":"Instance table for the burst values related to current SF Instance / Player","noupdate":"False if updating the burst should be done."}},{"ret":"True/False depending on if limit has been reached for SF Props","comment":["--- Checks if the total number of props across all instances has reached the max limit.","-- @class function","-- @return True/False depending on if limit has been reached for SF Props"],"code":["local function max_reached()","\tlocal c = 0","\tfor _, v in pairs( plyCount ) do","\t\tc = c + v","\tend","\tif c >= SF.Props.defaultquota:GetInt() then return true else return false end","end",""],"class":"function","classForced":true,"name":"max_reached","private":false,"summary":"\nChecks if the total number of props across all instances has reached the max limit.","description":"\nChecks if the total number of props across all instances has reached the max limit.","param":[]},{"ret":"True/False depending on if the personal limit has been reached for SF Props","comment":["--- Checks if the users personal limit of props has been exhausted","-- @class function","-- @param i Instance to use, this will relate to the player in question","-- @return True/False depending on if the personal limit has been reached for SF Props"],"code":["local function personal_max_reached( i )","\treturn plyCount[i.player] >= SF.Props.personalquota:GetInt()","end","","local function regenerateBurst()","\tfor i, _ in pairs( insts ) do","\t\tif i.data.props.burst < SF.Props.burstmax:GetInt() or 4 then -- Should allow for dynamic changing of burst rate from the server.","\t\t\ti.data.props.burst = i.data.props.burst + 1","\t\tend","\tend","end","","timer.Create( \"SF_Prop_BurstCounter\", 1 / math.max( SF.Props.burstrate:GetFloat() or 4, 0.0001 ), 0, regenerateBurst )","","cvars.AddChangeCallback( \"sf_props_burstrate\", function( convar_name, value_old, value_new )","\ttimer.Adjust( \"SF_Prop_BurstCounter\", 1 / math.max( SF.Props.burstrate:GetFloat() or 4, 0.0001 ), 0, regenerateBurst )","end ) ",""],"class":"function","classForced":true,"name":"personal_max_reached","private":false,"summary":"\nChecks if the users personal limit of props has been exhausted ","description":"\nChecks if the users personal limit of props has been exhausted","param":{"1":"i","i":"Instance to use, this will relate to the player in question"}},{"ret":"The prop object","comment":["--- Creates a prop.","-- @server","-- @return The prop object"],"code":["function props_library.create ( pos, ang, model, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( model, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not can_spawn( instance ) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 )","\telseif max_reached() then return SF.throw( \"Can't spawn props, maximum limit of \" .. SF.Props.defaultquota:GetInt() .. \" has been reached\", 2 ) end","\tif not IsValid( instance.player ) then return end","\tif not gamemode.Call( \"PlayerSpawnProp\", instance.player, model ) then return end","","\tlocal propdata = instance.data.props","\tlocal propent = ents.Create( \"prop_physics\" )","\t","\tpropent:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\tpropent:SetPos( pos )","\tpropent:SetAngles( ang )","\tpropent:SetModel( model )","\tpropent:Spawn()","\t","\tfor I = 0,  propent:GetPhysicsObjectCount() - 1 do","\t\tlocal obj = propent:GetPhysicsObjectNum( I )","\t\tif obj:IsValid() then","\t\t\tobj:EnableMotion(not frozen)","\t\tend","\tend","\t","\tinstance.player:AddCleanup( \"props\", propent )","\t","\tgamemode.Call( \"PlayerSpawnedProp\", instance.player, model, propent )","\tFixInvalidPhysicsObject( propent )","","\tlocal prop = SF.Entities.Wrap( propent )","","\tpropdata.props[ prop ] = prop","\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\treturn prop","end",""],"class":"function","summary":"\nCreates a prop.","name":"props_library.create","library":"prop","private":false,"server":true,"description":"\nCreates a prop.","param":["pos","ang","model","frozen"]},{"ret":"The sent object","comment":["--- Creates a sent.","-- @server","-- @return The sent object"],"code":["function props_library.createSent ( pos, ang, class, frozen )","\t","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tSF.CheckType( class, \"string\" )","\tfrozen = frozen and true or false","","\tlocal pos = vunwrap( pos )","\tlocal ang = SF.Angles.Unwrap( ang )","","\tlocal instance = SF.instance","\tif not can_spawn( instance ) then return SF.throw( \"Can't spawn props that often\", 2 )","\telseif personal_max_reached( instance ) then return SF.throw( \"Can't spawn props, maximum personal limit of \" .. SF.Props.personalquota:GetInt() .. \" has been reached\", 2 )","\telseif max_reached() then return SF.throw( \"Can't spawn props, maximum limit of \" .. SF.Props.defaultquota:GetInt() .. \" has been reached\", 2 ) end","\tif not IsValid( instance.player ) then return end","\t","","\tlocal swep = list.Get( \"Weapon\" )[ class ]","\tlocal sent = list.Get( \"SpawnableEntities\" )[ class ]","","\tlocal propdata = instance.data.props","\tlocal entity","\tlocal hookcall","\t","\tif swep then","\t","\t\tif ( ( !swep.Spawnable && !instance.player:IsAdmin() ) || ","\t\t      ( swep.AdminOnly && !instance.player:IsAdmin() ) ) then return end","\t\tif ( !gamemode.Call( \"PlayerSpawnSWEP\", instance.player, class, swep ) ) then return end","","","\t\tentity = ents.Create( swep.ClassName )","\t\t","\t\thookcall = \"PlayerSpawnedSWEP\"","\t","\telseif sent then","\t","\t\tif ( sent.AdminOnly && !instance.player:IsAdmin() ) then return false end","\t\tif ( !gamemode.Call( \"PlayerSpawnSENT\", instance.player, class ) ) then return end","\t","\t\tentity = ents.Create( sent.ClassName )","\t","\t\thookcall = \"PlayerSpawnedSENT\"","\t","\tend","\t","\tif ( IsValid( entity ) ) then","\t\t","\t\tentity:CallOnRemove( \"starfall_prop_delete\", propOnDestroy, propdata, instance.player )","\t\tentity:SetPos( pos )","\t\tentity:SetAngles( ang )","\t\t","\t\tentity:Spawn()","\t\tentity:Activate()","\t\t","\t\tlocal phys = entity:GetPhysicsObject()","\t\tif phys:IsValid() then","\t\t\tphys:EnableMotion(not frozen)","\t\tend","\t\t","\t\tinstance.player:AddCleanup( \"props\", entity )","\t\tgamemode.Call( hookcall, instance.player, entity )","\t","\t\tlocal wrapped = SF.Entities.Wrap( entity )","","\t\tpropdata.props[ wrapped ] = wrapped","","\t\tplyCount[ instance.player ] = plyCount[ instance.player ] + 1","\t","\t\treturn wrapped","\tend","end",""],"class":"function","summary":"\nCreates a sent.","name":"props_library.createSent","library":"prop","private":false,"server":true,"description":"\nCreates a sent.","param":["pos","ang","class","frozen"]},{"ret":"True if user can spawn props, False if not.","comment":["--- Checks if a user can spawn anymore props.","-- @server","-- @return True if user can spawn props, False if not."],"code":["function props_library.canSpawn ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return false end","\t","\tlocal instance = SF.instance","\treturn not personal_max_reached( instance ) and not max_reached() and can_spawn( instance, true )","\t","end",""],"class":"function","summary":"\nChecks if a user can spawn anymore props.","name":"props_library.canSpawn","library":"prop","private":false,"server":true,"description":"\nChecks if a user can spawn anymore props.","param":[]},{"ret":"number of props able to be spawned","comment":["--- Checks how many props can be spawned","-- @server","-- @return number of props able to be spawned"],"code":["function props_library.propsLeft ()","","\tif not SF.Permissions.check( SF.instance.player,  nil, \"prop.create\" ) then return 0 end","\t","\tlocal instance = SF.instance","\treturn math.min( SF.Props.personalquota:GetInt() - plyCount[instance.player], instance.data.props.burst )","\t","end",""],"class":"function","summary":"\nChecks how many props can be spawned ","name":"props_library.propsLeft","library":"prop","private":false,"server":true,"description":"\nChecks how many props can be spawned","param":[]},{"ret":"Number of props per second the user can spawn","comment":["--- Returns how many props per second the user can spawn","-- @server","-- @return Number of props per second the user can spawn"],"code":["function props_library.spawnRate ()","","\treturn SF.Props.burstrate:GetFloat() or 4","\t","end"],"class":"function","summary":"\nReturns how many props per second the user can spawn ","name":"props_library.spawnRate","library":"prop","private":false,"server":true,"description":"\nReturns how many props per second the user can spawn","param":[]}],"tables":[],"description":"\nLibrary for creating and manipulating physics-less models AKA \"Props\".","summary":"\nLibrary for creating and manipulating physics-less models AKA \"Props\"."},"libs_cl/joystick.lua":{"libraries":{"1":"joystick","joystick":{"comment":["--- Joystick library.","-- @client"],"functions":{"1":"getAxis","2":"getButton","3":"getName","4":"getPov","5":"numAxes","6":"numButtons","7":"numJoysticks","8":"numPovs","numJoysticks":{"ret":"Number of joysticks","comment":["--- Gets the number of detected joysticks.","-- @return Number of joysticks"],"code":["function joystick_library.numJoysticks( )","\tif joystick then","\t\treturn joystick.count( )","\tend","end",""],"class":"function","name":"joystick_library.numJoysticks","summary":"\nGets the number of detected joysticks.","private":false,"library":"joystick","description":"\nGets the number of detected joysticks.","param":[]},"getButton":{"ret":"0 or 1","comment":["--- Returns if the button is pushed or not","-- @param enum Joystick number. Starts at 0","-- @param button Joystick button number. Starts at 0","-- @return 0 or 1"],"code":["function joystick_library.getButton( enum, button )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.button( enum, button )","\tend","end",""],"class":"function","name":"joystick_library.getButton","summary":"\nReturns if the button is pushed or not ","private":false,"library":"joystick","description":"\nReturns if the button is pushed or not","param":{"1":"enum","2":"button","button":"Joystick button number. Starts at 0","enum":"Joystick number. Starts at 0"}},"getAxis":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the axis data value.","-- @param enum Joystick number. Starts at 0","-- @param axis Joystick axis number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getAxis( enum, axis )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.axis( enum, axis )","\tend","end",""],"class":"function","name":"joystick_library.getAxis","summary":"\nGets the axis data value.","private":false,"library":"joystick","description":"\nGets the axis data value.","param":{"1":"enum","2":"axis","axis":"Joystick axis number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"numButtons":{"ret":"Number of buttons","comment":["--- Gets the number of detected buttons on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of buttons"],"code":["function joystick_library.numButtons( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 3 )","\tend","end",""],"class":"function","name":"joystick_library.numButtons","summary":"\nGets the number of detected buttons on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected buttons on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numAxes":{"ret":"Number of axes","comment":["--- Gets the number of detected axes on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of axes"],"code":["function joystick_library.numAxes( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 1 )","\tend","end",""],"class":"function","name":"joystick_library.numAxes","summary":"\nGets the number of detected axes on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected axes on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numPovs":{"ret":"Number of povs","comment":["--- Gets the number of detected povs on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of povs"],"code":["function joystick_library.numPovs( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 2 )","\tend","end",""],"class":"function","name":"joystick_library.numPovs","summary":"\nGets the number of detected povs on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected povs on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"getPov":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the pov data value.","-- @param enum Joystick number. Starts at 0","-- @param pov Joystick pov number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getPov( enum, pov )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.pov( enum, pov )","\tend","end",""],"class":"function","name":"joystick_library.getPov","summary":"\nGets the pov data value.","private":false,"library":"joystick","description":"\nGets the pov data value.","param":{"1":"enum","2":"pov","pov":"Joystick pov number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"getName":{"ret":"Name of the device","comment":["--- Gets the hardware name of the joystick","-- @param enum Joystick number. Starts at 0","-- @return Name of the device"],"code":["function joystick_library.getName( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.name( enum )","\tend","end",""],"class":"function","name":"joystick_library.getName","summary":"\nGets the hardware name of the joystick ","private":false,"library":"joystick","description":"\nGets the hardware name of the joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}}},"class":"library","summary":"\nJoystick library.","fields":[],"name":"joystick","client":true,"description":"\nJoystick library.","libtbl":"joystick_library","tables":[],"code":["local joystick_library, _ = SF.Libraries.Register(\"joystick\")","","","if file.Exists(\"lua/bin/gmcl_joystick_win32.dll\", \"GAME\") then","\trequire(\"joystick\")","end","","local next_updates = {}","","local function refresh( enum )","\tenum = math.Clamp( enum, 0, 12 )","\tlocal next_update = next_updates[ enum ] or 0","\tif CurTime()>next_update then","\t\tnext_updates[ enum ] = CurTime() + 0.0303","\t\tjoystick.refresh( enum )","\tend","end",""]}},"type":"file","name":"libs_cl/joystick.lua","functions":{"1":"joystick_library.getAxis","2":"joystick_library.getButton","3":"joystick_library.getName","4":"joystick_library.getPov","5":"joystick_library.numAxes","6":"joystick_library.numButtons","7":"joystick_library.numJoysticks","8":"joystick_library.numPovs","joystick_library.getName":{"ret":"Name of the device","comment":["--- Gets the hardware name of the joystick","-- @param enum Joystick number. Starts at 0","-- @return Name of the device"],"code":["function joystick_library.getName( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.name( enum )","\tend","end",""],"class":"function","name":"joystick_library.getName","summary":"\nGets the hardware name of the joystick ","private":false,"library":"joystick","description":"\nGets the hardware name of the joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"joystick_library.getPov":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the pov data value.","-- @param enum Joystick number. Starts at 0","-- @param pov Joystick pov number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getPov( enum, pov )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.pov( enum, pov )","\tend","end",""],"class":"function","name":"joystick_library.getPov","summary":"\nGets the pov data value.","private":false,"library":"joystick","description":"\nGets the pov data value.","param":{"1":"enum","2":"pov","pov":"Joystick pov number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"joystick_library.getAxis":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the axis data value.","-- @param enum Joystick number. Starts at 0","-- @param axis Joystick axis number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getAxis( enum, axis )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.axis( enum, axis )","\tend","end",""],"class":"function","name":"joystick_library.getAxis","summary":"\nGets the axis data value.","private":false,"library":"joystick","description":"\nGets the axis data value.","param":{"1":"enum","2":"axis","axis":"Joystick axis number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"joystick_library.numPovs":{"ret":"Number of povs","comment":["--- Gets the number of detected povs on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of povs"],"code":["function joystick_library.numPovs( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 2 )","\tend","end",""],"class":"function","name":"joystick_library.numPovs","summary":"\nGets the number of detected povs on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected povs on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"joystick_library.numButtons":{"ret":"Number of buttons","comment":["--- Gets the number of detected buttons on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of buttons"],"code":["function joystick_library.numButtons( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 3 )","\tend","end",""],"class":"function","name":"joystick_library.numButtons","summary":"\nGets the number of detected buttons on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected buttons on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"joystick_library.numAxes":{"ret":"Number of axes","comment":["--- Gets the number of detected axes on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of axes"],"code":["function joystick_library.numAxes( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 1 )","\tend","end",""],"class":"function","name":"joystick_library.numAxes","summary":"\nGets the number of detected axes on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected axes on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"joystick_library.numJoysticks":{"ret":"Number of joysticks","comment":["--- Gets the number of detected joysticks.","-- @return Number of joysticks"],"code":["function joystick_library.numJoysticks( )","\tif joystick then","\t\treturn joystick.count( )","\tend","end",""],"class":"function","name":"joystick_library.numJoysticks","summary":"\nGets the number of detected joysticks.","private":false,"library":"joystick","description":"\nGets the number of detected joysticks.","param":[]},"joystick_library.getButton":{"ret":"0 or 1","comment":["--- Returns if the button is pushed or not","-- @param enum Joystick number. Starts at 0","-- @param button Joystick button number. Starts at 0","-- @return 0 or 1"],"code":["function joystick_library.getButton( enum, button )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.button( enum, button )","\tend","end",""],"class":"function","name":"joystick_library.getButton","summary":"\nReturns if the button is pushed or not ","private":false,"library":"joystick","description":"\nReturns if the button is pushed or not","param":{"1":"enum","2":"button","button":"Joystick button number. Starts at 0","enum":"Joystick number. Starts at 0"}}},"doc":[{"comment":["--- Joystick library.","-- @client"],"functions":{"1":"getAxis","2":"getButton","3":"getName","4":"getPov","5":"numAxes","6":"numButtons","7":"numJoysticks","8":"numPovs","numJoysticks":{"ret":"Number of joysticks","comment":["--- Gets the number of detected joysticks.","-- @return Number of joysticks"],"code":["function joystick_library.numJoysticks( )","\tif joystick then","\t\treturn joystick.count( )","\tend","end",""],"class":"function","name":"joystick_library.numJoysticks","summary":"\nGets the number of detected joysticks.","private":false,"library":"joystick","description":"\nGets the number of detected joysticks.","param":[]},"getButton":{"ret":"0 or 1","comment":["--- Returns if the button is pushed or not","-- @param enum Joystick number. Starts at 0","-- @param button Joystick button number. Starts at 0","-- @return 0 or 1"],"code":["function joystick_library.getButton( enum, button )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.button( enum, button )","\tend","end",""],"class":"function","name":"joystick_library.getButton","summary":"\nReturns if the button is pushed or not ","private":false,"library":"joystick","description":"\nReturns if the button is pushed or not","param":{"1":"enum","2":"button","button":"Joystick button number. Starts at 0","enum":"Joystick number. Starts at 0"}},"getAxis":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the axis data value.","-- @param enum Joystick number. Starts at 0","-- @param axis Joystick axis number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getAxis( enum, axis )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.axis( enum, axis )","\tend","end",""],"class":"function","name":"joystick_library.getAxis","summary":"\nGets the axis data value.","private":false,"library":"joystick","description":"\nGets the axis data value.","param":{"1":"enum","2":"axis","axis":"Joystick axis number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"numButtons":{"ret":"Number of buttons","comment":["--- Gets the number of detected buttons on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of buttons"],"code":["function joystick_library.numButtons( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 3 )","\tend","end",""],"class":"function","name":"joystick_library.numButtons","summary":"\nGets the number of detected buttons on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected buttons on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numAxes":{"ret":"Number of axes","comment":["--- Gets the number of detected axes on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of axes"],"code":["function joystick_library.numAxes( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 1 )","\tend","end",""],"class":"function","name":"joystick_library.numAxes","summary":"\nGets the number of detected axes on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected axes on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"numPovs":{"ret":"Number of povs","comment":["--- Gets the number of detected povs on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of povs"],"code":["function joystick_library.numPovs( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 2 )","\tend","end",""],"class":"function","name":"joystick_library.numPovs","summary":"\nGets the number of detected povs on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected povs on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},"getPov":{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the pov data value.","-- @param enum Joystick number. Starts at 0","-- @param pov Joystick pov number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getPov( enum, pov )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.pov( enum, pov )","\tend","end",""],"class":"function","name":"joystick_library.getPov","summary":"\nGets the pov data value.","private":false,"library":"joystick","description":"\nGets the pov data value.","param":{"1":"enum","2":"pov","pov":"Joystick pov number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},"getName":{"ret":"Name of the device","comment":["--- Gets the hardware name of the joystick","-- @param enum Joystick number. Starts at 0","-- @return Name of the device"],"code":["function joystick_library.getName( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.name( enum )","\tend","end",""],"class":"function","name":"joystick_library.getName","summary":"\nGets the hardware name of the joystick ","private":false,"library":"joystick","description":"\nGets the hardware name of the joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}}},"class":"library","summary":"\nJoystick library.","fields":[],"name":"joystick","client":true,"description":"\nJoystick library.","libtbl":"joystick_library","tables":[],"code":["local joystick_library, _ = SF.Libraries.Register(\"joystick\")","","","if file.Exists(\"lua/bin/gmcl_joystick_win32.dll\", \"GAME\") then","\trequire(\"joystick\")","end","","local next_updates = {}","","local function refresh( enum )","\tenum = math.Clamp( enum, 0, 12 )","\tlocal next_update = next_updates[ enum ] or 0","\tif CurTime()>next_update then","\t\tnext_updates[ enum ] = CurTime() + 0.0303","\t\tjoystick.refresh( enum )","\tend","end",""]},{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the axis data value.","-- @param enum Joystick number. Starts at 0","-- @param axis Joystick axis number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getAxis( enum, axis )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.axis( enum, axis )","\tend","end",""],"class":"function","name":"joystick_library.getAxis","summary":"\nGets the axis data value.","private":false,"library":"joystick","description":"\nGets the axis data value.","param":{"1":"enum","2":"axis","axis":"Joystick axis number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},{"ret":"0 - 65535 where 32767 is the middle.","comment":["--- Gets the pov data value.","-- @param enum Joystick number. Starts at 0","-- @param pov Joystick pov number. Ranges from 0 to 7.","-- @return 0 - 65535 where 32767 is the middle."],"code":["function joystick_library.getPov( enum, pov )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.pov( enum, pov )","\tend","end",""],"class":"function","name":"joystick_library.getPov","summary":"\nGets the pov data value.","private":false,"library":"joystick","description":"\nGets the pov data value.","param":{"1":"enum","2":"pov","pov":"Joystick pov number. Ranges from 0 to 7.","enum":"Joystick number. Starts at 0"}},{"ret":"0 or 1","comment":["--- Returns if the button is pushed or not","-- @param enum Joystick number. Starts at 0","-- @param button Joystick button number. Starts at 0","-- @return 0 or 1"],"code":["function joystick_library.getButton( enum, button )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.button( enum, button )","\tend","end",""],"class":"function","name":"joystick_library.getButton","summary":"\nReturns if the button is pushed or not ","private":false,"library":"joystick","description":"\nReturns if the button is pushed or not","param":{"1":"enum","2":"button","button":"Joystick button number. Starts at 0","enum":"Joystick number. Starts at 0"}},{"ret":"Name of the device","comment":["--- Gets the hardware name of the joystick","-- @param enum Joystick number. Starts at 0","-- @return Name of the device"],"code":["function joystick_library.getName( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.name( enum )","\tend","end",""],"class":"function","name":"joystick_library.getName","summary":"\nGets the hardware name of the joystick ","private":false,"library":"joystick","description":"\nGets the hardware name of the joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},{"ret":"Number of joysticks","comment":["--- Gets the number of detected joysticks.","-- @return Number of joysticks"],"code":["function joystick_library.numJoysticks( )","\tif joystick then","\t\treturn joystick.count( )","\tend","end",""],"class":"function","name":"joystick_library.numJoysticks","summary":"\nGets the number of detected joysticks.","private":false,"library":"joystick","description":"\nGets the number of detected joysticks.","param":[]},{"ret":"Number of axes","comment":["--- Gets the number of detected axes on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of axes"],"code":["function joystick_library.numAxes( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 1 )","\tend","end",""],"class":"function","name":"joystick_library.numAxes","summary":"\nGets the number of detected axes on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected axes on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},{"ret":"Number of povs","comment":["--- Gets the number of detected povs on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of povs"],"code":["function joystick_library.numPovs( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 2 )","\tend","end",""],"class":"function","name":"joystick_library.numPovs","summary":"\nGets the number of detected povs on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected povs on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}},{"ret":"Number of buttons","comment":["--- Gets the number of detected buttons on a joystick","-- @param enum Joystick number. Starts at 0","-- @return Number of buttons"],"code":["function joystick_library.numButtons( enum )","\tif joystick then","\t\trefresh( enum )","\t\treturn joystick.count( enum, 3 )","\tend","end",""],"class":"function","name":"joystick_library.numButtons","summary":"\nGets the number of detected buttons on a joystick ","private":false,"library":"joystick","description":"\nGets the number of detected buttons on a joystick","param":{"1":"enum","enum":"Joystick number. Starts at 0"}}],"tables":[],"description":"\nJoystick library.","summary":"\nJoystick library."},"libs_sh/players.lua":{"libraries":[],"type":"file","name":"libs_sh/players.lua","functions":{"1":"player_metamethods:__tostring","2":"player_methods:getActiveWeapon","3":"player_methods:getAimVector","4":"player_methods:getArmor","5":"player_methods:getDeaths","6":"player_methods:getEyeTrace","7":"player_methods:getFOV","8":"player_methods:getFrags","9":"player_methods:getFriendStatus","10":"player_methods:getJumpPower","11":"player_methods:getMaxSpeed","12":"player_methods:getName","13":"player_methods:getPing","14":"player_methods:getRunSpeed","15":"player_methods:getShootPos","16":"player_methods:getSteamID","17":"player_methods:getSteamID64","18":"player_methods:getTeam","19":"player_methods:getTeamName","20":"player_methods:getUniqueID","21":"player_methods:getUserID","22":"player_methods:inVehicle","23":"player_methods:isAdmin","24":"player_methods:isAlive","25":"player_methods:isBot","26":"player_methods:isConnected","27":"player_methods:isCrouching","28":"player_methods:isFlashlightOn","29":"player_methods:isFrozen","30":"player_methods:isMuted","31":"player_methods:isNPC","32":"player_methods:isPlayer","33":"player_methods:isSuperAdmin","34":"player_methods:isUserGroup","35":"player_methods:keyDown","player_methods:getUniqueID":{"ret":"unique ID","comment":["--- Returns the player's unique ID","-- @shared","-- @return unique ID"],"code":["function player_methods:getUniqueID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:UniqueID()","end",""],"class":"function","summary":"\nReturns the player's unique ID ","classlib":"Player","name":"player_methods:getUniqueID","server":true,"private":false,"client":true,"description":"\nReturns the player's unique ID","param":[]},"player_methods:getShootPos":{"ret":"Shoot position","comment":["--- Returns the player's shoot position","-- @shared","-- @return Shoot position"],"code":["function player_methods:getShootPos ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and vwrap( ent:GetShootPos() )","end",""],"class":"function","summary":"\nReturns the player's shoot position ","classlib":"Player","name":"player_methods:getShootPos","server":true,"private":false,"client":true,"description":"\nReturns the player's shoot position","param":[]},"player_methods:getTeam":{"ret":"team","comment":["--- Returns the player's current team","-- @shared","-- @return team"],"code":["function player_methods:getTeam ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Team()","end",""],"class":"function","summary":"\nReturns the player's current team ","classlib":"Player","name":"player_methods:getTeam","server":true,"private":false,"client":true,"description":"\nReturns the player's current team","param":[]},"player_methods:getPing":{"ret":"ping","comment":["--- Returns the player's current ping","-- @shared","-- @return ping"],"code":["function player_methods:getPing ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Ping()","end",""],"class":"function","summary":"\nReturns the player's current ping ","classlib":"Player","name":"player_methods:getPing","server":true,"private":false,"client":true,"description":"\nReturns the player's current ping","param":[]},"player_methods:isAdmin":{"ret":"True if player is admin","comment":["--- Returns whether the player is an admin","-- @shared","-- @return True if player is admin"],"code":["function player_methods:isAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is an admin ","classlib":"Player","name":"player_methods:isAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an admin","param":[]},"player_methods:getArmor":{"ret":"Armor","comment":["--- Returns the players armor","-- @shared","-- @return Armor"],"code":["function player_methods:getArmor ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Armor()","end",""],"class":"function","summary":"\nReturns the players armor ","classlib":"Player","name":"player_methods:getArmor","server":true,"private":false,"client":true,"description":"\nReturns the players armor","param":[]},"player_methods:getJumpPower":{"ret":"Jump power","comment":["--- Returns the player's jump power","-- @shared","-- @return Jump power"],"code":["function player_methods:getJumpPower ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetJumpPower()","end",""],"class":"function","summary":"\nReturns the player's jump power ","classlib":"Player","name":"player_methods:getJumpPower","server":true,"private":false,"client":true,"description":"\nReturns the player's jump power","param":[]},"player_methods:isFrozen":{"ret":"True if player is frozen","comment":["--- Returns whether the player is frozen","-- @shared","-- @return True if player is frozen"],"code":["function player_methods:isFrozen( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsFrozen( )","end",""],"class":"function","summary":"\nReturns whether the player is frozen ","classlib":"Player","name":"player_methods:isFrozen","server":true,"private":false,"client":true,"description":"\nReturns whether the player is frozen","param":[]},"player_methods:isCrouching":{"ret":"True if player crouching","comment":["--- Returns whether the player is crouching","-- @shared","-- @return True if player crouching"],"code":["function player_methods:isCrouching ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Crouching()","end",""],"class":"function","summary":"\nReturns whether the player is crouching ","classlib":"Player","name":"player_methods:isCrouching","server":true,"private":false,"client":true,"description":"\nReturns whether the player is crouching","param":[]},"player_methods:isMuted":{"ret":"True if the player was muted","comment":["\t--- Returns whether the local player has muted the player","\t-- @return True if the player was muted"],"code":["\tfunction player_methods:isMuted( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent and ent:IsMuted( )","\tend","end"],"class":"function","name":"player_methods:isMuted","summary":"\nReturns whether the local player has muted the player ","private":false,"classlib":"Player","description":"\nReturns whether the local player has muted the player","param":[]},"player_methods:getUserID":{"ret":"user ID","comment":["--- Returns the player's user ID","-- @shared","-- @return user ID"],"code":["function player_methods:getUserID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:UserID()","end",""],"class":"function","summary":"\nReturns the player's user ID ","classlib":"Player","name":"player_methods:getUserID","server":true,"private":false,"client":true,"description":"\nReturns the player's user ID","param":[]},"player_methods:isUserGroup":{"ret":"True if player belongs to group","comment":["--- Returns whether the player belongs to a usergroup","-- @shared","-- @param group Group to check against","-- @return True if player belongs to group"],"code":["function player_methods:isUserGroup( group )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsUserGroup( group )","end",""],"class":"function","summary":"\nReturns whether the player belongs to a usergroup ","classlib":"Player","name":"player_methods:isUserGroup","server":true,"private":false,"client":true,"description":"\nReturns whether the player belongs to a usergroup","param":{"1":"group","group":"Group to check against"}},"player_methods:isFlashlightOn":{"ret":"True if player has flashlight on","comment":["--- Returns whether the player's flashlight is on","-- @shared","-- @return True if player has flashlight on"],"code":["function player_methods:isFlashlightOn( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:FlashlightIsOn()","end",""],"class":"function","summary":"\nReturns whether the player's flashlight is on ","classlib":"Player","name":"player_methods:isFlashlightOn","server":true,"private":false,"client":true,"description":"\nReturns whether the player's flashlight is on","param":[]},"player_methods:getDeaths":{"ret":"Amount of deaths","comment":["--- Returns the amount of deaths of the player","-- @shared","-- @return Amount of deaths"],"code":["function player_methods:getDeaths ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Deaths()","end",""],"class":"function","summary":"\nReturns the amount of deaths of the player ","classlib":"Player","name":"player_methods:getDeaths","server":true,"private":false,"client":true,"description":"\nReturns the amount of deaths of the player","param":[]},"player_methods:getAimVector":{"ret":"Aim vector","comment":["--- Returns the player's aim vector","-- @shared","-- @return Aim vector"],"code":["function player_methods:getAimVector ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and vwrap( ent:GetAimVector() )","end",""],"class":"function","summary":"\nReturns the player's aim vector ","classlib":"Player","name":"player_methods:getAimVector","server":true,"private":false,"client":true,"description":"\nReturns the player's aim vector","param":[]},"player_methods:isNPC":{"ret":"True if player is an NPC","comment":["--- Returns whether the player is an NPC","-- @shared","-- @return True if player is an NPC"],"code":["function player_methods:isNPC( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsNPC( )","end",""],"class":"function","summary":"\nReturns whether the player is an NPC ","classlib":"Player","name":"player_methods:isNPC","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an NPC","param":[]},"player_methods:getFOV":{"ret":"Field of view","comment":["--- Returns the player's field of view","-- @shared","-- @return Field of view"],"code":["function player_methods:getFOV ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetFOV()","end",""],"class":"function","summary":"\nReturns the player's field of view ","classlib":"Player","name":"player_methods:getFOV","server":true,"private":false,"client":true,"description":"\nReturns the player's field of view","param":[]},"player_methods:isConnected":{"ret":"True if player is connected","comment":["--- Returns whether the player is connected","-- @shared","-- @return True if player is connected"],"code":["function player_methods:isConnected( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsConnected( )","end",""],"class":"function","summary":"\nReturns whether the player is connected ","classlib":"Player","name":"player_methods:isConnected","server":true,"private":false,"client":true,"description":"\nReturns whether the player is connected","param":[]},"player_methods:getSteamID":{"ret":"steam ID","comment":["--- Returns the player's steam ID","-- @shared","-- @return steam ID"],"code":["function player_methods:getSteamID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:SteamID()","end",""],"class":"function","summary":"\nReturns the player's steam ID ","classlib":"Player","name":"player_methods:getSteamID","server":true,"private":false,"client":true,"description":"\nReturns the player's steam ID","param":[]},"player_methods:isPlayer":{"ret":"True if player is player","comment":["--- Returns whether the player is a player","-- @shared","-- @return True if player is player"],"code":["function player_methods:isPlayer( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsPlayer()","end",""],"class":"function","summary":"\nReturns whether the player is a player ","classlib":"Player","name":"player_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a player","param":[]},"player_methods:isBot":{"ret":"True if player is a bot","comment":["--- Returns whether the player is a bot","-- @shared","-- @return True if player is a bot"],"code":["function player_methods:isBot( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsBot( )","end",""],"class":"function","summary":"\nReturns whether the player is a bot ","classlib":"Player","name":"player_methods:isBot","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a bot","param":[]},"player_methods:getEyeTrace":{"ret":"table trace data","comment":["--- Returns a table with information of what the player is looking at","-- @shared","-- @return table trace data"],"code":["function player_methods:getEyeTrace ()","\tif not SF.Permissions.check( SF.instance.player, SF.UnwrapObject( self ), \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\treturn SF.Sanitize( SF.UnwrapObject( self ):GetEyeTrace() )","end",""],"class":"function","summary":"\nReturns a table with information of what the player is looking at ","classlib":"Player","name":"player_methods:getEyeTrace","server":true,"private":false,"client":true,"description":"\nReturns a table with information of what the player is looking at","param":[]},"player_methods:isAlive":{"ret":"True if player alive","comment":["--- Returns whether the player is alive","-- @shared","-- @return True if player alive"],"code":["function player_methods:isAlive ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Alive()","end",""],"class":"function","summary":"\nReturns whether the player is alive ","classlib":"Player","name":"player_methods:isAlive","server":true,"private":false,"client":true,"description":"\nReturns whether the player is alive","param":[]},"player_methods:isSuperAdmin":{"ret":"True if player is super admin","comment":["--- Returns whether the player is a super admin","-- @shared","-- @return True if player is super admin"],"code":["function player_methods:isSuperAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsSuperAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is a super admin ","classlib":"Player","name":"player_methods:isSuperAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a super admin","param":[]},"player_metamethods:__tostring":{"comment":["--- To string","-- @shared"],"code":["function player_metamethods:__tostring()","\tlocal ent = SF.Entities.Unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","","-- ------------------------------------------------------------------------- --"],"class":"function","summary":"\nTo string ","name":"player_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},"player_methods:getName":{"ret":"Name","comment":["--- Returns the player's name","-- @shared","-- @return Name"],"code":["function player_methods:getName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetName()","end",""],"class":"function","summary":"\nReturns the player's name ","classlib":"Player","name":"player_methods:getName","server":true,"private":false,"client":true,"description":"\nReturns the player's name","param":[]},"player_methods:getActiveWeapon":{"ret":"The weapon","comment":["--- Returns the name of the player's active weapon","-- @shared","-- @return The weapon"],"code":["function player_methods:getActiveWeapon ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and SF.WrapObject( ent:GetActiveWeapon() )","end",""],"class":"function","summary":"\nReturns the name of the player's active weapon ","classlib":"Player","name":"player_methods:getActiveWeapon","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's active weapon","param":[]},"player_methods:getTeamName":{"ret":"team name","comment":["--- Returns the name of the player's current team","-- @shared","-- @return team name"],"code":["function player_methods:getTeamName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and team.GetName(ent:Team())","end",""],"class":"function","summary":"\nReturns the name of the player's current team ","classlib":"Player","name":"player_methods:getTeamName","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's current team","param":[]},"player_methods:getFriendStatus":{"ret":"One of: \"friend\", \"blocked\", \"none\", \"requested\"","comment":["\t--- Returns the relationship of the player to the local client","\t-- @return One of: \"friend\", \"blocked\", \"none\", \"requested\""],"code":["\tfunction player_methods:getFriendStatus( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent and ent:GetFriendStatus( )","\tend","\t"],"class":"function","name":"player_methods:getFriendStatus","summary":"\nReturns the relationship of the player to the local client ","private":false,"classlib":"Player","description":"\nReturns the relationship of the player to the local client","param":[]},"player_methods:keyDown":{"ret":"table trace data","comment":["--- Returns whether or not the player is pushing the key.","-- @shared","-- @param key Key to check.","---IN_KEY.ALT1","---IN_KEY.ALT2","---IN_KEY.ATTACK","---IN_KEY.ATTACK2","---IN_KEY.BACK","---IN_KEY.DUCK","---IN_KEY.FORWARD","---IN_KEY.JUMP","---IN_KEY.LEFT","---IN_KEY.MOVELEFT","---IN_KEY.MOVERIGHT","---IN_KEY.RELOAD","---IN_KEY.RIGHT","---IN_KEY.SCORE","---IN_KEY.SPEED","---IN_KEY.USE","---IN_KEY.WALK","---IN_KEY.ZOOM","---IN_KEY.GRENADE1","---IN_KEY.GRENADE2","---IN_KEY.WEAPON1","---IN_KEY.WEAPON2","---IN_KEY.BULLRUSH","---IN_KEY.CANCEL","---IN_KEY.RUN","-- @return table trace data"],"code":["function player_methods:keyDown ( key )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( key, \"number\" )","\t","\tlocal ent = SF.Entities.Unwrap( self )","\tif not IsValid( ent ) then return false end","\t","\treturn ent:KeyDown( key )","end","","if CLIENT then"],"class":"function","summary":"\nReturns whether or not the player is pushing the key.","classlib":"Player","name":"player_methods:keyDown","server":true,"private":false,"client":true,"description":"\nReturns whether or not the player is pushing the key.","param":{"1":"key","key":"Key to check. \nIN_KEY.ALT1 \nIN_KEY.ALT2 \nIN_KEY.ATTACK \nIN_KEY.ATTACK2 \nIN_KEY.BACK \nIN_KEY.DUCK \nIN_KEY.FORWARD \nIN_KEY.JUMP \nIN_KEY.LEFT \nIN_KEY.MOVELEFT \nIN_KEY.MOVERIGHT \nIN_KEY.RELOAD \nIN_KEY.RIGHT \nIN_KEY.SCORE \nIN_KEY.SPEED \nIN_KEY.USE \nIN_KEY.WALK \nIN_KEY.ZOOM \nIN_KEY.GRENADE1 \nIN_KEY.GRENADE2 \nIN_KEY.WEAPON1 \nIN_KEY.WEAPON2 \nIN_KEY.BULLRUSH \nIN_KEY.CANCEL \nIN_KEY.RUN"}},"player_methods:getRunSpeed":{"ret":"Running speed","comment":["--- Returns the player's running speed","-- @shared","-- @return Running speed"],"code":["function player_methods:getRunSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetRunSpeed()","end",""],"class":"function","summary":"\nReturns the player's running speed ","classlib":"Player","name":"player_methods:getRunSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's running speed","param":[]},"player_methods:getSteamID64":{"ret":"community ID","comment":["--- Returns the player's community ID","-- @shared","-- @return community ID"],"code":["function player_methods:getSteamID64 ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:SteamID64( )","end",""],"class":"function","summary":"\nReturns the player's community ID ","classlib":"Player","name":"player_methods:getSteamID64","server":true,"private":false,"client":true,"description":"\nReturns the player's community ID","param":[]},"player_methods:getFrags":{"ret":"Amount of kills","comment":["--- Returns the amount of kills of the player","-- @shared","-- @return Amount of kills"],"code":["function player_methods:getFrags ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Frags()","end",""],"class":"function","summary":"\nReturns the amount of kills of the player ","classlib":"Player","name":"player_methods:getFrags","server":true,"private":false,"client":true,"description":"\nReturns the amount of kills of the player","param":[]},"player_methods:inVehicle":{"ret":"True if player in vehicle","comment":["--- Returns whether the player is in a vehicle","-- @shared","-- @return True if player in vehicle"],"code":["function player_methods:inVehicle( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:InVehicle()","end",""],"class":"function","summary":"\nReturns whether the player is in a vehicle ","classlib":"Player","name":"player_methods:inVehicle","server":true,"private":false,"client":true,"description":"\nReturns whether the player is in a vehicle","param":[]},"player_methods:getMaxSpeed":{"ret":"Maximum speed","comment":["--- Returns the player's maximum speed","-- @shared","-- @return Maximum speed"],"code":["function player_methods:getMaxSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetMaxSpeed()","end",""],"class":"function","summary":"\nReturns the player's maximum speed ","classlib":"Player","name":"player_methods:getMaxSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's maximum speed","param":[]}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Player functions.","-------------------------------------------------------------------------------"],"code":["","SF.Players = {}"],"summary":"\n \nPlayer functions.","description":"\n \nPlayer functions. \n","param":[]},{"comment":["--- Player type"],"code":["local player_methods, player_metamethods = SF.Typedef(\"Player\", SF.Entities.Metatable)","","local vwrap = SF.WrapObject","","SF.Players.Methods = player_methods","SF.Players.Metatable = player_metamethods",""],"typtbl":"player_methods","fields":[],"name":"Player","summary":"\nPlayer type ","description":"\nPlayer type","class":"class","methods":{"1":"getActiveWeapon","2":"getAimVector","3":"getArmor","4":"getDeaths","5":"getEyeTrace","6":"getFOV","7":"getFrags","8":"getFriendStatus","9":"getJumpPower","10":"getMaxSpeed","11":"getName","12":"getPing","13":"getRunSpeed","14":"getShootPos","15":"getSteamID","16":"getSteamID64","17":"getTeam","18":"getTeamName","19":"getUniqueID","20":"getUserID","21":"inVehicle","22":"isAdmin","23":"isAlive","24":"isBot","25":"isConnected","26":"isCrouching","27":"isFlashlightOn","28":"isFrozen","29":"isMuted","30":"isNPC","31":"isPlayer","32":"isSuperAdmin","33":"isUserGroup","34":"keyDown","isUserGroup":{"ret":"True if player belongs to group","comment":["--- Returns whether the player belongs to a usergroup","-- @shared","-- @param group Group to check against","-- @return True if player belongs to group"],"code":["function player_methods:isUserGroup( group )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsUserGroup( group )","end",""],"class":"function","summary":"\nReturns whether the player belongs to a usergroup ","classlib":"Player","name":"player_methods:isUserGroup","server":true,"private":false,"client":true,"description":"\nReturns whether the player belongs to a usergroup","param":{"1":"group","group":"Group to check against"}},"isBot":{"ret":"True if player is a bot","comment":["--- Returns whether the player is a bot","-- @shared","-- @return True if player is a bot"],"code":["function player_methods:isBot( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsBot( )","end",""],"class":"function","summary":"\nReturns whether the player is a bot ","classlib":"Player","name":"player_methods:isBot","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a bot","param":[]},"getJumpPower":{"ret":"Jump power","comment":["--- Returns the player's jump power","-- @shared","-- @return Jump power"],"code":["function player_methods:getJumpPower ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetJumpPower()","end",""],"class":"function","summary":"\nReturns the player's jump power ","classlib":"Player","name":"player_methods:getJumpPower","server":true,"private":false,"client":true,"description":"\nReturns the player's jump power","param":[]},"inVehicle":{"ret":"True if player in vehicle","comment":["--- Returns whether the player is in a vehicle","-- @shared","-- @return True if player in vehicle"],"code":["function player_methods:inVehicle( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:InVehicle()","end",""],"class":"function","summary":"\nReturns whether the player is in a vehicle ","classlib":"Player","name":"player_methods:inVehicle","server":true,"private":false,"client":true,"description":"\nReturns whether the player is in a vehicle","param":[]},"keyDown":{"ret":"table trace data","comment":["--- Returns whether or not the player is pushing the key.","-- @shared","-- @param key Key to check.","---IN_KEY.ALT1","---IN_KEY.ALT2","---IN_KEY.ATTACK","---IN_KEY.ATTACK2","---IN_KEY.BACK","---IN_KEY.DUCK","---IN_KEY.FORWARD","---IN_KEY.JUMP","---IN_KEY.LEFT","---IN_KEY.MOVELEFT","---IN_KEY.MOVERIGHT","---IN_KEY.RELOAD","---IN_KEY.RIGHT","---IN_KEY.SCORE","---IN_KEY.SPEED","---IN_KEY.USE","---IN_KEY.WALK","---IN_KEY.ZOOM","---IN_KEY.GRENADE1","---IN_KEY.GRENADE2","---IN_KEY.WEAPON1","---IN_KEY.WEAPON2","---IN_KEY.BULLRUSH","---IN_KEY.CANCEL","---IN_KEY.RUN","-- @return table trace data"],"code":["function player_methods:keyDown ( key )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( key, \"number\" )","\t","\tlocal ent = SF.Entities.Unwrap( self )","\tif not IsValid( ent ) then return false end","\t","\treturn ent:KeyDown( key )","end","","if CLIENT then"],"class":"function","summary":"\nReturns whether or not the player is pushing the key.","classlib":"Player","name":"player_methods:keyDown","server":true,"private":false,"client":true,"description":"\nReturns whether or not the player is pushing the key.","param":{"1":"key","key":"Key to check. \nIN_KEY.ALT1 \nIN_KEY.ALT2 \nIN_KEY.ATTACK \nIN_KEY.ATTACK2 \nIN_KEY.BACK \nIN_KEY.DUCK \nIN_KEY.FORWARD \nIN_KEY.JUMP \nIN_KEY.LEFT \nIN_KEY.MOVELEFT \nIN_KEY.MOVERIGHT \nIN_KEY.RELOAD \nIN_KEY.RIGHT \nIN_KEY.SCORE \nIN_KEY.SPEED \nIN_KEY.USE \nIN_KEY.WALK \nIN_KEY.ZOOM \nIN_KEY.GRENADE1 \nIN_KEY.GRENADE2 \nIN_KEY.WEAPON1 \nIN_KEY.WEAPON2 \nIN_KEY.BULLRUSH \nIN_KEY.CANCEL \nIN_KEY.RUN"}},"getFOV":{"ret":"Field of view","comment":["--- Returns the player's field of view","-- @shared","-- @return Field of view"],"code":["function player_methods:getFOV ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetFOV()","end",""],"class":"function","summary":"\nReturns the player's field of view ","classlib":"Player","name":"player_methods:getFOV","server":true,"private":false,"client":true,"description":"\nReturns the player's field of view","param":[]},"getShootPos":{"ret":"Shoot position","comment":["--- Returns the player's shoot position","-- @shared","-- @return Shoot position"],"code":["function player_methods:getShootPos ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and vwrap( ent:GetShootPos() )","end",""],"class":"function","summary":"\nReturns the player's shoot position ","classlib":"Player","name":"player_methods:getShootPos","server":true,"private":false,"client":true,"description":"\nReturns the player's shoot position","param":[]},"getTeam":{"ret":"team","comment":["--- Returns the player's current team","-- @shared","-- @return team"],"code":["function player_methods:getTeam ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Team()","end",""],"class":"function","summary":"\nReturns the player's current team ","classlib":"Player","name":"player_methods:getTeam","server":true,"private":false,"client":true,"description":"\nReturns the player's current team","param":[]},"getArmor":{"ret":"Armor","comment":["--- Returns the players armor","-- @shared","-- @return Armor"],"code":["function player_methods:getArmor ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Armor()","end",""],"class":"function","summary":"\nReturns the players armor ","classlib":"Player","name":"player_methods:getArmor","server":true,"private":false,"client":true,"description":"\nReturns the players armor","param":[]},"getSteamID":{"ret":"steam ID","comment":["--- Returns the player's steam ID","-- @shared","-- @return steam ID"],"code":["function player_methods:getSteamID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:SteamID()","end",""],"class":"function","summary":"\nReturns the player's steam ID ","classlib":"Player","name":"player_methods:getSteamID","server":true,"private":false,"client":true,"description":"\nReturns the player's steam ID","param":[]},"isConnected":{"ret":"True if player is connected","comment":["--- Returns whether the player is connected","-- @shared","-- @return True if player is connected"],"code":["function player_methods:isConnected( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsConnected( )","end",""],"class":"function","summary":"\nReturns whether the player is connected ","classlib":"Player","name":"player_methods:isConnected","server":true,"private":false,"client":true,"description":"\nReturns whether the player is connected","param":[]},"getUserID":{"ret":"user ID","comment":["--- Returns the player's user ID","-- @shared","-- @return user ID"],"code":["function player_methods:getUserID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:UserID()","end",""],"class":"function","summary":"\nReturns the player's user ID ","classlib":"Player","name":"player_methods:getUserID","server":true,"private":false,"client":true,"description":"\nReturns the player's user ID","param":[]},"getMaxSpeed":{"ret":"Maximum speed","comment":["--- Returns the player's maximum speed","-- @shared","-- @return Maximum speed"],"code":["function player_methods:getMaxSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetMaxSpeed()","end",""],"class":"function","summary":"\nReturns the player's maximum speed ","classlib":"Player","name":"player_methods:getMaxSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's maximum speed","param":[]},"getSteamID64":{"ret":"community ID","comment":["--- Returns the player's community ID","-- @shared","-- @return community ID"],"code":["function player_methods:getSteamID64 ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:SteamID64( )","end",""],"class":"function","summary":"\nReturns the player's community ID ","classlib":"Player","name":"player_methods:getSteamID64","server":true,"private":false,"client":true,"description":"\nReturns the player's community ID","param":[]},"getRunSpeed":{"ret":"Running speed","comment":["--- Returns the player's running speed","-- @shared","-- @return Running speed"],"code":["function player_methods:getRunSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetRunSpeed()","end",""],"class":"function","summary":"\nReturns the player's running speed ","classlib":"Player","name":"player_methods:getRunSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's running speed","param":[]},"getAimVector":{"ret":"Aim vector","comment":["--- Returns the player's aim vector","-- @shared","-- @return Aim vector"],"code":["function player_methods:getAimVector ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and vwrap( ent:GetAimVector() )","end",""],"class":"function","summary":"\nReturns the player's aim vector ","classlib":"Player","name":"player_methods:getAimVector","server":true,"private":false,"client":true,"description":"\nReturns the player's aim vector","param":[]},"getUniqueID":{"ret":"unique ID","comment":["--- Returns the player's unique ID","-- @shared","-- @return unique ID"],"code":["function player_methods:getUniqueID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:UniqueID()","end",""],"class":"function","summary":"\nReturns the player's unique ID ","classlib":"Player","name":"player_methods:getUniqueID","server":true,"private":false,"client":true,"description":"\nReturns the player's unique ID","param":[]},"getFriendStatus":{"ret":"One of: \"friend\", \"blocked\", \"none\", \"requested\"","comment":["\t--- Returns the relationship of the player to the local client","\t-- @return One of: \"friend\", \"blocked\", \"none\", \"requested\""],"code":["\tfunction player_methods:getFriendStatus( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent and ent:GetFriendStatus( )","\tend","\t"],"class":"function","name":"player_methods:getFriendStatus","summary":"\nReturns the relationship of the player to the local client ","private":false,"classlib":"Player","description":"\nReturns the relationship of the player to the local client","param":[]},"getFrags":{"ret":"Amount of kills","comment":["--- Returns the amount of kills of the player","-- @shared","-- @return Amount of kills"],"code":["function player_methods:getFrags ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Frags()","end",""],"class":"function","summary":"\nReturns the amount of kills of the player ","classlib":"Player","name":"player_methods:getFrags","server":true,"private":false,"client":true,"description":"\nReturns the amount of kills of the player","param":[]},"isPlayer":{"ret":"True if player is player","comment":["--- Returns whether the player is a player","-- @shared","-- @return True if player is player"],"code":["function player_methods:isPlayer( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsPlayer()","end",""],"class":"function","summary":"\nReturns whether the player is a player ","classlib":"Player","name":"player_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a player","param":[]},"getPing":{"ret":"ping","comment":["--- Returns the player's current ping","-- @shared","-- @return ping"],"code":["function player_methods:getPing ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Ping()","end",""],"class":"function","summary":"\nReturns the player's current ping ","classlib":"Player","name":"player_methods:getPing","server":true,"private":false,"client":true,"description":"\nReturns the player's current ping","param":[]},"isMuted":{"ret":"True if the player was muted","comment":["\t--- Returns whether the local player has muted the player","\t-- @return True if the player was muted"],"code":["\tfunction player_methods:isMuted( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent and ent:IsMuted( )","\tend","end"],"class":"function","name":"player_methods:isMuted","summary":"\nReturns whether the local player has muted the player ","private":false,"classlib":"Player","description":"\nReturns whether the local player has muted the player","param":[]},"isAlive":{"ret":"True if player alive","comment":["--- Returns whether the player is alive","-- @shared","-- @return True if player alive"],"code":["function player_methods:isAlive ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Alive()","end",""],"class":"function","summary":"\nReturns whether the player is alive ","classlib":"Player","name":"player_methods:isAlive","server":true,"private":false,"client":true,"description":"\nReturns whether the player is alive","param":[]},"isFlashlightOn":{"ret":"True if player has flashlight on","comment":["--- Returns whether the player's flashlight is on","-- @shared","-- @return True if player has flashlight on"],"code":["function player_methods:isFlashlightOn( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:FlashlightIsOn()","end",""],"class":"function","summary":"\nReturns whether the player's flashlight is on ","classlib":"Player","name":"player_methods:isFlashlightOn","server":true,"private":false,"client":true,"description":"\nReturns whether the player's flashlight is on","param":[]},"getName":{"ret":"Name","comment":["--- Returns the player's name","-- @shared","-- @return Name"],"code":["function player_methods:getName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetName()","end",""],"class":"function","summary":"\nReturns the player's name ","classlib":"Player","name":"player_methods:getName","server":true,"private":false,"client":true,"description":"\nReturns the player's name","param":[]},"isNPC":{"ret":"True if player is an NPC","comment":["--- Returns whether the player is an NPC","-- @shared","-- @return True if player is an NPC"],"code":["function player_methods:isNPC( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsNPC( )","end",""],"class":"function","summary":"\nReturns whether the player is an NPC ","classlib":"Player","name":"player_methods:isNPC","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an NPC","param":[]},"getEyeTrace":{"ret":"table trace data","comment":["--- Returns a table with information of what the player is looking at","-- @shared","-- @return table trace data"],"code":["function player_methods:getEyeTrace ()","\tif not SF.Permissions.check( SF.instance.player, SF.UnwrapObject( self ), \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\treturn SF.Sanitize( SF.UnwrapObject( self ):GetEyeTrace() )","end",""],"class":"function","summary":"\nReturns a table with information of what the player is looking at ","classlib":"Player","name":"player_methods:getEyeTrace","server":true,"private":false,"client":true,"description":"\nReturns a table with information of what the player is looking at","param":[]},"isAdmin":{"ret":"True if player is admin","comment":["--- Returns whether the player is an admin","-- @shared","-- @return True if player is admin"],"code":["function player_methods:isAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is an admin ","classlib":"Player","name":"player_methods:isAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an admin","param":[]},"isSuperAdmin":{"ret":"True if player is super admin","comment":["--- Returns whether the player is a super admin","-- @shared","-- @return True if player is super admin"],"code":["function player_methods:isSuperAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsSuperAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is a super admin ","classlib":"Player","name":"player_methods:isSuperAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a super admin","param":[]},"isCrouching":{"ret":"True if player crouching","comment":["--- Returns whether the player is crouching","-- @shared","-- @return True if player crouching"],"code":["function player_methods:isCrouching ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Crouching()","end",""],"class":"function","summary":"\nReturns whether the player is crouching ","classlib":"Player","name":"player_methods:isCrouching","server":true,"private":false,"client":true,"description":"\nReturns whether the player is crouching","param":[]},"getTeamName":{"ret":"team name","comment":["--- Returns the name of the player's current team","-- @shared","-- @return team name"],"code":["function player_methods:getTeamName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and team.GetName(ent:Team())","end",""],"class":"function","summary":"\nReturns the name of the player's current team ","classlib":"Player","name":"player_methods:getTeamName","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's current team","param":[]},"getDeaths":{"ret":"Amount of deaths","comment":["--- Returns the amount of deaths of the player","-- @shared","-- @return Amount of deaths"],"code":["function player_methods:getDeaths ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Deaths()","end",""],"class":"function","summary":"\nReturns the amount of deaths of the player ","classlib":"Player","name":"player_methods:getDeaths","server":true,"private":false,"client":true,"description":"\nReturns the amount of deaths of the player","param":[]},"getActiveWeapon":{"ret":"The weapon","comment":["--- Returns the name of the player's active weapon","-- @shared","-- @return The weapon"],"code":["function player_methods:getActiveWeapon ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and SF.WrapObject( ent:GetActiveWeapon() )","end",""],"class":"function","summary":"\nReturns the name of the player's active weapon ","classlib":"Player","name":"player_methods:getActiveWeapon","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's active weapon","param":[]},"isFrozen":{"ret":"True if player is frozen","comment":["--- Returns whether the player is frozen","-- @shared","-- @return True if player is frozen"],"code":["function player_methods:isFrozen( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsFrozen( )","end",""],"class":"function","summary":"\nReturns whether the player is frozen ","classlib":"Player","name":"player_methods:isFrozen","server":true,"private":false,"client":true,"description":"\nReturns whether the player is frozen","param":[]}}},{"comment":["--- Custom wrapper/unwrapper is necessary for player objects","-- wrapper"],"code":["local dsetmeta = debug.setmetatable","local function wrap( object )","\tobject = SF.Entities.Wrap( object )","\tdsetmeta( object, player_metamethods )","\treturn object","end","","SF.AddObjectWrapper( debug.getregistry().Player, player_metamethods, wrap )","","-- unwrapper","SF.AddObjectUnwrapper( player_metamethods, SF.Entities.Unwrap )",""],"summary":"\nCustom wrapper/unwrapper is necessary for player objects \nwrapper ","description":"\nCustom wrapper/unwrapper is necessary for player objects \nwrapper","param":[]},{"comment":["--- To string","-- @shared"],"code":["function player_metamethods:__tostring()","\tlocal ent = SF.Entities.Unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","","-- ------------------------------------------------------------------------- --"],"class":"function","summary":"\nTo string ","name":"player_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},{"ret":"True if player alive","comment":["--- Returns whether the player is alive","-- @shared","-- @return True if player alive"],"code":["function player_methods:isAlive ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Alive()","end",""],"class":"function","summary":"\nReturns whether the player is alive ","classlib":"Player","name":"player_methods:isAlive","server":true,"private":false,"client":true,"description":"\nReturns whether the player is alive","param":[]},{"ret":"Armor","comment":["--- Returns the players armor","-- @shared","-- @return Armor"],"code":["function player_methods:getArmor ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Armor()","end",""],"class":"function","summary":"\nReturns the players armor ","classlib":"Player","name":"player_methods:getArmor","server":true,"private":false,"client":true,"description":"\nReturns the players armor","param":[]},{"ret":"True if player crouching","comment":["--- Returns whether the player is crouching","-- @shared","-- @return True if player crouching"],"code":["function player_methods:isCrouching ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Crouching()","end",""],"class":"function","summary":"\nReturns whether the player is crouching ","classlib":"Player","name":"player_methods:isCrouching","server":true,"private":false,"client":true,"description":"\nReturns whether the player is crouching","param":[]},{"ret":"Amount of deaths","comment":["--- Returns the amount of deaths of the player","-- @shared","-- @return Amount of deaths"],"code":["function player_methods:getDeaths ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Deaths()","end",""],"class":"function","summary":"\nReturns the amount of deaths of the player ","classlib":"Player","name":"player_methods:getDeaths","server":true,"private":false,"client":true,"description":"\nReturns the amount of deaths of the player","param":[]},{"ret":"True if player has flashlight on","comment":["--- Returns whether the player's flashlight is on","-- @shared","-- @return True if player has flashlight on"],"code":["function player_methods:isFlashlightOn( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:FlashlightIsOn()","end",""],"class":"function","summary":"\nReturns whether the player's flashlight is on ","classlib":"Player","name":"player_methods:isFlashlightOn","server":true,"private":false,"client":true,"description":"\nReturns whether the player's flashlight is on","param":[]},{"ret":"Amount of kills","comment":["--- Returns the amount of kills of the player","-- @shared","-- @return Amount of kills"],"code":["function player_methods:getFrags ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Frags()","end",""],"class":"function","summary":"\nReturns the amount of kills of the player ","classlib":"Player","name":"player_methods:getFrags","server":true,"private":false,"client":true,"description":"\nReturns the amount of kills of the player","param":[]},{"ret":"The weapon","comment":["--- Returns the name of the player's active weapon","-- @shared","-- @return The weapon"],"code":["function player_methods:getActiveWeapon ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and SF.WrapObject( ent:GetActiveWeapon() )","end",""],"class":"function","summary":"\nReturns the name of the player's active weapon ","classlib":"Player","name":"player_methods:getActiveWeapon","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's active weapon","param":[]},{"ret":"Aim vector","comment":["--- Returns the player's aim vector","-- @shared","-- @return Aim vector"],"code":["function player_methods:getAimVector ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and vwrap( ent:GetAimVector() )","end",""],"class":"function","summary":"\nReturns the player's aim vector ","classlib":"Player","name":"player_methods:getAimVector","server":true,"private":false,"client":true,"description":"\nReturns the player's aim vector","param":[]},{"ret":"Field of view","comment":["--- Returns the player's field of view","-- @shared","-- @return Field of view"],"code":["function player_methods:getFOV ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetFOV()","end",""],"class":"function","summary":"\nReturns the player's field of view ","classlib":"Player","name":"player_methods:getFOV","server":true,"private":false,"client":true,"description":"\nReturns the player's field of view","param":[]},{"ret":"Jump power","comment":["--- Returns the player's jump power","-- @shared","-- @return Jump power"],"code":["function player_methods:getJumpPower ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetJumpPower()","end",""],"class":"function","summary":"\nReturns the player's jump power ","classlib":"Player","name":"player_methods:getJumpPower","server":true,"private":false,"client":true,"description":"\nReturns the player's jump power","param":[]},{"ret":"Maximum speed","comment":["--- Returns the player's maximum speed","-- @shared","-- @return Maximum speed"],"code":["function player_methods:getMaxSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetMaxSpeed()","end",""],"class":"function","summary":"\nReturns the player's maximum speed ","classlib":"Player","name":"player_methods:getMaxSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's maximum speed","param":[]},{"ret":"Name","comment":["--- Returns the player's name","-- @shared","-- @return Name"],"code":["function player_methods:getName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetName()","end",""],"class":"function","summary":"\nReturns the player's name ","classlib":"Player","name":"player_methods:getName","server":true,"private":false,"client":true,"description":"\nReturns the player's name","param":[]},{"ret":"Running speed","comment":["--- Returns the player's running speed","-- @shared","-- @return Running speed"],"code":["function player_methods:getRunSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetRunSpeed()","end",""],"class":"function","summary":"\nReturns the player's running speed ","classlib":"Player","name":"player_methods:getRunSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's running speed","param":[]},{"ret":"Shoot position","comment":["--- Returns the player's shoot position","-- @shared","-- @return Shoot position"],"code":["function player_methods:getShootPos ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and vwrap( ent:GetShootPos() )","end",""],"class":"function","summary":"\nReturns the player's shoot position ","classlib":"Player","name":"player_methods:getShootPos","server":true,"private":false,"client":true,"description":"\nReturns the player's shoot position","param":[]},{"ret":"True if player in vehicle","comment":["--- Returns whether the player is in a vehicle","-- @shared","-- @return True if player in vehicle"],"code":["function player_methods:inVehicle( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:InVehicle()","end",""],"class":"function","summary":"\nReturns whether the player is in a vehicle ","classlib":"Player","name":"player_methods:inVehicle","server":true,"private":false,"client":true,"description":"\nReturns whether the player is in a vehicle","param":[]},{"ret":"True if player is admin","comment":["--- Returns whether the player is an admin","-- @shared","-- @return True if player is admin"],"code":["function player_methods:isAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is an admin ","classlib":"Player","name":"player_methods:isAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an admin","param":[]},{"ret":"True if player is a bot","comment":["--- Returns whether the player is a bot","-- @shared","-- @return True if player is a bot"],"code":["function player_methods:isBot( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsBot( )","end",""],"class":"function","summary":"\nReturns whether the player is a bot ","classlib":"Player","name":"player_methods:isBot","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a bot","param":[]},{"ret":"True if player is connected","comment":["--- Returns whether the player is connected","-- @shared","-- @return True if player is connected"],"code":["function player_methods:isConnected( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsConnected( )","end",""],"class":"function","summary":"\nReturns whether the player is connected ","classlib":"Player","name":"player_methods:isConnected","server":true,"private":false,"client":true,"description":"\nReturns whether the player is connected","param":[]},{"ret":"True if player is frozen","comment":["--- Returns whether the player is frozen","-- @shared","-- @return True if player is frozen"],"code":["function player_methods:isFrozen( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsFrozen( )","end",""],"class":"function","summary":"\nReturns whether the player is frozen ","classlib":"Player","name":"player_methods:isFrozen","server":true,"private":false,"client":true,"description":"\nReturns whether the player is frozen","param":[]},{"ret":"True if player is an NPC","comment":["--- Returns whether the player is an NPC","-- @shared","-- @return True if player is an NPC"],"code":["function player_methods:isNPC( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsNPC( )","end",""],"class":"function","summary":"\nReturns whether the player is an NPC ","classlib":"Player","name":"player_methods:isNPC","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an NPC","param":[]},{"ret":"True if player is player","comment":["--- Returns whether the player is a player","-- @shared","-- @return True if player is player"],"code":["function player_methods:isPlayer( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsPlayer()","end",""],"class":"function","summary":"\nReturns whether the player is a player ","classlib":"Player","name":"player_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a player","param":[]},{"ret":"True if player is super admin","comment":["--- Returns whether the player is a super admin","-- @shared","-- @return True if player is super admin"],"code":["function player_methods:isSuperAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsSuperAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is a super admin ","classlib":"Player","name":"player_methods:isSuperAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a super admin","param":[]},{"ret":"True if player belongs to group","comment":["--- Returns whether the player belongs to a usergroup","-- @shared","-- @param group Group to check against","-- @return True if player belongs to group"],"code":["function player_methods:isUserGroup( group )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsUserGroup( group )","end",""],"class":"function","summary":"\nReturns whether the player belongs to a usergroup ","classlib":"Player","name":"player_methods:isUserGroup","server":true,"private":false,"client":true,"description":"\nReturns whether the player belongs to a usergroup","param":{"1":"group","group":"Group to check against"}},{"ret":"ping","comment":["--- Returns the player's current ping","-- @shared","-- @return ping"],"code":["function player_methods:getPing ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Ping()","end",""],"class":"function","summary":"\nReturns the player's current ping ","classlib":"Player","name":"player_methods:getPing","server":true,"private":false,"client":true,"description":"\nReturns the player's current ping","param":[]},{"ret":"steam ID","comment":["--- Returns the player's steam ID","-- @shared","-- @return steam ID"],"code":["function player_methods:getSteamID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:SteamID()","end",""],"class":"function","summary":"\nReturns the player's steam ID ","classlib":"Player","name":"player_methods:getSteamID","server":true,"private":false,"client":true,"description":"\nReturns the player's steam ID","param":[]},{"ret":"community ID","comment":["--- Returns the player's community ID","-- @shared","-- @return community ID"],"code":["function player_methods:getSteamID64 ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:SteamID64( )","end",""],"class":"function","summary":"\nReturns the player's community ID ","classlib":"Player","name":"player_methods:getSteamID64","server":true,"private":false,"client":true,"description":"\nReturns the player's community ID","param":[]},{"ret":"team","comment":["--- Returns the player's current team","-- @shared","-- @return team"],"code":["function player_methods:getTeam ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Team()","end",""],"class":"function","summary":"\nReturns the player's current team ","classlib":"Player","name":"player_methods:getTeam","server":true,"private":false,"client":true,"description":"\nReturns the player's current team","param":[]},{"ret":"team name","comment":["--- Returns the name of the player's current team","-- @shared","-- @return team name"],"code":["function player_methods:getTeamName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and team.GetName(ent:Team())","end",""],"class":"function","summary":"\nReturns the name of the player's current team ","classlib":"Player","name":"player_methods:getTeamName","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's current team","param":[]},{"ret":"unique ID","comment":["--- Returns the player's unique ID","-- @shared","-- @return unique ID"],"code":["function player_methods:getUniqueID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:UniqueID()","end",""],"class":"function","summary":"\nReturns the player's unique ID ","classlib":"Player","name":"player_methods:getUniqueID","server":true,"private":false,"client":true,"description":"\nReturns the player's unique ID","param":[]},{"ret":"user ID","comment":["--- Returns the player's user ID","-- @shared","-- @return user ID"],"code":["function player_methods:getUserID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:UserID()","end",""],"class":"function","summary":"\nReturns the player's user ID ","classlib":"Player","name":"player_methods:getUserID","server":true,"private":false,"client":true,"description":"\nReturns the player's user ID","param":[]},{"ret":"table trace data","comment":["--- Returns a table with information of what the player is looking at","-- @shared","-- @return table trace data"],"code":["function player_methods:getEyeTrace ()","\tif not SF.Permissions.check( SF.instance.player, SF.UnwrapObject( self ), \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\treturn SF.Sanitize( SF.UnwrapObject( self ):GetEyeTrace() )","end",""],"class":"function","summary":"\nReturns a table with information of what the player is looking at ","classlib":"Player","name":"player_methods:getEyeTrace","server":true,"private":false,"client":true,"description":"\nReturns a table with information of what the player is looking at","param":[]},{"ret":"table trace data","comment":["--- Returns whether or not the player is pushing the key.","-- @shared","-- @param key Key to check.","---IN_KEY.ALT1","---IN_KEY.ALT2","---IN_KEY.ATTACK","---IN_KEY.ATTACK2","---IN_KEY.BACK","---IN_KEY.DUCK","---IN_KEY.FORWARD","---IN_KEY.JUMP","---IN_KEY.LEFT","---IN_KEY.MOVELEFT","---IN_KEY.MOVERIGHT","---IN_KEY.RELOAD","---IN_KEY.RIGHT","---IN_KEY.SCORE","---IN_KEY.SPEED","---IN_KEY.USE","---IN_KEY.WALK","---IN_KEY.ZOOM","---IN_KEY.GRENADE1","---IN_KEY.GRENADE2","---IN_KEY.WEAPON1","---IN_KEY.WEAPON2","---IN_KEY.BULLRUSH","---IN_KEY.CANCEL","---IN_KEY.RUN","-- @return table trace data"],"code":["function player_methods:keyDown ( key )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( key, \"number\" )","\t","\tlocal ent = SF.Entities.Unwrap( self )","\tif not IsValid( ent ) then return false end","\t","\treturn ent:KeyDown( key )","end","","if CLIENT then"],"class":"function","summary":"\nReturns whether or not the player is pushing the key.","classlib":"Player","name":"player_methods:keyDown","server":true,"private":false,"client":true,"description":"\nReturns whether or not the player is pushing the key.","param":{"1":"key","key":"Key to check. \nIN_KEY.ALT1 \nIN_KEY.ALT2 \nIN_KEY.ATTACK \nIN_KEY.ATTACK2 \nIN_KEY.BACK \nIN_KEY.DUCK \nIN_KEY.FORWARD \nIN_KEY.JUMP \nIN_KEY.LEFT \nIN_KEY.MOVELEFT \nIN_KEY.MOVERIGHT \nIN_KEY.RELOAD \nIN_KEY.RIGHT \nIN_KEY.SCORE \nIN_KEY.SPEED \nIN_KEY.USE \nIN_KEY.WALK \nIN_KEY.ZOOM \nIN_KEY.GRENADE1 \nIN_KEY.GRENADE2 \nIN_KEY.WEAPON1 \nIN_KEY.WEAPON2 \nIN_KEY.BULLRUSH \nIN_KEY.CANCEL \nIN_KEY.RUN"}},{"ret":"One of: \"friend\", \"blocked\", \"none\", \"requested\"","comment":["\t--- Returns the relationship of the player to the local client","\t-- @return One of: \"friend\", \"blocked\", \"none\", \"requested\""],"code":["\tfunction player_methods:getFriendStatus( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent and ent:GetFriendStatus( )","\tend","\t"],"class":"function","name":"player_methods:getFriendStatus","summary":"\nReturns the relationship of the player to the local client ","private":false,"classlib":"Player","description":"\nReturns the relationship of the player to the local client","param":[]},{"ret":"True if the player was muted","comment":["\t--- Returns whether the local player has muted the player","\t-- @return True if the player was muted"],"code":["\tfunction player_methods:isMuted( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent and ent:IsMuted( )","\tend","end"],"class":"function","name":"player_methods:isMuted","summary":"\nReturns whether the local player has muted the player ","private":false,"classlib":"Player","description":"\nReturns whether the local player has muted the player","param":[]}],"tables":[],"description":"\n \nPlayer functions. \n","summary":"\n \nPlayer functions."},"libs_sh/file.lua":{"libraries":{"1":"file","file":{"comment":["--- File functions. Allows modification of files.","-- @shared"],"functions":{"1":"append","2":"createDir","3":"delete","4":"exists","5":"read","6":"write","read":{"ret":["Contents, or nil if error","Error message if applicable"],"comment":["--- Reads a file from path","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return Contents, or nil if error","-- @return Error message if applicable"],"code":["function file_library.read ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tlocal contents = file.Read( \"sf_filedata/\" .. path, \"DATA\" )","\tif contents then return contents else SF.throw( \"file not found\", 2 ) return end","end",""],"class":"function","name":"file_library.read","summary":"\nReads a file from path ","private":false,"library":"file","description":"\nReads a file from path","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"write":{"ret":["True if OK, nil if error","Error message if applicable"],"comment":["--- Writes to a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if OK, nil if error","-- @return Error message if applicable"],"code":["function file_library.write ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.Write( \"sf_filedata/\" .. path, data )","\treturn true","end",""],"class":"function","name":"file_library.write","summary":"\nWrites to a file ","private":false,"library":"file","description":"\nWrites to a file","param":{"1":"path","2":"data","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"append":{"ret":"Error message if applicable","comment":["--- Appends a string to the end of a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @param data String that will be appended to the file.","-- @return Error message if applicable"],"code":["function file_library.append ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.Append( \"sf_filedata/\" .. path, data )","\treturn true","end",""],"class":"function","name":"file_library.append","summary":"\nAppends a string to the end of a file ","private":false,"library":"file","description":"\nAppends a string to the end of a file","param":{"1":"path","2":"data","data":"String that will be appended to the file.","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"createDir":{"comment":["--- Creates a directory","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'"],"code":["function file_library.createDir ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.CreateDir( \"sf_filedata/\" .. path )","end"],"class":"function","name":"file_library.createDir","summary":"\nCreates a directory ","private":false,"library":"file","description":"\nCreates a directory","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"delete":{"ret":["True if successful, nil if error","Error message if applicable"],"comment":["--- Deletes a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if successful, nil if error","-- @return Error message if applicable"],"code":["function file_library.delete ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tif not file.Exists( \"sf_filedata/\" .. path, \"DATA\" ) then SF.throw( \"file not found\", 2 ) return end","\tfile.Delete( path )","\treturn true","end",""],"class":"function","name":"file_library.delete","summary":"\nDeletes a file ","private":false,"library":"file","description":"\nDeletes a file","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"exists":{"ret":["True if exists, false if not, nil if error","Error message if applicable"],"comment":["--- Checks if a file exists","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if exists, false if not, nil if error","-- @return Error message if applicable"],"code":["function file_library.exists ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Exists( \"sf_filedata/\" .. path, \"DATA\" )","end",""],"class":"function","name":"file_library.exists","summary":"\nChecks if a file exists ","private":false,"library":"file","description":"\nChecks if a file exists","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}}},"class":"library","summary":"\nFile functions.","code":["local file_library, _ = SF.Libraries.Register( \"file\" )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"file.read\", \"Read files\", \"Allows the user to read files from data/sf_scriptdata directory\" )","\tP.registerPrivilege( \"file.write\", \"Write files\", \"Allows the user to write files to data/sf_scriptdata directory\" )","\tP.registerPrivilege( \"file.exists\", \"File existence check\", \"Allows the user to determine whether a file in data/sf_scriptdata exists\" )","end","","file.CreateDir( \"sf_filedata/\" )",""],"fields":[],"name":"file","client":true,"description":"\nFile functions. Allows modification of files.","libtbl":"file_library","tables":[],"server":true}},"type":"file","name":"libs_sh/file.lua","functions":{"1":"file_library.append","2":"file_library.createDir","3":"file_library.delete","4":"file_library.exists","5":"file_library.read","6":"file_library.write","file_library.write":{"ret":["True if OK, nil if error","Error message if applicable"],"comment":["--- Writes to a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if OK, nil if error","-- @return Error message if applicable"],"code":["function file_library.write ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.Write( \"sf_filedata/\" .. path, data )","\treturn true","end",""],"class":"function","name":"file_library.write","summary":"\nWrites to a file ","private":false,"library":"file","description":"\nWrites to a file","param":{"1":"path","2":"data","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.exists":{"ret":["True if exists, false if not, nil if error","Error message if applicable"],"comment":["--- Checks if a file exists","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if exists, false if not, nil if error","-- @return Error message if applicable"],"code":["function file_library.exists ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Exists( \"sf_filedata/\" .. path, \"DATA\" )","end",""],"class":"function","name":"file_library.exists","summary":"\nChecks if a file exists ","private":false,"library":"file","description":"\nChecks if a file exists","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.append":{"ret":"Error message if applicable","comment":["--- Appends a string to the end of a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @param data String that will be appended to the file.","-- @return Error message if applicable"],"code":["function file_library.append ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.Append( \"sf_filedata/\" .. path, data )","\treturn true","end",""],"class":"function","name":"file_library.append","summary":"\nAppends a string to the end of a file ","private":false,"library":"file","description":"\nAppends a string to the end of a file","param":{"1":"path","2":"data","data":"String that will be appended to the file.","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.read":{"ret":["Contents, or nil if error","Error message if applicable"],"comment":["--- Reads a file from path","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return Contents, or nil if error","-- @return Error message if applicable"],"code":["function file_library.read ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tlocal contents = file.Read( \"sf_filedata/\" .. path, \"DATA\" )","\tif contents then return contents else SF.throw( \"file not found\", 2 ) return end","end",""],"class":"function","name":"file_library.read","summary":"\nReads a file from path ","private":false,"library":"file","description":"\nReads a file from path","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.createDir":{"comment":["--- Creates a directory","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'"],"code":["function file_library.createDir ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.CreateDir( \"sf_filedata/\" .. path )","end"],"class":"function","name":"file_library.createDir","summary":"\nCreates a directory ","private":false,"library":"file","description":"\nCreates a directory","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"file_library.delete":{"ret":["True if successful, nil if error","Error message if applicable"],"comment":["--- Deletes a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if successful, nil if error","-- @return Error message if applicable"],"code":["function file_library.delete ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tif not file.Exists( \"sf_filedata/\" .. path, \"DATA\" ) then SF.throw( \"file not found\", 2 ) return end","\tfile.Delete( path )","\treturn true","end",""],"class":"function","name":"file_library.delete","summary":"\nDeletes a file ","private":false,"library":"file","description":"\nDeletes a file","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}}},"doc":[{"summary":"\n \nFile functions \n ","description":"\n \nFile functions \n","comment":["-------------------------------------------------------------------------------","-- File functions","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- File functions. Allows modification of files.","-- @shared"],"functions":{"1":"append","2":"createDir","3":"delete","4":"exists","5":"read","6":"write","read":{"ret":["Contents, or nil if error","Error message if applicable"],"comment":["--- Reads a file from path","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return Contents, or nil if error","-- @return Error message if applicable"],"code":["function file_library.read ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tlocal contents = file.Read( \"sf_filedata/\" .. path, \"DATA\" )","\tif contents then return contents else SF.throw( \"file not found\", 2 ) return end","end",""],"class":"function","name":"file_library.read","summary":"\nReads a file from path ","private":false,"library":"file","description":"\nReads a file from path","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"write":{"ret":["True if OK, nil if error","Error message if applicable"],"comment":["--- Writes to a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if OK, nil if error","-- @return Error message if applicable"],"code":["function file_library.write ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.Write( \"sf_filedata/\" .. path, data )","\treturn true","end",""],"class":"function","name":"file_library.write","summary":"\nWrites to a file ","private":false,"library":"file","description":"\nWrites to a file","param":{"1":"path","2":"data","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"append":{"ret":"Error message if applicable","comment":["--- Appends a string to the end of a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @param data String that will be appended to the file.","-- @return Error message if applicable"],"code":["function file_library.append ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.Append( \"sf_filedata/\" .. path, data )","\treturn true","end",""],"class":"function","name":"file_library.append","summary":"\nAppends a string to the end of a file ","private":false,"library":"file","description":"\nAppends a string to the end of a file","param":{"1":"path","2":"data","data":"String that will be appended to the file.","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"createDir":{"comment":["--- Creates a directory","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'"],"code":["function file_library.createDir ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.CreateDir( \"sf_filedata/\" .. path )","end"],"class":"function","name":"file_library.createDir","summary":"\nCreates a directory ","private":false,"library":"file","description":"\nCreates a directory","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"delete":{"ret":["True if successful, nil if error","Error message if applicable"],"comment":["--- Deletes a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if successful, nil if error","-- @return Error message if applicable"],"code":["function file_library.delete ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tif not file.Exists( \"sf_filedata/\" .. path, \"DATA\" ) then SF.throw( \"file not found\", 2 ) return end","\tfile.Delete( path )","\treturn true","end",""],"class":"function","name":"file_library.delete","summary":"\nDeletes a file ","private":false,"library":"file","description":"\nDeletes a file","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},"exists":{"ret":["True if exists, false if not, nil if error","Error message if applicable"],"comment":["--- Checks if a file exists","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if exists, false if not, nil if error","-- @return Error message if applicable"],"code":["function file_library.exists ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Exists( \"sf_filedata/\" .. path, \"DATA\" )","end",""],"class":"function","name":"file_library.exists","summary":"\nChecks if a file exists ","private":false,"library":"file","description":"\nChecks if a file exists","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}}},"class":"library","summary":"\nFile functions.","code":["local file_library, _ = SF.Libraries.Register( \"file\" )","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"file.read\", \"Read files\", \"Allows the user to read files from data/sf_scriptdata directory\" )","\tP.registerPrivilege( \"file.write\", \"Write files\", \"Allows the user to write files to data/sf_scriptdata directory\" )","\tP.registerPrivilege( \"file.exists\", \"File existence check\", \"Allows the user to determine whether a file in data/sf_scriptdata exists\" )","end","","file.CreateDir( \"sf_filedata/\" )",""],"fields":[],"name":"file","client":true,"description":"\nFile functions. Allows modification of files.","libtbl":"file_library","tables":[],"server":true},{"ret":["Contents, or nil if error","Error message if applicable"],"comment":["--- Reads a file from path","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return Contents, or nil if error","-- @return Error message if applicable"],"code":["function file_library.read ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.read\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tlocal contents = file.Read( \"sf_filedata/\" .. path, \"DATA\" )","\tif contents then return contents else SF.throw( \"file not found\", 2 ) return end","end",""],"class":"function","name":"file_library.read","summary":"\nReads a file from path ","private":false,"library":"file","description":"\nReads a file from path","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"ret":["True if OK, nil if error","Error message if applicable"],"comment":["--- Writes to a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if OK, nil if error","-- @return Error message if applicable"],"code":["function file_library.write ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.Write( \"sf_filedata/\" .. path, data )","\treturn true","end",""],"class":"function","name":"file_library.write","summary":"\nWrites to a file ","private":false,"library":"file","description":"\nWrites to a file","param":{"1":"path","2":"data","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"ret":"Error message if applicable","comment":["--- Appends a string to the end of a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @param data String that will be appended to the file.","-- @return Error message if applicable"],"code":["function file_library.append ( path, data )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tSF.CheckType( data, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.Append( \"sf_filedata/\" .. path, data )","\treturn true","end",""],"class":"function","name":"file_library.append","summary":"\nAppends a string to the end of a file ","private":false,"library":"file","description":"\nAppends a string to the end of a file","param":{"1":"path","2":"data","data":"String that will be appended to the file.","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"ret":["True if exists, false if not, nil if error","Error message if applicable"],"comment":["--- Checks if a file exists","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if exists, false if not, nil if error","-- @return Error message if applicable"],"code":["function file_library.exists ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.exists\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\treturn file.Exists( \"sf_filedata/\" .. path, \"DATA\" )","end",""],"class":"function","name":"file_library.exists","summary":"\nChecks if a file exists ","private":false,"library":"file","description":"\nChecks if a file exists","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"ret":["True if successful, nil if error","Error message if applicable"],"comment":["--- Deletes a file","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'","-- @return True if successful, nil if error","-- @return Error message if applicable"],"code":["function file_library.delete ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tif not file.Exists( \"sf_filedata/\" .. path, \"DATA\" ) then SF.throw( \"file not found\", 2 ) return end","\tfile.Delete( path )","\treturn true","end",""],"class":"function","name":"file_library.delete","summary":"\nDeletes a file ","private":false,"library":"file","description":"\nDeletes a file","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}},{"comment":["--- Creates a directory","-- @param path Filepath relative to data/sf_filedata/. Cannot contain '..'"],"code":["function file_library.createDir ( path )","\tif not SF.Permissions.check( SF.instance.player, path, \"file.write\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( path, \"string\" )","\tif path:find( \"..\", 1, true ) then SF.throw( \"path contains '..'\", 2 ) return end","\tfile.CreateDir( \"sf_filedata/\" .. path )","end"],"class":"function","name":"file_library.createDir","summary":"\nCreates a directory ","private":false,"library":"file","description":"\nCreates a directory","param":{"1":"path","path":"Filepath relative to data/sf_filedata/. Cannot contain '..'"}}],"tables":[],"description":"\n \nFile functions \n","summary":"\n \nFile functions \n "},"libs_sh/weapons.lua":{"libraries":[],"type":"file","name":"libs_sh/weapons.lua","functions":{"1":"weapon_metamethods:__tostring","2":"weapon_methods:clip1","3":"weapon_methods:clip2","4":"weapon_methods:getActivity","5":"weapon_methods:getHoldType","6":"weapon_methods:getNextPrimaryFire","7":"weapon_methods:getNextSecondaryFire","8":"weapon_methods:getPrimaryAmmoType","9":"weapon_methods:getPrintName","10":"weapon_methods:getSecondaryAmmoType","11":"weapon_methods:isCarriedByLocalPlayer","12":"weapon_methods:isWeaponVisible","13":"weapon_methods:lastShootTime","weapon_methods:getActivity":{"ret":"number Current activity","comment":["--- Returns the sequence enumeration number that the weapon is playing. Must be used on a view model. ","-- @shared","-- @return number Current activity"],"code":["function weapon_methods:getActivity ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetActivity()","end",""],"class":"function","summary":"\nReturns the sequence enumeration number that the weapon is playing.","classlib":"Weapon","name":"weapon_methods:getActivity","server":true,"private":false,"client":true,"description":"\nReturns the sequence enumeration number that the weapon is playing. Must be used on a view model.","param":[]},"weapon_metamethods:__tostring":{"comment":["--- To string","-- @shared"],"code":["function weapon_metamethods:__tostring()","\tlocal ent = SF.Entities.Unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","","-- ------------------------------------------------------------------------- --"],"class":"function","summary":"\nTo string ","name":"weapon_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},"weapon_methods:getPrimaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the primary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getPrimaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetPrimaryAmmoType()","end",""],"class":"function","summary":"\nGets the primary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getPrimaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the primary ammo type of the given weapon.","param":[]},"weapon_methods:isCarriedByLocalPlayer":{"ret":"whether or not the weapon is carried by the local player","comment":["\t--- Returns if the weapon is carried by the local player. ","\t-- @client","\t-- @return whether or not the weapon is carried by the local player"],"code":["\tfunction weapon_methods:isCarriedByLocalPlayer ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:IsCarriedByLocalPlayer()","\tend","end"],"class":"function","summary":"\nReturns if the weapon is carried by the local player.","name":"weapon_methods:isCarriedByLocalPlayer","classlib":"Weapon","private":false,"client":true,"description":"\nReturns if the weapon is carried by the local player.","param":[]},"weapon_methods:getNextPrimaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can primary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextPrimaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextPrimaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can primary fire.","classlib":"Weapon","name":"weapon_methods:getNextPrimaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can primary fire.","param":[]},"weapon_methods:isWeaponVisible":{"ret":"Whether the weapon is visble or not","comment":["--- Returns whether the weapon is visible","-- @shared","-- @return Whether the weapon is visble or not"],"code":["function weapon_methods:isWeaponVisible ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:IsWeaponVisible()","end",""],"class":"function","summary":"\nReturns whether the weapon is visible ","classlib":"Weapon","name":"weapon_methods:isWeaponVisible","server":true,"private":false,"client":true,"description":"\nReturns whether the weapon is visible","param":[]},"weapon_methods:getHoldType":{"ret":"string Holdtype","comment":["--- Returns the hold type of the weapon. ","-- @shared","-- @return string Holdtype"],"code":["function weapon_methods:getHoldType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetHoldType()","end",""],"class":"function","summary":"\nReturns the hold type of the weapon.","classlib":"Weapon","name":"weapon_methods:getHoldType","server":true,"private":false,"client":true,"description":"\nReturns the hold type of the weapon.","param":[]},"weapon_methods:getPrintName":{"ret":"string Display name of weapon","comment":["\t--- Gets Display name of weapon","\t-- @client","\t-- @return string Display name of weapon"],"code":["\tfunction weapon_methods:getPrintName ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:GetPrintName()","\tend","\t"],"class":"function","summary":"\nGets Display name of weapon ","name":"weapon_methods:getPrintName","classlib":"Weapon","private":false,"client":true,"description":"\nGets Display name of weapon","param":[]},"weapon_methods:lastShootTime":{"ret":"Time the weapon was last shot","comment":["--- Returns the time since a weapon was last fired at a float variable","-- @shared","-- @return Time the weapon was last shot"],"code":["function weapon_methods:lastShootTime ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:LastShootTime()","end","","if CLIENT then"],"class":"function","summary":"\nReturns the time since a weapon was last fired at a float variable ","classlib":"Weapon","name":"weapon_methods:lastShootTime","server":true,"private":false,"client":true,"description":"\nReturns the time since a weapon was last fired at a float variable","param":[]},"weapon_methods:clip2":{"ret":"amount of ammo","comment":["--- Returns Ammo in secondary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip2 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip2()","end",""],"class":"function","summary":"\nReturns Ammo in secondary clip ","classlib":"Weapon","name":"weapon_methods:clip2","server":true,"private":false,"client":true,"description":"\nReturns Ammo in secondary clip","param":[]},"weapon_methods:getSecondaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the secondary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getSecondaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetSecondaryAmmoType()","end",""],"class":"function","summary":"\nGets the secondary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getSecondaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the secondary ammo type of the given weapon.","param":[]},"weapon_methods:getNextSecondaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can secondary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextSecondaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextSecondaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can secondary fire.","classlib":"Weapon","name":"weapon_methods:getNextSecondaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can secondary fire.","param":[]},"weapon_methods:clip1":{"ret":"amount of ammo","comment":["--- Returns Ammo in primary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip1 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip1()","end",""],"class":"function","summary":"\nReturns Ammo in primary clip ","classlib":"Weapon","name":"weapon_methods:clip1","server":true,"private":false,"client":true,"description":"\nReturns Ammo in primary clip","param":[]}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Weapon functions.","-------------------------------------------------------------------------------"],"code":["","SF.Weapons = {}"],"summary":"\n \nWeapon functions.","description":"\n \nWeapon functions. \n","param":[]},{"comment":["--- Weapon type"],"code":["local weapon_methods, weapon_metamethods = SF.Typedef(\"Weapon\", SF.Entities.Metatable)","","local vwrap = SF.WrapObject","","SF.Weapons.Methods = weapon_methods","SF.Weapons.Metatable = weapon_metamethods",""],"typtbl":"weapon_methods","fields":[],"name":"Weapon","summary":"\nWeapon type ","description":"\nWeapon type","class":"class","methods":{"1":"clip1","2":"clip2","3":"getActivity","4":"getHoldType","5":"getNextPrimaryFire","6":"getNextSecondaryFire","7":"getPrimaryAmmoType","8":"getPrintName","9":"getSecondaryAmmoType","10":"isCarriedByLocalPlayer","11":"isWeaponVisible","12":"lastShootTime","lastShootTime":{"ret":"Time the weapon was last shot","comment":["--- Returns the time since a weapon was last fired at a float variable","-- @shared","-- @return Time the weapon was last shot"],"code":["function weapon_methods:lastShootTime ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:LastShootTime()","end","","if CLIENT then"],"class":"function","summary":"\nReturns the time since a weapon was last fired at a float variable ","classlib":"Weapon","name":"weapon_methods:lastShootTime","server":true,"private":false,"client":true,"description":"\nReturns the time since a weapon was last fired at a float variable","param":[]},"getNextPrimaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can primary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextPrimaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextPrimaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can primary fire.","classlib":"Weapon","name":"weapon_methods:getNextPrimaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can primary fire.","param":[]},"clip2":{"ret":"amount of ammo","comment":["--- Returns Ammo in secondary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip2 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip2()","end",""],"class":"function","summary":"\nReturns Ammo in secondary clip ","classlib":"Weapon","name":"weapon_methods:clip2","server":true,"private":false,"client":true,"description":"\nReturns Ammo in secondary clip","param":[]},"isCarriedByLocalPlayer":{"ret":"whether or not the weapon is carried by the local player","comment":["\t--- Returns if the weapon is carried by the local player. ","\t-- @client","\t-- @return whether or not the weapon is carried by the local player"],"code":["\tfunction weapon_methods:isCarriedByLocalPlayer ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:IsCarriedByLocalPlayer()","\tend","end"],"class":"function","summary":"\nReturns if the weapon is carried by the local player.","name":"weapon_methods:isCarriedByLocalPlayer","classlib":"Weapon","private":false,"client":true,"description":"\nReturns if the weapon is carried by the local player.","param":[]},"getSecondaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the secondary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getSecondaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetSecondaryAmmoType()","end",""],"class":"function","summary":"\nGets the secondary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getSecondaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the secondary ammo type of the given weapon.","param":[]},"clip1":{"ret":"amount of ammo","comment":["--- Returns Ammo in primary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip1 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip1()","end",""],"class":"function","summary":"\nReturns Ammo in primary clip ","classlib":"Weapon","name":"weapon_methods:clip1","server":true,"private":false,"client":true,"description":"\nReturns Ammo in primary clip","param":[]},"getActivity":{"ret":"number Current activity","comment":["--- Returns the sequence enumeration number that the weapon is playing. Must be used on a view model. ","-- @shared","-- @return number Current activity"],"code":["function weapon_methods:getActivity ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetActivity()","end",""],"class":"function","summary":"\nReturns the sequence enumeration number that the weapon is playing.","classlib":"Weapon","name":"weapon_methods:getActivity","server":true,"private":false,"client":true,"description":"\nReturns the sequence enumeration number that the weapon is playing. Must be used on a view model.","param":[]},"getPrintName":{"ret":"string Display name of weapon","comment":["\t--- Gets Display name of weapon","\t-- @client","\t-- @return string Display name of weapon"],"code":["\tfunction weapon_methods:getPrintName ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:GetPrintName()","\tend","\t"],"class":"function","summary":"\nGets Display name of weapon ","name":"weapon_methods:getPrintName","classlib":"Weapon","private":false,"client":true,"description":"\nGets Display name of weapon","param":[]},"getPrimaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the primary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getPrimaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetPrimaryAmmoType()","end",""],"class":"function","summary":"\nGets the primary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getPrimaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the primary ammo type of the given weapon.","param":[]},"getNextSecondaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can secondary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextSecondaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextSecondaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can secondary fire.","classlib":"Weapon","name":"weapon_methods:getNextSecondaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can secondary fire.","param":[]},"getHoldType":{"ret":"string Holdtype","comment":["--- Returns the hold type of the weapon. ","-- @shared","-- @return string Holdtype"],"code":["function weapon_methods:getHoldType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetHoldType()","end",""],"class":"function","summary":"\nReturns the hold type of the weapon.","classlib":"Weapon","name":"weapon_methods:getHoldType","server":true,"private":false,"client":true,"description":"\nReturns the hold type of the weapon.","param":[]},"isWeaponVisible":{"ret":"Whether the weapon is visble or not","comment":["--- Returns whether the weapon is visible","-- @shared","-- @return Whether the weapon is visble or not"],"code":["function weapon_methods:isWeaponVisible ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:IsWeaponVisible()","end",""],"class":"function","summary":"\nReturns whether the weapon is visible ","classlib":"Weapon","name":"weapon_methods:isWeaponVisible","server":true,"private":false,"client":true,"description":"\nReturns whether the weapon is visible","param":[]}}},{"comment":["--- Custom wrapper/unwrapper is necessary for weapon objects","-- wrapper"],"code":["local dsetmeta = debug.setmetatable","local function wrap( object )","\tobject = SF.Entities.Wrap( object )","\tdsetmeta( object, weapon_metamethods )","\treturn object","end","","SF.AddObjectWrapper( debug.getregistry().Weapon, weapon_metamethods, wrap )","SF.AddObjectUnwrapper( weapon_metamethods, SF.Entities.Unwrap )",""],"summary":"\nCustom wrapper/unwrapper is necessary for weapon objects \nwrapper ","description":"\nCustom wrapper/unwrapper is necessary for weapon objects \nwrapper","param":[]},{"comment":["--- To string","-- @shared"],"code":["function weapon_metamethods:__tostring()","\tlocal ent = SF.Entities.Unwrap(self)","\tif not ent then return \"(null entity)\"","\telse return tostring(ent) end","end","","","-- ------------------------------------------------------------------------- --"],"class":"function","summary":"\nTo string ","name":"weapon_metamethods:__tostring","server":true,"private":false,"client":true,"description":"\nTo string","param":[]},{"ret":"amount of ammo","comment":["--- Returns Ammo in primary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip1 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip1()","end",""],"class":"function","summary":"\nReturns Ammo in primary clip ","classlib":"Weapon","name":"weapon_methods:clip1","server":true,"private":false,"client":true,"description":"\nReturns Ammo in primary clip","param":[]},{"ret":"amount of ammo","comment":["--- Returns Ammo in secondary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip2 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip2()","end",""],"class":"function","summary":"\nReturns Ammo in secondary clip ","classlib":"Weapon","name":"weapon_methods:clip2","server":true,"private":false,"client":true,"description":"\nReturns Ammo in secondary clip","param":[]},{"ret":"number Current activity","comment":["--- Returns the sequence enumeration number that the weapon is playing. Must be used on a view model. ","-- @shared","-- @return number Current activity"],"code":["function weapon_methods:getActivity ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetActivity()","end",""],"class":"function","summary":"\nReturns the sequence enumeration number that the weapon is playing.","classlib":"Weapon","name":"weapon_methods:getActivity","server":true,"private":false,"client":true,"description":"\nReturns the sequence enumeration number that the weapon is playing. Must be used on a view model.","param":[]},{"ret":"string Holdtype","comment":["--- Returns the hold type of the weapon. ","-- @shared","-- @return string Holdtype"],"code":["function weapon_methods:getHoldType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetHoldType()","end",""],"class":"function","summary":"\nReturns the hold type of the weapon.","classlib":"Weapon","name":"weapon_methods:getHoldType","server":true,"private":false,"client":true,"description":"\nReturns the hold type of the weapon.","param":[]},{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can primary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextPrimaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextPrimaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can primary fire.","classlib":"Weapon","name":"weapon_methods:getNextPrimaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can primary fire.","param":[]},{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can secondary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextSecondaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextSecondaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can secondary fire.","classlib":"Weapon","name":"weapon_methods:getNextSecondaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can secondary fire.","param":[]},{"ret":"Ammo number type","comment":["--- Gets the primary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getPrimaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetPrimaryAmmoType()","end",""],"class":"function","summary":"\nGets the primary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getPrimaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the primary ammo type of the given weapon.","param":[]},{"ret":"Ammo number type","comment":["--- Gets the secondary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getSecondaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetSecondaryAmmoType()","end",""],"class":"function","summary":"\nGets the secondary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getSecondaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the secondary ammo type of the given weapon.","param":[]},{"ret":"Whether the weapon is visble or not","comment":["--- Returns whether the weapon is visible","-- @shared","-- @return Whether the weapon is visble or not"],"code":["function weapon_methods:isWeaponVisible ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:IsWeaponVisible()","end",""],"class":"function","summary":"\nReturns whether the weapon is visible ","classlib":"Weapon","name":"weapon_methods:isWeaponVisible","server":true,"private":false,"client":true,"description":"\nReturns whether the weapon is visible","param":[]},{"ret":"Time the weapon was last shot","comment":["--- Returns the time since a weapon was last fired at a float variable","-- @shared","-- @return Time the weapon was last shot"],"code":["function weapon_methods:lastShootTime ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:LastShootTime()","end","","if CLIENT then"],"class":"function","summary":"\nReturns the time since a weapon was last fired at a float variable ","classlib":"Weapon","name":"weapon_methods:lastShootTime","server":true,"private":false,"client":true,"description":"\nReturns the time since a weapon was last fired at a float variable","param":[]},{"ret":"string Display name of weapon","comment":["\t--- Gets Display name of weapon","\t-- @client","\t-- @return string Display name of weapon"],"code":["\tfunction weapon_methods:getPrintName ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:GetPrintName()","\tend","\t"],"class":"function","summary":"\nGets Display name of weapon ","name":"weapon_methods:getPrintName","classlib":"Weapon","private":false,"client":true,"description":"\nGets Display name of weapon","param":[]},{"ret":"whether or not the weapon is carried by the local player","comment":["\t--- Returns if the weapon is carried by the local player. ","\t-- @client","\t-- @return whether or not the weapon is carried by the local player"],"code":["\tfunction weapon_methods:isCarriedByLocalPlayer ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:IsCarriedByLocalPlayer()","\tend","end"],"class":"function","summary":"\nReturns if the weapon is carried by the local player.","name":"weapon_methods:isCarriedByLocalPlayer","classlib":"Weapon","private":false,"client":true,"description":"\nReturns if the weapon is carried by the local player.","param":[]}],"tables":[],"description":"\n \nWeapon functions. \n","summary":"\n \nWeapon functions."},"libs_cl/input.lua":{"libraries":{"1":"input","input":{"comment":["--- Input library.","-- @client"],"functions":{"1":"getCursorPos","2":"getKeyName","3":"getMBName","4":"isControlDown","5":"isKeyDown","6":"isMBDown","7":"isShiftDown","8":"lookupBinding","9":"wasKeyPressed","10":"wasKeyReleased","11":"wasMBPressed","12":"wasMBReleased","getCursorPos":{"ret":["The x position of the mouse","The y position of the mouse"],"comment":["--- Gets the position of the mouse","-- @return The x position of the mouse","-- @return The y position of the mouse"],"code":["function input_methods.getCursorPos( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetCursorPos( )","end",""],"class":"function","name":"input_methods.getCursorPos","summary":"\nGets the position of the mouse ","private":false,"library":"input","description":"\nGets the position of the mouse","param":[]},"lookupBinding":{"ret":["The id of the first key bound","The name of the first key bound"],"comment":["--- Gets the first key that is bound to the command passed","-- @param bind The name of the bind","-- @return The id of the first key bound","-- @return The name of the first key bound"],"code":["","function input_methods.lookupBinding( binding )","\tSF.CheckType( binding, \"string\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal bind = input.LookupBinding( binding )","\tif bind then","\t\tbind = bind:upper( )","\t\treturn input_methods.KEY[ bind ] or input_methods.MOUSE[ bind ], bind","\tend","end",""],"class":"function","name":"input_methods.lookupBinding","summary":"\nGets the first key that is bound to the command passed ","private":false,"library":"input","description":"\nGets the first key that is bound to the command passed","param":{"1":"binding","2":"bind","bind":"The name of the bind"}},"isControlDown":{"ret":"True if the control key is down","comment":["--- Gets whether the control key is down","-- @return True if the control key is down"],"code":["function input_methods.isControlDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsControlDown( )","end",""],"class":"function","name":"input_methods.isControlDown","summary":"\nGets whether the control key is down ","private":false,"library":"input","description":"\nGets whether the control key is down","param":[]},"wasKeyReleased":{"ret":"True if the key was released","comment":["--- Gets whether the key was released this frame","-- @param key The key id, see input.KEY","-- @return True if the key was released"],"code":["function input_methods.wasKeyReleased( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.key[ key ] and keystate.key[ key ].wasReleased","end","","","for i = MOUSE_FIRST, MOUSE_LAST do","\tlastState.mouse[ i ] = false","\tkeystate.mouse[ i ] = {","\t\twasPressed = false,","\t\twasReleased = false","\t}","end","","local _MOUSENAMES = {","\t[ 107 ] = \"MOUSE1\",","\t[ 108 ] = \"MOUSE2\",","\t[ 109 ] = \"MOUSE3\",","\t[ 110 ] = \"MOUSE4\",","\t[ 111 ] = \"MOUSE5\",","\t[ 112 ] = \"MWHEELUP\",","\t[ 113 ] = \"MWHEELDOWN\"","}","","hook.Add( \"Think\", \"sf_keystate_mouse update\", function( )","\tfor i = MOUSE_FIRST, MOUSE_LAST do","\t\tlocal isKeyDown = input.IsMouseDown( i )","","\t\tlocal keyName = _MOUSENAMES[ i ]","","\t\tkeystate.mouse[ i ].wasPressed = isKeyDown and lastState.mouse[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.mouse[ i ] and keystate.mouse[ i ].wasPressed then","\t\t\trunInputHook( \"inputPressed\", \"mouse\", _MOUSENAMES[ i ]:upper( ) )","\t\tend","","\t\tkeystate.mouse[ i ].wasReleased = not isKeyDown and lastState.mouse[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.mouse[ i ] and keystate.mouse[ i ].wasReleased then","\t\t\trunInputHook( \"inputReleased\", \"mouse\", _MOUSENAMES[ i ]:upper( ) )","\t\tend","","\t\tlastState.mouse[ i ] = isKeyDown","\tend","end )",""],"class":"function","name":"input_methods.wasKeyReleased","summary":"\nGets whether the key was released this frame ","private":false,"library":"input","description":"\nGets whether the key was released this frame","param":{"1":"key","key":"The key id, see input.KEY"}},"wasMBReleased":{"ret":"True if the button was released","comment":["--- Gets whether the mouse button was released this frame","-- @param key The key id, see input.MOUSE","-- @return True if the button was released"],"code":["function input_methods.wasMBReleased( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.mouse[ key ] and keystate.mouse[ key ].wasReleased","end",""],"class":"function","name":"input_methods.wasMBReleased","summary":"\nGets whether the mouse button was released this frame ","private":false,"library":"input","description":"\nGets whether the mouse button was released this frame","param":{"1":"key","key":"The key id, see input.MOUSE"}},"getMBName":{"ret":"The name of the mouse button","comment":["--- Gets the name of a mouse button from the id","-- @param key The button id, see input.MOUSE","-- @return The name of the mouse button"],"code":["function input_methods.getMBName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn _MOUSENAMES[ key ]","end"],"class":"function","name":"input_methods.getMBName","summary":"\nGets the name of a mouse button from the id ","private":false,"library":"input","description":"\nGets the name of a mouse button from the id","param":{"1":"key","key":"The button id, see input.MOUSE"}},"wasKeyPressed":{"ret":"True if the key was pressed","comment":["--- Gets whether the key was pressed this frame","-- @param key The key id, see input.KEY","-- @return True if the key was pressed"],"code":["function input_methods.wasKeyPressed( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.key[ key ] and keystate.key[ key ].wasPressed","end",""],"class":"function","name":"input_methods.wasKeyPressed","summary":"\nGets whether the key was pressed this frame ","private":false,"library":"input","description":"\nGets whether the key was pressed this frame","param":{"1":"key","key":"The key id, see input.KEY"}},"isShiftDown":{"ret":"True if the shift key is down","comment":["--- Gets whether the shift key is down","-- @return True if the shift key is down"],"code":["function input_methods.isShiftDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsShiftDown( )","end",""],"class":"function","name":"input_methods.isShiftDown","summary":"\nGets whether the shift key is down ","private":false,"library":"input","description":"\nGets whether the shift key is down","param":[]},"isKeyDown":{"ret":"True if the key is down","comment":["--- Gets whether a key is down","-- @param key The key id, see input.KEY","-- @return True if the key is down"],"code":["function input_methods.isKeyDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsKeyDown( key )","end",""],"class":"function","name":"input_methods.isKeyDown","summary":"\nGets whether a key is down ","private":false,"library":"input","description":"\nGets whether a key is down","param":{"1":"key","key":"The key id, see input.KEY"}},"wasMBPressed":{"ret":"True if the button was pressed","comment":["--- Gets whether the mouse button was pressed this frame","-- @param key The button id, see input.MOUSE","-- @return True if the button was pressed"],"code":["function input_methods.wasMBPressed( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.mouse[ key ] and keystate.mouse[ key ].wasPressed","end",""],"class":"function","name":"input_methods.wasMBPressed","summary":"\nGets whether the mouse button was pressed this frame ","private":false,"library":"input","description":"\nGets whether the mouse button was pressed this frame","param":{"1":"key","key":"The button id, see input.MOUSE"}},"isMBDown":{"ret":"True if the mouse button is down","comment":["--- Gets whether a mouse button is down","-- @param key The mouse button, see input.MOUSE","-- @return True if the mouse button is down"],"code":["function input_methods.isMBDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsMouseDown( key )","end","","local lastState = { key = { }, mouse = { } }","local keystate = { key = { }, mouse = { } }","","for i = KEY_FIRST, KEY_LAST do","\tlastState.key[ i ] = false","\tkeystate.key[ i ] = {","\t\twasPressed = false,","\t\twasReleased = false","\t}","end","","local function runInputHook( hookname, scope, key )","\tfor instance,_ in pairs( SF.allInstances ) do","\t\tif not SF.Permissions.check( instance.player, nil, \"input.\" .. scope ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t\t","\t\t","\t\tinstance:runScriptHook( hookname, key )","\tend","end","","hook.Add( \"Think\", \"sf_keystate_key update\", function( )","\tfor i = KEY_FIRST, KEY_LAST do","\t\tlocal isKeyDown = input.IsKeyDown( i )","","\t\tlocal keyName = input.GetKeyName( i )","","\t\tkeystate.key[ i ].wasPressed = isKeyDown and lastState.key[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.key[ i ] and keystate.key[ i ].wasPressed then","\t\t\trunInputHook( \"inputPressed\", \"key\", input.GetKeyName( i ):upper( ) )","\t\tend","","\t\tkeystate.key[ i ].wasReleased = not isKeyDown and lastState.key[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.key[ i ] and keystate.key[ i ].wasReleased then","\t\t\trunInputHook( \"inputReleased\", \"key\", input.GetKeyName( i ):upper( ) )","\t\tend","\t\t","\t\tlastState.key[ i ] = isKeyDown","\tend","end )",""],"class":"function","name":"input_methods.isMBDown","summary":"\nGets whether a mouse button is down ","private":false,"library":"input","description":"\nGets whether a mouse button is down","param":{"1":"key","key":"The mouse button, see input.MOUSE"}},"getKeyName":{"ret":"The name of the key","comment":["--- Gets the name of a key from the id","-- @param key The key id, see input.KEY","-- @return The name of the key"],"code":["function input_methods.getKeyName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetKeyName( key )","end",""],"class":"function","name":"input_methods.getKeyName","summary":"\nGets the name of a key from the id ","private":false,"library":"input","description":"\nGets the name of a key from the id","param":{"1":"key","key":"The key id, see input.KEY"}}},"class":"library","summary":"\nInput library.","fields":[],"name":"input","client":true,"description":"\nInput library.","libtbl":"input_methods","tables":[],"code":["local input_methods, input_metamethods = SF.Libraries.Register( \"input\" )","","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"input\", \"Input\", \"Allows the user to use the input library\" )","\tP.registerPrivilege( \"input.key\", \"Keyboard\", \"Allows the user to poll keyboard inputs\" )","\tP.registerPrivilege( \"input.mouse\", \"Mouse\", \"Allows the user to poll mouse inputs\" )","end",""]}},"type":"file","name":"libs_cl/input.lua","functions":{"1":"input_methods.getCursorPos","2":"input_methods.getKeyName","3":"input_methods.getMBName","4":"input_methods.isControlDown","5":"input_methods.isKeyDown","6":"input_methods.isMBDown","7":"input_methods.isShiftDown","8":"input_methods.lookupBinding","9":"input_methods.wasKeyPressed","10":"input_methods.wasKeyReleased","11":"input_methods.wasMBPressed","12":"input_methods.wasMBReleased","input_methods.lookupBinding":{"ret":["The id of the first key bound","The name of the first key bound"],"comment":["--- Gets the first key that is bound to the command passed","-- @param bind The name of the bind","-- @return The id of the first key bound","-- @return The name of the first key bound"],"code":["","function input_methods.lookupBinding( binding )","\tSF.CheckType( binding, \"string\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal bind = input.LookupBinding( binding )","\tif bind then","\t\tbind = bind:upper( )","\t\treturn input_methods.KEY[ bind ] or input_methods.MOUSE[ bind ], bind","\tend","end",""],"class":"function","name":"input_methods.lookupBinding","summary":"\nGets the first key that is bound to the command passed ","private":false,"library":"input","description":"\nGets the first key that is bound to the command passed","param":{"1":"binding","2":"bind","bind":"The name of the bind"}},"input_methods.isMBDown":{"ret":"True if the mouse button is down","comment":["--- Gets whether a mouse button is down","-- @param key The mouse button, see input.MOUSE","-- @return True if the mouse button is down"],"code":["function input_methods.isMBDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsMouseDown( key )","end","","local lastState = { key = { }, mouse = { } }","local keystate = { key = { }, mouse = { } }","","for i = KEY_FIRST, KEY_LAST do","\tlastState.key[ i ] = false","\tkeystate.key[ i ] = {","\t\twasPressed = false,","\t\twasReleased = false","\t}","end","","local function runInputHook( hookname, scope, key )","\tfor instance,_ in pairs( SF.allInstances ) do","\t\tif not SF.Permissions.check( instance.player, nil, \"input.\" .. scope ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t\t","\t\t","\t\tinstance:runScriptHook( hookname, key )","\tend","end","","hook.Add( \"Think\", \"sf_keystate_key update\", function( )","\tfor i = KEY_FIRST, KEY_LAST do","\t\tlocal isKeyDown = input.IsKeyDown( i )","","\t\tlocal keyName = input.GetKeyName( i )","","\t\tkeystate.key[ i ].wasPressed = isKeyDown and lastState.key[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.key[ i ] and keystate.key[ i ].wasPressed then","\t\t\trunInputHook( \"inputPressed\", \"key\", input.GetKeyName( i ):upper( ) )","\t\tend","","\t\tkeystate.key[ i ].wasReleased = not isKeyDown and lastState.key[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.key[ i ] and keystate.key[ i ].wasReleased then","\t\t\trunInputHook( \"inputReleased\", \"key\", input.GetKeyName( i ):upper( ) )","\t\tend","\t\t","\t\tlastState.key[ i ] = isKeyDown","\tend","end )",""],"class":"function","name":"input_methods.isMBDown","summary":"\nGets whether a mouse button is down ","private":false,"library":"input","description":"\nGets whether a mouse button is down","param":{"1":"key","key":"The mouse button, see input.MOUSE"}},"input_methods.getMBName":{"ret":"The name of the mouse button","comment":["--- Gets the name of a mouse button from the id","-- @param key The button id, see input.MOUSE","-- @return The name of the mouse button"],"code":["function input_methods.getMBName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn _MOUSENAMES[ key ]","end"],"class":"function","name":"input_methods.getMBName","summary":"\nGets the name of a mouse button from the id ","private":false,"library":"input","description":"\nGets the name of a mouse button from the id","param":{"1":"key","key":"The button id, see input.MOUSE"}},"input_methods.isControlDown":{"ret":"True if the control key is down","comment":["--- Gets whether the control key is down","-- @return True if the control key is down"],"code":["function input_methods.isControlDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsControlDown( )","end",""],"class":"function","name":"input_methods.isControlDown","summary":"\nGets whether the control key is down ","private":false,"library":"input","description":"\nGets whether the control key is down","param":[]},"input_methods.isKeyDown":{"ret":"True if the key is down","comment":["--- Gets whether a key is down","-- @param key The key id, see input.KEY","-- @return True if the key is down"],"code":["function input_methods.isKeyDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsKeyDown( key )","end",""],"class":"function","name":"input_methods.isKeyDown","summary":"\nGets whether a key is down ","private":false,"library":"input","description":"\nGets whether a key is down","param":{"1":"key","key":"The key id, see input.KEY"}},"input_methods.wasMBReleased":{"ret":"True if the button was released","comment":["--- Gets whether the mouse button was released this frame","-- @param key The key id, see input.MOUSE","-- @return True if the button was released"],"code":["function input_methods.wasMBReleased( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.mouse[ key ] and keystate.mouse[ key ].wasReleased","end",""],"class":"function","name":"input_methods.wasMBReleased","summary":"\nGets whether the mouse button was released this frame ","private":false,"library":"input","description":"\nGets whether the mouse button was released this frame","param":{"1":"key","key":"The key id, see input.MOUSE"}},"input_methods.wasKeyPressed":{"ret":"True if the key was pressed","comment":["--- Gets whether the key was pressed this frame","-- @param key The key id, see input.KEY","-- @return True if the key was pressed"],"code":["function input_methods.wasKeyPressed( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.key[ key ] and keystate.key[ key ].wasPressed","end",""],"class":"function","name":"input_methods.wasKeyPressed","summary":"\nGets whether the key was pressed this frame ","private":false,"library":"input","description":"\nGets whether the key was pressed this frame","param":{"1":"key","key":"The key id, see input.KEY"}},"input_methods.getKeyName":{"ret":"The name of the key","comment":["--- Gets the name of a key from the id","-- @param key The key id, see input.KEY","-- @return The name of the key"],"code":["function input_methods.getKeyName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetKeyName( key )","end",""],"class":"function","name":"input_methods.getKeyName","summary":"\nGets the name of a key from the id ","private":false,"library":"input","description":"\nGets the name of a key from the id","param":{"1":"key","key":"The key id, see input.KEY"}},"input_methods.wasKeyReleased":{"ret":"True if the key was released","comment":["--- Gets whether the key was released this frame","-- @param key The key id, see input.KEY","-- @return True if the key was released"],"code":["function input_methods.wasKeyReleased( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.key[ key ] and keystate.key[ key ].wasReleased","end","","","for i = MOUSE_FIRST, MOUSE_LAST do","\tlastState.mouse[ i ] = false","\tkeystate.mouse[ i ] = {","\t\twasPressed = false,","\t\twasReleased = false","\t}","end","","local _MOUSENAMES = {","\t[ 107 ] = \"MOUSE1\",","\t[ 108 ] = \"MOUSE2\",","\t[ 109 ] = \"MOUSE3\",","\t[ 110 ] = \"MOUSE4\",","\t[ 111 ] = \"MOUSE5\",","\t[ 112 ] = \"MWHEELUP\",","\t[ 113 ] = \"MWHEELDOWN\"","}","","hook.Add( \"Think\", \"sf_keystate_mouse update\", function( )","\tfor i = MOUSE_FIRST, MOUSE_LAST do","\t\tlocal isKeyDown = input.IsMouseDown( i )","","\t\tlocal keyName = _MOUSENAMES[ i ]","","\t\tkeystate.mouse[ i ].wasPressed = isKeyDown and lastState.mouse[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.mouse[ i ] and keystate.mouse[ i ].wasPressed then","\t\t\trunInputHook( \"inputPressed\", \"mouse\", _MOUSENAMES[ i ]:upper( ) )","\t\tend","","\t\tkeystate.mouse[ i ].wasReleased = not isKeyDown and lastState.mouse[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.mouse[ i ] and keystate.mouse[ i ].wasReleased then","\t\t\trunInputHook( \"inputReleased\", \"mouse\", _MOUSENAMES[ i ]:upper( ) )","\t\tend","","\t\tlastState.mouse[ i ] = isKeyDown","\tend","end )",""],"class":"function","name":"input_methods.wasKeyReleased","summary":"\nGets whether the key was released this frame ","private":false,"library":"input","description":"\nGets whether the key was released this frame","param":{"1":"key","key":"The key id, see input.KEY"}},"input_methods.getCursorPos":{"ret":["The x position of the mouse","The y position of the mouse"],"comment":["--- Gets the position of the mouse","-- @return The x position of the mouse","-- @return The y position of the mouse"],"code":["function input_methods.getCursorPos( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetCursorPos( )","end",""],"class":"function","name":"input_methods.getCursorPos","summary":"\nGets the position of the mouse ","private":false,"library":"input","description":"\nGets the position of the mouse","param":[]},"input_methods.isShiftDown":{"ret":"True if the shift key is down","comment":["--- Gets whether the shift key is down","-- @return True if the shift key is down"],"code":["function input_methods.isShiftDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsShiftDown( )","end",""],"class":"function","name":"input_methods.isShiftDown","summary":"\nGets whether the shift key is down ","private":false,"library":"input","description":"\nGets whether the shift key is down","param":[]},"input_methods.wasMBPressed":{"ret":"True if the button was pressed","comment":["--- Gets whether the mouse button was pressed this frame","-- @param key The button id, see input.MOUSE","-- @return True if the button was pressed"],"code":["function input_methods.wasMBPressed( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.mouse[ key ] and keystate.mouse[ key ].wasPressed","end",""],"class":"function","name":"input_methods.wasMBPressed","summary":"\nGets whether the mouse button was pressed this frame ","private":false,"library":"input","description":"\nGets whether the mouse button was pressed this frame","param":{"1":"key","key":"The button id, see input.MOUSE"}}},"doc":[{"comment":["--- Input library.","-- @client"],"functions":{"1":"getCursorPos","2":"getKeyName","3":"getMBName","4":"isControlDown","5":"isKeyDown","6":"isMBDown","7":"isShiftDown","8":"lookupBinding","9":"wasKeyPressed","10":"wasKeyReleased","11":"wasMBPressed","12":"wasMBReleased","getCursorPos":{"ret":["The x position of the mouse","The y position of the mouse"],"comment":["--- Gets the position of the mouse","-- @return The x position of the mouse","-- @return The y position of the mouse"],"code":["function input_methods.getCursorPos( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetCursorPos( )","end",""],"class":"function","name":"input_methods.getCursorPos","summary":"\nGets the position of the mouse ","private":false,"library":"input","description":"\nGets the position of the mouse","param":[]},"lookupBinding":{"ret":["The id of the first key bound","The name of the first key bound"],"comment":["--- Gets the first key that is bound to the command passed","-- @param bind The name of the bind","-- @return The id of the first key bound","-- @return The name of the first key bound"],"code":["","function input_methods.lookupBinding( binding )","\tSF.CheckType( binding, \"string\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal bind = input.LookupBinding( binding )","\tif bind then","\t\tbind = bind:upper( )","\t\treturn input_methods.KEY[ bind ] or input_methods.MOUSE[ bind ], bind","\tend","end",""],"class":"function","name":"input_methods.lookupBinding","summary":"\nGets the first key that is bound to the command passed ","private":false,"library":"input","description":"\nGets the first key that is bound to the command passed","param":{"1":"binding","2":"bind","bind":"The name of the bind"}},"isControlDown":{"ret":"True if the control key is down","comment":["--- Gets whether the control key is down","-- @return True if the control key is down"],"code":["function input_methods.isControlDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsControlDown( )","end",""],"class":"function","name":"input_methods.isControlDown","summary":"\nGets whether the control key is down ","private":false,"library":"input","description":"\nGets whether the control key is down","param":[]},"wasKeyReleased":{"ret":"True if the key was released","comment":["--- Gets whether the key was released this frame","-- @param key The key id, see input.KEY","-- @return True if the key was released"],"code":["function input_methods.wasKeyReleased( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.key[ key ] and keystate.key[ key ].wasReleased","end","","","for i = MOUSE_FIRST, MOUSE_LAST do","\tlastState.mouse[ i ] = false","\tkeystate.mouse[ i ] = {","\t\twasPressed = false,","\t\twasReleased = false","\t}","end","","local _MOUSENAMES = {","\t[ 107 ] = \"MOUSE1\",","\t[ 108 ] = \"MOUSE2\",","\t[ 109 ] = \"MOUSE3\",","\t[ 110 ] = \"MOUSE4\",","\t[ 111 ] = \"MOUSE5\",","\t[ 112 ] = \"MWHEELUP\",","\t[ 113 ] = \"MWHEELDOWN\"","}","","hook.Add( \"Think\", \"sf_keystate_mouse update\", function( )","\tfor i = MOUSE_FIRST, MOUSE_LAST do","\t\tlocal isKeyDown = input.IsMouseDown( i )","","\t\tlocal keyName = _MOUSENAMES[ i ]","","\t\tkeystate.mouse[ i ].wasPressed = isKeyDown and lastState.mouse[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.mouse[ i ] and keystate.mouse[ i ].wasPressed then","\t\t\trunInputHook( \"inputPressed\", \"mouse\", _MOUSENAMES[ i ]:upper( ) )","\t\tend","","\t\tkeystate.mouse[ i ].wasReleased = not isKeyDown and lastState.mouse[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.mouse[ i ] and keystate.mouse[ i ].wasReleased then","\t\t\trunInputHook( \"inputReleased\", \"mouse\", _MOUSENAMES[ i ]:upper( ) )","\t\tend","","\t\tlastState.mouse[ i ] = isKeyDown","\tend","end )",""],"class":"function","name":"input_methods.wasKeyReleased","summary":"\nGets whether the key was released this frame ","private":false,"library":"input","description":"\nGets whether the key was released this frame","param":{"1":"key","key":"The key id, see input.KEY"}},"wasMBReleased":{"ret":"True if the button was released","comment":["--- Gets whether the mouse button was released this frame","-- @param key The key id, see input.MOUSE","-- @return True if the button was released"],"code":["function input_methods.wasMBReleased( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.mouse[ key ] and keystate.mouse[ key ].wasReleased","end",""],"class":"function","name":"input_methods.wasMBReleased","summary":"\nGets whether the mouse button was released this frame ","private":false,"library":"input","description":"\nGets whether the mouse button was released this frame","param":{"1":"key","key":"The key id, see input.MOUSE"}},"getMBName":{"ret":"The name of the mouse button","comment":["--- Gets the name of a mouse button from the id","-- @param key The button id, see input.MOUSE","-- @return The name of the mouse button"],"code":["function input_methods.getMBName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn _MOUSENAMES[ key ]","end"],"class":"function","name":"input_methods.getMBName","summary":"\nGets the name of a mouse button from the id ","private":false,"library":"input","description":"\nGets the name of a mouse button from the id","param":{"1":"key","key":"The button id, see input.MOUSE"}},"wasKeyPressed":{"ret":"True if the key was pressed","comment":["--- Gets whether the key was pressed this frame","-- @param key The key id, see input.KEY","-- @return True if the key was pressed"],"code":["function input_methods.wasKeyPressed( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.key[ key ] and keystate.key[ key ].wasPressed","end",""],"class":"function","name":"input_methods.wasKeyPressed","summary":"\nGets whether the key was pressed this frame ","private":false,"library":"input","description":"\nGets whether the key was pressed this frame","param":{"1":"key","key":"The key id, see input.KEY"}},"isShiftDown":{"ret":"True if the shift key is down","comment":["--- Gets whether the shift key is down","-- @return True if the shift key is down"],"code":["function input_methods.isShiftDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsShiftDown( )","end",""],"class":"function","name":"input_methods.isShiftDown","summary":"\nGets whether the shift key is down ","private":false,"library":"input","description":"\nGets whether the shift key is down","param":[]},"isKeyDown":{"ret":"True if the key is down","comment":["--- Gets whether a key is down","-- @param key The key id, see input.KEY","-- @return True if the key is down"],"code":["function input_methods.isKeyDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsKeyDown( key )","end",""],"class":"function","name":"input_methods.isKeyDown","summary":"\nGets whether a key is down ","private":false,"library":"input","description":"\nGets whether a key is down","param":{"1":"key","key":"The key id, see input.KEY"}},"wasMBPressed":{"ret":"True if the button was pressed","comment":["--- Gets whether the mouse button was pressed this frame","-- @param key The button id, see input.MOUSE","-- @return True if the button was pressed"],"code":["function input_methods.wasMBPressed( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.mouse[ key ] and keystate.mouse[ key ].wasPressed","end",""],"class":"function","name":"input_methods.wasMBPressed","summary":"\nGets whether the mouse button was pressed this frame ","private":false,"library":"input","description":"\nGets whether the mouse button was pressed this frame","param":{"1":"key","key":"The button id, see input.MOUSE"}},"isMBDown":{"ret":"True if the mouse button is down","comment":["--- Gets whether a mouse button is down","-- @param key The mouse button, see input.MOUSE","-- @return True if the mouse button is down"],"code":["function input_methods.isMBDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsMouseDown( key )","end","","local lastState = { key = { }, mouse = { } }","local keystate = { key = { }, mouse = { } }","","for i = KEY_FIRST, KEY_LAST do","\tlastState.key[ i ] = false","\tkeystate.key[ i ] = {","\t\twasPressed = false,","\t\twasReleased = false","\t}","end","","local function runInputHook( hookname, scope, key )","\tfor instance,_ in pairs( SF.allInstances ) do","\t\tif not SF.Permissions.check( instance.player, nil, \"input.\" .. scope ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t\t","\t\t","\t\tinstance:runScriptHook( hookname, key )","\tend","end","","hook.Add( \"Think\", \"sf_keystate_key update\", function( )","\tfor i = KEY_FIRST, KEY_LAST do","\t\tlocal isKeyDown = input.IsKeyDown( i )","","\t\tlocal keyName = input.GetKeyName( i )","","\t\tkeystate.key[ i ].wasPressed = isKeyDown and lastState.key[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.key[ i ] and keystate.key[ i ].wasPressed then","\t\t\trunInputHook( \"inputPressed\", \"key\", input.GetKeyName( i ):upper( ) )","\t\tend","","\t\tkeystate.key[ i ].wasReleased = not isKeyDown and lastState.key[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.key[ i ] and keystate.key[ i ].wasReleased then","\t\t\trunInputHook( \"inputReleased\", \"key\", input.GetKeyName( i ):upper( ) )","\t\tend","\t\t","\t\tlastState.key[ i ] = isKeyDown","\tend","end )",""],"class":"function","name":"input_methods.isMBDown","summary":"\nGets whether a mouse button is down ","private":false,"library":"input","description":"\nGets whether a mouse button is down","param":{"1":"key","key":"The mouse button, see input.MOUSE"}},"getKeyName":{"ret":"The name of the key","comment":["--- Gets the name of a key from the id","-- @param key The key id, see input.KEY","-- @return The name of the key"],"code":["function input_methods.getKeyName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetKeyName( key )","end",""],"class":"function","name":"input_methods.getKeyName","summary":"\nGets the name of a key from the id ","private":false,"library":"input","description":"\nGets the name of a key from the id","param":{"1":"key","key":"The key id, see input.KEY"}}},"class":"library","summary":"\nInput library.","fields":[],"name":"input","client":true,"description":"\nInput library.","libtbl":"input_methods","tables":[],"code":["local input_methods, input_metamethods = SF.Libraries.Register( \"input\" )","","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"input\", \"Input\", \"Allows the user to use the input library\" )","\tP.registerPrivilege( \"input.key\", \"Keyboard\", \"Allows the user to poll keyboard inputs\" )","\tP.registerPrivilege( \"input.mouse\", \"Mouse\", \"Allows the user to poll mouse inputs\" )","end",""]},{"ret":["The id of the first key bound","The name of the first key bound"],"comment":["--- Gets the first key that is bound to the command passed","-- @param bind The name of the bind","-- @return The id of the first key bound","-- @return The name of the first key bound"],"code":["","function input_methods.lookupBinding( binding )","\tSF.CheckType( binding, \"string\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal bind = input.LookupBinding( binding )","\tif bind then","\t\tbind = bind:upper( )","\t\treturn input_methods.KEY[ bind ] or input_methods.MOUSE[ bind ], bind","\tend","end",""],"class":"function","name":"input_methods.lookupBinding","summary":"\nGets the first key that is bound to the command passed ","private":false,"library":"input","description":"\nGets the first key that is bound to the command passed","param":{"1":"binding","2":"bind","bind":"The name of the bind"}},{"ret":"True if the key is down","comment":["--- Gets whether a key is down","-- @param key The key id, see input.KEY","-- @return True if the key is down"],"code":["function input_methods.isKeyDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsKeyDown( key )","end",""],"class":"function","name":"input_methods.isKeyDown","summary":"\nGets whether a key is down ","private":false,"library":"input","description":"\nGets whether a key is down","param":{"1":"key","key":"The key id, see input.KEY"}},{"ret":"The name of the key","comment":["--- Gets the name of a key from the id","-- @param key The key id, see input.KEY","-- @return The name of the key"],"code":["function input_methods.getKeyName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetKeyName( key )","end",""],"class":"function","name":"input_methods.getKeyName","summary":"\nGets the name of a key from the id ","private":false,"library":"input","description":"\nGets the name of a key from the id","param":{"1":"key","key":"The key id, see input.KEY"}},{"ret":"True if the shift key is down","comment":["--- Gets whether the shift key is down","-- @return True if the shift key is down"],"code":["function input_methods.isShiftDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsShiftDown( )","end",""],"class":"function","name":"input_methods.isShiftDown","summary":"\nGets whether the shift key is down ","private":false,"library":"input","description":"\nGets whether the shift key is down","param":[]},{"ret":"True if the control key is down","comment":["--- Gets whether the control key is down","-- @return True if the control key is down"],"code":["function input_methods.isControlDown( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsControlDown( )","end",""],"class":"function","name":"input_methods.isControlDown","summary":"\nGets whether the control key is down ","private":false,"library":"input","description":"\nGets whether the control key is down","param":[]},{"ret":["The x position of the mouse","The y position of the mouse"],"comment":["--- Gets the position of the mouse","-- @return The x position of the mouse","-- @return The y position of the mouse"],"code":["function input_methods.getCursorPos( )","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.GetCursorPos( )","end",""],"class":"function","name":"input_methods.getCursorPos","summary":"\nGets the position of the mouse ","private":false,"library":"input","description":"\nGets the position of the mouse","param":[]},{"ret":"True if the mouse button is down","comment":["--- Gets whether a mouse button is down","-- @param key The mouse button, see input.MOUSE","-- @return True if the mouse button is down"],"code":["function input_methods.isMBDown( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn input.IsMouseDown( key )","end","","local lastState = { key = { }, mouse = { } }","local keystate = { key = { }, mouse = { } }","","for i = KEY_FIRST, KEY_LAST do","\tlastState.key[ i ] = false","\tkeystate.key[ i ] = {","\t\twasPressed = false,","\t\twasReleased = false","\t}","end","","local function runInputHook( hookname, scope, key )","\tfor instance,_ in pairs( SF.allInstances ) do","\t\tif not SF.Permissions.check( instance.player, nil, \"input.\" .. scope ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t\t","\t\t","\t\tinstance:runScriptHook( hookname, key )","\tend","end","","hook.Add( \"Think\", \"sf_keystate_key update\", function( )","\tfor i = KEY_FIRST, KEY_LAST do","\t\tlocal isKeyDown = input.IsKeyDown( i )","","\t\tlocal keyName = input.GetKeyName( i )","","\t\tkeystate.key[ i ].wasPressed = isKeyDown and lastState.key[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.key[ i ] and keystate.key[ i ].wasPressed then","\t\t\trunInputHook( \"inputPressed\", \"key\", input.GetKeyName( i ):upper( ) )","\t\tend","","\t\tkeystate.key[ i ].wasReleased = not isKeyDown and lastState.key[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.key[ i ] and keystate.key[ i ].wasReleased then","\t\t\trunInputHook( \"inputReleased\", \"key\", input.GetKeyName( i ):upper( ) )","\t\tend","\t\t","\t\tlastState.key[ i ] = isKeyDown","\tend","end )",""],"class":"function","name":"input_methods.isMBDown","summary":"\nGets whether a mouse button is down ","private":false,"library":"input","description":"\nGets whether a mouse button is down","param":{"1":"key","key":"The mouse button, see input.MOUSE"}},{"ret":"True if the key was pressed","comment":["--- Gets whether the key was pressed this frame","-- @param key The key id, see input.KEY","-- @return True if the key was pressed"],"code":["function input_methods.wasKeyPressed( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.key[ key ] and keystate.key[ key ].wasPressed","end",""],"class":"function","name":"input_methods.wasKeyPressed","summary":"\nGets whether the key was pressed this frame ","private":false,"library":"input","description":"\nGets whether the key was pressed this frame","param":{"1":"key","key":"The key id, see input.KEY"}},{"ret":"True if the key was released","comment":["--- Gets whether the key was released this frame","-- @param key The key id, see input.KEY","-- @return True if the key was released"],"code":["function input_methods.wasKeyReleased( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.key\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.key[ key ] and keystate.key[ key ].wasReleased","end","","","for i = MOUSE_FIRST, MOUSE_LAST do","\tlastState.mouse[ i ] = false","\tkeystate.mouse[ i ] = {","\t\twasPressed = false,","\t\twasReleased = false","\t}","end","","local _MOUSENAMES = {","\t[ 107 ] = \"MOUSE1\",","\t[ 108 ] = \"MOUSE2\",","\t[ 109 ] = \"MOUSE3\",","\t[ 110 ] = \"MOUSE4\",","\t[ 111 ] = \"MOUSE5\",","\t[ 112 ] = \"MWHEELUP\",","\t[ 113 ] = \"MWHEELDOWN\"","}","","hook.Add( \"Think\", \"sf_keystate_mouse update\", function( )","\tfor i = MOUSE_FIRST, MOUSE_LAST do","\t\tlocal isKeyDown = input.IsMouseDown( i )","","\t\tlocal keyName = _MOUSENAMES[ i ]","","\t\tkeystate.mouse[ i ].wasPressed = isKeyDown and lastState.mouse[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.mouse[ i ] and keystate.mouse[ i ].wasPressed then","\t\t\trunInputHook( \"inputPressed\", \"mouse\", _MOUSENAMES[ i ]:upper( ) )","\t\tend","","\t\tkeystate.mouse[ i ].wasReleased = not isKeyDown and lastState.mouse[ i ] ~= isKeyDown or false","\t\tif keyName and keystate.mouse[ i ] and keystate.mouse[ i ].wasReleased then","\t\t\trunInputHook( \"inputReleased\", \"mouse\", _MOUSENAMES[ i ]:upper( ) )","\t\tend","","\t\tlastState.mouse[ i ] = isKeyDown","\tend","end )",""],"class":"function","name":"input_methods.wasKeyReleased","summary":"\nGets whether the key was released this frame ","private":false,"library":"input","description":"\nGets whether the key was released this frame","param":{"1":"key","key":"The key id, see input.KEY"}},{"classForced":true,"summary":"\nCalled when a button is pressed ","comment":["--- Called when a button is pressed","-- @name inputPressed","-- @class hook","-- @param name Name of the key"],"code":[""],"description":"\nCalled when a button is pressed","class":"hook","name":"inputPressed","param":{"1":"name","name":"Name of the key"}},{"classForced":true,"summary":"\nCalled when a button is released ","comment":["--- Called when a button is released","-- @name inputReleased","-- @class hook","-- @param name Name of the key"],"code":[""],"description":"\nCalled when a button is released","class":"hook","name":"inputReleased","param":{"1":"name","name":"Name of the key"}},{"ret":"True if the button was pressed","comment":["--- Gets whether the mouse button was pressed this frame","-- @param key The button id, see input.MOUSE","-- @return True if the button was pressed"],"code":["function input_methods.wasMBPressed( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.mouse[ key ] and keystate.mouse[ key ].wasPressed","end",""],"class":"function","name":"input_methods.wasMBPressed","summary":"\nGets whether the mouse button was pressed this frame ","private":false,"library":"input","description":"\nGets whether the mouse button was pressed this frame","param":{"1":"key","key":"The button id, see input.MOUSE"}},{"ret":"True if the button was released","comment":["--- Gets whether the mouse button was released this frame","-- @param key The key id, see input.MOUSE","-- @return True if the button was released"],"code":["function input_methods.wasMBReleased( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input.mouse\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn keystate.mouse[ key ] and keystate.mouse[ key ].wasReleased","end",""],"class":"function","name":"input_methods.wasMBReleased","summary":"\nGets whether the mouse button was released this frame ","private":false,"library":"input","description":"\nGets whether the mouse button was released this frame","param":{"1":"key","key":"The key id, see input.MOUSE"}},{"ret":"The name of the mouse button","comment":["--- Gets the name of a mouse button from the id","-- @param key The button id, see input.MOUSE","-- @return The name of the mouse button"],"code":["function input_methods.getMBName( key )","\tSF.CheckType( key, \"number\" )","","\tif not SF.Permissions.check( SF.instance.player, nil, \"input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\treturn _MOUSENAMES[ key ]","end"],"class":"function","name":"input_methods.getMBName","summary":"\nGets the name of a mouse button from the id ","private":false,"library":"input","description":"\nGets the name of a mouse button from the id","param":{"1":"key","key":"The button id, see input.MOUSE"}}],"tables":[],"description":"\nInput library.","summary":"\nInput library."},"libs_sh/bit.lua":{"libraries":{"1":"bit","bit":{"comment":["--- Bitwise library","-- @shared"],"functions":{"1":"arshift","2":"band","3":"bnot","4":"bor","5":"bswap","6":"bxor","7":"lshift","8":"rol","9":"ror","10":"rshift","11":"tobit","12":"tohex","band":{"ret":"Bitwise and of all values","comment":["--- Bitwise and","-- @param value1 First value","-- @param ... More values","-- @return Bitwise and of all values"],"code":["function bit_library.band ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.band( value1, ... )","end",""],"class":"function","name":"bit_library.band","summary":"\nBitwise and ","private":false,"library":"bit","description":"\nBitwise and","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"rshift":{"ret":"Shifted value","comment":["--- Shift right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.rshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.rshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.rshift","summary":"\nShift right ","private":false,"library":"bit","description":"\nShift right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"bor":{"ret":"Bitwise or of all values","comment":["--- Bitwise or","-- @param value1 First value","-- @param ... More values","-- @return Bitwise or of all values"],"code":["function bit_library.bor ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.bor( value1, ... )","end",""],"class":"function","name":"bit_library.bor","summary":"\nBitwise or ","private":false,"library":"bit","description":"\nBitwise or","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"bnot":{"ret":"Negated value","comment":["--- Bitwise not","-- Negates every bit","-- @param value Value to be modified","-- @return Negated value"],"code":["function bit_library.bnot ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.bnot( value )","end",""],"class":"function","name":"bit_library.bnot","summary":"\nBitwise not \nNegates every bit ","private":false,"library":"bit","description":"\nBitwise not \nNegates every bit","param":{"1":"value","value":"Value to be modified"}},"bswap":{"ret":"Value with swapped byte order","comment":["--- Swaps byte order","-- @param value Value to be modified","-- @return Value with swapped byte order"],"code":["function bit_library.bswap ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.bswap( value )","end",""],"class":"function","name":"bit_library.bswap","summary":"\nSwaps byte order ","private":false,"library":"bit","description":"\nSwaps byte order","param":{"1":"value","value":"Value to be modified"}},"bxor":{"ret":"Bitwise xor of all values","comment":["--- Bitwise xor","-- @param value1 First value","-- @param ... More values","-- @return Bitwise xor of all values"],"code":["function bit_library.bxor ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.bxor( value1, ... )","end",""],"class":"function","name":"bit_library.bxor","summary":"\nBitwise xor ","private":false,"library":"bit","description":"\nBitwise xor","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"tobit":{"ret":"Clamped value","comment":["--- Clamps to 32-bit integer","-- @param value Value to be modified","-- @return Clamped value"],"code":["function bit_library.tobit ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.tobit( value )","end",""],"class":"function","name":"bit_library.tobit","summary":"\nClamps to 32-bit integer ","private":false,"library":"bit","description":"\nClamps to 32-bit integer","param":{"1":"value","value":"Value to be modified"}},"ror":{"ret":"Rotated value","comment":["--- Rotate right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Rotated value"],"code":["function bit_library.ror ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.ror( value, shiftCount )","end",""],"class":"function","name":"bit_library.ror","summary":"\nRotate right ","private":false,"library":"bit","description":"\nRotate right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"lshift":{"ret":"Shifted value","comment":["--- Shift left","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.lshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.lshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.lshift","summary":"\nShift left ","private":false,"library":"bit","description":"\nShift left","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"tohex":{"ret":"Hexadecimal representation","comment":["--- Returns the hexadecimal representation of the value","-- @param value Value","-- @param digits Amounts of digits. Optional.","-- @return Hexadecimal representation"],"code":["function bit_library.tohex ( value, digits )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( digits, \"number\" )","","\treturn bit.tohex( value, digits )","end"],"class":"function","name":"bit_library.tohex","summary":"\nReturns the hexadecimal representation of the value ","private":false,"library":"bit","description":"\nReturns the hexadecimal representation of the value","param":{"1":"value","2":"digits","value":"Value","digits":"Amounts of digits. Optional."}},"arshift":{"ret":"Shifted value","comment":["--- Arithmetic shift right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.arshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.arshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.arshift","summary":"\nArithmetic shift right ","private":false,"library":"bit","description":"\nArithmetic shift right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"rol":{"ret":"Rotated value","comment":["--- Rotate left","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Rotated value"],"code":["function bit_library.rol ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.rol( value, shiftCount )","end",""],"class":"function","name":"bit_library.rol","summary":"\nRotate left ","private":false,"library":"bit","description":"\nRotate left","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}}},"class":"library","summary":"\nBitwise library ","code":["local bit_library, _ = SF.Libraries.Register( \"bit\" )","local bit = bit",""],"fields":[],"name":"bit","client":true,"description":"\nBitwise library","libtbl":"bit_library","tables":[],"server":true}},"type":"file","name":"libs_sh/bit.lua","functions":{"1":"bit_library.arshift","2":"bit_library.band","3":"bit_library.bnot","4":"bit_library.bor","5":"bit_library.bswap","6":"bit_library.bxor","7":"bit_library.lshift","8":"bit_library.rol","9":"bit_library.ror","10":"bit_library.rshift","11":"bit_library.tobit","12":"bit_library.tohex","bit_library.band":{"ret":"Bitwise and of all values","comment":["--- Bitwise and","-- @param value1 First value","-- @param ... More values","-- @return Bitwise and of all values"],"code":["function bit_library.band ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.band( value1, ... )","end",""],"class":"function","name":"bit_library.band","summary":"\nBitwise and ","private":false,"library":"bit","description":"\nBitwise and","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"bit_library.bswap":{"ret":"Value with swapped byte order","comment":["--- Swaps byte order","-- @param value Value to be modified","-- @return Value with swapped byte order"],"code":["function bit_library.bswap ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.bswap( value )","end",""],"class":"function","name":"bit_library.bswap","summary":"\nSwaps byte order ","private":false,"library":"bit","description":"\nSwaps byte order","param":{"1":"value","value":"Value to be modified"}},"bit_library.arshift":{"ret":"Shifted value","comment":["--- Arithmetic shift right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.arshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.arshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.arshift","summary":"\nArithmetic shift right ","private":false,"library":"bit","description":"\nArithmetic shift right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"bit_library.bor":{"ret":"Bitwise or of all values","comment":["--- Bitwise or","-- @param value1 First value","-- @param ... More values","-- @return Bitwise or of all values"],"code":["function bit_library.bor ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.bor( value1, ... )","end",""],"class":"function","name":"bit_library.bor","summary":"\nBitwise or ","private":false,"library":"bit","description":"\nBitwise or","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"bit_library.tohex":{"ret":"Hexadecimal representation","comment":["--- Returns the hexadecimal representation of the value","-- @param value Value","-- @param digits Amounts of digits. Optional.","-- @return Hexadecimal representation"],"code":["function bit_library.tohex ( value, digits )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( digits, \"number\" )","","\treturn bit.tohex( value, digits )","end"],"class":"function","name":"bit_library.tohex","summary":"\nReturns the hexadecimal representation of the value ","private":false,"library":"bit","description":"\nReturns the hexadecimal representation of the value","param":{"1":"value","2":"digits","value":"Value","digits":"Amounts of digits. Optional."}},"bit_library.tobit":{"ret":"Clamped value","comment":["--- Clamps to 32-bit integer","-- @param value Value to be modified","-- @return Clamped value"],"code":["function bit_library.tobit ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.tobit( value )","end",""],"class":"function","name":"bit_library.tobit","summary":"\nClamps to 32-bit integer ","private":false,"library":"bit","description":"\nClamps to 32-bit integer","param":{"1":"value","value":"Value to be modified"}},"bit_library.rshift":{"ret":"Shifted value","comment":["--- Shift right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.rshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.rshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.rshift","summary":"\nShift right ","private":false,"library":"bit","description":"\nShift right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"bit_library.bnot":{"ret":"Negated value","comment":["--- Bitwise not","-- Negates every bit","-- @param value Value to be modified","-- @return Negated value"],"code":["function bit_library.bnot ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.bnot( value )","end",""],"class":"function","name":"bit_library.bnot","summary":"\nBitwise not \nNegates every bit ","private":false,"library":"bit","description":"\nBitwise not \nNegates every bit","param":{"1":"value","value":"Value to be modified"}},"bit_library.bxor":{"ret":"Bitwise xor of all values","comment":["--- Bitwise xor","-- @param value1 First value","-- @param ... More values","-- @return Bitwise xor of all values"],"code":["function bit_library.bxor ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.bxor( value1, ... )","end",""],"class":"function","name":"bit_library.bxor","summary":"\nBitwise xor ","private":false,"library":"bit","description":"\nBitwise xor","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"bit_library.ror":{"ret":"Rotated value","comment":["--- Rotate right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Rotated value"],"code":["function bit_library.ror ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.ror( value, shiftCount )","end",""],"class":"function","name":"bit_library.ror","summary":"\nRotate right ","private":false,"library":"bit","description":"\nRotate right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"bit_library.lshift":{"ret":"Shifted value","comment":["--- Shift left","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.lshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.lshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.lshift","summary":"\nShift left ","private":false,"library":"bit","description":"\nShift left","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"bit_library.rol":{"ret":"Rotated value","comment":["--- Rotate left","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Rotated value"],"code":["function bit_library.rol ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.rol( value, shiftCount )","end",""],"class":"function","name":"bit_library.rol","summary":"\nRotate left ","private":false,"library":"bit","description":"\nRotate left","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}}},"doc":[{"summary":"\nBitwise library ","description":"\nBitwise library","comment":["--- Bitwise library"],"code":[""]},{"comment":["--- Bitwise library","-- @shared"],"functions":{"1":"arshift","2":"band","3":"bnot","4":"bor","5":"bswap","6":"bxor","7":"lshift","8":"rol","9":"ror","10":"rshift","11":"tobit","12":"tohex","band":{"ret":"Bitwise and of all values","comment":["--- Bitwise and","-- @param value1 First value","-- @param ... More values","-- @return Bitwise and of all values"],"code":["function bit_library.band ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.band( value1, ... )","end",""],"class":"function","name":"bit_library.band","summary":"\nBitwise and ","private":false,"library":"bit","description":"\nBitwise and","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"rshift":{"ret":"Shifted value","comment":["--- Shift right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.rshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.rshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.rshift","summary":"\nShift right ","private":false,"library":"bit","description":"\nShift right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"bor":{"ret":"Bitwise or of all values","comment":["--- Bitwise or","-- @param value1 First value","-- @param ... More values","-- @return Bitwise or of all values"],"code":["function bit_library.bor ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.bor( value1, ... )","end",""],"class":"function","name":"bit_library.bor","summary":"\nBitwise or ","private":false,"library":"bit","description":"\nBitwise or","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"bnot":{"ret":"Negated value","comment":["--- Bitwise not","-- Negates every bit","-- @param value Value to be modified","-- @return Negated value"],"code":["function bit_library.bnot ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.bnot( value )","end",""],"class":"function","name":"bit_library.bnot","summary":"\nBitwise not \nNegates every bit ","private":false,"library":"bit","description":"\nBitwise not \nNegates every bit","param":{"1":"value","value":"Value to be modified"}},"bswap":{"ret":"Value with swapped byte order","comment":["--- Swaps byte order","-- @param value Value to be modified","-- @return Value with swapped byte order"],"code":["function bit_library.bswap ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.bswap( value )","end",""],"class":"function","name":"bit_library.bswap","summary":"\nSwaps byte order ","private":false,"library":"bit","description":"\nSwaps byte order","param":{"1":"value","value":"Value to be modified"}},"bxor":{"ret":"Bitwise xor of all values","comment":["--- Bitwise xor","-- @param value1 First value","-- @param ... More values","-- @return Bitwise xor of all values"],"code":["function bit_library.bxor ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.bxor( value1, ... )","end",""],"class":"function","name":"bit_library.bxor","summary":"\nBitwise xor ","private":false,"library":"bit","description":"\nBitwise xor","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},"tobit":{"ret":"Clamped value","comment":["--- Clamps to 32-bit integer","-- @param value Value to be modified","-- @return Clamped value"],"code":["function bit_library.tobit ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.tobit( value )","end",""],"class":"function","name":"bit_library.tobit","summary":"\nClamps to 32-bit integer ","private":false,"library":"bit","description":"\nClamps to 32-bit integer","param":{"1":"value","value":"Value to be modified"}},"ror":{"ret":"Rotated value","comment":["--- Rotate right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Rotated value"],"code":["function bit_library.ror ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.ror( value, shiftCount )","end",""],"class":"function","name":"bit_library.ror","summary":"\nRotate right ","private":false,"library":"bit","description":"\nRotate right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"lshift":{"ret":"Shifted value","comment":["--- Shift left","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.lshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.lshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.lshift","summary":"\nShift left ","private":false,"library":"bit","description":"\nShift left","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"tohex":{"ret":"Hexadecimal representation","comment":["--- Returns the hexadecimal representation of the value","-- @param value Value","-- @param digits Amounts of digits. Optional.","-- @return Hexadecimal representation"],"code":["function bit_library.tohex ( value, digits )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( digits, \"number\" )","","\treturn bit.tohex( value, digits )","end"],"class":"function","name":"bit_library.tohex","summary":"\nReturns the hexadecimal representation of the value ","private":false,"library":"bit","description":"\nReturns the hexadecimal representation of the value","param":{"1":"value","2":"digits","value":"Value","digits":"Amounts of digits. Optional."}},"arshift":{"ret":"Shifted value","comment":["--- Arithmetic shift right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.arshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.arshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.arshift","summary":"\nArithmetic shift right ","private":false,"library":"bit","description":"\nArithmetic shift right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},"rol":{"ret":"Rotated value","comment":["--- Rotate left","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Rotated value"],"code":["function bit_library.rol ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.rol( value, shiftCount )","end",""],"class":"function","name":"bit_library.rol","summary":"\nRotate left ","private":false,"library":"bit","description":"\nRotate left","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}}},"class":"library","summary":"\nBitwise library ","code":["local bit_library, _ = SF.Libraries.Register( \"bit\" )","local bit = bit",""],"fields":[],"name":"bit","client":true,"description":"\nBitwise library","libtbl":"bit_library","tables":[],"server":true},{"ret":"Shifted value","comment":["--- Arithmetic shift right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.arshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.arshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.arshift","summary":"\nArithmetic shift right ","private":false,"library":"bit","description":"\nArithmetic shift right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},{"ret":"Bitwise and of all values","comment":["--- Bitwise and","-- @param value1 First value","-- @param ... More values","-- @return Bitwise and of all values"],"code":["function bit_library.band ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.band( value1, ... )","end",""],"class":"function","name":"bit_library.band","summary":"\nBitwise and ","private":false,"library":"bit","description":"\nBitwise and","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},{"ret":"Negated value","comment":["--- Bitwise not","-- Negates every bit","-- @param value Value to be modified","-- @return Negated value"],"code":["function bit_library.bnot ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.bnot( value )","end",""],"class":"function","name":"bit_library.bnot","summary":"\nBitwise not \nNegates every bit ","private":false,"library":"bit","description":"\nBitwise not \nNegates every bit","param":{"1":"value","value":"Value to be modified"}},{"ret":"Bitwise or of all values","comment":["--- Bitwise or","-- @param value1 First value","-- @param ... More values","-- @return Bitwise or of all values"],"code":["function bit_library.bor ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.bor( value1, ... )","end",""],"class":"function","name":"bit_library.bor","summary":"\nBitwise or ","private":false,"library":"bit","description":"\nBitwise or","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},{"ret":"Value with swapped byte order","comment":["--- Swaps byte order","-- @param value Value to be modified","-- @return Value with swapped byte order"],"code":["function bit_library.bswap ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.bswap( value )","end",""],"class":"function","name":"bit_library.bswap","summary":"\nSwaps byte order ","private":false,"library":"bit","description":"\nSwaps byte order","param":{"1":"value","value":"Value to be modified"}},{"ret":"Bitwise xor of all values","comment":["--- Bitwise xor","-- @param value1 First value","-- @param ... More values","-- @return Bitwise xor of all values"],"code":["function bit_library.bxor ( value1, ... )","\tSF.CheckType( value1, \"number\" )","\tfor _, v in ipairs( { ... } ) do","\t\tSF.CheckType( v, \"number\" )","\tend","","\treturn bit.bxor( value1, ... )","end",""],"class":"function","name":"bit_library.bxor","summary":"\nBitwise xor ","private":false,"library":"bit","description":"\nBitwise xor","param":{"1":"value1","2":"...","...":"More values","value1":"First value"}},{"ret":"Shifted value","comment":["--- Shift left","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.lshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.lshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.lshift","summary":"\nShift left ","private":false,"library":"bit","description":"\nShift left","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},{"ret":"Rotated value","comment":["--- Rotate left","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Rotated value"],"code":["function bit_library.rol ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.rol( value, shiftCount )","end",""],"class":"function","name":"bit_library.rol","summary":"\nRotate left ","private":false,"library":"bit","description":"\nRotate left","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},{"ret":"Rotated value","comment":["--- Rotate right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Rotated value"],"code":["function bit_library.ror ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.ror( value, shiftCount )","end",""],"class":"function","name":"bit_library.ror","summary":"\nRotate right ","private":false,"library":"bit","description":"\nRotate right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},{"ret":"Shifted value","comment":["--- Shift right","-- @param value Value to be modified","-- @param shiftCount Amounts of bits to shift","-- @return Shifted value"],"code":["function bit_library.rshift ( value, shiftCount )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( shiftCount, \"number\" )","","\treturn bit.rshift( value, shiftCount )","end",""],"class":"function","name":"bit_library.rshift","summary":"\nShift right ","private":false,"library":"bit","description":"\nShift right","param":{"1":"value","2":"shiftCount","value":"Value to be modified","shiftCount":"Amounts of bits to shift"}},{"ret":"Clamped value","comment":["--- Clamps to 32-bit integer","-- @param value Value to be modified","-- @return Clamped value"],"code":["function bit_library.tobit ( value )","\tSF.CheckType( value, \"number\" )","","\treturn bit.tobit( value )","end",""],"class":"function","name":"bit_library.tobit","summary":"\nClamps to 32-bit integer ","private":false,"library":"bit","description":"\nClamps to 32-bit integer","param":{"1":"value","value":"Value to be modified"}},{"ret":"Hexadecimal representation","comment":["--- Returns the hexadecimal representation of the value","-- @param value Value","-- @param digits Amounts of digits. Optional.","-- @return Hexadecimal representation"],"code":["function bit_library.tohex ( value, digits )","\tSF.CheckType( value, \"number\" )","\tSF.CheckType( digits, \"number\" )","","\treturn bit.tohex( value, digits )","end"],"class":"function","name":"bit_library.tohex","summary":"\nReturns the hexadecimal representation of the value ","private":false,"library":"bit","description":"\nReturns the hexadecimal representation of the value","param":{"1":"value","2":"digits","value":"Value","digits":"Amounts of digits. Optional."}}],"tables":[],"description":"\nBitwise library","summary":"\nBitwise library "},"editor.lua":{"libraries":[],"type":"file","name":"editor.lua","functions":{"1":"SF.Editor.BuildIncludesTable","SF.Editor.BuildIncludesTable":{"ret":["True if ok, false if a file was missing","A table with mainfile = codename and files = a table of filenames and their contents, or the missing file path."],"comment":["\t--- (Client) Builds a table for the compiler to use","\t-- @param maincode The source code for the main chunk","\t-- @param codename The name of the main chunk","\t-- @return True if ok, false if a file was missing","\t-- @return A table with mainfile = codename and files = a table of filenames and their contents, or the missing file path."],"code":["\tfunction SF.Editor.BuildIncludesTable ( maincode, codename )","\t\tif not SF.Editor.initialized then SF.Editor.init() return false, \"Editor needs to finish loading...\" end","\t\tlocal tbl = {}","\t\tmaincode = maincode or SF.Editor.getCode()","\t\tcodename = codename or SF.Editor.getOpenFile() or \"main\"","\t\ttbl.mainfile = codename","\t\ttbl.files = {}","\t\ttbl.filecount = 0","\t\ttbl.includes = {}","","\t\tlocal loaded = {}","\t\tlocal ppdata = {}","","\t\tlocal function recursiveLoad ( path )","\t\t\tif loaded[ path ] then return end","\t\t\tloaded[ path ] = true","\t\t\t","\t\t\tlocal code","\t\t\tif path == codename and maincode then","\t\t\t\tcode = maincode","\t\t\telse","\t\t\t\tcode = file.Read( \"starfall/\"..path, \"DATA\" ) or error( \"Bad include: \" .. path, 0 )","\t\t\tend","\t\t\t","\t\t\ttbl.files[ path ] = code","\t\t\tSF.Preprocessor.ParseDirectives( path, code, {}, ppdata )","\t\t\t","\t\t\tif ppdata.includes and ppdata.includes[ path ] then","\t\t\t\tlocal inc = ppdata.includes[ path ]","\t\t\t\tif not tbl.includes[ path ] then","\t\t\t\t\ttbl.includes[ path ] = inc","\t\t\t\t\ttbl.filecount = tbl.filecount + 1","\t\t\t\telse","\t\t\t\t\tassert( tbl.includes[ path ] == inc )","\t\t\t\tend","\t\t\t\t","\t\t\t\tfor i = 1, #inc do","\t\t\t\t\trecursiveLoad( inc[i] )","\t\t\t\tend","\t\t\tend","\t\tend","\t\tlocal ok, msg = pcall( recursiveLoad, codename )","","\t\tlocal function findCycle ( file, visited, recStack )","\t\t\tif not visited[ file ] then","\t\t\t\t--Mark the current file as visited and part of recursion stack","\t\t\t\tvisited[ file ] = true","\t\t\t\trecStack[ file ] = true","","\t\t\t\t--Recurse for all the files included in this file","\t\t\t\tfor k, v in pairs( ppdata.includes[ file ] or {} ) do","\t\t\t\t\tif recStack[ v ] then","\t\t\t\t\t\treturn true, file","\t\t\t\t\telseif not visited[ v ] then","\t\t\t\t\t\tlocal cyclic, cyclicFile = findCycle( v, visited, recStack )","\t\t\t\t\t\tif cyclic then return true, cyclicFile end","\t\t\t\t\tend","\t\t\t\tend","\t\t\tend","\t\t\t","\t\t\t--Remove this file from the recursion stack","\t\t\trecStack[ file ] = false","\t\t\treturn false, nil","\t\tend","","\t\tlocal isCyclic = false","\t\tlocal cyclicFile = nil","\t\tfor k, v in pairs( ppdata.includes or {} ) do","\t\t\tlocal cyclic, file = findCycle( k, {}, {} )","\t\t\tif cyclic then","\t\t\t\tisCyclic = true","\t\t\t\tcyclicFile = file","\t\t\t\tbreak","\t\t\tend","\t\tend","\t\t","\t\tif isCyclic then","\t\t\treturn false, \"Loop in includes from: \" .. cyclicFile","\t\tend","","\t\tif ok then","\t\t\treturn true, tbl","\t\telseif msg:sub( 1, 13 ) == \"Bad include: \" then","\t\t\treturn false, msg","\t\telse","\t\t\terror( msg, 0 )","\t\tend","\tend","","\t-- CLIENT ANIMATION","","\tlocal busy_players = { }","\thook.Add( \"EntityRemoved\", \"starfall_busy_animation\", function ( ply )","\t\tbusy_players[ ply ] = nil","\tend )","","\tlocal emitter = ParticleEmitter( vector_origin )","","\tnet.Receive( \"starfall_editor_status\", function ( len )","\t\tlocal ply = net.ReadEntity()","\t\tlocal status = net.ReadBit() ~= 0 -- net.ReadBit returns 0 or 1, despite net.WriteBit taking a boolean","\t\tif not ply:IsValid() or ply == LocalPlayer() then return end","","\t\tbusy_players[ ply ] = status or nil","\tend )","","\tlocal rolldelta = math.rad( 80 )","\ttimer.Create( \"starfall_editor_status\", 1 / 3, 0, function ()","\t\trolldelta = -rolldelta","\t\tfor ply, _ in pairs( busy_players ) do","\t\t\tlocal BoneIndx = ply:LookupBone( \"ValveBiped.Bip01_Head1\" ) or ply:LookupBone( \"ValveBiped.HC_Head_Bone\" ) or 0","\t\t\tlocal BonePos, BoneAng = ply:GetBonePosition( BoneIndx )","\t\t\tlocal particle = emitter:Add( \"radon/starfall2\", BonePos + Vector( math.random( -10, 10 ), math.random( -10, 10 ), 60 + math.random( 0, 10 ) ) )","\t\t\tif particle then","\t\t\t\tparticle:SetColor( math.random( 30, 50 ), math.random( 40, 150 ), math.random( 180, 220 ) )","\t\t\t\tparticle:SetVelocity( Vector( 0, 0, -40 ) )","","\t\t\t\tparticle:SetDieTime( 1.5 )","\t\t\t\tparticle:SetLifeTime( 0 )","","\t\t\t\tparticle:SetStartSize( 10 )","\t\t\t\tparticle:SetEndSize( 5 )","","\t\t\t\tparticle:SetStartAlpha( 255 )","\t\t\t\tparticle:SetEndAlpha( 0 )","","\t\t\t\tparticle:SetRollDelta( rolldelta )","\t\t\tend","\t\tend","\tend )","","elseif SERVER then","","\tutil.AddNetworkString( \"starfall_editor_status\" )","","\tlocal function getFiles ( dir, dir2 )","\t\tlocal files = {}","\t\tlocal dir2 = dir2 or \"\"","\t\tlocal f, directories = file.Find( dir .. \"/\" .. dir2 .. \"/*\", \"GAME\" )","\t\tfor k, v in pairs( f ) do","\t\t\tfiles[ #files + 1 ] = dir2 .. \"/\" .. v","\t\tend","\t\tfor k, v in pairs( directories ) do","\t\t\ttable.Add( files, getFiles( dir, dir2 .. \"/\" .. v ) )","\t\tend","\t\treturn files","\tend","","\tfor k, v in pairs( getFiles( addon_path, \"materials/radon\" ) ) do","\t\tresource.AddFile( v )","\tend","","\tlocal starfall_event = {}","","\tconcommand.Add( \"starfall_event\", function ( ply, command, args )","\t\tlocal handler = starfall_event[ args[ 1 ] ]","\t\tif not handler then return end","\t\treturn handler( ply, args )","\tend )","","\tfunction starfall_event.editor_open ( ply, args )","\t\tnet.Start( \"starfall_editor_status\" )","\t\tnet.WriteEntity( ply )","\t\tnet.WriteBit( true )","\t\tnet.Broadcast()","\tend","","\tfunction starfall_event.editor_close ( ply, args )","\t\tnet.Start( \"starfall_editor_status\" )","\t\tnet.WriteEntity( ply )","\t\tnet.WriteBit( false )","\t\tnet.Broadcast()","\tend","end"],"class":"function","name":"SF.Editor.BuildIncludesTable","private":false,"summary":"\n(Client) Builds a table for the compiler to use ","description":"\n(Client) Builds a table for the compiler to use","param":{"1":"maincode","2":"codename","codename":"The name of the main chunk","maincode":"The source code for the main chunk"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","--\tSF Editor","--\tOriginally created by Jazzelhawk","--\t","--\tTo do:","--\tFind new icons","-------------------------------------------------------------------------------"],"code":["","SF.Editor = {}","","local addon_path = nil","","do","\tlocal tbl = debug.getinfo( 1 )","\tlocal file = tbl.short_src","\taddon_path = string.TrimRight( string.match( file, \".-/.-/\" ), \"/\" )","end","","if CLIENT then","","\tinclude( \"sfderma.lua\" )","","\t-- Colors","\tSF.Editor.colors = {}","\tSF.Editor.colors.dark \t\t= Color( 36, 41, 53 )","\tSF.Editor.colors.meddark \t= Color( 48, 57, 92 )","\tSF.Editor.colors.med \t\t= Color( 78, 122, 199 )","\tSF.Editor.colors.medlight \t= Color( 127, 178, 240 )","\tSF.Editor.colors.light \t\t= Color( 173, 213, 247 )","","\t-- Icons","\tSF.Editor.icons = {}","\tSF.Editor.icons.arrowr \t\t= Material( \"radon/arrow_right.png\", \"noclamp smooth\" )","\tSF.Editor.icons.arrowl \t\t= Material( \"radon/arrow_left.png\", \"noclamp smooth\" )","","\tlocal defaultCode = [[--@name ","--@author ","","--[[","\tStarfall Scripting Environment","","\tMore info: http://inpstarfall.github.io/Starfall","\tGithub: http://github.com/INPStarfall/Starfall","\tReference Page: http://sf.inp.io","\tDevelopment Thread: http://www.wiremod.com/forum/developers-showcase/22739-starfall-processor.html","","\tDefault Keyboard shortcuts: https://github.com/ajaxorg/ace/wiki/Default-Keyboard-Shortcuts","]]..\"]]\"","","\tlocal invalid_filename_chars = {","\t\t[\"*\"] = \"\",","\t\t[\"?\"] = \"\",","\t\t[\">\"] = \"\",","\t\t[\"<\"] = \"\",","\t\t[\"|\"] = \"\",","\t\t[\"\\\\\"] = \"\",","\t\t['\"'] = \"\",","\t}","","\tCreateClientConVar( \"sf_editor_width\", 1100, true, false )","\tCreateClientConVar( \"sf_editor_height\", 760, true, false )","\tCreateClientConVar( \"sf_editor_posx\", ScrW()/2-1100/2, true, false )","\tCreateClientConVar( \"sf_editor_posy\", ScrH()/2-760/2, true, false )","","\tCreateClientConVar( \"sf_fileviewer_width\", 263, true, false )","\tCreateClientConVar( \"sf_fileviewer_height\", 760, true, false )","\tCreateClientConVar( \"sf_fileviewer_posx\", ScrW()/2-1100/2-263, true, false )","\tCreateClientConVar( \"sf_fileviewer_posy\", ScrH()/2-760/2, true, false )","\tCreateClientConVar( \"sf_fileviewer_locked\", 1, true, false )","","\tCreateClientConVar( \"sf_editor_widgets\", 1, true, false )","\tCreateClientConVar( \"sf_editor_linenumbers\", 1, true, false )","\tCreateClientConVar( \"sf_editor_gutter\", 1, true, false )","\tCreateClientConVar( \"sf_editor_invisiblecharacters\", 0, true, false )","\tCreateClientConVar( \"sf_editor_indentguides\", 1, true, false )","\tCreateClientConVar( \"sf_editor_activeline\", 1, true, false )","\tCreateClientConVar( \"sf_editor_autocompletion\", 1, true, false )","\tCreateClientConVar( \"sf_editor_fixkeys\", system.IsLinux() and 1 or 0, true, false ) --maybe osx too? need someone to check","\tCreateClientConVar( \"sf_editor_fixconsolebug\", 0, true, false )","","\tlocal editorUrl = \"http://thegrb93.github.io/StarfallEx/starfall/\"","\tlocal htmlEditorCode = nil","\tlocal initializingEditor = false","","\tfunction SF.Editor.init ( leave_open )","\t\tif initializingEditor then ","\t\t\tSF.AddNotify( LocalPlayer(), \"Editor is busy loading...\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 ) ","\t\t\treturn","\t\tend","\t\t","\t\tif not htmlEditorCode then","\t\t\t","\t\t\tinitializingEditor = true","\t\t\tSF.AddNotify( LocalPlayer(), \"Loading editor now...\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 ) ","\t\t\t","\t\t\tlocal function finishedInit(successful, error_code)","\t\t\t\tif not initializingEditor then return end","\t\t\t\tinitializingEditor = false","\t\t\t\thook.Remove(\"Think\", \"SF_LoadingEditor\")","\t\t\t\tif successful then","\t\t\t\t\tSF.Editor.init ( leave_open )","\t\t\t\telse","\t\t\t\t\tprint(\"Starfall failed to load editor, Error: \", error_code) ","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"Failed to load the editor...\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\t\t\t\tend","\t\t\tend","\t\t\t","\t\t\tlocal aceFiles = {\"ace/ace.js\", \"ace/ext-whitespace.js\", \"ace/ext-elastic_tabstops_lite.js\", \"ace/mode-lua.js\", \"ace/ext-emmet.js\", \"ace/ext-split.js\", \"ace/ext-old_ie.js\", \"ace/worker-lua.js\", \"ace/ext-linking.js\", \"ace/ext-beautify.js\", \"ace/ext-modelist.js\", \"ace/ext-textarea.js\", \"ace/ext-chromevox.js\", \"ace/ext-searchbox.js\", \"ace/ext-statusbar.js\", \"ace/ext-themelist.js\", \"ace/theme-monokai.js\", \"ace/ext-spellcheck.js\", \"ace/keybinding-vim.js\", \"ace/ext-error_marker.js\", \"ace/keybinding-emacs.js\", \"ace/ext-settings_menu.js\", \"ace/ext-language_tools.js\", \"ace/ext-keybinding_menu.js\", \"ace/ext-static_highlight.js\",}","\t\t\tlocal editorcode","\t\t\tlocal editorscripts = {}","\t\t\tlocal function getAceFile()","\t\t\t\tif not initializingEditor then return end","\t\t\t\tlocal nextindex = #editorscripts + 1","\t\t\t\tif aceFiles[nextindex] then","\t\t\t\t\thttp.Fetch( editorUrl..aceFiles[nextindex], ","\t\t\t\t\tfunction( body, len, headers, code )","\t\t\t\t\t\teditorscripts[nextindex] = \"<script>\\n\" .. body .. \"</script>\\n\"","\t\t\t\t\t\tgetAceFile()","\t\t\t\t\tend, ","\t\t\t\t\tfunction( error_code ) ","\t\t\t\t\t\tfinishedInit( false, error_code )","\t\t\t\t\tend )","\t\t\t\telse","\t\t\t\t\thtmlEditorCode = editorcode:Replace( \"<script>//replace//</script>\",  table.concat( editorscripts ) )","\t\t\t\tend","\t\t\tend","\t\t\tlocal function getEditorFile()","\t\t\t\thttp.Fetch( editorUrl..\"editor.html\", ","\t\t\t\tfunction( body, len, headers, code )","\t\t\t\t\teditorcode = body","\t\t\t\t\tgetAceFile()","\t\t\t\tend, ","\t\t\t\tfunction( error_code ) ","\t\t\t\t\tfinishedInit( false, error_code )","\t\t\t\tend )","\t\t\tend","\t\t\tgetEditorFile()","\t\t\t","\t\t\tlocal timeout = CurTime() + 30","\t\t\thook.Add(\"Think\", \"SF_LoadingEditor\", function()","\t\t\t\tif htmlEditorCode then","\t\t\t\t\tfinishedInit( true )","\t\t\t\telse","\t\t\t\t\tif CurTime() > timeout then","\t\t\t\t\t\tfinishedInit( false, \"Download Timed Out\" )","\t\t\t\t\tend","\t\t\t\tend","\t\t\tend)","\t\t\t","\t\t\treturn ","\t\tend","","\t\tif not file.Exists( \"starfall\", \"DATA\" ) then","\t\t\tfile.CreateDir( \"starfall\" )","\t\tend","","\t\tSF.Editor.editor = SF.Editor.createEditor()","\t\tSF.Editor.fileViewer = SF.Editor.createFileViewer()","\t\tSF.Editor.fileViewer:close()","\t\tSF.Editor.settingsWindow = SF.Editor.createSettingsWindow()","\t\tSF.Editor.settingsWindow:close()","","\t\tSF.Editor.runJS = function ( ... ) ","\t\t\tSF.Editor.editor.components.htmlPanel:QueueJavascript( ... )","\t\tend","","\t\tSF.Editor.updateSettings()","","\t\tlocal tabs = util.JSONToTable( file.Read( \"sf_tabs.txt\" ) or \"\" )","\t\tif tabs ~= nil and #tabs ~= 0 then","\t\t\tfor k, v in pairs( tabs ) do","\t\t\t\tif type( v ) ~= \"number\" then","\t\t\t\t\tSF.Editor.addTab( v.filename, v.code )","\t\t\t\tend","\t\t\tend","\t\t\tSF.Editor.selectTab( tabs.selectedTab or 1 )","\t\telse","\t\t\tSF.Editor.addTab()","\t\tend","","\t\tSF.Editor.editor:close()","\t\tSF.Editor.initialized = true","\t\tif leave_open then","\t\t\tSF.Editor.open()","\t\tend","\t\t","\t\treturn true","\tend","","\tfunction SF.Editor.open ()","\t\tif not SF.Editor.initialized then","\t\t\tSF.Editor.init ( true )","\t\t\treturn false","\t\tend","","\t\tSF.Editor.editor:open()","","\t\tif CanRunConsoleCommand() then","\t\t\tRunConsoleCommand( \"starfall_event\", \"editor_open\" )","\t\tend","\t\treturn true","\tend","","\tfunction SF.Editor.close ()","\t\tSF.Editor.editor:close()","","\t\tif CanRunConsoleCommand() then","\t\t\tRunConsoleCommand( \"starfall_event\", \"editor_close\" )","\t\tend","\tend","","\tfunction SF.Editor.updateCode () -- Incase anyone needs to force update the code","\t\tSF.Editor.runJS( \"console.log(\\\"RUNLUA:SF.Editor.getActiveTab().code = \\\\\\\"\\\" + addslashes(editor.getValue()) + \\\"\\\\\\\"\\\")\" )","\tend","","\tfunction SF.Editor.getCode ()","\t\treturn SF.Editor.getActiveTab().code","\tend","","\tfunction SF.Editor.getOpenFile ()","\t\treturn SF.Editor.getActiveTab().filename","\tend","","\tfunction SF.Editor.getTabHolder ()","\t\treturn SF.Editor.editor.components[ \"tabHolder\" ]","\tend","","\tfunction SF.Editor.getActiveTab ()","\t\treturn SF.Editor.getTabHolder():getActiveTab()","\tend","","\tfunction SF.Editor.selectTab ( tab )","\t\tlocal tabHolder = SF.Editor.getTabHolder()","\t\tif type( tab ) == \"number\" then","\t\t\ttab = math.min( tab, #tabHolder.tabs )","\t\t\ttab = tabHolder.tabs[ tab ]  ","\t\tend","\t\tif tab == nil then","\t\t\tSF.Editor.selectTab( 1 )","\t\t\treturn","\t\tend","","\t\ttabHolder:selectTab( tab )","","\t\tSF.Editor.runJS( \"selectEditSession(\"..tabHolder:getTabIndex( tab )..\")\" )","\tend","","\tfunction SF.Editor.addTab ( filename, code )","","\t\tlocal name = filename or \"generic\"","","\t\tif code then","\t\t\tlocal ppdata = {}","\t\t\tSF.Preprocessor.ParseDirectives( \"file\", code, {}, ppdata )","\t\t\tif ppdata.scriptnames and ppdata.scriptnames.file ~= \"\" then ","\t\t\t\tname = ppdata.scriptnames.file","\t\t\tend","\t\tend","","\t\tcode = code or defaultCode","","\t\tSF.Editor.runJS( \"newEditSession(\\\"\"..string.JavascriptSafe( code or defaultCode )..\"\\\")\" )","","\t\tlocal tab = SF.Editor.getTabHolder():addTab( name )","\t\ttab.code = code","\t\ttab.name = name","\t\ttab.filename = filename","","\t\tfunction tab:DoClick ()","\t\t\tSF.Editor.selectTab( self )","\t\tend","","\t\tSF.Editor.selectTab( tab )","\tend","","\tfunction SF.Editor.removeTab ( tab )","\t\tlocal tabHolder = SF.Editor.getTabHolder()","\t\tif type( tab ) == \"number\" then","\t\t\ttab = tabHolder.tabs[ tab ]  ","\t\tend","\t\tif tab == nil then return end","","\t\ttabHolder:removeTab( tab )","\tend","","\tfunction SF.Editor.saveTab ( tab )","\t\tif not tab.filename then SF.Editor.saveTabAs( tab ) return end","\t\tlocal saveFile = \"starfall/\" .. tab.filename","\t\tfile.Write( saveFile, tab.code )","\t\tSF.Editor.updateTabName( tab )","\t\tSF.AddNotify( LocalPlayer(), \"Starfall code saved as \" .. saveFile .. \".\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\tend","","\tfunction SF.Editor.saveTabAs ( tab )","","\t\tSF.Editor.updateTabName( tab )","","\t\tlocal saveName = \"\"","\t\tif tab.filename then","\t\t\tsaveName = string.StripExtension( tab.filename )","\t\telse","\t\t\tsaveName = tab.name or \"generic\"","\t\tend","","\t\tDerma_StringRequestNoBlur(","\t\t\t\t\"Save File\",","\t\t\t\t\"\",","\t\t\t\tsaveName,","\t\t\t\tfunction ( text )","\t\t\t\t\tif text == \"\" then return end","\t\t\t\t\ttext = string.gsub( text, \".\", invalid_filename_chars )","\t\t\t\t\tlocal saveFile = \"starfall/\" .. text .. \".txt\"","\t\t\t\t\tfile.Write( saveFile, tab.code )","\t\t\t\t\tSF.AddNotify( LocalPlayer(), \"Starfall code saved as \" .. saveFile .. \".\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\t\t\t\t\tSF.Editor.fileViewer.components[ \"browser\" ].tree:reloadTree()","\t\t\t\t\ttab.filename = text .. \".txt\"","\t\t\t\t\tSF.Editor.updateTabName( tab )","\t\t\t\tend","\t\t\t)","\tend","","\tfunction SF.Editor.doValidation ( forceShow )","","\t\tlocal function valid ()","\t\t\tlocal code = SF.Editor.getActiveTab().code","","\t\t\tlocal err = CompileString( code, \"Validation\", false )","","\t\t\tif type( err ) ~= \"string\" then ","\t\t\t\tif forceShow then SF.AddNotify( LocalPlayer(), \"Validation successful\", NOTIFY_GENERIC, 3, NOTIFYSOUND_DRIP3 ) end","\t\t\t\tSF.Editor.runJS( \"editor.session.clearAnnotations(); clearErrorLines()\" )","\t\t\t\treturn ","\t\t\tend","","\t\t\tlocal row = tonumber( err:match( \"%d+\" ) ) - 1","\t\t\tlocal message = err:match( \": .+$\" ):sub( 3 )","","\t\t\tSF.Editor.runJS( string.format( \"editor.session.setAnnotations([{row: %d, text: \\\"%s\\\", type: \\\"error\\\"}])\", row, message:JavascriptSafe() ) )","\t\t\tSF.Editor.runJS( [[","\t\t\t\tclearErrorLines();","","\t\t\t\tvar Range = ace.require(\"ace/range\").Range;","\t\t\t\tvar range = new Range(]] .. row .. [[, 1, ]] .. row .. [[, Infinity);","","\t\t\t\teditor.session.addMarker(range, \"ace_error\", \"screenLine\");","","\t\t\t]] )","\t\t\t","\t\t\tif not forceShow then return end","","\t\t\tSF.Editor.runJS( \"editor.session.unfold({row: \" .. row .. \", column: 0})\" )","\t\t\tSF.Editor.runJS( \"editor.scrollToLine( \" .. row .. \", true )\" )","","","\t\tend","\t\tif forceShow then valid() return end","\t\tif not timer.Exists( \"validationTimer\" ) or ( timer.Exists( \"validationTimer\") and not timer.Adjust( \"validationTimer\", 0.5, 1, valid ) ) then","\t\t\ttimer.Remove( \"validationTimer\" )","\t\t\ttimer.Create( \"validationTimer\", 0.5, 1, valid )","\t\tend","","\tend","","\tlocal function createLibraryMap ()","","\t\tlocal map = {}","","\t\tfor lib, tbl in pairs( SF.Types ) do","\t\t\tif ( lib == \"Environment\" or lib:find( \"Library: \" ) ) and type( tbl.__index ) == \"table\" then","\t\t\t\tlib = lib:Replace( \"Library: \", \"\" )","\t\t\t\tmap[ lib ] = {}","\t\t\t\tfor name, val in pairs( tbl.__index ) do","\t\t\t\t\ttable.insert( map[ lib ], name )","\t\t\t\tend","\t\t\tend","\t\tend","","\t\tmap.Angle = {}","\t\tfor name, val in pairs( SF.Angles.Methods ) do","\t\t\ttable.insert( map.Angle, name )","\t\tend","\t\tmap.Color = {}","\t\tfor name, val in pairs( SF.Color.Methods ) do","\t\t\ttable.insert( map.Color, name )","\t\tend","\t\tmap.Entity = {}","\t\tfor name, val in pairs( SF.Entities.Methods ) do","\t\t\ttable.insert( map.Entity, name )","\t\tend","\t\tmap.Player = {}","\t\tfor name, val in pairs( SF.Players.Methods ) do","\t\t\ttable.insert( map.Player, name )","\t\tend","\t\tmap.Sound = {}","\t\tfor name, val in pairs( SF.Sounds.Methods ) do","\t\t\ttable.insert( map.Sound, name )","\t\tend","\t\tmap.VMatrix = {}","\t\tfor name, val in pairs( SF.VMatrix.Methods ) do","\t\t\ttable.insert( map.VMatrix, name )","\t\tend","\t\tmap.Vector = {}","\t\tfor name, val in pairs( SF.Vectors.Methods ) do","\t\t\ttable.insert( map.Vector, name )","\t\tend","","\t\treturn map","\tend","","\tfunction SF.Editor.refreshTab ( tab )","","\t\tlocal tabHolder = SF.Editor.getTabHolder()","\t\tif type( tab ) == \"number\" then","\t\t\ttab = tabHolder.tabs[ tab ]  ","\t\tend","\t\tif tab == nil then return end","","\t\tSF.Editor.updateTabName( tab )","","\t\tlocal fileName = tab.filename","\t\tlocal tabIndex = tabHolder:getTabIndex( tab )","","\t\tif not fileName or not file.Exists( \"starfall/\" .. fileName, \"DATA\" ) then ","\t\t\tSF.AddNotify( LocalPlayer(), \"Unable to refresh tab as file doesn't exist\", NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\t\t\treturn ","\t\tend","","\t\tlocal fileData = file.Read( \"starfall/\" .. fileName, \"DATA\" )","","\t\tSF.Editor.runJS( \"editSessions[ \" .. tabIndex .. \" - 1 ].setValue( \\\"\" .. fileData:JavascriptSafe() .. \"\\\" )\" )","","\t\tSF.Editor.updateTabName( tab )","","\t\tSF.AddNotify( LocalPlayer(), \"Refreshed tab: \" .. fileName, NOTIFY_GENERIC, 5, NOTIFYSOUND_DRIP3 )","\tend","","\tfunction SF.Editor.updateTabName ( tab )","\t\tlocal ppdata = {}","\t\tSF.Preprocessor.ParseDirectives( \"tab\", tab.code, {}, ppdata )","\t\tif ppdata.scriptnames and ppdata.scriptnames.tab ~= \"\" then ","\t\t\ttab.name = ppdata.scriptnames.tab","\t\telse","\t\t\ttab.name = tab.filename or \"generic\"","\t\tend","\t\ttab:SetText( tab.name )","\tend","","\tfunction SF.Editor.createEditor ()","\t\tlocal editor = vgui.Create( \"StarfallFrame\" )","\t\teditor:SetSize( 800, 600 )","\t\teditor:SetTitle( \"Starfall Code Editor\" )","\t\teditor:Center()","","\t\tfunction editor:OnKeyCodePressed ( keyCode )","\t\t\tif keyCode == KEY_S and ( input.IsKeyDown( KEY_LCONTROL ) or input.IsKeyDown( KEY_RCONTROL ) ) then","\t\t\t\tSF.Editor.saveTab( SF.Editor.getActiveTab() )","\t\t\telseif keyCode == KEY_Q and ( input.IsKeyDown( KEY_LCONTROL ) or input.IsKeyDown( KEY_RCONTROL ) ) then","\t\t\t\tSF.Editor.close()","\t\t\tend","\t\tend","","\t\tlocal buttonHolder = editor.components[ \"buttonHolder\" ]","","\t\tbuttonHolder:getButton( \"Close\" ).DoClick = function ( self )","\t\t\tSF.Editor.close()","\t\tend","","\t\tbuttonHolder:removeButton( \"Lock\" )","","\t\tlocal buttonSaveExit = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonSaveExit:SetText( \"Save and Exit\" )","\t\tfunction buttonSaveExit:DoClick ()","\t\t\tSF.Editor.saveTab( SF.Editor.getActiveTab() )","\t\t\tSF.Editor.close()","\t\tend","\t\tbuttonHolder:addButton( \"SaveExit\", buttonSaveExit )","","\t\tlocal buttonSettings = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonSettings:SetText( \"Settings\" )","\t\tfunction buttonSettings:DoClick ()","\t\t\tif SF.Editor.settingsWindow:IsVisible() then","\t\t\t\tSF.Editor.settingsWindow:close()","\t\t\telse","\t\t\t\tSF.Editor.settingsWindow:open()","\t\t\tend","\t\tend","\t\tbuttonHolder:addButton( \"Settings\", buttonSettings )","","\t\tlocal buttonHelper = vgui.Create( \"StarfallButton\", buttonHolder )\t","\t\tbuttonHelper:SetText( \"SF Helper\" )","\t\tfunction buttonHelper:DoClick ()","\t\t\tSF.Helper.show()","\t\tend","\t\tbuttonHolder:addButton( \"Helper\", buttonHelper )","","\t\tlocal buttonFiles = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonFiles:SetText( \"Files\" )","\t\tfunction buttonFiles:DoClick ()","\t\t\tif SF.Editor.fileViewer:IsVisible() then","\t\t\t\tSF.Editor.fileViewer:close()","\t\t\telse","\t\t\t\tSF.Editor.fileViewer:open()","\t\t\tend","\t\tend","\t\tbuttonHolder:addButton( \"Files\", buttonFiles )","","\t\tlocal buttonSaveAs = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonSaveAs:SetText( \"Save As\" )","\t\tfunction buttonSaveAs:DoClick ()","\t\t\tSF.Editor.saveTabAs( SF.Editor.getActiveTab() )","\t\tend","\t\tbuttonHolder:addButton( \"SaveAs\", buttonSaveAs )","","\t\tlocal buttonSave = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonSave:SetText( \"Save\" )","\t\tfunction buttonSave:DoClick ()","\t\t\tSF.Editor.saveTab( SF.Editor.getActiveTab() )","\t\tend","\t\tbuttonHolder:addButton( \"Save\", buttonSave )","","\t\tlocal buttonNewFile = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonNewFile:SetText( \"New tab\" )","\t\tfunction buttonNewFile:DoClick ()","\t\t\tSF.Editor.addTab()","\t\tend","\t\tbuttonHolder:addButton( \"NewFile\", buttonNewFile )","","\t\tlocal buttonCloseTab = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonCloseTab:SetText( \"Close tab\" )","\t\tfunction buttonCloseTab:DoClick ()","\t\t\tSF.Editor.removeTab( SF.Editor.getActiveTab() )","\t\tend","\t\tbuttonHolder:addButton( \"CloseTab\", buttonCloseTab )","","\t\tlocal html = vgui.Create( \"DHTML\", editor )","\t\thtml:SetPos( 5, 54 )","\t\thtml:SetHTML( htmlEditorCode )","","\t\thtml:SetAllowLua( true )","","\t\tlocal map = createLibraryMap()","","\t\thtml:QueueJavascript( \"libraryMap = JSON.parse(\\\"\" .. util.TableToJSON( map ):JavascriptSafe() .. \"\\\")\" )","","\t\tlocal libs = {}","\t\tlocal functions = {}","\t\ttable.ForEach( map, function ( lib, vals )","\t\t\tif lib == \"Environment\" or lib:GetChar( 1 ):upper() ~= lib:GetChar( 1 ) then","\t\t\t\ttable.insert( libs, lib )","\t\t\tend","\t\t\ttable.ForEach( vals, function ( key, val )","\t\t\t\ttable.insert( functions, val )","\t\t\tend )","\t\tend )","","\t\thtml:QueueJavascript( \"createStarfallMode(\\\"\" .. table.concat( libs, \"|\" ) .. \"\\\", \\\"\" .. table.concat( table.Add( table.Copy( functions ), libs ), \"|\" ) .. \"\\\")\" )","","\t\tfunction html:PerformLayout ( ... )","\t\t \tself:SetSize( editor:GetWide() - 10, editor:GetTall() - 59 )","\t\tend","\t\tfunction html:OnKeyCodePressed ( key, notfirst )","","\t\t\tlocal function repeatKey ()","\t\t\t\ttimer.Create( \"repeatKey\"..key, not notfirst and 0.5 or 0.02, 1, function () self:OnKeyCodePressed( key, true ) end )","\t\t\tend","","\t\t\tif GetConVarNumber( \"sf_editor_fixkeys\" ) == 0 then return end","\t\t\tif ( input.IsKeyDown( KEY_LSHIFT ) or input.IsKeyDown( KEY_RSHIFT ) ) and ","\t\t\t\t( input.IsKeyDown( KEY_LCONTROL ) or input.IsKeyDown( KEY_RCONTROL ) ) then","\t\t\t\tif key == KEY_UP and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.modifyNumber(1)\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_DOWN and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.modifyNumber(-1)\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_LEFT and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectWordLeft()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_RIGHT and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectWordRight()\" )","\t\t\t\t\trepeatKey()","\t\t\t\tend","\t\t\telseif input.IsKeyDown( KEY_LSHIFT ) or input.IsKeyDown( KEY_RSHIFT ) then","\t\t\t\tif key == KEY_LEFT and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectLeft()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_RIGHT and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectRight()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_UP and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectUp()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_DOWN and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectDown()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_HOME and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectLineStart()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_END and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.selection.selectLineEnd()\" )","\t\t\t\t\trepeatKey()","\t\t\t\tend","\t\t\telseif input.IsKeyDown( KEY_LCONTROL ) or input.IsKeyDown( KEY_RCONTROL ) then","\t\t\t\tif key == KEY_LEFT and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.navigateWordLeft()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_RIGHT and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.navigateWordRight()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_BACKSPACE and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.removeWordLeft()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_DELETE and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.removeWordRight()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_SPACE and input.IsKeyDown( key ) then","\t\t\t\t\tSF.Editor.doValidation( true )","\t\t\t\telseif key == KEY_C and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"console.log(\\\"RUNLUA:SetClipboardText(\\\\\\\"\\\"+ addslashes(editor.getSelectedText()) +\\\"\\\\\\\")\\\")\" )","\t\t\t\tend","\t\t\telseif input.IsKeyDown( KEY_LALT ) or input.IsKeyDown( KEY_RALT ) then","\t\t\t\tif key == KEY_UP and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.moveLinesUp()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_DOWN and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.moveLinesDown()\" )","\t\t\t\t\trepeatKey()","\t\t\t\tend","\t\t\telse","\t\t\t\tif key == KEY_LEFT and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.navigateLeft(1)\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_RIGHT and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.navigateRight(1)\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_UP and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.navigateUp(1)\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_DOWN and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.navigateDown(1)\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_HOME and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.navigateLineStart()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_END and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.navigateLineEnd()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_PAGEUP and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.navigateFileStart()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_PAGEDOWN and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.navigateFileEnd()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_BACKSPACE and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.remove('left')\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_DELETE and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.remove('right')\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_ENTER and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.splitLine(); editor.navigateDown(1); editor.navigateLineStart()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_INSERT and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.toggleOverwrite()\" )","\t\t\t\t\trepeatKey()","\t\t\t\telseif key == KEY_TAB and input.IsKeyDown( key ) then","\t\t\t\t\tself:QueueJavascript( \"editor.indent()\" )","\t\t\t\t\trepeatKey()","\t\t\t\tend","\t\t\tend","\t\tend","\t\teditor:AddComponent( \"htmlPanel\", html )","","\t\tfunction editor:OnOpen ()","\t\t\thtml:Call( \"editor.focus()\" )","\t\t\thtml:RequestFocus()","\t\tend","","\t\tlocal tabHolder = vgui.Create( \"StarfallTabHolder\", editor )","\t\ttabHolder:SetPos( 5, 30 )","\t\ttabHolder.menuoptions[ #tabHolder.menuoptions + 1 ] = { \"\", \"SPACER\" }","\t\ttabHolder.menuoptions[ #tabHolder.menuoptions + 1 ] = { \"Save\", function ()","\t\t\tif not tabHolder.targetTab then return end","\t\t\tSF.Editor.saveTab( tabHolder.targetTab )","\t\t\ttabHolder.targetTab = nil","\t\tend }","\t\ttabHolder.menuoptions[ #tabHolder.menuoptions + 1 ] = { \"Save As\", function ()","\t\t\tif not tabHolder.targetTab then return end","\t\t\tSF.Editor.saveTabAs( tabHolder.targetTab )","\t\t\ttabHolder.targetTab = nil","\t\tend }","\t\ttabHolder.menuoptions[ #tabHolder.menuoptions + 1 ] = { \"\", \"SPACER\" }","\t\ttabHolder.menuoptions[ #tabHolder.menuoptions + 1 ] = { \"Refresh\", function ()","\t\t\tif not tabHolder.targetTab then return end","\t\t\t","\t\t\tSF.Editor.refreshTab( tabHolder.targetTab )","","\t\t\ttabHolder.targetTab = nil","\t\tend }","","\t\tfunction tabHolder:OnRemoveTab ( tabIndex )","\t\t\tSF.Editor.runJS( \"removeEditSession(\"..tabIndex..\")\" )","","\t\t\tif #self.tabs == 0 then","\t\t\t\tSF.Editor.addTab()","\t\t\tend","\t\t\tSF.Editor.selectTab( tabIndex )","\t\tend","\t\teditor:AddComponent( \"tabHolder\", tabHolder )","\t\t","\t\tfunction editor:OnClose ()","\t\t\tlocal tabs = {}","\t\t\tfor k, v in pairs( tabHolder.tabs ) do","\t\t\t\ttabs[ k ] = {}","\t\t\t\ttabs[ k ].filename = v.filename","\t\t\t\ttabs[ k ].code = v.code","\t\t\tend","\t\t\ttabs.selectedTab = SF.Editor.getTabHolder():getTabIndex( SF.Editor.getActiveTab() )","\t\t\tfile.Write( \"sf_tabs.txt\", util.TableToJSON( tabs ) )","\t\tend","","\t\tfunction editor:OnThink ()","\t\t\tif self.Dragged or self.Resized then","\t\t\t\tSF.Editor.saveSettings()","\t\t\tend","\t\tend","","\t\treturn editor","\tend","","\tfunction SF.Editor.createFileViewer ()","\t\tlocal fileViewer = vgui.Create( \"StarfallFrame\" )","\t\tfileViewer:SetSize( 200, 600 )","\t\tfileViewer:SetTitle( \"Starfall File Viewer\" )","\t\tfileViewer:Center()","","\t\tlocal browser = vgui.Create( \"StarfallFileBrowser\", fileViewer )","","\t\tlocal searchBox, tree = browser:getComponents()","\t\ttree:setup( \"starfall\" )","\t\tfunction tree:OnNodeSelected ( node )","\t\t\tif not node:GetFileName() or string.GetExtensionFromFilename( node:GetFileName() ) ~= \"txt\" then return end","\t\t\tlocal fileName = string.gsub( node:GetFileName(), \"starfall/\", \"\", 1 )","\t\t\tlocal code = file.Read( node:GetFileName(), \"DATA\" )","","\t\t\tfor k, v in pairs( SF.Editor.getTabHolder().tabs ) do","\t\t\t\tif v.filename == fileName and v.code == code then","\t\t\t\t\tSF.Editor.selectTab( v )","\t\t\t\t\treturn","\t\t\t\tend","\t\t\tend","","\t\t\tSF.Editor.addTab( fileName, code )","\t\tend","","\t\tfileViewer:AddComponent( \"browser\", browser )","","\t\tlocal buttonHolder = fileViewer.components[ \"buttonHolder\" ]","","\t\tlocal buttonLock = buttonHolder:getButton( \"Lock\" )","\t\tbuttonLock._DoClick = buttonLock.DoClick","\t\tbuttonLock.DoClick = function ( self )","\t\t\tself:_DoClick()","\t\t\tSF.Editor.saveSettings()","\t\tend","","\t\tlocal buttonRefresh = vgui.Create( \"StarfallButton\", buttonHolder )","\t\tbuttonRefresh:SetText( \"Refresh\" )","\t\tbuttonRefresh:SetHoverColor( Color( 7, 70, 0 ) )","\t\tbuttonRefresh:SetColor( Color( 26, 104, 17 ) )","\t\tbuttonRefresh:SetLabelColor( Color( 103, 155, 153 ) )","\t\tfunction buttonRefresh:DoClick ()","\t\t\ttree:reloadTree()","\t\t\tsearchBox:SetValue( \"Search...\" )","\t\tend","\t\tbuttonHolder:addButton( \"Refresh\", buttonRefresh )","","\t\tfunction fileViewer:OnThink ()","\t\t\tif self.Dragged or self.Resized then","\t\t\t\tSF.Editor.saveSettings()","\t\t\tend","\t\tend","","\t\tfunction fileViewer:OnOpen ()","\t\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Files\" ).active = true","\t\tend","","\t\tfunction fileViewer:OnClose ()","\t\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Files\" ).active = false","\t\tend","","\t\treturn fileViewer","\tend","","\tfunction SF.Editor.createSettingsWindow ()","\t\tlocal frame = vgui.Create( \"StarfallFrame\" )","\t\tframe:SetSize( 200, 400 )","\t\tframe:SetTitle( \"Starfall Settings\" )","\t\tframe:Center()","\t\tframe:SetVisible( true )","\t\tframe:MakePopup( true )","","\t\tlocal panel = vgui.Create( \"StarfallPanel\", frame )","\t\tpanel:SetPos( 5, 40 )","\t\tfunction panel:PerformLayout ()","\t\t\tself:SetSize( frame:GetWide() - 10, frame:GetTall() - 45 )","\t\tend","\t\tframe:AddComponent( \"panel\", panel )","","\t\tlocal function setDoClick ( panel )","\t\t\tfunction panel:OnChange ()","\t\t\t\tSF.Editor.updateSettings()","\t\t\tend","","\t\t\treturn panel","\t\tend","","\t\tlocal form = vgui.Create( \"DForm\", panel )\t","\t\tform:Dock( FILL )","\t\tform.Header:SetVisible( false )","\t\tform.Paint = function () end","\t\tsetDoClick(form:CheckBox( \"Show fold widgets\", \"sf_editor_widgets\" ))","\t\tsetDoClick(form:CheckBox( \"Show line numbers\", \"sf_editor_linenumbers\" ))","\t\tsetDoClick(form:CheckBox( \"Show gutter\", \"sf_editor_gutter\" ))","\t\tsetDoClick(form:CheckBox( \"Show invisible characters\", \"sf_editor_invisiblecharacters\" ))","\t\tsetDoClick(form:CheckBox( \"Show indenting guides\", \"sf_editor_indentguides\" ))","\t\tsetDoClick(form:CheckBox( \"Highlight active line\", \"sf_editor_activeline\" ))","\t\tsetDoClick(form:CheckBox( \"Auto completion\", \"sf_editor_autocompletion\" ))","\t\tsetDoClick(form:CheckBox( \"Fix keys not working on Linux\", \"sf_editor_fixkeys\" )):SetTooltip( \"Some keys don't work with the editor on Linux\\nEg. Enter, Tab, Backspace, Arrow keys etc...\" )","\t\tsetDoClick(form:CheckBox( \"Fix console bug\", \"sf_editor_fixconsolebug\" )):SetTooltip( \"Fix console opening when pressing ' or @ (UK Keyboad layout)\" )","","\t\tfunction frame:OnOpen ()","\t\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Settings\" ).active = true","\t\tend","","\t\tfunction frame:OnClose ()","\t\t\tSF.Editor.editor.components[ \"buttonHolder\" ]:getButton( \"Settings\" ).active = false","\t\tend","","\t\treturn frame","\tend","","\tfunction SF.Editor.saveSettings ()","\t\tlocal frame = SF.Editor.editor","\t\tRunConsoleCommand( \"sf_editor_width\", frame:GetWide() )","\t\tRunConsoleCommand( \"sf_editor_height\", frame:GetTall() )","\t\tlocal x, y = frame:GetPos()","\t\tRunConsoleCommand( \"sf_editor_posx\", x )","\t\tRunConsoleCommand( \"sf_editor_posy\", y )","","\t\tlocal frame = SF.Editor.fileViewer","\t\tRunConsoleCommand( \"sf_fileviewer_width\", frame:GetWide() )","\t\tRunConsoleCommand( \"sf_fileviewer_height\", frame:GetTall() )","\t\tlocal x, y = frame:GetPos()","\t\tRunConsoleCommand( \"sf_fileviewer_posx\", x )","\t\tRunConsoleCommand( \"sf_fileviewer_posy\", y )","\t\tRunConsoleCommand( \"sf_fileviewer_locked\", frame.locked and 1 or 0 )","\tend","","\tfunction SF.Editor.updateSettings ()","\t\tlocal frame = SF.Editor.editor","\t\tframe:SetWide( GetConVarNumber( \"sf_editor_width\" ) )","\t\tframe:SetTall( GetConVarNumber( \"sf_editor_height\" ) )","\t\tframe:SetPos( GetConVarNumber( \"sf_editor_posx\" ), GetConVarNumber( \"sf_editor_posy\" ) )","","\t\tlocal frame = SF.Editor.fileViewer","\t\tframe:SetWide( GetConVarNumber( \"sf_fileviewer_width\" ) )","\t\tframe:SetTall( GetConVarNumber( \"sf_fileviewer_height\" ) )","\t\tframe:SetPos( GetConVarNumber( \"sf_fileviewer_posx\" ), GetConVarNumber( \"sf_fileviewer_posy\" ) )","\t\tframe:lock( SF.Editor.editor )","\t\tframe.locked = tobool(GetConVarNumber( \"sf_fileviewer_locked\" ))","","\t\tlocal buttonLock = frame.components[ \"buttonHolder\" ]:getButton( \"Lock\" )","\t\tbuttonLock.active = frame.locked","\t\tbuttonLock:SetText( frame.locked and \"Locked\" or \"Unlocked\" )","","\t\tlocal js = SF.Editor.runJS","\t\tjs( \"editor.setOption(\\\"showFoldWidgets\\\", \" .. GetConVarNumber( \"sf_editor_widgets\" ) .. \")\" )","\t\tjs( \"editor.setOption(\\\"showLineNumbers\\\", \" .. GetConVarNumber( \"sf_editor_linenumbers\" ) .. \")\" )","\t\tjs( \"editor.setOption(\\\"showGutter\\\", \" .. GetConVarNumber( \"sf_editor_gutter\" ) .. \")\" )","\t\tjs( \"editor.setOption(\\\"showInvisibles\\\", \" .. GetConVarNumber( \"sf_editor_invisiblecharacters\" ) .. \")\" )","\t\tjs( \"editor.setOption(\\\"displayIndentGuides\\\", \" .. GetConVarNumber( \"sf_editor_indentguides\" ) .. \")\" )","\t\tjs( \"editor.setOption(\\\"highlightActiveLine\\\", \" .. GetConVarNumber( \"sf_editor_activeline\" ) .. \")\" )","\t\tjs( \"editor.setOption(\\\"highlightGutterLine\\\", \" .. GetConVarNumber( \"sf_editor_activeline\" ) .. \")\" )","\t\tjs( \"editor.setOption(\\\"enableLiveAutocompletion\\\", \" .. GetConVarNumber( \"sf_editor_autocompletion\" ) .. \")\" )","\tend",""],"summary":"\n \nSF Editor \nOriginally created by Jazzelhawk \n \nTo do: \nFind new icons \n ","description":"\n \nSF Editor \nOriginally created by Jazzelhawk \n \nTo do: \nFind new icons \n","param":[]},{"ret":["True if ok, false if a file was missing","A table with mainfile = codename and files = a table of filenames and their contents, or the missing file path."],"comment":["\t--- (Client) Builds a table for the compiler to use","\t-- @param maincode The source code for the main chunk","\t-- @param codename The name of the main chunk","\t-- @return True if ok, false if a file was missing","\t-- @return A table with mainfile = codename and files = a table of filenames and their contents, or the missing file path."],"code":["\tfunction SF.Editor.BuildIncludesTable ( maincode, codename )","\t\tif not SF.Editor.initialized then SF.Editor.init() return false, \"Editor needs to finish loading...\" end","\t\tlocal tbl = {}","\t\tmaincode = maincode or SF.Editor.getCode()","\t\tcodename = codename or SF.Editor.getOpenFile() or \"main\"","\t\ttbl.mainfile = codename","\t\ttbl.files = {}","\t\ttbl.filecount = 0","\t\ttbl.includes = {}","","\t\tlocal loaded = {}","\t\tlocal ppdata = {}","","\t\tlocal function recursiveLoad ( path )","\t\t\tif loaded[ path ] then return end","\t\t\tloaded[ path ] = true","\t\t\t","\t\t\tlocal code","\t\t\tif path == codename and maincode then","\t\t\t\tcode = maincode","\t\t\telse","\t\t\t\tcode = file.Read( \"starfall/\"..path, \"DATA\" ) or error( \"Bad include: \" .. path, 0 )","\t\t\tend","\t\t\t","\t\t\ttbl.files[ path ] = code","\t\t\tSF.Preprocessor.ParseDirectives( path, code, {}, ppdata )","\t\t\t","\t\t\tif ppdata.includes and ppdata.includes[ path ] then","\t\t\t\tlocal inc = ppdata.includes[ path ]","\t\t\t\tif not tbl.includes[ path ] then","\t\t\t\t\ttbl.includes[ path ] = inc","\t\t\t\t\ttbl.filecount = tbl.filecount + 1","\t\t\t\telse","\t\t\t\t\tassert( tbl.includes[ path ] == inc )","\t\t\t\tend","\t\t\t\t","\t\t\t\tfor i = 1, #inc do","\t\t\t\t\trecursiveLoad( inc[i] )","\t\t\t\tend","\t\t\tend","\t\tend","\t\tlocal ok, msg = pcall( recursiveLoad, codename )","","\t\tlocal function findCycle ( file, visited, recStack )","\t\t\tif not visited[ file ] then","\t\t\t\t--Mark the current file as visited and part of recursion stack","\t\t\t\tvisited[ file ] = true","\t\t\t\trecStack[ file ] = true","","\t\t\t\t--Recurse for all the files included in this file","\t\t\t\tfor k, v in pairs( ppdata.includes[ file ] or {} ) do","\t\t\t\t\tif recStack[ v ] then","\t\t\t\t\t\treturn true, file","\t\t\t\t\telseif not visited[ v ] then","\t\t\t\t\t\tlocal cyclic, cyclicFile = findCycle( v, visited, recStack )","\t\t\t\t\t\tif cyclic then return true, cyclicFile end","\t\t\t\t\tend","\t\t\t\tend","\t\t\tend","\t\t\t","\t\t\t--Remove this file from the recursion stack","\t\t\trecStack[ file ] = false","\t\t\treturn false, nil","\t\tend","","\t\tlocal isCyclic = false","\t\tlocal cyclicFile = nil","\t\tfor k, v in pairs( ppdata.includes or {} ) do","\t\t\tlocal cyclic, file = findCycle( k, {}, {} )","\t\t\tif cyclic then","\t\t\t\tisCyclic = true","\t\t\t\tcyclicFile = file","\t\t\t\tbreak","\t\t\tend","\t\tend","\t\t","\t\tif isCyclic then","\t\t\treturn false, \"Loop in includes from: \" .. cyclicFile","\t\tend","","\t\tif ok then","\t\t\treturn true, tbl","\t\telseif msg:sub( 1, 13 ) == \"Bad include: \" then","\t\t\treturn false, msg","\t\telse","\t\t\terror( msg, 0 )","\t\tend","\tend","","\t-- CLIENT ANIMATION","","\tlocal busy_players = { }","\thook.Add( \"EntityRemoved\", \"starfall_busy_animation\", function ( ply )","\t\tbusy_players[ ply ] = nil","\tend )","","\tlocal emitter = ParticleEmitter( vector_origin )","","\tnet.Receive( \"starfall_editor_status\", function ( len )","\t\tlocal ply = net.ReadEntity()","\t\tlocal status = net.ReadBit() ~= 0 -- net.ReadBit returns 0 or 1, despite net.WriteBit taking a boolean","\t\tif not ply:IsValid() or ply == LocalPlayer() then return end","","\t\tbusy_players[ ply ] = status or nil","\tend )","","\tlocal rolldelta = math.rad( 80 )","\ttimer.Create( \"starfall_editor_status\", 1 / 3, 0, function ()","\t\trolldelta = -rolldelta","\t\tfor ply, _ in pairs( busy_players ) do","\t\t\tlocal BoneIndx = ply:LookupBone( \"ValveBiped.Bip01_Head1\" ) or ply:LookupBone( \"ValveBiped.HC_Head_Bone\" ) or 0","\t\t\tlocal BonePos, BoneAng = ply:GetBonePosition( BoneIndx )","\t\t\tlocal particle = emitter:Add( \"radon/starfall2\", BonePos + Vector( math.random( -10, 10 ), math.random( -10, 10 ), 60 + math.random( 0, 10 ) ) )","\t\t\tif particle then","\t\t\t\tparticle:SetColor( math.random( 30, 50 ), math.random( 40, 150 ), math.random( 180, 220 ) )","\t\t\t\tparticle:SetVelocity( Vector( 0, 0, -40 ) )","","\t\t\t\tparticle:SetDieTime( 1.5 )","\t\t\t\tparticle:SetLifeTime( 0 )","","\t\t\t\tparticle:SetStartSize( 10 )","\t\t\t\tparticle:SetEndSize( 5 )","","\t\t\t\tparticle:SetStartAlpha( 255 )","\t\t\t\tparticle:SetEndAlpha( 0 )","","\t\t\t\tparticle:SetRollDelta( rolldelta )","\t\t\tend","\t\tend","\tend )","","elseif SERVER then","","\tutil.AddNetworkString( \"starfall_editor_status\" )","","\tlocal function getFiles ( dir, dir2 )","\t\tlocal files = {}","\t\tlocal dir2 = dir2 or \"\"","\t\tlocal f, directories = file.Find( dir .. \"/\" .. dir2 .. \"/*\", \"GAME\" )","\t\tfor k, v in pairs( f ) do","\t\t\tfiles[ #files + 1 ] = dir2 .. \"/\" .. v","\t\tend","\t\tfor k, v in pairs( directories ) do","\t\t\ttable.Add( files, getFiles( dir, dir2 .. \"/\" .. v ) )","\t\tend","\t\treturn files","\tend","","\tfor k, v in pairs( getFiles( addon_path, \"materials/radon\" ) ) do","\t\tresource.AddFile( v )","\tend","","\tlocal starfall_event = {}","","\tconcommand.Add( \"starfall_event\", function ( ply, command, args )","\t\tlocal handler = starfall_event[ args[ 1 ] ]","\t\tif not handler then return end","\t\treturn handler( ply, args )","\tend )","","\tfunction starfall_event.editor_open ( ply, args )","\t\tnet.Start( \"starfall_editor_status\" )","\t\tnet.WriteEntity( ply )","\t\tnet.WriteBit( true )","\t\tnet.Broadcast()","\tend","","\tfunction starfall_event.editor_close ( ply, args )","\t\tnet.Start( \"starfall_editor_status\" )","\t\tnet.WriteEntity( ply )","\t\tnet.WriteBit( false )","\t\tnet.Broadcast()","\tend","end"],"class":"function","name":"SF.Editor.BuildIncludesTable","private":false,"summary":"\n(Client) Builds a table for the compiler to use ","description":"\n(Client) Builds a table for the compiler to use","param":{"1":"maincode","2":"codename","codename":"The name of the main chunk","maincode":"The source code for the main chunk"}}],"tables":[],"description":"\n \nSF Editor \nOriginally created by Jazzelhawk \n \nTo do: \nFind new icons \n","summary":"\n \nSF Editor \nOriginally created by Jazzelhawk \n \nTo do: \nFind new icons \n "},"libs_sh/von.lua":{"libraries":{"1":"von","von":{"comment":["--- vON Library","-- @shared"],"functions":{"1":"deserialize","2":"serialize","serialize":{"ret":"String","description":"\nSerialize a table","code":["von.serialize = setmetatable(_serialize,_s_meta)"],"class":"function","classForced":true,"summary":"\nSerialize a table ","name":"von.serialize","library":"von","comment":["--- Serialize a table","-- @shared","-- @class function","-- @name von.serialize","-- @param tbl Table to serialize","-- @return String"],"client":true,"server":true,"param":{"1":"tbl","tbl":"Table to serialize"}},"deserialize":{"ret":"Table","description":"\nDeserialize a string","code":["von.deserialize = setmetatable(_deserialize,_d_meta)",""],"class":"function","classForced":true,"summary":"\nDeserialize a string ","name":"von.deserialize","library":"von","comment":["--- Deserialize a string","-- @shared","-- @class function","-- @name von.deserialize","-- @param str String to deserialize","-- @return Table"],"client":true,"server":true,"param":{"1":"str","str":"String to deserialize"}}},"class":"library","summary":"\nvON Library ","code":["local von, _ = SF.Libraries.Register(\"von\")","","local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable","local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next","","--\tThis is kept away from the table for speed.","function d_findVariable(s, i, len, lastType)","\tlocal i, c, typeRead, val = i or 1","","\t--\tKeep looping through the string.","\twhile true do","\t\t--\tStop at the end. Throw an error. This function MUST NOT meet the end!","\t\tif i > len then","\t\t\tSF.throw( \"vON: Reached end of string, cannot form proper variable.\", 3 )","\t\tend","","\t\t--\tCache the character. Nobody wants to look for the same character ten times.","\t\tc = sub(s, i, i)","","\t\t--\tIf it just read a type definition, then a variable HAS to come after it.","\t\tif typeRead then","\t\t\t--\tAttempt to deserialize a variable of the freshly read type.","\t\t\tval, i = _deserialize[lastType](s, i, len)","\t\t\t--\tReturn the value read, the index of the last processed character, and the type of the last read variable.","\t\t\treturn val, i, lastType","","\t\t\t--\t@ means nil. It should not even appear in the output string of the serializer. Nils are useless to store.","\t\telseif c == \"@\" then","\t\t\treturn nil, i, lastType","","\t\t\t--\tn means a number will follow. Base 10... :C","\t\telseif c == \"n\" then","\t\t\tlastType = \"number\"","\t\t\ttypeRead = true","","\t\t\t--\tb means boolean flags.","\t\telseif c == \"b\" then","\t\t\tlastType = \"boolean\"","\t\t\ttypeRead = true","","\t\t\t--\t\" means the start of a string.","\t\telseif c == \"\\\"\" then","\t\t\tlastType = \"string\"","\t\t\ttypeRead = true","","\t\t\t--\t{ means the start of a table!","\t\telseif c == \"{\" then","\t\t\tlastType = \"table\"","\t\t\ttypeRead = true","","\t\t\t--\tIf no type has been found, attempt to deserialize the last type read.","\t\telseif lastType then","\t\t\tval, i = _deserialize[lastType](s, i, len)","\t\t\treturn val, i, lastType","","\t\t\t--\tThis will occur if the very first character in the vON code is wrong.","\t\telse","\t\t\tSF.throw( \"vON: Malformed data... Can't find a proper type definition. Char#\" .. i .. \":\" .. c, 3 )","\t\tend","","\t\t--\tMove the pointer one step forward.","\t\ti = i + 1","\tend","end","","--\tThis is kept away from the table for speed.","--\tYeah, crapload of parameters.","function s_anyVariable(data, lastType, isNumeric, isKey, isLast, nice, indent)","","\t--\tBasically, if the type changes.","\tif lastType ~= type(data) then","\t\t--\tRemember the new type. Caching the type is useless.","\t\tlastType = type(data)","","\t\t--\tReturn the serialized data and the (new) last type.","\t\t--\tThe second argument, which is true now, means that the data type was just changed.","\t\treturn _serialize[lastType](data, true, isNumeric, isKey, isLast, nice, indent), lastType","\tend","","\t--\tOtherwise, simply serialize the data.","\treturn _serialize[lastType](data, false, isNumeric, isKey, isLast, nice, indent), lastType","end","","_deserialize = {","","\t--\tWell, tables are very loose...","\t--\tThe first table doesn't have to begin and end with { and }.","\t[\"table\"] = function(s, i, len, unnecessaryEnd)","\t\tlocal ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals and locals.","","\t\t--\tKeep looping.","\t\twhile true do","\t\t\t--\tUntil it meets the end.","\t\t\tif i > len then","\t\t\t\t--\tYeah, if the end is unnecessary, it won't spit an error. The main chunk doesn't require an end, for example.","\t\t\t\tif unnecessaryEnd then","\t\t\t\t\treturn ret, i","","\t\t\t\t\t--\tOtherwise, the data has to be damaged.","\t\t\t\telse","\t\t\t\t\tSF.throw( \"vON: Reached end of string, incomplete table definition.\", 2 )","\t\t\t\tend","\t\t\tend","","\t\t\t--\tCache the character.","\t\t\tc = sub(s,i,i)","\t\t\t--print(i, \"table char:\", c, tostring(unnecessaryEnd))","","\t\t\t--\tIf it's the end of a table definition, return.","\t\t\tif c == \"}\" then","\t\t\t\treturn ret, i","","\t\t\t\t--\tIf it's the component separator, switch to key:value pairs.","\t\t\telseif c == \"~\" then","\t\t\t\tnumeric = false","","\t\t\telseif c == \";\" then","\t\t\t\t--\tLol, nothing!","\t\t\t\t--\tRemenant from numbers, for faster parsing.","","\t\t\t\t--\tOK, now, if it's on the numeric component, simply add everything encountered.","\t\t\telseif numeric then","\t\t\t\t--\tFind a variable and it's value","\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType)","\t\t\t\t--\tAdd it to the table.","\t\t\t\tret[#ret + 1] = val","","\t\t\t\t--\tOtherwise, if it's the key:value component...","\t\t\telse","\t\t\t\t--\tIf a value is expected...","\t\t\t\tif expectValue then","\t\t\t\t\t--\tRead it.","\t\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType)","\t\t\t\t\t--\tAdd it?","\t\t\t\t\tret[key] = val","\t\t\t\t\t--\tClean up.","\t\t\t\t\texpectValue, key = false, nil","","\t\t\t\t\t--\tIf it's the separator...","\t\t\t\telseif c == \":\" then","\t\t\t\t\t--\tExpect a value next.","\t\t\t\t\texpectValue = true","","\t\t\t\t\t--\tBut, if there's a key read already...","\t\t\t\telseif key then","\t\t\t\t\t--\tThen this is malformed.","\t\t\t\t\tSF.throw( \"vON: Malformed table... Two keys declared successively? Char#\" .. i .. \":\" .. c, 2 )","","\t\t\t\t\t--\tOtherwise the key will be read.","\t\t\t\telse","\t\t\t\t\t--\tI love multi-return and multi-assignement.","\t\t\t\t\tkey, i, lastType = d_findVariable(s, i, len, lastType)","\t\t\t\tend","\t\t\tend","","\t\t\ti = i + 1","\t\tend","","\t\treturn nil, i","\tend,","","","\t--\tNumbers are weakly defined.","\t--\tThe declaration is not very explicit. It'll do it's best to parse the number.","\t--\tHas various endings: \\n, }, ~, : and ;, some of which will force the table deserializer to go one char backwards.","\t[\"number\"] = function(s, i, len)","\t\tlocal i, a = i or 1","\t\t--\tLocals, locals, locals, locals","","\t\ta = find(s, \"[;:}~]\", i)","","\t\tif a then","\t\t\treturn tonumber(sub(s, i, a - 1)), a - 1","\t\tend","","\t\tSF.throw( \"vON: Number definition started... Found no end.\", 3 )","\tend,","","","\t--\tA boolean is A SINGLE CHARACTER, either 1 for true or 0 for false.","\t--\tAny other attempt at boolean declaration will result in a failure.","\t[\"boolean\"] = function(s, i, len)","\t\tlocal c = sub(s,i,i)","\t\t--\tOnly one character is needed.","","\t\t--\tIf it's 1, then it's true","\t\tif c == \"1\" then","\t\t\treturn true, i","","\t\t\t--\tIf it's 0, then it's false.","\t\telseif c == \"0\" then","\t\t\treturn false, i","\t\tend","","\t\t--\tAny other supposely \"boolean\" is just a sign of malformed data.","\t\tSF.throw( \"vON: Invalid value on boolean type... Char#\" .. i .. \": \" .. c, 3 )","\tend,","","","\t--\tStrings are very easy to parse and also very explicit.","\t--\t\" simply marks the type of a string.","\t--\tThen it is parsed until an unescaped \" is countered.","\t[\"string\"] = function(s, i, len)","\t\tlocal res, i, a = \"\", i or 1","\t\t--\tLocals, locals, locals, locals","","\t\twhile true do","\t\t\ta = find(s, \"\\\"\", i, true)","","\t\t\tif a then","\t\t\t\tif sub(s, a - 1, a - 1) == \"\\\\\" then","\t\t\t\t\tres = res .. sub(s, i, a - 2) .. \"\\\"\"","\t\t\t\t\ti = a + 1","\t\t\t\telse","\t\t\t\t\treturn res .. sub(s, i, a - 2), a","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw( \"vON: String definition started... Found no end.\", 3 )","\t\t\tend","\t\tend","\tend","}","","","_serialize = {","","\t--\tUh. Nothing to comment.","\t--\tShitload of parameters.","\t--\tMakes shit faster than simply passing it around in locals.","\t--\ttable.concat works better than normal concatenations WITH LARGE-ISH STRINGS ONLY.","\t[\"table\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first)","\t--print(string.format(\"data: %s; mustInitiate: %s; isKey: %s; isLast: %s; nice: %s; indent: %s; first: %s\", tostring(data), tostring(mustInitiate), tostring(isKey), tostring(isLast), tostring(nice), tostring(indent), tostring(first)))","","\t\tlocal result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals, locals and locals.","","\t\t--\tFirst thing to be done is separate the numeric and key:value components of the given table in two tables.","\t\t--\tpairs(data) is slower than next, data as far as my tests tell me.","\t\tfor k, v in next, data do","\t\t\t--\tSkip the numeric keyz.","\t\t\tif type(k) ~= \"number\" or k < 1 or k > len then","\t\t\t\tkeyvals[#keyvals + 1] = k","\t\t\tend","\t\tend","","\t\tkeyvalsLen = #keyvals","","\t\t--\tMain chunk - no initial character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"{\"","\t\tend","","\t\t--\tAdd numeric values.","\t\tif len > 0 then","\t\t\tfor i = 1, len do","\t\t\t\tval, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, false, 0)","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tIf there are key:value pairs.","\t\tif keyvalsLen > 0 then","\t\t\t--\tInsert delimiter.","\t\t\tresult[#result + 1] = \"~\"","","\t\t\t--\tInsert key:value pairs.","\t\t\tfor _i = 1, keyvalsLen do","\t\t\t\tkeyvalsProgress = keyvalsProgress + 1","","\t\t\t\tval, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, false, 0)","","\t\t\t\tresult[#result + 1] = val..\":\"","","\t\t\t\tval, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, false, 0)","","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tMain chunk needs no ending character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"}\"","\t\tend","","\t\treturn concat(result)","\tend,","","","\t--\tNormal concatenations is a lot faster with small strings than table.concat","\t--\tAlso, not so branched-ish.","\t[\"number\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t--\tIf a number hasn't been written before, add the type prefix.","\t\tif mustInitiate then","\t\t\tif isKey or isLast then","\t\t\t\treturn \"n\"..data","\t\t\telse","\t\t\t\treturn \"n\"..data..\";\"","\t\t\tend","\t\tend","","\t\tif isKey or isLast then","\t\t\treturn \"n\"..data","\t\telse","\t\t\treturn \"n\"..data..\";\"","\t\tend","\tend,","","","\t--\tI hope gsub is fast enough.","\t[\"string\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t\treturn \"\\\"\" .. gsub(data, \"\\\"\", \"\\\\\\\"\") .. \"v\\\"\"","\tend,","","","\t--\tFastest.","\t[\"boolean\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t--\tPrefix if we must.","\t\tif mustInitiate then","\t\t\tif data then","\t\t\t\treturn \"b1\"","\t\t\telse","\t\t\t\treturn \"b0\"","\t\t\tend","\t\tend","","\t\tif data then","\t\t\treturn \"1\"","\t\telse","\t\t\treturn \"0\"","\t\tend","\tend,","","","\t--\tFastest.","\t[\"nil\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t\treturn \"@\"","\tend","}","","local _s_table = _serialize.table","local _d_table = _deserialize.table","","_d_meta = {","\t__call = function(self, str)","\t\tif type(str) == \"string\" then","\t\t\treturn _d_table(str, nil, #str, true)","\t\tend","\t\tSF.throw( \"vON: You must deserialize a string, not a \" .. type( str ), 2 )","\tend","}","_s_meta = {","\t__call = function(self, data)","\t\tif type(data) == \"table\" then","\t\t\treturn _s_table(data, nil, nil, nil, nil, true)","\t\tend","\t\tSF.throw( \"vON: You must serialize a table, not a \" .. type( data ), 2 )","\tend","}",""],"fields":[],"name":"von","client":true,"description":"\nvON Library","libtbl":"von","tables":[],"server":true}},"type":"file","name":"libs_sh/von.lua","functions":{"1":"von.deserialize","2":"von.serialize","von.deserialize":{"ret":"Table","description":"\nDeserialize a string","code":["von.deserialize = setmetatable(_deserialize,_d_meta)",""],"class":"function","classForced":true,"summary":"\nDeserialize a string ","name":"von.deserialize","library":"von","comment":["--- Deserialize a string","-- @shared","-- @class function","-- @name von.deserialize","-- @param str String to deserialize","-- @return Table"],"client":true,"server":true,"param":{"1":"str","str":"String to deserialize"}},"von.serialize":{"ret":"String","description":"\nSerialize a table","code":["von.serialize = setmetatable(_serialize,_s_meta)"],"class":"function","classForced":true,"summary":"\nSerialize a table ","name":"von.serialize","library":"von","comment":["--- Serialize a table","-- @shared","-- @class function","-- @name von.serialize","-- @param tbl Table to serialize","-- @return String"],"client":true,"server":true,"param":{"1":"tbl","tbl":"Table to serialize"}}},"doc":[{"comment":["-----------------------------------------------------------------------------------------------------------------------------"],"code":["","\tThanks to the following people for their contribution:","\t\t-\tDivran\t\t\t\t\t\tSuggested improvements for making the code quicker.","\t\t\t\t\t\t\t\t\t\tSuggested an excellent new way of deserializing strings.","\t\t\t\t\t\t\t\t\t\tLead me to finding an extreme flaw in string parsing.","\t\t-\tpennerlord\t\t\t\t\tProvided some performance tests to help me improve the code.",""],"summary":"\n ","description":"\n","param":[]},{"comment":["-----------------------------------------------------------------------------------------------------------------------------"],"code":["","\tThe value types supported in this release of vON are:","\t\t-\ttable","\t\t-\tnumber","\t\t-\tboolean","\t\t-\tstring","\t\t-\tnil","","\tThese are the native Lua types one would normally serialize.",""],"summary":"\n ","description":"\n","param":[]},{"comment":["-----------------------------------------------------------------------------------------------------------------------------"],"code":["","\tNew in this version:","\t\t-\tAdded errors on (de)serialization when passwing the wrong data type.","\t\t-\tRemoved two redundant arguments in the serialization functable.","--]]",""],"summary":"\n ","description":"\n","param":[]},{"comment":["--- vON Library","-- @shared"],"functions":{"1":"deserialize","2":"serialize","serialize":{"ret":"String","description":"\nSerialize a table","code":["von.serialize = setmetatable(_serialize,_s_meta)"],"class":"function","classForced":true,"summary":"\nSerialize a table ","name":"von.serialize","library":"von","comment":["--- Serialize a table","-- @shared","-- @class function","-- @name von.serialize","-- @param tbl Table to serialize","-- @return String"],"client":true,"server":true,"param":{"1":"tbl","tbl":"Table to serialize"}},"deserialize":{"ret":"Table","description":"\nDeserialize a string","code":["von.deserialize = setmetatable(_deserialize,_d_meta)",""],"class":"function","classForced":true,"summary":"\nDeserialize a string ","name":"von.deserialize","library":"von","comment":["--- Deserialize a string","-- @shared","-- @class function","-- @name von.deserialize","-- @param str String to deserialize","-- @return Table"],"client":true,"server":true,"param":{"1":"str","str":"String to deserialize"}}},"class":"library","summary":"\nvON Library ","code":["local von, _ = SF.Libraries.Register(\"von\")","","local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable","local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next","","--\tThis is kept away from the table for speed.","function d_findVariable(s, i, len, lastType)","\tlocal i, c, typeRead, val = i or 1","","\t--\tKeep looping through the string.","\twhile true do","\t\t--\tStop at the end. Throw an error. This function MUST NOT meet the end!","\t\tif i > len then","\t\t\tSF.throw( \"vON: Reached end of string, cannot form proper variable.\", 3 )","\t\tend","","\t\t--\tCache the character. Nobody wants to look for the same character ten times.","\t\tc = sub(s, i, i)","","\t\t--\tIf it just read a type definition, then a variable HAS to come after it.","\t\tif typeRead then","\t\t\t--\tAttempt to deserialize a variable of the freshly read type.","\t\t\tval, i = _deserialize[lastType](s, i, len)","\t\t\t--\tReturn the value read, the index of the last processed character, and the type of the last read variable.","\t\t\treturn val, i, lastType","","\t\t\t--\t@ means nil. It should not even appear in the output string of the serializer. Nils are useless to store.","\t\telseif c == \"@\" then","\t\t\treturn nil, i, lastType","","\t\t\t--\tn means a number will follow. Base 10... :C","\t\telseif c == \"n\" then","\t\t\tlastType = \"number\"","\t\t\ttypeRead = true","","\t\t\t--\tb means boolean flags.","\t\telseif c == \"b\" then","\t\t\tlastType = \"boolean\"","\t\t\ttypeRead = true","","\t\t\t--\t\" means the start of a string.","\t\telseif c == \"\\\"\" then","\t\t\tlastType = \"string\"","\t\t\ttypeRead = true","","\t\t\t--\t{ means the start of a table!","\t\telseif c == \"{\" then","\t\t\tlastType = \"table\"","\t\t\ttypeRead = true","","\t\t\t--\tIf no type has been found, attempt to deserialize the last type read.","\t\telseif lastType then","\t\t\tval, i = _deserialize[lastType](s, i, len)","\t\t\treturn val, i, lastType","","\t\t\t--\tThis will occur if the very first character in the vON code is wrong.","\t\telse","\t\t\tSF.throw( \"vON: Malformed data... Can't find a proper type definition. Char#\" .. i .. \":\" .. c, 3 )","\t\tend","","\t\t--\tMove the pointer one step forward.","\t\ti = i + 1","\tend","end","","--\tThis is kept away from the table for speed.","--\tYeah, crapload of parameters.","function s_anyVariable(data, lastType, isNumeric, isKey, isLast, nice, indent)","","\t--\tBasically, if the type changes.","\tif lastType ~= type(data) then","\t\t--\tRemember the new type. Caching the type is useless.","\t\tlastType = type(data)","","\t\t--\tReturn the serialized data and the (new) last type.","\t\t--\tThe second argument, which is true now, means that the data type was just changed.","\t\treturn _serialize[lastType](data, true, isNumeric, isKey, isLast, nice, indent), lastType","\tend","","\t--\tOtherwise, simply serialize the data.","\treturn _serialize[lastType](data, false, isNumeric, isKey, isLast, nice, indent), lastType","end","","_deserialize = {","","\t--\tWell, tables are very loose...","\t--\tThe first table doesn't have to begin and end with { and }.","\t[\"table\"] = function(s, i, len, unnecessaryEnd)","\t\tlocal ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals and locals.","","\t\t--\tKeep looping.","\t\twhile true do","\t\t\t--\tUntil it meets the end.","\t\t\tif i > len then","\t\t\t\t--\tYeah, if the end is unnecessary, it won't spit an error. The main chunk doesn't require an end, for example.","\t\t\t\tif unnecessaryEnd then","\t\t\t\t\treturn ret, i","","\t\t\t\t\t--\tOtherwise, the data has to be damaged.","\t\t\t\telse","\t\t\t\t\tSF.throw( \"vON: Reached end of string, incomplete table definition.\", 2 )","\t\t\t\tend","\t\t\tend","","\t\t\t--\tCache the character.","\t\t\tc = sub(s,i,i)","\t\t\t--print(i, \"table char:\", c, tostring(unnecessaryEnd))","","\t\t\t--\tIf it's the end of a table definition, return.","\t\t\tif c == \"}\" then","\t\t\t\treturn ret, i","","\t\t\t\t--\tIf it's the component separator, switch to key:value pairs.","\t\t\telseif c == \"~\" then","\t\t\t\tnumeric = false","","\t\t\telseif c == \";\" then","\t\t\t\t--\tLol, nothing!","\t\t\t\t--\tRemenant from numbers, for faster parsing.","","\t\t\t\t--\tOK, now, if it's on the numeric component, simply add everything encountered.","\t\t\telseif numeric then","\t\t\t\t--\tFind a variable and it's value","\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType)","\t\t\t\t--\tAdd it to the table.","\t\t\t\tret[#ret + 1] = val","","\t\t\t\t--\tOtherwise, if it's the key:value component...","\t\t\telse","\t\t\t\t--\tIf a value is expected...","\t\t\t\tif expectValue then","\t\t\t\t\t--\tRead it.","\t\t\t\t\tval, i, lastType = d_findVariable(s, i, len, lastType)","\t\t\t\t\t--\tAdd it?","\t\t\t\t\tret[key] = val","\t\t\t\t\t--\tClean up.","\t\t\t\t\texpectValue, key = false, nil","","\t\t\t\t\t--\tIf it's the separator...","\t\t\t\telseif c == \":\" then","\t\t\t\t\t--\tExpect a value next.","\t\t\t\t\texpectValue = true","","\t\t\t\t\t--\tBut, if there's a key read already...","\t\t\t\telseif key then","\t\t\t\t\t--\tThen this is malformed.","\t\t\t\t\tSF.throw( \"vON: Malformed table... Two keys declared successively? Char#\" .. i .. \":\" .. c, 2 )","","\t\t\t\t\t--\tOtherwise the key will be read.","\t\t\t\telse","\t\t\t\t\t--\tI love multi-return and multi-assignement.","\t\t\t\t\tkey, i, lastType = d_findVariable(s, i, len, lastType)","\t\t\t\tend","\t\t\tend","","\t\t\ti = i + 1","\t\tend","","\t\treturn nil, i","\tend,","","","\t--\tNumbers are weakly defined.","\t--\tThe declaration is not very explicit. It'll do it's best to parse the number.","\t--\tHas various endings: \\n, }, ~, : and ;, some of which will force the table deserializer to go one char backwards.","\t[\"number\"] = function(s, i, len)","\t\tlocal i, a = i or 1","\t\t--\tLocals, locals, locals, locals","","\t\ta = find(s, \"[;:}~]\", i)","","\t\tif a then","\t\t\treturn tonumber(sub(s, i, a - 1)), a - 1","\t\tend","","\t\tSF.throw( \"vON: Number definition started... Found no end.\", 3 )","\tend,","","","\t--\tA boolean is A SINGLE CHARACTER, either 1 for true or 0 for false.","\t--\tAny other attempt at boolean declaration will result in a failure.","\t[\"boolean\"] = function(s, i, len)","\t\tlocal c = sub(s,i,i)","\t\t--\tOnly one character is needed.","","\t\t--\tIf it's 1, then it's true","\t\tif c == \"1\" then","\t\t\treturn true, i","","\t\t\t--\tIf it's 0, then it's false.","\t\telseif c == \"0\" then","\t\t\treturn false, i","\t\tend","","\t\t--\tAny other supposely \"boolean\" is just a sign of malformed data.","\t\tSF.throw( \"vON: Invalid value on boolean type... Char#\" .. i .. \": \" .. c, 3 )","\tend,","","","\t--\tStrings are very easy to parse and also very explicit.","\t--\t\" simply marks the type of a string.","\t--\tThen it is parsed until an unescaped \" is countered.","\t[\"string\"] = function(s, i, len)","\t\tlocal res, i, a = \"\", i or 1","\t\t--\tLocals, locals, locals, locals","","\t\twhile true do","\t\t\ta = find(s, \"\\\"\", i, true)","","\t\t\tif a then","\t\t\t\tif sub(s, a - 1, a - 1) == \"\\\\\" then","\t\t\t\t\tres = res .. sub(s, i, a - 2) .. \"\\\"\"","\t\t\t\t\ti = a + 1","\t\t\t\telse","\t\t\t\t\treturn res .. sub(s, i, a - 2), a","\t\t\t\tend","\t\t\telse","\t\t\t\tSF.throw( \"vON: String definition started... Found no end.\", 3 )","\t\t\tend","\t\tend","\tend","}","","","_serialize = {","","\t--\tUh. Nothing to comment.","\t--\tShitload of parameters.","\t--\tMakes shit faster than simply passing it around in locals.","\t--\ttable.concat works better than normal concatenations WITH LARGE-ISH STRINGS ONLY.","\t[\"table\"] = function(data, mustInitiate, isNumeric, isKey, isLast, first)","\t--print(string.format(\"data: %s; mustInitiate: %s; isKey: %s; isLast: %s; nice: %s; indent: %s; first: %s\", tostring(data), tostring(mustInitiate), tostring(isKey), tostring(isLast), tostring(nice), tostring(indent), tostring(first)))","","\t\tlocal result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0","\t\t--\tLocals, locals, locals, locals, locals, locals, locals, locals, locals and locals.","","\t\t--\tFirst thing to be done is separate the numeric and key:value components of the given table in two tables.","\t\t--\tpairs(data) is slower than next, data as far as my tests tell me.","\t\tfor k, v in next, data do","\t\t\t--\tSkip the numeric keyz.","\t\t\tif type(k) ~= \"number\" or k < 1 or k > len then","\t\t\t\tkeyvals[#keyvals + 1] = k","\t\t\tend","\t\tend","","\t\tkeyvalsLen = #keyvals","","\t\t--\tMain chunk - no initial character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"{\"","\t\tend","","\t\t--\tAdd numeric values.","\t\tif len > 0 then","\t\t\tfor i = 1, len do","\t\t\t\tval, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, false, 0)","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tIf there are key:value pairs.","\t\tif keyvalsLen > 0 then","\t\t\t--\tInsert delimiter.","\t\t\tresult[#result + 1] = \"~\"","","\t\t\t--\tInsert key:value pairs.","\t\t\tfor _i = 1, keyvalsLen do","\t\t\t\tkeyvalsProgress = keyvalsProgress + 1","","\t\t\t\tval, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, false, 0)","","\t\t\t\tresult[#result + 1] = val..\":\"","","\t\t\t\tval, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, false, 0)","","\t\t\t\tresult[#result + 1] = val","\t\t\tend","\t\tend","","\t\t--\tMain chunk needs no ending character.","\t\tif not first then","\t\t\tresult[#result + 1] = \"}\"","\t\tend","","\t\treturn concat(result)","\tend,","","","\t--\tNormal concatenations is a lot faster with small strings than table.concat","\t--\tAlso, not so branched-ish.","\t[\"number\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t--\tIf a number hasn't been written before, add the type prefix.","\t\tif mustInitiate then","\t\t\tif isKey or isLast then","\t\t\t\treturn \"n\"..data","\t\t\telse","\t\t\t\treturn \"n\"..data..\";\"","\t\t\tend","\t\tend","","\t\tif isKey or isLast then","\t\t\treturn \"n\"..data","\t\telse","\t\t\treturn \"n\"..data..\";\"","\t\tend","\tend,","","","\t--\tI hope gsub is fast enough.","\t[\"string\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t\treturn \"\\\"\" .. gsub(data, \"\\\"\", \"\\\\\\\"\") .. \"v\\\"\"","\tend,","","","\t--\tFastest.","\t[\"boolean\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t--\tPrefix if we must.","\t\tif mustInitiate then","\t\t\tif data then","\t\t\t\treturn \"b1\"","\t\t\telse","\t\t\t\treturn \"b0\"","\t\t\tend","\t\tend","","\t\tif data then","\t\t\treturn \"1\"","\t\telse","\t\t\treturn \"0\"","\t\tend","\tend,","","","\t--\tFastest.","\t[\"nil\"] = function(data, mustInitiate, isNumeric, isKey, isLast)","\t\treturn \"@\"","\tend","}","","local _s_table = _serialize.table","local _d_table = _deserialize.table","","_d_meta = {","\t__call = function(self, str)","\t\tif type(str) == \"string\" then","\t\t\treturn _d_table(str, nil, #str, true)","\t\tend","\t\tSF.throw( \"vON: You must deserialize a string, not a \" .. type( str ), 2 )","\tend","}","_s_meta = {","\t__call = function(self, data)","\t\tif type(data) == \"table\" then","\t\t\treturn _s_table(data, nil, nil, nil, nil, true)","\t\tend","\t\tSF.throw( \"vON: You must serialize a table, not a \" .. type( data ), 2 )","\tend","}",""],"fields":[],"name":"von","client":true,"description":"\nvON Library","libtbl":"von","tables":[],"server":true},{"ret":"Table","description":"\nDeserialize a string","code":["von.deserialize = setmetatable(_deserialize,_d_meta)",""],"class":"function","classForced":true,"summary":"\nDeserialize a string ","name":"von.deserialize","library":"von","comment":["--- Deserialize a string","-- @shared","-- @class function","-- @name von.deserialize","-- @param str String to deserialize","-- @return Table"],"client":true,"server":true,"param":{"1":"str","str":"String to deserialize"}},{"ret":"String","description":"\nSerialize a table","code":["von.serialize = setmetatable(_serialize,_s_meta)"],"class":"function","classForced":true,"summary":"\nSerialize a table ","name":"von.serialize","library":"von","comment":["--- Serialize a table","-- @shared","-- @class function","-- @name von.serialize","-- @param tbl Table to serialize","-- @return String"],"client":true,"server":true,"param":{"1":"tbl","tbl":"Table to serialize"}}],"tables":[],"description":"\n","summary":"\n "},"libs_sh/trace.lua":{"libraries":{"1":"trace","trace":{"comment":["--- Provides functions for doing line/AABB traces","-- @shared","-- @field MAT_ANTLION","-- @field MAT_BLOODYFLESH","-- @field MAT_CONCRETE","-- @field MAT_DIRT","-- @field MAT_FLESH","-- @field MAT_GRATE","-- @field MAT_ALIENFLESH","-- @field MAT_CLIP","-- @field MAT_PLASTIC","-- @field MAT_METAL","-- @field MAT_SAND","-- @field MAT_FOLIAGE","-- @field MAT_COMPUTER","-- @field MAT_SLOSH","-- @field MAT_TILE","-- @field MAT_VENT","-- @field MAT_WOOD","-- @field MAT_GLASS","-- @field HITGROUP_GENERIC","-- @field HITGROUP_HEAD","-- @field HITGROUP_CHEST","-- @field HITGROUP_STOMACH","-- @field HITGROUP_LEFTARM","-- @field HITGROUP_RIGHTARM","-- @field HITGROUP_LEFTLEG","-- @field HITGROUP_RIGHTLEG","-- @field HITGROUP_GEAR","-- @field MASK_SPLITAREAPORTAL","-- @field MASK_SOLID_BRUSHONLY","-- @field MASK_WATER","-- @field MASK_BLOCKLOS","-- @field MASK_OPAQUE","-- @field MASK_VISIBLE","-- @field MASK_DEADSOLID","-- @field MASK_PLAYERSOLID_BRUSHONLY","-- @field MASK_NPCWORLDSTATIC","-- @field MASK_NPCSOLID_BRUSHONLY","-- @field MASK_CURRENT","-- @field MASK_SHOT_PORTAL","-- @field MASK_SOLID","-- @field MASK_BLOCKLOS_AND_NPCS","-- @field MASK_OPAQUE_AND_NPCS","-- @field MASK_VISIBLE_AND_NPCS","-- @field MASK_PLAYERSOLID","-- @field MASK_NPCSOLID","-- @field MASK_SHOT_HULL","-- @field MASK_SHOT","-- @field MASK_ALL","-- @field CONTENTS_EMPTY","-- @field CONTENTS_SOLID","-- @field CONTENTS_WINDOW","-- @field CONTENTS_AUX","-- @field CONTENTS_GRATE","-- @field CONTENTS_SLIME","-- @field CONTENTS_WATER","-- @field CONTENTS_BLOCKLOS","-- @field CONTENTS_OPAQUE","-- @field CONTENTS_TESTFOGVOLUME","-- @field CONTENTS_TEAM4","-- @field CONTENTS_TEAM3","-- @field CONTENTS_TEAM1","-- @field CONTENTS_TEAM2","-- @field CONTENTS_IGNORE_NODRAW_OPAQUE","-- @field CONTENTS_MOVEABLE","-- @field CONTENTS_AREAPORTAL","-- @field CONTENTS_PLAYERCLIP","-- @field CONTENTS_MONSTERCLIP","-- @field CONTENTS_CURRENT_0","-- @field CONTENTS_CURRENT_90","-- @field CONTENTS_CURRENT_180","-- @field CONTENTS_CURRENT_270","-- @field CONTENTS_CURRENT_UP","-- @field CONTENTS_CURRENT_DOWN","-- @field CONTENTS_ORIGIN","-- @field CONTENTS_MONSTER","-- @field CONTENTS_DEBRIS","-- @field CONTENTS_DETAIL","-- @field CONTENTS_TRANSLUCENT","-- @field CONTENTS_LADDER","-- @field CONTENTS_HITBOX"],"functions":{"1":"trace","2":"traceHull","traceHull":{"ret":"Result of the trace","comment":["--- Does a swept-AABB trace","-- @param start Start position","-- @param endpos End position","-- @param minbox Lower box corner","-- @param maxbox Upper box corner","-- @param filter Entity/array of entities to filter","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.traceHull ( start, endpos, minbox, maxbox, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minbox, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxbox, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos, minbox, maxbox = vunwrap( start ), vunwrap( endpos ), vunwrap( minbox ), vunwrap( maxbox )","","\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask,","\t\tmins = minbox,","\t\tmaxs = maxbox","\t}","\t","\treturn SF.Sanitize( util.TraceHull( trace ) )","end"],"class":"function","name":"trace_library.traceHull","summary":"\nDoes a swept-AABB trace ","private":false,"library":"trace","description":"\nDoes a swept-AABB trace","param":{"1":"start","2":"endpos","3":"minbox","4":"maxbox","5":"filter","6":"mask","filter":"Entity/array of entities to filter","maxbox":"Upper box corner","start":"Start position","mask":"Trace mask","minbox":"Lower box corner","endpos":"End position"}},"trace":{"ret":"Result of the trace","comment":["--- Does a line trace","-- @param start Start position","-- @param endpos End position","-- @param filter Entity/array of entities to filter","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.trace ( start, endpos, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos = vunwrap( start ), vunwrap( endpos )","","\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask","\t}","\t","\treturn SF.Sanitize( util.TraceLine( trace ) )","end",""],"class":"function","name":"trace_library.trace","summary":"\nDoes a line trace ","private":false,"library":"trace","description":"\nDoes a line trace","param":{"1":"start","2":"endpos","3":"filter","4":"mask","start":"Start position","mask":"Trace mask","filter":"Entity/array of entities to filter","endpos":"End position"}}},"class":"library","summary":"\nProvides functions for doing line/AABB traces ","field":{"1":"MAT_ANTLION","2":"MAT_BLOODYFLESH","3":"MAT_CONCRETE","4":"MAT_DIRT","5":"MAT_FLESH","6":"MAT_GRATE","7":"MAT_ALIENFLESH","8":"MAT_CLIP","9":"MAT_PLASTIC","10":"MAT_METAL","11":"MAT_SAND","12":"MAT_FOLIAGE","13":"MAT_COMPUTER","14":"MAT_SLOSH","15":"MAT_TILE","16":"MAT_VENT","17":"MAT_WOOD","18":"MAT_GLASS","19":"HITGROUP_GENERIC","20":"HITGROUP_HEAD","21":"HITGROUP_CHEST","22":"HITGROUP_STOMACH","23":"HITGROUP_LEFTARM","24":"HITGROUP_RIGHTARM","25":"HITGROUP_LEFTLEG","26":"HITGROUP_RIGHTLEG","27":"HITGROUP_GEAR","28":"MASK_SPLITAREAPORTAL","29":"MASK_SOLID_BRUSHONLY","30":"MASK_WATER","31":"MASK_BLOCKLOS","32":"MASK_OPAQUE","33":"MASK_VISIBLE","34":"MASK_DEADSOLID","35":"MASK_PLAYERSOLID_BRUSHONLY","36":"MASK_NPCWORLDSTATIC","37":"MASK_NPCSOLID_BRUSHONLY","38":"MASK_CURRENT","39":"MASK_SHOT_PORTAL","40":"MASK_SOLID","41":"MASK_BLOCKLOS_AND_NPCS","42":"MASK_OPAQUE_AND_NPCS","43":"MASK_VISIBLE_AND_NPCS","44":"MASK_PLAYERSOLID","45":"MASK_NPCSOLID","46":"MASK_SHOT_HULL","47":"MASK_SHOT","48":"MASK_ALL","49":"CONTENTS_EMPTY","50":"CONTENTS_SOLID","51":"CONTENTS_WINDOW","52":"CONTENTS_AUX","53":"CONTENTS_GRATE","54":"CONTENTS_SLIME","55":"CONTENTS_WATER","56":"CONTENTS_BLOCKLOS","57":"CONTENTS_OPAQUE","58":"CONTENTS_TESTFOGVOLUME","59":"CONTENTS_TEAM4","60":"CONTENTS_TEAM3","61":"CONTENTS_TEAM1","62":"CONTENTS_TEAM2","63":"CONTENTS_IGNORE_NODRAW_OPAQUE","64":"CONTENTS_MOVEABLE","65":"CONTENTS_AREAPORTAL","66":"CONTENTS_PLAYERCLIP","67":"CONTENTS_MONSTERCLIP","68":"CONTENTS_CURRENT_0","69":"CONTENTS_CURRENT_90","70":"CONTENTS_CURRENT_180","71":"CONTENTS_CURRENT_270","72":"CONTENTS_CURRENT_UP","73":"CONTENTS_CURRENT_DOWN","74":"CONTENTS_ORIGIN","75":"CONTENTS_MONSTER","76":"CONTENTS_DEBRIS","77":"CONTENTS_DETAIL","78":"CONTENTS_TRANSLUCENT","79":"CONTENTS_LADDER","80":"CONTENTS_HITBOX","MASK_DEADSOLID":"","MASK_BLOCKLOS":"","CONTENTS_EMPTY":"","MASK_OPAQUE":"","CONTENTS_IGNORE_NODRAW_OPAQUE":"","MASK_VISIBLE":"","HITGROUP_LEFTLEG":"","MASK_PLAYERSOLID_BRUSHONLY":"","HITGROUP_RIGHTARM":"","CONTENTS_CURRENT_DOWN":"","CONTENTS_OPAQUE":"","MAT_TILE":"","MAT_FOLIAGE":"","HITGROUP_HEAD":"","MASK_SHOT":"","MAT_COMPUTER":"","CONTENTS_TEAM3":"","MASK_SPLITAREAPORTAL":"","CONTENTS_CURRENT_UP":"","MAT_CONCRETE":"","MAT_CLIP":"","MAT_WOOD":"","MAT_ANTLION":"","MASK_NPCSOLID_BRUSHONLY":"","CONTENTS_DEBRIS":"","MASK_SHOT_PORTAL":"","HITGROUP_STOMACH":"","MAT_SLOSH":"","CONTENTS_PLAYERCLIP":"","MASK_NPCWORLDSTATIC":"","MASK_OPAQUE_AND_NPCS":"","MAT_BLOODYFLESH":"","MASK_BLOCKLOS_AND_NPCS":"","CONTENTS_TEAM1":"","HITGROUP_CHEST":"","CONTENTS_AREAPORTAL":"","HITGROUP_GENERIC":"","MAT_METAL":"","HITGROUP_GEAR":"","MAT_VENT":"","MAT_PLASTIC":"","CONTENTS_CURRENT_180":"","MAT_ALIENFLESH":"","MAT_FLESH":"","MAT_GLASS":"","CONTENTS_HITBOX":"","CONTENTS_LADDER":"","CONTENTS_MONSTER":"","CONTENTS_ORIGIN":"","CONTENTS_TEAM2":"","CONTENTS_DETAIL":"","CONTENTS_GRATE":"","MASK_NPCSOLID":"","CONTENTS_MOVEABLE":"","CONTENTS_TRANSLUCENT":"","CONTENTS_CURRENT_270":"","MASK_VISIBLE_AND_NPCS":"","CONTENTS_SOLID":"","CONTENTS_MONSTERCLIP":"","MAT_SAND":"","CONTENTS_SLIME":"","CONTENTS_CURRENT_0":"","CONTENTS_WINDOW":"","MASK_PLAYERSOLID":"","MASK_ALL":"","CONTENTS_BLOCKLOS":"","MASK_WATER":"","MASK_SOLID_BRUSHONLY":"","HITGROUP_RIGHTLEG":"","CONTENTS_CURRENT_90":"","CONTENTS_AUX":"","MASK_CURRENT":"","MAT_DIRT":"","CONTENTS_TEAM4":"","CONTENTS_TESTFOGVOLUME":"","CONTENTS_WATER":"","MASK_SOLID":"","MASK_SHOT_HULL":"","HITGROUP_LEFTARM":"","MAT_GRATE":""},"code":["local trace_library, _ = SF.Libraries.Register(\"trace\")","","-- Material Enumeration","trace_library.MAT_ANTLION = MAT_ANTLION","trace_library.MAT_BLOODYFLESH = MAT_BLOODYFLESH","trace_library.MAT_CONCRETE = MAT_CONCRETE","trace_library.MAT_DIRT = MAT_DIRT","trace_library.MAT_FLESH = MAT_FLESH","trace_library.MAT_GRATE = MAT_GRATE","trace_library.MAT_ALIENFLESH = MAT_ALIENFLESH","trace_library.MAT_CLIP = MAT_CLIP","trace_library.MAT_PLASTIC = MAT_PLASTIC","trace_library.MAT_METAL = MAT_METAL","trace_library.MAT_SAND = MAT_SAND","trace_library.MAT_FOLIAGE = MAT_FOLIAGE","trace_library.MAT_COMPUTER = MAT_COMPUTER","trace_library.MAT_SLOSH = MAT_SLOSH","trace_library.MAT_TILE = MAT_TILE","trace_library.MAT_VENT = MAT_VENT","trace_library.MAT_WOOD = MAT_WOOD","trace_library.MAT_GLASS = MAT_GLASS","","-- Hithroup Enumeration","trace_library.HITGROUP_GENERIC = HITGROUP_GENERIC","trace_library.HITGROUP_HEAD = HITGROUP_HEAD","trace_library.HITGROUP_CHEST = HITGROUP_CHEST","trace_library.HITGROUP_STOMACH = HITGROUP_STOMACH","trace_library.HITGROUP_LEFTARM = HITGROUP_LEFTARM","trace_library.HITGROUP_RIGHTARM = HITGROUP_RIGHTARM","trace_library.HITGROUP_LEFTLEG = HITGROUP_LEFTLEG","trace_library.HITGROUP_RIGHTLEG = HITGROUP_RIGHTLEG","trace_library.HITGROUP_GEAR = HITGROUP_GEAR","","-- Mask Enumerations","trace_library.MASK_SPLITAREAPORTAL = MASK_SPLITAREAPORTAL","trace_library.MASK_SOLID_BRUSHONLY = MASK_SOLID_BRUSHONLY","trace_library.MASK_WATER = MASK_WATER","trace_library.MASK_BLOCKLOS = MASK_BLOCKLOS","trace_library.MASK_OPAQUE = MASK_OPAQUE","trace_library.MASK_VISIBLE = MASK_VISIBLE","trace_library.MASK_DEADSOLID = MASK_DEADSOLID","trace_library.MASK_PLAYERSOLID_BRUSHONLY = MASK_PLAYERSOLID_BRUSHONLY","trace_library.MASK_NPCWORLDSTATIC = MASK_NPCWORLDSTATIC","trace_library.MASK_NPCSOLID_BRUSHONLY = MASK_NPCSOLID_BRUSHONLY","trace_library.MASK_CURRENT = MASK_CURRENT","trace_library.MASK_SHOT_PORTAL = MASK_SHOT_PORTAL","trace_library.MASK_SOLID = MASK_SOLID","trace_library.MASK_BLOCKLOS_AND_NPCS = MASK_BLOCKLOS_AND_NPCS","trace_library.MASK_OPAQUE_AND_NPCS = MASK_OPAQUE_AND_NPCS","trace_library.MASK_VISIBLE_AND_NPCS = MASK_VISIBLE_AND_NPCS","trace_library.MASK_PLAYERSOLID = MASK_PLAYERSOLID","trace_library.MASK_NPCSOLID = MASK_NPCSOLID","trace_library.MASK_SHOT_HULL = MASK_SHOT_HULL","trace_library.MASK_SHOT = MASK_SHOT","trace_library.MASK_ALL = MASK_ALL","","-- Content Enumerations","trace_library.CONTENTS_EMPTY = CONTENTS_EMPTY","trace_library.CONTENTS_SOLID = CONTENTS_SOLID","trace_library.CONTENTS_WINDOW = CONTENTS_WINDOW","trace_library.CONTENTS_AUX = CONTENTS_AUX","trace_library.CONTENTS_GRATE = CONTENTS_GRATE","trace_library.CONTENTS_SLIME = CONTENTS_SLIME","trace_library.CONTENTS_WATER = CONTENTS_WATER","trace_library.CONTENTS_BLOCKLOS = CONTENTS_BLOCKLOS","trace_library.CONTENTS_OPAQUE = CONTENTS_OPAQUE","trace_library.CONTENTS_TESTFOGVOLUME = CONTENTS_TESTFOGVOLUME","trace_library.CONTENTS_TEAM4 = CONTENTS_TEAM4","trace_library.CONTENTS_TEAM3 = CONTENTS_TEAM3","trace_library.CONTENTS_TEAM1 = CONTENTS_TEAM1","trace_library.CONTENTS_TEAM2 = CONTENTS_TEAM2","trace_library.CONTENTS_IGNORE_NODRAW_OPAQUE = CONTENTS_IGNORE_NODRAW_OPAQUE","trace_library.CONTENTS_MOVEABLE = CONTENTS_MOVEABLE","trace_library.CONTENTS_AREAPORTAL = CONTENTS_AREAPORTAL","trace_library.CONTENTS_PLAYERCLIP = CONTENTS_PLAYERCLIP","trace_library.CONTENTS_MONSTERCLIP = CONTENTS_MONSTERCLIP","trace_library.CONTENTS_CURRENT_0 = CONTENTS_CURRENT_0","trace_library.CONTENTS_CURRENT_90 = CONTENTS_CURRENT_90","trace_library.CONTENTS_CURRENT_180 = CONTENTS_CURRENT_180","trace_library.CONTENTS_CURRENT_270 = CONTENTS_CURRENT_270","trace_library.CONTENTS_CURRENT_UP = CONTENTS_CURRENT_UP","trace_library.CONTENTS_CURRENT_DOWN = CONTENTS_CURRENT_DOWN","trace_library.CONTENTS_ORIGIN = CONTENTS_ORIGIN","trace_library.CONTENTS_MONSTER = CONTENTS_MONSTER","trace_library.CONTENTS_DEBRIS = CONTENTS_DEBRIS","trace_library.CONTENTS_DETAIL = CONTENTS_DETAIL","trace_library.CONTENTS_TRANSLUCENT = CONTENTS_TRANSLUCENT","trace_library.CONTENTS_LADDER = CONTENTS_LADDER","trace_library.CONTENTS_HITBOX = CONTENTS_HITBOX","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"trace\", \"Trace\", \"Allows the user to start traces\" )","end","","-- Local functions","","local wrap","local unwrap","","local function postload()","\twrap = SF.Entities.Wrap","\tunwrap = SF.Entities.Unwrap","end","SF.Libraries.AddHook(\"postload\",postload)","","local function convertFilter(filter)","\tif unwrap(filter) then","\t\treturn {filter}","\telse","\t\tlocal l = {}","\t\tlocal count = 1","\t\tfor i=1,#filter do","\t\t\tlocal unwrapped = unwrap(filter[i])","\t\t\tif unwrapped then","\t\t\t\tl[count] = unwrapped","\t\t\t\tcount = count + 1","\t\t\tend","\t\tend","\t\treturn l","\tend","end",""],"fields":[],"name":"trace","client":true,"description":"\nProvides functions for doing line/AABB traces","libtbl":"trace_library","tables":[],"server":true}},"type":"file","name":"libs_sh/trace.lua","functions":{"1":"trace_library.trace","2":"trace_library.traceHull","trace_library.trace":{"ret":"Result of the trace","comment":["--- Does a line trace","-- @param start Start position","-- @param endpos End position","-- @param filter Entity/array of entities to filter","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.trace ( start, endpos, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos = vunwrap( start ), vunwrap( endpos )","","\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask","\t}","\t","\treturn SF.Sanitize( util.TraceLine( trace ) )","end",""],"class":"function","name":"trace_library.trace","summary":"\nDoes a line trace ","private":false,"library":"trace","description":"\nDoes a line trace","param":{"1":"start","2":"endpos","3":"filter","4":"mask","start":"Start position","mask":"Trace mask","filter":"Entity/array of entities to filter","endpos":"End position"}},"trace_library.traceHull":{"ret":"Result of the trace","comment":["--- Does a swept-AABB trace","-- @param start Start position","-- @param endpos End position","-- @param minbox Lower box corner","-- @param maxbox Upper box corner","-- @param filter Entity/array of entities to filter","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.traceHull ( start, endpos, minbox, maxbox, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minbox, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxbox, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos, minbox, maxbox = vunwrap( start ), vunwrap( endpos ), vunwrap( minbox ), vunwrap( maxbox )","","\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask,","\t\tmins = minbox,","\t\tmaxs = maxbox","\t}","\t","\treturn SF.Sanitize( util.TraceHull( trace ) )","end"],"class":"function","name":"trace_library.traceHull","summary":"\nDoes a swept-AABB trace ","private":false,"library":"trace","description":"\nDoes a swept-AABB trace","param":{"1":"start","2":"endpos","3":"minbox","4":"maxbox","5":"filter","6":"mask","filter":"Entity/array of entities to filter","maxbox":"Upper box corner","start":"Start position","mask":"Trace mask","minbox":"Lower box corner","endpos":"End position"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Trace library","-------------------------------------------------------------------------------"],"code":["","local dgetmeta = debug.getmetatable","","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","--[[","-- Here's a neat little script to convert enumerations wiki.gmod.com-style","-- into something usable in code","","local lines = <copy+paste enumeration with trailing \\n here>","","for line in lines:gmatch(\"([^\\n]*)\\n\") do"," local v = line:match(\"^.*|%s*(.*)$\")"," print(\"trace_library.\"..v..\" = \"..v)","end","]]",""],"summary":"\n \nTrace library \n ","description":"\n \nTrace library \n","param":[]},{"comment":["--- Provides functions for doing line/AABB traces","-- @shared","-- @field MAT_ANTLION","-- @field MAT_BLOODYFLESH","-- @field MAT_CONCRETE","-- @field MAT_DIRT","-- @field MAT_FLESH","-- @field MAT_GRATE","-- @field MAT_ALIENFLESH","-- @field MAT_CLIP","-- @field MAT_PLASTIC","-- @field MAT_METAL","-- @field MAT_SAND","-- @field MAT_FOLIAGE","-- @field MAT_COMPUTER","-- @field MAT_SLOSH","-- @field MAT_TILE","-- @field MAT_VENT","-- @field MAT_WOOD","-- @field MAT_GLASS","-- @field HITGROUP_GENERIC","-- @field HITGROUP_HEAD","-- @field HITGROUP_CHEST","-- @field HITGROUP_STOMACH","-- @field HITGROUP_LEFTARM","-- @field HITGROUP_RIGHTARM","-- @field HITGROUP_LEFTLEG","-- @field HITGROUP_RIGHTLEG","-- @field HITGROUP_GEAR","-- @field MASK_SPLITAREAPORTAL","-- @field MASK_SOLID_BRUSHONLY","-- @field MASK_WATER","-- @field MASK_BLOCKLOS","-- @field MASK_OPAQUE","-- @field MASK_VISIBLE","-- @field MASK_DEADSOLID","-- @field MASK_PLAYERSOLID_BRUSHONLY","-- @field MASK_NPCWORLDSTATIC","-- @field MASK_NPCSOLID_BRUSHONLY","-- @field MASK_CURRENT","-- @field MASK_SHOT_PORTAL","-- @field MASK_SOLID","-- @field MASK_BLOCKLOS_AND_NPCS","-- @field MASK_OPAQUE_AND_NPCS","-- @field MASK_VISIBLE_AND_NPCS","-- @field MASK_PLAYERSOLID","-- @field MASK_NPCSOLID","-- @field MASK_SHOT_HULL","-- @field MASK_SHOT","-- @field MASK_ALL","-- @field CONTENTS_EMPTY","-- @field CONTENTS_SOLID","-- @field CONTENTS_WINDOW","-- @field CONTENTS_AUX","-- @field CONTENTS_GRATE","-- @field CONTENTS_SLIME","-- @field CONTENTS_WATER","-- @field CONTENTS_BLOCKLOS","-- @field CONTENTS_OPAQUE","-- @field CONTENTS_TESTFOGVOLUME","-- @field CONTENTS_TEAM4","-- @field CONTENTS_TEAM3","-- @field CONTENTS_TEAM1","-- @field CONTENTS_TEAM2","-- @field CONTENTS_IGNORE_NODRAW_OPAQUE","-- @field CONTENTS_MOVEABLE","-- @field CONTENTS_AREAPORTAL","-- @field CONTENTS_PLAYERCLIP","-- @field CONTENTS_MONSTERCLIP","-- @field CONTENTS_CURRENT_0","-- @field CONTENTS_CURRENT_90","-- @field CONTENTS_CURRENT_180","-- @field CONTENTS_CURRENT_270","-- @field CONTENTS_CURRENT_UP","-- @field CONTENTS_CURRENT_DOWN","-- @field CONTENTS_ORIGIN","-- @field CONTENTS_MONSTER","-- @field CONTENTS_DEBRIS","-- @field CONTENTS_DETAIL","-- @field CONTENTS_TRANSLUCENT","-- @field CONTENTS_LADDER","-- @field CONTENTS_HITBOX"],"functions":{"1":"trace","2":"traceHull","traceHull":{"ret":"Result of the trace","comment":["--- Does a swept-AABB trace","-- @param start Start position","-- @param endpos End position","-- @param minbox Lower box corner","-- @param maxbox Upper box corner","-- @param filter Entity/array of entities to filter","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.traceHull ( start, endpos, minbox, maxbox, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minbox, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxbox, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos, minbox, maxbox = vunwrap( start ), vunwrap( endpos ), vunwrap( minbox ), vunwrap( maxbox )","","\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask,","\t\tmins = minbox,","\t\tmaxs = maxbox","\t}","\t","\treturn SF.Sanitize( util.TraceHull( trace ) )","end"],"class":"function","name":"trace_library.traceHull","summary":"\nDoes a swept-AABB trace ","private":false,"library":"trace","description":"\nDoes a swept-AABB trace","param":{"1":"start","2":"endpos","3":"minbox","4":"maxbox","5":"filter","6":"mask","filter":"Entity/array of entities to filter","maxbox":"Upper box corner","start":"Start position","mask":"Trace mask","minbox":"Lower box corner","endpos":"End position"}},"trace":{"ret":"Result of the trace","comment":["--- Does a line trace","-- @param start Start position","-- @param endpos End position","-- @param filter Entity/array of entities to filter","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.trace ( start, endpos, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos = vunwrap( start ), vunwrap( endpos )","","\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask","\t}","\t","\treturn SF.Sanitize( util.TraceLine( trace ) )","end",""],"class":"function","name":"trace_library.trace","summary":"\nDoes a line trace ","private":false,"library":"trace","description":"\nDoes a line trace","param":{"1":"start","2":"endpos","3":"filter","4":"mask","start":"Start position","mask":"Trace mask","filter":"Entity/array of entities to filter","endpos":"End position"}}},"class":"library","summary":"\nProvides functions for doing line/AABB traces ","field":{"1":"MAT_ANTLION","2":"MAT_BLOODYFLESH","3":"MAT_CONCRETE","4":"MAT_DIRT","5":"MAT_FLESH","6":"MAT_GRATE","7":"MAT_ALIENFLESH","8":"MAT_CLIP","9":"MAT_PLASTIC","10":"MAT_METAL","11":"MAT_SAND","12":"MAT_FOLIAGE","13":"MAT_COMPUTER","14":"MAT_SLOSH","15":"MAT_TILE","16":"MAT_VENT","17":"MAT_WOOD","18":"MAT_GLASS","19":"HITGROUP_GENERIC","20":"HITGROUP_HEAD","21":"HITGROUP_CHEST","22":"HITGROUP_STOMACH","23":"HITGROUP_LEFTARM","24":"HITGROUP_RIGHTARM","25":"HITGROUP_LEFTLEG","26":"HITGROUP_RIGHTLEG","27":"HITGROUP_GEAR","28":"MASK_SPLITAREAPORTAL","29":"MASK_SOLID_BRUSHONLY","30":"MASK_WATER","31":"MASK_BLOCKLOS","32":"MASK_OPAQUE","33":"MASK_VISIBLE","34":"MASK_DEADSOLID","35":"MASK_PLAYERSOLID_BRUSHONLY","36":"MASK_NPCWORLDSTATIC","37":"MASK_NPCSOLID_BRUSHONLY","38":"MASK_CURRENT","39":"MASK_SHOT_PORTAL","40":"MASK_SOLID","41":"MASK_BLOCKLOS_AND_NPCS","42":"MASK_OPAQUE_AND_NPCS","43":"MASK_VISIBLE_AND_NPCS","44":"MASK_PLAYERSOLID","45":"MASK_NPCSOLID","46":"MASK_SHOT_HULL","47":"MASK_SHOT","48":"MASK_ALL","49":"CONTENTS_EMPTY","50":"CONTENTS_SOLID","51":"CONTENTS_WINDOW","52":"CONTENTS_AUX","53":"CONTENTS_GRATE","54":"CONTENTS_SLIME","55":"CONTENTS_WATER","56":"CONTENTS_BLOCKLOS","57":"CONTENTS_OPAQUE","58":"CONTENTS_TESTFOGVOLUME","59":"CONTENTS_TEAM4","60":"CONTENTS_TEAM3","61":"CONTENTS_TEAM1","62":"CONTENTS_TEAM2","63":"CONTENTS_IGNORE_NODRAW_OPAQUE","64":"CONTENTS_MOVEABLE","65":"CONTENTS_AREAPORTAL","66":"CONTENTS_PLAYERCLIP","67":"CONTENTS_MONSTERCLIP","68":"CONTENTS_CURRENT_0","69":"CONTENTS_CURRENT_90","70":"CONTENTS_CURRENT_180","71":"CONTENTS_CURRENT_270","72":"CONTENTS_CURRENT_UP","73":"CONTENTS_CURRENT_DOWN","74":"CONTENTS_ORIGIN","75":"CONTENTS_MONSTER","76":"CONTENTS_DEBRIS","77":"CONTENTS_DETAIL","78":"CONTENTS_TRANSLUCENT","79":"CONTENTS_LADDER","80":"CONTENTS_HITBOX","MASK_DEADSOLID":"","MASK_BLOCKLOS":"","CONTENTS_EMPTY":"","MASK_OPAQUE":"","CONTENTS_IGNORE_NODRAW_OPAQUE":"","MASK_VISIBLE":"","HITGROUP_LEFTLEG":"","MASK_PLAYERSOLID_BRUSHONLY":"","HITGROUP_RIGHTARM":"","CONTENTS_CURRENT_DOWN":"","CONTENTS_OPAQUE":"","MAT_TILE":"","MAT_FOLIAGE":"","HITGROUP_HEAD":"","MASK_SHOT":"","MAT_COMPUTER":"","CONTENTS_TEAM3":"","MASK_SPLITAREAPORTAL":"","CONTENTS_CURRENT_UP":"","MAT_CONCRETE":"","MAT_CLIP":"","MAT_WOOD":"","MAT_ANTLION":"","MASK_NPCSOLID_BRUSHONLY":"","CONTENTS_DEBRIS":"","MASK_SHOT_PORTAL":"","HITGROUP_STOMACH":"","MAT_SLOSH":"","CONTENTS_PLAYERCLIP":"","MASK_NPCWORLDSTATIC":"","MASK_OPAQUE_AND_NPCS":"","MAT_BLOODYFLESH":"","MASK_BLOCKLOS_AND_NPCS":"","CONTENTS_TEAM1":"","HITGROUP_CHEST":"","CONTENTS_AREAPORTAL":"","HITGROUP_GENERIC":"","MAT_METAL":"","HITGROUP_GEAR":"","MAT_VENT":"","MAT_PLASTIC":"","CONTENTS_CURRENT_180":"","MAT_ALIENFLESH":"","MAT_FLESH":"","MAT_GLASS":"","CONTENTS_HITBOX":"","CONTENTS_LADDER":"","CONTENTS_MONSTER":"","CONTENTS_ORIGIN":"","CONTENTS_TEAM2":"","CONTENTS_DETAIL":"","CONTENTS_GRATE":"","MASK_NPCSOLID":"","CONTENTS_MOVEABLE":"","CONTENTS_TRANSLUCENT":"","CONTENTS_CURRENT_270":"","MASK_VISIBLE_AND_NPCS":"","CONTENTS_SOLID":"","CONTENTS_MONSTERCLIP":"","MAT_SAND":"","CONTENTS_SLIME":"","CONTENTS_CURRENT_0":"","CONTENTS_WINDOW":"","MASK_PLAYERSOLID":"","MASK_ALL":"","CONTENTS_BLOCKLOS":"","MASK_WATER":"","MASK_SOLID_BRUSHONLY":"","HITGROUP_RIGHTLEG":"","CONTENTS_CURRENT_90":"","CONTENTS_AUX":"","MASK_CURRENT":"","MAT_DIRT":"","CONTENTS_TEAM4":"","CONTENTS_TESTFOGVOLUME":"","CONTENTS_WATER":"","MASK_SOLID":"","MASK_SHOT_HULL":"","HITGROUP_LEFTARM":"","MAT_GRATE":""},"code":["local trace_library, _ = SF.Libraries.Register(\"trace\")","","-- Material Enumeration","trace_library.MAT_ANTLION = MAT_ANTLION","trace_library.MAT_BLOODYFLESH = MAT_BLOODYFLESH","trace_library.MAT_CONCRETE = MAT_CONCRETE","trace_library.MAT_DIRT = MAT_DIRT","trace_library.MAT_FLESH = MAT_FLESH","trace_library.MAT_GRATE = MAT_GRATE","trace_library.MAT_ALIENFLESH = MAT_ALIENFLESH","trace_library.MAT_CLIP = MAT_CLIP","trace_library.MAT_PLASTIC = MAT_PLASTIC","trace_library.MAT_METAL = MAT_METAL","trace_library.MAT_SAND = MAT_SAND","trace_library.MAT_FOLIAGE = MAT_FOLIAGE","trace_library.MAT_COMPUTER = MAT_COMPUTER","trace_library.MAT_SLOSH = MAT_SLOSH","trace_library.MAT_TILE = MAT_TILE","trace_library.MAT_VENT = MAT_VENT","trace_library.MAT_WOOD = MAT_WOOD","trace_library.MAT_GLASS = MAT_GLASS","","-- Hithroup Enumeration","trace_library.HITGROUP_GENERIC = HITGROUP_GENERIC","trace_library.HITGROUP_HEAD = HITGROUP_HEAD","trace_library.HITGROUP_CHEST = HITGROUP_CHEST","trace_library.HITGROUP_STOMACH = HITGROUP_STOMACH","trace_library.HITGROUP_LEFTARM = HITGROUP_LEFTARM","trace_library.HITGROUP_RIGHTARM = HITGROUP_RIGHTARM","trace_library.HITGROUP_LEFTLEG = HITGROUP_LEFTLEG","trace_library.HITGROUP_RIGHTLEG = HITGROUP_RIGHTLEG","trace_library.HITGROUP_GEAR = HITGROUP_GEAR","","-- Mask Enumerations","trace_library.MASK_SPLITAREAPORTAL = MASK_SPLITAREAPORTAL","trace_library.MASK_SOLID_BRUSHONLY = MASK_SOLID_BRUSHONLY","trace_library.MASK_WATER = MASK_WATER","trace_library.MASK_BLOCKLOS = MASK_BLOCKLOS","trace_library.MASK_OPAQUE = MASK_OPAQUE","trace_library.MASK_VISIBLE = MASK_VISIBLE","trace_library.MASK_DEADSOLID = MASK_DEADSOLID","trace_library.MASK_PLAYERSOLID_BRUSHONLY = MASK_PLAYERSOLID_BRUSHONLY","trace_library.MASK_NPCWORLDSTATIC = MASK_NPCWORLDSTATIC","trace_library.MASK_NPCSOLID_BRUSHONLY = MASK_NPCSOLID_BRUSHONLY","trace_library.MASK_CURRENT = MASK_CURRENT","trace_library.MASK_SHOT_PORTAL = MASK_SHOT_PORTAL","trace_library.MASK_SOLID = MASK_SOLID","trace_library.MASK_BLOCKLOS_AND_NPCS = MASK_BLOCKLOS_AND_NPCS","trace_library.MASK_OPAQUE_AND_NPCS = MASK_OPAQUE_AND_NPCS","trace_library.MASK_VISIBLE_AND_NPCS = MASK_VISIBLE_AND_NPCS","trace_library.MASK_PLAYERSOLID = MASK_PLAYERSOLID","trace_library.MASK_NPCSOLID = MASK_NPCSOLID","trace_library.MASK_SHOT_HULL = MASK_SHOT_HULL","trace_library.MASK_SHOT = MASK_SHOT","trace_library.MASK_ALL = MASK_ALL","","-- Content Enumerations","trace_library.CONTENTS_EMPTY = CONTENTS_EMPTY","trace_library.CONTENTS_SOLID = CONTENTS_SOLID","trace_library.CONTENTS_WINDOW = CONTENTS_WINDOW","trace_library.CONTENTS_AUX = CONTENTS_AUX","trace_library.CONTENTS_GRATE = CONTENTS_GRATE","trace_library.CONTENTS_SLIME = CONTENTS_SLIME","trace_library.CONTENTS_WATER = CONTENTS_WATER","trace_library.CONTENTS_BLOCKLOS = CONTENTS_BLOCKLOS","trace_library.CONTENTS_OPAQUE = CONTENTS_OPAQUE","trace_library.CONTENTS_TESTFOGVOLUME = CONTENTS_TESTFOGVOLUME","trace_library.CONTENTS_TEAM4 = CONTENTS_TEAM4","trace_library.CONTENTS_TEAM3 = CONTENTS_TEAM3","trace_library.CONTENTS_TEAM1 = CONTENTS_TEAM1","trace_library.CONTENTS_TEAM2 = CONTENTS_TEAM2","trace_library.CONTENTS_IGNORE_NODRAW_OPAQUE = CONTENTS_IGNORE_NODRAW_OPAQUE","trace_library.CONTENTS_MOVEABLE = CONTENTS_MOVEABLE","trace_library.CONTENTS_AREAPORTAL = CONTENTS_AREAPORTAL","trace_library.CONTENTS_PLAYERCLIP = CONTENTS_PLAYERCLIP","trace_library.CONTENTS_MONSTERCLIP = CONTENTS_MONSTERCLIP","trace_library.CONTENTS_CURRENT_0 = CONTENTS_CURRENT_0","trace_library.CONTENTS_CURRENT_90 = CONTENTS_CURRENT_90","trace_library.CONTENTS_CURRENT_180 = CONTENTS_CURRENT_180","trace_library.CONTENTS_CURRENT_270 = CONTENTS_CURRENT_270","trace_library.CONTENTS_CURRENT_UP = CONTENTS_CURRENT_UP","trace_library.CONTENTS_CURRENT_DOWN = CONTENTS_CURRENT_DOWN","trace_library.CONTENTS_ORIGIN = CONTENTS_ORIGIN","trace_library.CONTENTS_MONSTER = CONTENTS_MONSTER","trace_library.CONTENTS_DEBRIS = CONTENTS_DEBRIS","trace_library.CONTENTS_DETAIL = CONTENTS_DETAIL","trace_library.CONTENTS_TRANSLUCENT = CONTENTS_TRANSLUCENT","trace_library.CONTENTS_LADDER = CONTENTS_LADDER","trace_library.CONTENTS_HITBOX = CONTENTS_HITBOX","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"trace\", \"Trace\", \"Allows the user to start traces\" )","end","","-- Local functions","","local wrap","local unwrap","","local function postload()","\twrap = SF.Entities.Wrap","\tunwrap = SF.Entities.Unwrap","end","SF.Libraries.AddHook(\"postload\",postload)","","local function convertFilter(filter)","\tif unwrap(filter) then","\t\treturn {filter}","\telse","\t\tlocal l = {}","\t\tlocal count = 1","\t\tfor i=1,#filter do","\t\t\tlocal unwrapped = unwrap(filter[i])","\t\t\tif unwrapped then","\t\t\t\tl[count] = unwrapped","\t\t\t\tcount = count + 1","\t\t\tend","\t\tend","\t\treturn l","\tend","end",""],"fields":[],"name":"trace","client":true,"description":"\nProvides functions for doing line/AABB traces","libtbl":"trace_library","tables":[],"server":true},{"ret":"Result of the trace","comment":["--- Does a line trace","-- @param start Start position","-- @param endpos End position","-- @param filter Entity/array of entities to filter","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.trace ( start, endpos, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos = vunwrap( start ), vunwrap( endpos )","","\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask","\t}","\t","\treturn SF.Sanitize( util.TraceLine( trace ) )","end",""],"class":"function","name":"trace_library.trace","summary":"\nDoes a line trace ","private":false,"library":"trace","description":"\nDoes a line trace","param":{"1":"start","2":"endpos","3":"filter","4":"mask","start":"Start position","mask":"Trace mask","filter":"Entity/array of entities to filter","endpos":"End position"}},{"ret":"Result of the trace","comment":["--- Does a swept-AABB trace","-- @param start Start position","-- @param endpos End position","-- @param minbox Lower box corner","-- @param maxbox Upper box corner","-- @param filter Entity/array of entities to filter","-- @param mask Trace mask","-- @return Result of the trace"],"code":["function trace_library.traceHull ( start, endpos, minbox, maxbox, filter, mask )","\tif not SF.Permissions.check( SF.instance.player, nil, \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( start, SF.Types[ \"Vector\" ] )","\tSF.CheckType( endpos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( minbox, SF.Types[ \"Vector\" ] )","\tSF.CheckType( maxbox, SF.Types[ \"Vector\" ] )","","\tlocal start, endpos, minbox, maxbox = vunwrap( start ), vunwrap( endpos ), vunwrap( minbox ), vunwrap( maxbox )","","\tfilter = convertFilter( SF.CheckType( filter, \"table\", 0, {} ) )","\tif mask ~= nil then mask = SF.CheckType( mask, \"number\" ) end","","\tlocal trace = {","\t\tstart = start,","\t\tendpos = endpos,","\t\tfilter = filter,","\t\tmask = mask,","\t\tmins = minbox,","\t\tmaxs = maxbox","\t}","\t","\treturn SF.Sanitize( util.TraceHull( trace ) )","end"],"class":"function","name":"trace_library.traceHull","summary":"\nDoes a swept-AABB trace ","private":false,"library":"trace","description":"\nDoes a swept-AABB trace","param":{"1":"start","2":"endpos","3":"minbox","4":"maxbox","5":"filter","6":"mask","filter":"Entity/array of entities to filter","maxbox":"Upper box corner","start":"Start position","mask":"Trace mask","minbox":"Lower box corner","endpos":"End position"}}],"tables":[],"description":"\n \nTrace library \n","summary":"\n \nTrace library \n "},"libs_sh/vectors.lua":{"libraries":[],"type":"file","name":"libs_sh/vectors.lua","functions":{"1":"vec_metamethods.__index","2":"vec_metamethods.__newindex","3":"vec_metamethods:__add","4":"vec_metamethods:__div","5":"vec_metamethods:__eq","6":"vec_metamethods:__mul","7":"vec_metamethods:__sub","8":"vec_metamethods:__tostring","9":"vec_metamethods:__unm","10":"vec_methods:add","11":"vec_methods:cross","12":"vec_methods:dot","13":"vec_methods:getAngle","14":"vec_methods:getAngleEx","15":"vec_methods:getDistance","16":"vec_methods:getDistanceSqr","17":"vec_methods:getLength","18":"vec_methods:getLength2D","19":"vec_methods:getLength2DSqr","20":"vec_methods:getLengthSqr","21":"vec_methods:getNormalized","22":"vec_methods:isEqualTol","23":"vec_methods:isZero","24":"vec_methods:mul","25":"vec_methods:normalize","26":"vec_methods:rotate","27":"vec_methods:set","28":"vec_methods:setZero","29":"vec_methods:sub","30":"vec_methods:toScreen","31":"vec_methods:withinAABox","vec_methods:dot":{"ret":"Number","comment":["--- Dot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:dot ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):Dot( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:dot","summary":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths.","private":false,"classlib":"Vector","description":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","param":{"1":"v","v":"Second Vector"}},"vec_methods:isZero":{"ret":"bool True/False","comment":["--- Are all fields zero.","-- @return bool True/False"],"code":["function vec_methods:isZero ()","\treturn unwrap( self ):IsZero()","end",""],"class":"function","name":"vec_methods:isZero","summary":"\nAre all fields zero.","private":false,"classlib":"Vector","description":"\nAre all fields zero.","param":[]},"vec_methods:getAngle":{"ret":"Angle","comment":["--- Get the vector's angle.","-- @return Angle"],"code":["function vec_methods:getAngle ()","\treturn SF.WrapObject( unwrap( self ):Angle() )","end",""],"class":"function","name":"vec_methods:getAngle","summary":"\nGet the vector's angle.","private":false,"classlib":"Vector","description":"\nGet the vector's angle.","param":[]},"vec_metamethods.__index":{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function vec_metamethods.__index ( t, k )","\tif type( k ) == \"number\" then","\t\tif k >= 1 and k <= 3 then","\t\t\treturn unwrap( t )[ k ]","\t\tend","\telse","\t\tif k == \"x\" or k ==\"y\" or k == \"z\" then","\t\t\treturn unwrap( t )[ k ]","\t\tend","\tend","\treturn _p[ k ]","end",""],"private":false,"class":"function","name":"vec_metamethods.__index","param":["t","k"]},"vec_methods:withinAABox":{"ret":"bool True/False.","comment":["--- Returns whenever the given vector is in a box created by the 2 other vectors.","-- @param v1 Vector used to define AABox","-- @param v2 Second Vector to define AABox","-- @return bool True/False."],"code":["function vec_methods:withinAABox ( v1, v2 )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):WithinAABox( unwrap( v1 ), unwrap( v2 ) )","end"],"class":"function","name":"vec_methods:withinAABox","summary":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","private":false,"classlib":"Vector","description":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","param":{"1":"v1","2":"v2","v2":"Second Vector to define AABox","v1":"Vector used to define AABox"}},"vec_methods:isEqualTol":{"ret":"bool True/False.","comment":["--- Is this vector and v equal within tolerance t.","-- @param v Second Vector","-- @param t Tolerance number.","-- @return bool True/False."],"code":["function vec_methods:isEqualTol ( v, t )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tSF.CheckType( t, \"number\" )","\treturn unwrap( self ):IsEqualTol( unwrap( v ), t )","end",""],"class":"function","name":"vec_methods:isEqualTol","summary":"\nIs this vector and v equal within tolerance t.","private":false,"classlib":"Vector","description":"\nIs this vector and v equal within tolerance t.","param":{"1":"v","2":"t","t":"Tolerance number.","v":"Second Vector"}},"vec_methods:getAngleEx":{"ret":"Angle","comment":["--- Returns the Angle between two vectors.","-- @param v Second Vector","-- @return Angle"],"code":["function vec_methods:getAngleEx ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn SF.WrapObject( unwrap( self ):AngleEx( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods:getAngleEx","summary":"\nReturns the Angle between two vectors.","private":false,"classlib":"Vector","description":"\nReturns the Angle between two vectors.","param":{"1":"v","v":"Second Vector"}},"vec_methods:toScreen":{"ret":"nil","comment":["--- Translates the vectors position into 2D user screen coordinates. Self-Modifies.","-- @return nil"],"code":["function vec_methods:toScreen ()","\treturn unwrap( self ):ToScreen()","end",""],"class":"function","name":"vec_methods:toScreen","summary":"\nTranslates the vectors position into 2D user screen coordinates.","private":false,"classlib":"Vector","description":"\nTranslates the vectors position into 2D user screen coordinates. Self-Modifies.","param":[]},"vec_methods:getDistanceSqr":{"ret":"Number","comment":["--- Returns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:getDistanceSqr ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):DistToSqr( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:getDistanceSqr","summary":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","private":false,"classlib":"Vector","description":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","param":{"1":"v","v":"Second Vector"}},"vec_metamethods:__div":{"ret":"Scaled vector.","comment":["--- division metamethod","-- @param n Scalar to divide the Vector by","-- @return Scaled vector."],"code":["function vec_metamethods:__div ( n )","\tSF.CheckType( n, \"number\" )","\treturn SF.WrapObject( unwrap( self ):__div( n ) )","end",""],"class":"function","name":"vec_metamethods:__div","private":false,"summary":"\ndivision metamethod ","description":"\ndivision metamethod","param":{"1":"n","n":"Scalar to divide the Vector by"}},"vec_methods:sub":{"ret":"nil","comment":["--- Subtract v from this Vector. Self-Modifies.","-- @param v Second Vector.","-- @return nil"],"code":["function vec_methods:sub ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Sub( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:sub","summary":"\nSubtract v from this Vector.","private":false,"classlib":"Vector","description":"\nSubtract v from this Vector. Self-Modifies.","param":{"1":"v","v":"Second Vector."}},"vec_metamethods:__tostring":{"ret":"string representing the vector.","comment":["--- tostring metamethod","-- @return string representing the vector."],"code":["function vec_metamethods:__tostring ()","\treturn unwrap( self ):__tostring()","end",""],"class":"function","name":"vec_metamethods:__tostring","private":false,"summary":"\ntostring metamethod ","description":"\ntostring metamethod","param":[]},"vec_methods:set":{"ret":"nil","comment":["--- Copies the values from the second vector to the first vector. Self-Modifies.","-- @param v Second Vector","-- @return nil"],"code":["function vec_methods:set ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Set( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:set","summary":"\nCopies the values from the second vector to the first vector.","private":false,"classlib":"Vector","description":"\nCopies the values from the second vector to the first vector. Self-Modifies.","param":{"1":"v","v":"Second Vector"}},"vec_methods:rotate":{"ret":"nil.","comment":["--- Rotate the vector by Angle a. Self-Modifies.","-- @param a Angle to rotate by.","-- @return nil."],"code":["function vec_methods:rotate ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\tunwrap( self ):Rotate( SF.UnwrapObject( a ) )","end",""],"class":"function","name":"vec_methods:rotate","summary":"\nRotate the vector by Angle a.","private":false,"classlib":"Vector","description":"\nRotate the vector by Angle a. Self-Modifies.","param":{"1":"a","a":"Angle to rotate by."}},"vec_metamethods:__mul":{"ret":"Scaled vector.","comment":["--- multiplication metamethod","-- @param n Scalar to multiply against vector","-- @return Scaled vector."],"code":["function vec_metamethods:__mul ( n )","\tSF.CheckType( n, \"number\" )","\treturn wrap( unwrap( self ):__mul( n ) )","end",""],"class":"function","name":"vec_metamethods:__mul","private":false,"summary":"\nmultiplication metamethod ","description":"\nmultiplication metamethod","param":{"1":"n","n":"Scalar to multiply against vector"}},"vec_methods:normalize":{"ret":"nil","comment":["--- Normalise the vector, same direction, length 0. Self-Modifies.","-- @return nil"],"code":["function vec_methods:normalize ()","\tunwrap( self ):Normalize()","end",""],"class":"function","name":"vec_methods:normalize","summary":"\nNormalise the vector, same direction, length 0.","private":false,"classlib":"Vector","description":"\nNormalise the vector, same direction, length 0. Self-Modifies.","param":[]},"vec_methods:setZero":{"ret":"nil","comment":["--- Set's all vector fields to 0.","-- @return nil"],"code":["function vec_methods:setZero ()","\tunwrap( self ):Zero()","end",""],"class":"function","name":"vec_methods:setZero","summary":"\nSet's all vector fields to 0.","private":false,"classlib":"Vector","description":"\nSet's all vector fields to 0.","param":[]},"vec_methods:getLength":{"ret":"number Length.","comment":["--- Get the vector's Length.","-- @return number Length."],"code":["function vec_methods:getLength ()","\treturn unwrap( self ):Length()","end",""],"class":"function","name":"vec_methods:getLength","summary":"\nGet the vector's Length.","private":false,"classlib":"Vector","description":"\nGet the vector's Length.","param":[]},"vec_methods:mul":{"ret":"nil","comment":["--- Scalar Multiplication of the vector. Self-Modifies.","-- @param n Scalar to multiply with.","-- @return nil"],"code":["function vec_methods:mul ( n )","\tSF.CheckType( n, \"number\" )","\tunwrap( self ):Mul( n )","end",""],"class":"function","name":"vec_methods:mul","summary":"\nScalar Multiplication of the vector.","private":false,"classlib":"Vector","description":"\nScalar Multiplication of the vector. Self-Modifies.","param":{"1":"n","n":"Scalar to multiply with."}},"vec_metamethods:__unm":{"ret":"negated vector.","comment":["--- unary minus metamethod","-- @return negated vector."],"code":["function vec_metamethods:__unm ()","\treturn wrap( unwrap( self ):__unm() )","end",""],"class":"function","name":"vec_metamethods:__unm","private":false,"summary":"\nunary minus metamethod ","description":"\nunary minus metamethod","param":[]},"vec_metamethods.__newindex":{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function vec_metamethods.__newindex ( t, k, v )","\tif type( k ) == \"number\" then","\t\tif k >= 1 and k <= 3 then","\t\t\tSF.UnwrapObject( t ).__newindex( SF.UnwrapObject( t ), k, v )","\t\tend","\telseif k == \"x\" or k ==\"y\" or k == \"z\" then","\t\tSF.UnwrapObject( t ).__newindex( SF.UnwrapObject( t ), k, v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = vec_metamethods.__index"],"private":false,"class":"function","name":"vec_metamethods.__newindex","param":["t","k","v"]},"vec_methods:getLength2DSqr":{"ret":"number length squared.","comment":["--- Returns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","-- @return number length squared."],"code":["function vec_methods:getLength2DSqr ()","\treturn unwrap( self ):Length2DSqr()","end",""],"class":"function","name":"vec_methods:getLength2DSqr","summary":"\nReturns the length squared of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","param":[]},"vec_methods:add":{"ret":"nil","comment":["--- Add vector - Modifies self.","-- @param v Vector to add","-- @return nil"],"code":["function vec_methods:add ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Add( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:add","summary":"\nAdd vector - Modifies self.","private":false,"classlib":"Vector","description":"\nAdd vector - Modifies self.","param":{"1":"v","v":"Vector to add"}},"vec_methods:getLength2D":{"ret":"number length","comment":["--- Returns the length of the vector in two dimensions, without the Z axis.","-- @return number length"],"code":["function vec_methods:getLength2D ()","\treturn unwrap( self ):Length2D()","end",""],"class":"function","name":"vec_methods:getLength2D","summary":"\nReturns the length of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length of the vector in two dimensions, without the Z axis.","param":[]},"vec_metamethods:__add":{"ret":"Resultant vector after addition operation.","comment":["--- add metamethod","-- @param v Vector to add","-- @return Resultant vector after addition operation."],"code":["function vec_metamethods:__add ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn wrap( unwrap( self ):__add( unwrap( v ) ) )","end",""],"class":"function","name":"vec_metamethods:__add","private":false,"summary":"\nadd metamethod ","description":"\nadd metamethod","param":{"1":"v","v":"Vector to add"}},"vec_methods:getLengthSqr":{"ret":"number length squared.","comment":["--- Get the vector's length squared ( Saves computation by skipping the square root ).","-- @return number length squared."],"code":["function vec_methods:getLengthSqr ()","\treturn unwrap( self ):LengthSqr()","end",""],"class":"function","name":"vec_methods:getLengthSqr","summary":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","private":false,"classlib":"Vector","description":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","param":[]},"vec_methods:getNormalized":{"ret":"Vector Normalised","comment":["--- Returns a new vector with the same direction by length of 1.","-- @return Vector Normalised"],"code":["function vec_methods:getNormalized ()","\treturn wrap( unwrap( self ):GetNormalized() )","end",""],"class":"function","name":"vec_methods:getNormalized","summary":"\nReturns a new vector with the same direction by length of 1.","private":false,"classlib":"Vector","description":"\nReturns a new vector with the same direction by length of 1.","param":[]},"vec_methods:getDistance":{"ret":"Number","comment":["--- Returns the pythagorean distance between the vector and the other vector.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:getDistance ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):Distance( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:getDistance","summary":"\nReturns the pythagorean distance between the vector and the other vector.","private":false,"classlib":"Vector","description":"\nReturns the pythagorean distance between the vector and the other vector.","param":{"1":"v","v":"Second Vector"}},"vec_metamethods:__eq":{"ret":"bool if both sides are equal.","comment":["--- equivalence metamethod","-- @return bool if both sides are equal."],"code":["function vec_metamethods:__eq ( ... )","\treturn SF.Sanitize( unwrap( self ):__eq( SF.Unsanitize( ... ) ) )","end",""],"class":"function","name":"vec_metamethods:__eq","private":false,"summary":"\nequivalence metamethod ","description":"\nequivalence metamethod","param":["..."]},"vec_methods:cross":{"ret":"Vector","comment":["--- Calculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","-- @param v Second Vector","-- @return Vector"],"code":["function vec_methods:cross ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn wrap( unwrap( self ):Cross( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods:cross","summary":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","private":false,"classlib":"Vector","description":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","param":{"1":"v","v":"Second Vector"}},"vec_metamethods:__sub":{"ret":"Resultant vector after subtraction operation.","comment":["--- sub metamethod","-- @param v Vector to subtract","-- @return Resultant vector after subtraction operation."],"code":["function vec_metamethods:__sub ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn wrap( unwrap( self ):__sub( unwrap( v ) ) )","end",""],"class":"function","name":"vec_metamethods:__sub","private":false,"summary":"\nsub metamethod ","description":"\nsub metamethod","param":{"1":"v","v":"Vector to subtract"}}},"doc":[{"comment":["--- Vector type","-- @shared"],"code":["local vec_methods, vec_metamethods = SF.Typedef( \"Vector\" )","local wrap, unwrap = SF.CreateWrapper( vec_metamethods, true, false, debug.getregistry().Vector )","","SF.DefaultEnvironment.Vector = function ( ... )","\treturn wrap( Vector( ... ) )","end","","SF.Vectors.Wrap = wrap","SF.Vectors.Unwrap = unwrap","SF.Vectors.Methods = vec_methods","SF.Vectors.Metatable = vec_metamethods",""],"typtbl":"vec_methods","summary":"\nVector type ","fields":[],"name":"Vector","server":true,"description":"\nVector type","client":true,"class":"class","methods":{"1":"add","2":"cross","3":"dot","4":"getAngle","5":"getAngleEx","6":"getDistance","7":"getDistanceSqr","8":"getLength","9":"getLength2D","10":"getLength2DSqr","11":"getLengthSqr","12":"getNormalized","13":"isEqualTol","14":"isZero","15":"mul","16":"normalize","17":"rotate","18":"set","19":"setZero","20":"sub","21":"toScreen","22":"withinAABox","isEqualTol":{"ret":"bool True/False.","comment":["--- Is this vector and v equal within tolerance t.","-- @param v Second Vector","-- @param t Tolerance number.","-- @return bool True/False."],"code":["function vec_methods:isEqualTol ( v, t )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tSF.CheckType( t, \"number\" )","\treturn unwrap( self ):IsEqualTol( unwrap( v ), t )","end",""],"class":"function","name":"vec_methods:isEqualTol","summary":"\nIs this vector and v equal within tolerance t.","private":false,"classlib":"Vector","description":"\nIs this vector and v equal within tolerance t.","param":{"1":"v","2":"t","t":"Tolerance number.","v":"Second Vector"}},"getAngle":{"ret":"Angle","comment":["--- Get the vector's angle.","-- @return Angle"],"code":["function vec_methods:getAngle ()","\treturn SF.WrapObject( unwrap( self ):Angle() )","end",""],"class":"function","name":"vec_methods:getAngle","summary":"\nGet the vector's angle.","private":false,"classlib":"Vector","description":"\nGet the vector's angle.","param":[]},"getLength2D":{"ret":"number length","comment":["--- Returns the length of the vector in two dimensions, without the Z axis.","-- @return number length"],"code":["function vec_methods:getLength2D ()","\treturn unwrap( self ):Length2D()","end",""],"class":"function","name":"vec_methods:getLength2D","summary":"\nReturns the length of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length of the vector in two dimensions, without the Z axis.","param":[]},"getLength":{"ret":"number Length.","comment":["--- Get the vector's Length.","-- @return number Length."],"code":["function vec_methods:getLength ()","\treturn unwrap( self ):Length()","end",""],"class":"function","name":"vec_methods:getLength","summary":"\nGet the vector's Length.","private":false,"classlib":"Vector","description":"\nGet the vector's Length.","param":[]},"normalize":{"ret":"nil","comment":["--- Normalise the vector, same direction, length 0. Self-Modifies.","-- @return nil"],"code":["function vec_methods:normalize ()","\tunwrap( self ):Normalize()","end",""],"class":"function","name":"vec_methods:normalize","summary":"\nNormalise the vector, same direction, length 0.","private":false,"classlib":"Vector","description":"\nNormalise the vector, same direction, length 0. Self-Modifies.","param":[]},"getDistanceSqr":{"ret":"Number","comment":["--- Returns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:getDistanceSqr ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):DistToSqr( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:getDistanceSqr","summary":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","private":false,"classlib":"Vector","description":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","param":{"1":"v","v":"Second Vector"}},"getDistance":{"ret":"Number","comment":["--- Returns the pythagorean distance between the vector and the other vector.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:getDistance ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):Distance( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:getDistance","summary":"\nReturns the pythagorean distance between the vector and the other vector.","private":false,"classlib":"Vector","description":"\nReturns the pythagorean distance between the vector and the other vector.","param":{"1":"v","v":"Second Vector"}},"setZero":{"ret":"nil","comment":["--- Set's all vector fields to 0.","-- @return nil"],"code":["function vec_methods:setZero ()","\tunwrap( self ):Zero()","end",""],"class":"function","name":"vec_methods:setZero","summary":"\nSet's all vector fields to 0.","private":false,"classlib":"Vector","description":"\nSet's all vector fields to 0.","param":[]},"getLength2DSqr":{"ret":"number length squared.","comment":["--- Returns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","-- @return number length squared."],"code":["function vec_methods:getLength2DSqr ()","\treturn unwrap( self ):Length2DSqr()","end",""],"class":"function","name":"vec_methods:getLength2DSqr","summary":"\nReturns the length squared of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","param":[]},"sub":{"ret":"nil","comment":["--- Subtract v from this Vector. Self-Modifies.","-- @param v Second Vector.","-- @return nil"],"code":["function vec_methods:sub ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Sub( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:sub","summary":"\nSubtract v from this Vector.","private":false,"classlib":"Vector","description":"\nSubtract v from this Vector. Self-Modifies.","param":{"1":"v","v":"Second Vector."}},"toScreen":{"ret":"nil","comment":["--- Translates the vectors position into 2D user screen coordinates. Self-Modifies.","-- @return nil"],"code":["function vec_methods:toScreen ()","\treturn unwrap( self ):ToScreen()","end",""],"class":"function","name":"vec_methods:toScreen","summary":"\nTranslates the vectors position into 2D user screen coordinates.","private":false,"classlib":"Vector","description":"\nTranslates the vectors position into 2D user screen coordinates. Self-Modifies.","param":[]},"set":{"ret":"nil","comment":["--- Copies the values from the second vector to the first vector. Self-Modifies.","-- @param v Second Vector","-- @return nil"],"code":["function vec_methods:set ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Set( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:set","summary":"\nCopies the values from the second vector to the first vector.","private":false,"classlib":"Vector","description":"\nCopies the values from the second vector to the first vector. Self-Modifies.","param":{"1":"v","v":"Second Vector"}},"isZero":{"ret":"bool True/False","comment":["--- Are all fields zero.","-- @return bool True/False"],"code":["function vec_methods:isZero ()","\treturn unwrap( self ):IsZero()","end",""],"class":"function","name":"vec_methods:isZero","summary":"\nAre all fields zero.","private":false,"classlib":"Vector","description":"\nAre all fields zero.","param":[]},"getNormalized":{"ret":"Vector Normalised","comment":["--- Returns a new vector with the same direction by length of 1.","-- @return Vector Normalised"],"code":["function vec_methods:getNormalized ()","\treturn wrap( unwrap( self ):GetNormalized() )","end",""],"class":"function","name":"vec_methods:getNormalized","summary":"\nReturns a new vector with the same direction by length of 1.","private":false,"classlib":"Vector","description":"\nReturns a new vector with the same direction by length of 1.","param":[]},"withinAABox":{"ret":"bool True/False.","comment":["--- Returns whenever the given vector is in a box created by the 2 other vectors.","-- @param v1 Vector used to define AABox","-- @param v2 Second Vector to define AABox","-- @return bool True/False."],"code":["function vec_methods:withinAABox ( v1, v2 )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):WithinAABox( unwrap( v1 ), unwrap( v2 ) )","end"],"class":"function","name":"vec_methods:withinAABox","summary":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","private":false,"classlib":"Vector","description":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","param":{"1":"v1","2":"v2","v2":"Second Vector to define AABox","v1":"Vector used to define AABox"}},"getLengthSqr":{"ret":"number length squared.","comment":["--- Get the vector's length squared ( Saves computation by skipping the square root ).","-- @return number length squared."],"code":["function vec_methods:getLengthSqr ()","\treturn unwrap( self ):LengthSqr()","end",""],"class":"function","name":"vec_methods:getLengthSqr","summary":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","private":false,"classlib":"Vector","description":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","param":[]},"dot":{"ret":"Number","comment":["--- Dot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:dot ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):Dot( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:dot","summary":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths.","private":false,"classlib":"Vector","description":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","param":{"1":"v","v":"Second Vector"}},"cross":{"ret":"Vector","comment":["--- Calculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","-- @param v Second Vector","-- @return Vector"],"code":["function vec_methods:cross ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn wrap( unwrap( self ):Cross( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods:cross","summary":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","private":false,"classlib":"Vector","description":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","param":{"1":"v","v":"Second Vector"}},"getAngleEx":{"ret":"Angle","comment":["--- Returns the Angle between two vectors.","-- @param v Second Vector","-- @return Angle"],"code":["function vec_methods:getAngleEx ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn SF.WrapObject( unwrap( self ):AngleEx( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods:getAngleEx","summary":"\nReturns the Angle between two vectors.","private":false,"classlib":"Vector","description":"\nReturns the Angle between two vectors.","param":{"1":"v","v":"Second Vector"}},"rotate":{"ret":"nil.","comment":["--- Rotate the vector by Angle a. Self-Modifies.","-- @param a Angle to rotate by.","-- @return nil."],"code":["function vec_methods:rotate ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\tunwrap( self ):Rotate( SF.UnwrapObject( a ) )","end",""],"class":"function","name":"vec_methods:rotate","summary":"\nRotate the vector by Angle a.","private":false,"classlib":"Vector","description":"\nRotate the vector by Angle a. Self-Modifies.","param":{"1":"a","a":"Angle to rotate by."}},"mul":{"ret":"nil","comment":["--- Scalar Multiplication of the vector. Self-Modifies.","-- @param n Scalar to multiply with.","-- @return nil"],"code":["function vec_methods:mul ( n )","\tSF.CheckType( n, \"number\" )","\tunwrap( self ):Mul( n )","end",""],"class":"function","name":"vec_methods:mul","summary":"\nScalar Multiplication of the vector.","private":false,"classlib":"Vector","description":"\nScalar Multiplication of the vector. Self-Modifies.","param":{"1":"n","n":"Scalar to multiply with."}},"add":{"ret":"nil","comment":["--- Add vector - Modifies self.","-- @param v Vector to add","-- @return nil"],"code":["function vec_methods:add ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Add( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:add","summary":"\nAdd vector - Modifies self.","private":false,"classlib":"Vector","description":"\nAdd vector - Modifies self.","param":{"1":"v","v":"Vector to add"}}}},{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function vec_metamethods.__newindex ( t, k, v )","\tif type( k ) == \"number\" then","\t\tif k >= 1 and k <= 3 then","\t\t\tSF.UnwrapObject( t ).__newindex( SF.UnwrapObject( t ), k, v )","\t\tend","\telseif k == \"x\" or k ==\"y\" or k == \"z\" then","\t\tSF.UnwrapObject( t ).__newindex( SF.UnwrapObject( t ), k, v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = vec_metamethods.__index"],"private":false,"class":"function","name":"vec_metamethods.__newindex","param":["t","k","v"]},{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function vec_metamethods.__index ( t, k )","\tif type( k ) == \"number\" then","\t\tif k >= 1 and k <= 3 then","\t\t\treturn unwrap( t )[ k ]","\t\tend","\telse","\t\tif k == \"x\" or k ==\"y\" or k == \"z\" then","\t\t\treturn unwrap( t )[ k ]","\t\tend","\tend","\treturn _p[ k ]","end",""],"private":false,"class":"function","name":"vec_metamethods.__index","param":["t","k"]},{"ret":"string representing the vector.","comment":["--- tostring metamethod","-- @return string representing the vector."],"code":["function vec_metamethods:__tostring ()","\treturn unwrap( self ):__tostring()","end",""],"class":"function","name":"vec_metamethods:__tostring","private":false,"summary":"\ntostring metamethod ","description":"\ntostring metamethod","param":[]},{"ret":"Scaled vector.","comment":["--- multiplication metamethod","-- @param n Scalar to multiply against vector","-- @return Scaled vector."],"code":["function vec_metamethods:__mul ( n )","\tSF.CheckType( n, \"number\" )","\treturn wrap( unwrap( self ):__mul( n ) )","end",""],"class":"function","name":"vec_metamethods:__mul","private":false,"summary":"\nmultiplication metamethod ","description":"\nmultiplication metamethod","param":{"1":"n","n":"Scalar to multiply against vector"}},{"ret":"Scaled vector.","comment":["--- division metamethod","-- @param n Scalar to divide the Vector by","-- @return Scaled vector."],"code":["function vec_metamethods:__div ( n )","\tSF.CheckType( n, \"number\" )","\treturn SF.WrapObject( unwrap( self ):__div( n ) )","end",""],"class":"function","name":"vec_metamethods:__div","private":false,"summary":"\ndivision metamethod ","description":"\ndivision metamethod","param":{"1":"n","n":"Scalar to divide the Vector by"}},{"ret":"Resultant vector after addition operation.","comment":["--- add metamethod","-- @param v Vector to add","-- @return Resultant vector after addition operation."],"code":["function vec_metamethods:__add ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn wrap( unwrap( self ):__add( unwrap( v ) ) )","end",""],"class":"function","name":"vec_metamethods:__add","private":false,"summary":"\nadd metamethod ","description":"\nadd metamethod","param":{"1":"v","v":"Vector to add"}},{"ret":"Resultant vector after subtraction operation.","comment":["--- sub metamethod","-- @param v Vector to subtract","-- @return Resultant vector after subtraction operation."],"code":["function vec_metamethods:__sub ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn wrap( unwrap( self ):__sub( unwrap( v ) ) )","end",""],"class":"function","name":"vec_metamethods:__sub","private":false,"summary":"\nsub metamethod ","description":"\nsub metamethod","param":{"1":"v","v":"Vector to subtract"}},{"ret":"negated vector.","comment":["--- unary minus metamethod","-- @return negated vector."],"code":["function vec_metamethods:__unm ()","\treturn wrap( unwrap( self ):__unm() )","end",""],"class":"function","name":"vec_metamethods:__unm","private":false,"summary":"\nunary minus metamethod ","description":"\nunary minus metamethod","param":[]},{"ret":"bool if both sides are equal.","comment":["--- equivalence metamethod","-- @return bool if both sides are equal."],"code":["function vec_metamethods:__eq ( ... )","\treturn SF.Sanitize( unwrap( self ):__eq( SF.Unsanitize( ... ) ) )","end",""],"class":"function","name":"vec_metamethods:__eq","private":false,"summary":"\nequivalence metamethod ","description":"\nequivalence metamethod","param":["..."]},{"ret":"nil","comment":["--- Add vector - Modifies self.","-- @param v Vector to add","-- @return nil"],"code":["function vec_methods:add ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Add( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:add","summary":"\nAdd vector - Modifies self.","private":false,"classlib":"Vector","description":"\nAdd vector - Modifies self.","param":{"1":"v","v":"Vector to add"}},{"ret":"Angle","comment":["--- Get the vector's angle.","-- @return Angle"],"code":["function vec_methods:getAngle ()","\treturn SF.WrapObject( unwrap( self ):Angle() )","end",""],"class":"function","name":"vec_methods:getAngle","summary":"\nGet the vector's angle.","private":false,"classlib":"Vector","description":"\nGet the vector's angle.","param":[]},{"ret":"Angle","comment":["--- Returns the Angle between two vectors.","-- @param v Second Vector","-- @return Angle"],"code":["function vec_methods:getAngleEx ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn SF.WrapObject( unwrap( self ):AngleEx( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods:getAngleEx","summary":"\nReturns the Angle between two vectors.","private":false,"classlib":"Vector","description":"\nReturns the Angle between two vectors.","param":{"1":"v","v":"Second Vector"}},{"ret":"Vector","comment":["--- Calculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","-- @param v Second Vector","-- @return Vector"],"code":["function vec_methods:cross ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn wrap( unwrap( self ):Cross( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods:cross","summary":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","private":false,"classlib":"Vector","description":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","param":{"1":"v","v":"Second Vector"}},{"ret":"Number","comment":["--- Returns the pythagorean distance between the vector and the other vector.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:getDistance ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):Distance( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:getDistance","summary":"\nReturns the pythagorean distance between the vector and the other vector.","private":false,"classlib":"Vector","description":"\nReturns the pythagorean distance between the vector and the other vector.","param":{"1":"v","v":"Second Vector"}},{"ret":"Number","comment":["--- Returns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:getDistanceSqr ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):DistToSqr( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:getDistanceSqr","summary":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","private":false,"classlib":"Vector","description":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","param":{"1":"v","v":"Second Vector"}},{"ret":"Number","comment":["--- Dot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:dot ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):Dot( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:dot","summary":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths.","private":false,"classlib":"Vector","description":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","param":{"1":"v","v":"Second Vector"}},{"ret":"Vector Normalised","comment":["--- Returns a new vector with the same direction by length of 1.","-- @return Vector Normalised"],"code":["function vec_methods:getNormalized ()","\treturn wrap( unwrap( self ):GetNormalized() )","end",""],"class":"function","name":"vec_methods:getNormalized","summary":"\nReturns a new vector with the same direction by length of 1.","private":false,"classlib":"Vector","description":"\nReturns a new vector with the same direction by length of 1.","param":[]},{"ret":"bool True/False.","comment":["--- Is this vector and v equal within tolerance t.","-- @param v Second Vector","-- @param t Tolerance number.","-- @return bool True/False."],"code":["function vec_methods:isEqualTol ( v, t )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tSF.CheckType( t, \"number\" )","\treturn unwrap( self ):IsEqualTol( unwrap( v ), t )","end",""],"class":"function","name":"vec_methods:isEqualTol","summary":"\nIs this vector and v equal within tolerance t.","private":false,"classlib":"Vector","description":"\nIs this vector and v equal within tolerance t.","param":{"1":"v","2":"t","t":"Tolerance number.","v":"Second Vector"}},{"ret":"bool True/False","comment":["--- Are all fields zero.","-- @return bool True/False"],"code":["function vec_methods:isZero ()","\treturn unwrap( self ):IsZero()","end",""],"class":"function","name":"vec_methods:isZero","summary":"\nAre all fields zero.","private":false,"classlib":"Vector","description":"\nAre all fields zero.","param":[]},{"ret":"number Length.","comment":["--- Get the vector's Length.","-- @return number Length."],"code":["function vec_methods:getLength ()","\treturn unwrap( self ):Length()","end",""],"class":"function","name":"vec_methods:getLength","summary":"\nGet the vector's Length.","private":false,"classlib":"Vector","description":"\nGet the vector's Length.","param":[]},{"ret":"number length squared.","comment":["--- Get the vector's length squared ( Saves computation by skipping the square root ).","-- @return number length squared."],"code":["function vec_methods:getLengthSqr ()","\treturn unwrap( self ):LengthSqr()","end",""],"class":"function","name":"vec_methods:getLengthSqr","summary":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","private":false,"classlib":"Vector","description":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","param":[]},{"ret":"number length","comment":["--- Returns the length of the vector in two dimensions, without the Z axis.","-- @return number length"],"code":["function vec_methods:getLength2D ()","\treturn unwrap( self ):Length2D()","end",""],"class":"function","name":"vec_methods:getLength2D","summary":"\nReturns the length of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length of the vector in two dimensions, without the Z axis.","param":[]},{"ret":"number length squared.","comment":["--- Returns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","-- @return number length squared."],"code":["function vec_methods:getLength2DSqr ()","\treturn unwrap( self ):Length2DSqr()","end",""],"class":"function","name":"vec_methods:getLength2DSqr","summary":"\nReturns the length squared of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","param":[]},{"ret":"nil","comment":["--- Scalar Multiplication of the vector. Self-Modifies.","-- @param n Scalar to multiply with.","-- @return nil"],"code":["function vec_methods:mul ( n )","\tSF.CheckType( n, \"number\" )","\tunwrap( self ):Mul( n )","end",""],"class":"function","name":"vec_methods:mul","summary":"\nScalar Multiplication of the vector.","private":false,"classlib":"Vector","description":"\nScalar Multiplication of the vector. Self-Modifies.","param":{"1":"n","n":"Scalar to multiply with."}},{"ret":"nil","comment":["--- Set's all vector fields to 0.","-- @return nil"],"code":["function vec_methods:setZero ()","\tunwrap( self ):Zero()","end",""],"class":"function","name":"vec_methods:setZero","summary":"\nSet's all vector fields to 0.","private":false,"classlib":"Vector","description":"\nSet's all vector fields to 0.","param":[]},{"ret":"nil","comment":["--- Normalise the vector, same direction, length 0. Self-Modifies.","-- @return nil"],"code":["function vec_methods:normalize ()","\tunwrap( self ):Normalize()","end",""],"class":"function","name":"vec_methods:normalize","summary":"\nNormalise the vector, same direction, length 0.","private":false,"classlib":"Vector","description":"\nNormalise the vector, same direction, length 0. Self-Modifies.","param":[]},{"ret":"nil.","comment":["--- Rotate the vector by Angle a. Self-Modifies.","-- @param a Angle to rotate by.","-- @return nil."],"code":["function vec_methods:rotate ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\tunwrap( self ):Rotate( SF.UnwrapObject( a ) )","end",""],"class":"function","name":"vec_methods:rotate","summary":"\nRotate the vector by Angle a.","private":false,"classlib":"Vector","description":"\nRotate the vector by Angle a. Self-Modifies.","param":{"1":"a","a":"Angle to rotate by."}},{"ret":"nil","comment":["--- Copies the values from the second vector to the first vector. Self-Modifies.","-- @param v Second Vector","-- @return nil"],"code":["function vec_methods:set ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Set( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:set","summary":"\nCopies the values from the second vector to the first vector.","private":false,"classlib":"Vector","description":"\nCopies the values from the second vector to the first vector. Self-Modifies.","param":{"1":"v","v":"Second Vector"}},{"ret":"nil","comment":["--- Subtract v from this Vector. Self-Modifies.","-- @param v Second Vector.","-- @return nil"],"code":["function vec_methods:sub ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Sub( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:sub","summary":"\nSubtract v from this Vector.","private":false,"classlib":"Vector","description":"\nSubtract v from this Vector. Self-Modifies.","param":{"1":"v","v":"Second Vector."}},{"ret":"nil","comment":["--- Translates the vectors position into 2D user screen coordinates. Self-Modifies.","-- @return nil"],"code":["function vec_methods:toScreen ()","\treturn unwrap( self ):ToScreen()","end",""],"class":"function","name":"vec_methods:toScreen","summary":"\nTranslates the vectors position into 2D user screen coordinates.","private":false,"classlib":"Vector","description":"\nTranslates the vectors position into 2D user screen coordinates. Self-Modifies.","param":[]},{"ret":"bool True/False.","comment":["--- Returns whenever the given vector is in a box created by the 2 other vectors.","-- @param v1 Vector used to define AABox","-- @param v2 Second Vector to define AABox","-- @return bool True/False."],"code":["function vec_methods:withinAABox ( v1, v2 )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):WithinAABox( unwrap( v1 ), unwrap( v2 ) )","end"],"class":"function","name":"vec_methods:withinAABox","summary":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","private":false,"classlib":"Vector","description":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","param":{"1":"v1","2":"v2","v2":"Second Vector to define AABox","v1":"Vector used to define AABox"}}],"tables":[],"description":"\nVector type","summary":"\nVector type "},"libs_sh/vmatrix.lua":{"libraries":[],"type":"file","name":"libs_sh/vmatrix.lua","functions":{"1":"SF.DefaultEnvironment.Matrix","2":"vmatrix_metamethods:__tostring","3":"vmatrix_methods:getAngles","4":"vmatrix_methods:getInverse","5":"vmatrix_methods:getInverseTR","6":"vmatrix_methods:getScale","7":"vmatrix_methods:getTranslation","8":"vmatrix_methods:rotate","9":"vmatrix_methods:scale","10":"vmatrix_methods:scaleTranslation","11":"vmatrix_methods:setAngles","12":"vmatrix_methods:setTranslation","13":"vmatrix_methods:translate","vmatrix_methods:rotate":{"comment":["--- Rotate the matrix","-- @param ang Angle to rotate by"],"code":["function vmatrix_methods:rotate ( ang )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","","\tlocal v = unwrap( self )","\tv:Rotate( SF.UnwrapObject( ang ) )","","end",""],"class":"function","name":"vmatrix_methods:rotate","summary":"\nRotate the matrix ","private":false,"classlib":"VMatrix","description":"\nRotate the matrix","param":{"1":"ang","ang":"Angle to rotate by"}},"vmatrix_methods:getTranslation":{"ret":"Translation","comment":["--- Returns translation","-- @return Translation"],"code":["function vmatrix_methods:getTranslation ()","\treturn SF.WrapObject( unwrap( self ):GetTranslation() )","end",""],"class":"function","name":"vmatrix_methods:getTranslation","summary":"\nReturns translation ","private":false,"classlib":"VMatrix","description":"\nReturns translation","param":[]},"vmatrix_methods:translate":{"comment":["--- Translate the matrix","-- @param vec Vector to translate by"],"code":["function vmatrix_methods:translate ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Translate( vec )","end","","function vmatrix_metamethods.__mul ( lhs, rhs )","\treturn vwrap( vunwrap( lhs ) * vunwrap( rhs ) )","end"],"class":"function","name":"vmatrix_methods:translate","summary":"\nTranslate the matrix ","private":false,"classlib":"VMatrix","description":"\nTranslate the matrix","param":{"1":"vec","vec":"Vector to translate by"}},"vmatrix_methods:scale":{"comment":["--- Scale the matrix","-- @param vec Vector to scale by"],"code":["function vmatrix_methods:scale ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Scale( vec )","end",""],"class":"function","name":"vmatrix_methods:scale","summary":"\nScale the matrix ","private":false,"classlib":"VMatrix","description":"\nScale the matrix","param":{"1":"vec","vec":"Vector to scale by"}},"vmatrix_methods:getAngles":{"ret":"Angles","comment":["--- Returns angles","-- @return Angles"],"code":["function vmatrix_methods:getAngles ()","\treturn SF.WrapObject( unwrap( self ):GetAngles() )","end",""],"class":"function","name":"vmatrix_methods:getAngles","summary":"\nReturns angles ","private":false,"classlib":"VMatrix","description":"\nReturns angles","param":[]},"vmatrix_methods:setTranslation":{"comment":["--- Sets the translation","-- @param vec New translation"],"code":["function vmatrix_methods:setTranslation ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:SetTranslation( vec )","end",""],"class":"function","name":"vmatrix_methods:setTranslation","summary":"\nSets the translation ","private":false,"classlib":"VMatrix","description":"\nSets the translation","param":{"1":"vec","vec":"New translation"}},"vmatrix_methods:setAngles":{"comment":["--- Sets the angles","-- @param ang New angles"],"code":["function vmatrix_methods:setAngles ( ang )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","","\tlocal v = unwrap( self )","\tv:SetAngles( SF.UnwrapObject( ang ) )","end",""],"class":"function","name":"vmatrix_methods:setAngles","summary":"\nSets the angles ","private":false,"classlib":"VMatrix","description":"\nSets the angles","param":{"1":"ang","ang":"New angles"}},"vmatrix_methods:scaleTranslation":{"comment":["--- Scales the absolute translation","-- @param num Amount to scale by"],"code":["function vmatrix_methods:scaleTranslation ( num )","\tSF.CheckType( num, \"number\" )","","\tlocal v = unwrap( self )","\tv:ScaleTranslation( num )","end",""],"class":"function","name":"vmatrix_methods:scaleTranslation","summary":"\nScales the absolute translation ","private":false,"classlib":"VMatrix","description":"\nScales the absolute translation","param":{"1":"num","num":"Amount to scale by"}},"vmatrix_metamethods:__tostring":{"ret":"string representing the matrix.","comment":["--- tostring metamethod","-- @return string representing the matrix."],"code":["function vmatrix_metamethods:__tostring ()","\treturn unwrap( self ):__tostring()","end",""],"class":"function","name":"vmatrix_metamethods:__tostring","private":false,"summary":"\ntostring metamethod ","description":"\ntostring metamethod","param":[]},"vmatrix_methods:getScale":{"ret":"Scale","comment":["--- Returns scale","-- @return Scale"],"code":["function vmatrix_methods:getScale ()","\treturn SF.WrapObject( unwrap( self ):GetScale() )","end",""],"class":"function","name":"vmatrix_methods:getScale","summary":"\nReturns scale ","private":false,"classlib":"VMatrix","description":"\nReturns scale","param":[]},"SF.DefaultEnvironment.Matrix":{"ret":"New VMatrix","comment":["--- Returns a new VMatrix","-- @return New VMatrix"],"code":["SF.DefaultEnvironment.Matrix = function ()","\treturn wrap( Matrix() )","end",""],"class":"function","name":"SF.DefaultEnvironment.Matrix","private":false,"summary":"\nReturns a new VMatrix ","description":"\nReturns a new VMatrix","param":[]},"vmatrix_methods:getInverse":{"ret":"inverted matrix","comment":["--- Inverts the matrix","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverse ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverse() )","","end",""],"class":"function","name":"vmatrix_methods:getInverse","summary":"\nInverts the matrix ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix","param":[]},"vmatrix_methods:getInverseTR":{"ret":"inverted matrix","comment":["--- Inverts the matrix efficiently for translations and rotations","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverseTR ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverseTR() )","","end",""],"class":"function","name":"vmatrix_methods:getInverseTR","summary":"\nInverts the matrix efficiently for translations and rotations ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix efficiently for translations and rotations","param":[]}},"doc":[{"comment":["--- VMatrix type"],"code":["local vmatrix_methods, vmatrix_metamethods = SF.Typedef( \"VMatrix\" )","local wrap, unwrap = SF.CreateWrapper( vmatrix_metamethods, true, false, debug.getregistry().VMatrix )","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","SF.VMatrix.Methods = vmatrix_methods","SF.VMatrix.Metatable = vmatrix_metamethods","SF.VMatrix.Wrap = wrap","SF.VMatrix.Unwrap = unwrap",""],"typtbl":"vmatrix_methods","fields":[],"name":"VMatrix","summary":"\nVMatrix type ","description":"\nVMatrix type","class":"class","methods":{"1":"getAngles","2":"getInverse","3":"getInverseTR","4":"getScale","5":"getTranslation","6":"rotate","7":"scale","8":"scaleTranslation","9":"setAngles","10":"setTranslation","11":"translate","scale":{"comment":["--- Scale the matrix","-- @param vec Vector to scale by"],"code":["function vmatrix_methods:scale ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Scale( vec )","end",""],"class":"function","name":"vmatrix_methods:scale","summary":"\nScale the matrix ","private":false,"classlib":"VMatrix","description":"\nScale the matrix","param":{"1":"vec","vec":"Vector to scale by"}},"getScale":{"ret":"Scale","comment":["--- Returns scale","-- @return Scale"],"code":["function vmatrix_methods:getScale ()","\treturn SF.WrapObject( unwrap( self ):GetScale() )","end",""],"class":"function","name":"vmatrix_methods:getScale","summary":"\nReturns scale ","private":false,"classlib":"VMatrix","description":"\nReturns scale","param":[]},"getAngles":{"ret":"Angles","comment":["--- Returns angles","-- @return Angles"],"code":["function vmatrix_methods:getAngles ()","\treturn SF.WrapObject( unwrap( self ):GetAngles() )","end",""],"class":"function","name":"vmatrix_methods:getAngles","summary":"\nReturns angles ","private":false,"classlib":"VMatrix","description":"\nReturns angles","param":[]},"translate":{"comment":["--- Translate the matrix","-- @param vec Vector to translate by"],"code":["function vmatrix_methods:translate ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Translate( vec )","end","","function vmatrix_metamethods.__mul ( lhs, rhs )","\treturn vwrap( vunwrap( lhs ) * vunwrap( rhs ) )","end"],"class":"function","name":"vmatrix_methods:translate","summary":"\nTranslate the matrix ","private":false,"classlib":"VMatrix","description":"\nTranslate the matrix","param":{"1":"vec","vec":"Vector to translate by"}},"getTranslation":{"ret":"Translation","comment":["--- Returns translation","-- @return Translation"],"code":["function vmatrix_methods:getTranslation ()","\treturn SF.WrapObject( unwrap( self ):GetTranslation() )","end",""],"class":"function","name":"vmatrix_methods:getTranslation","summary":"\nReturns translation ","private":false,"classlib":"VMatrix","description":"\nReturns translation","param":[]},"setTranslation":{"comment":["--- Sets the translation","-- @param vec New translation"],"code":["function vmatrix_methods:setTranslation ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:SetTranslation( vec )","end",""],"class":"function","name":"vmatrix_methods:setTranslation","summary":"\nSets the translation ","private":false,"classlib":"VMatrix","description":"\nSets the translation","param":{"1":"vec","vec":"New translation"}},"getInverse":{"ret":"inverted matrix","comment":["--- Inverts the matrix","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverse ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverse() )","","end",""],"class":"function","name":"vmatrix_methods:getInverse","summary":"\nInverts the matrix ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix","param":[]},"setAngles":{"comment":["--- Sets the angles","-- @param ang New angles"],"code":["function vmatrix_methods:setAngles ( ang )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","","\tlocal v = unwrap( self )","\tv:SetAngles( SF.UnwrapObject( ang ) )","end",""],"class":"function","name":"vmatrix_methods:setAngles","summary":"\nSets the angles ","private":false,"classlib":"VMatrix","description":"\nSets the angles","param":{"1":"ang","ang":"New angles"}},"rotate":{"comment":["--- Rotate the matrix","-- @param ang Angle to rotate by"],"code":["function vmatrix_methods:rotate ( ang )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","","\tlocal v = unwrap( self )","\tv:Rotate( SF.UnwrapObject( ang ) )","","end",""],"class":"function","name":"vmatrix_methods:rotate","summary":"\nRotate the matrix ","private":false,"classlib":"VMatrix","description":"\nRotate the matrix","param":{"1":"ang","ang":"Angle to rotate by"}},"getInverseTR":{"ret":"inverted matrix","comment":["--- Inverts the matrix efficiently for translations and rotations","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverseTR ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverseTR() )","","end",""],"class":"function","name":"vmatrix_methods:getInverseTR","summary":"\nInverts the matrix efficiently for translations and rotations ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix efficiently for translations and rotations","param":[]},"scaleTranslation":{"comment":["--- Scales the absolute translation","-- @param num Amount to scale by"],"code":["function vmatrix_methods:scaleTranslation ( num )","\tSF.CheckType( num, \"number\" )","","\tlocal v = unwrap( self )","\tv:ScaleTranslation( num )","end",""],"class":"function","name":"vmatrix_methods:scaleTranslation","summary":"\nScales the absolute translation ","private":false,"classlib":"VMatrix","description":"\nScales the absolute translation","param":{"1":"num","num":"Amount to scale by"}}}},{"ret":"New VMatrix","comment":["--- Returns a new VMatrix","-- @return New VMatrix"],"code":["SF.DefaultEnvironment.Matrix = function ()","\treturn wrap( Matrix() )","end",""],"class":"function","name":"SF.DefaultEnvironment.Matrix","private":false,"summary":"\nReturns a new VMatrix ","description":"\nReturns a new VMatrix","param":[]},{"ret":"string representing the matrix.","comment":["--- tostring metamethod","-- @return string representing the matrix."],"code":["function vmatrix_metamethods:__tostring ()","\treturn unwrap( self ):__tostring()","end",""],"class":"function","name":"vmatrix_metamethods:__tostring","private":false,"summary":"\ntostring metamethod ","description":"\ntostring metamethod","param":[]},{"ret":"Angles","comment":["--- Returns angles","-- @return Angles"],"code":["function vmatrix_methods:getAngles ()","\treturn SF.WrapObject( unwrap( self ):GetAngles() )","end",""],"class":"function","name":"vmatrix_methods:getAngles","summary":"\nReturns angles ","private":false,"classlib":"VMatrix","description":"\nReturns angles","param":[]},{"ret":"Scale","comment":["--- Returns scale","-- @return Scale"],"code":["function vmatrix_methods:getScale ()","\treturn SF.WrapObject( unwrap( self ):GetScale() )","end",""],"class":"function","name":"vmatrix_methods:getScale","summary":"\nReturns scale ","private":false,"classlib":"VMatrix","description":"\nReturns scale","param":[]},{"ret":"Translation","comment":["--- Returns translation","-- @return Translation"],"code":["function vmatrix_methods:getTranslation ()","\treturn SF.WrapObject( unwrap( self ):GetTranslation() )","end",""],"class":"function","name":"vmatrix_methods:getTranslation","summary":"\nReturns translation ","private":false,"classlib":"VMatrix","description":"\nReturns translation","param":[]},{"comment":["--- Rotate the matrix","-- @param ang Angle to rotate by"],"code":["function vmatrix_methods:rotate ( ang )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","","\tlocal v = unwrap( self )","\tv:Rotate( SF.UnwrapObject( ang ) )","","end",""],"class":"function","name":"vmatrix_methods:rotate","summary":"\nRotate the matrix ","private":false,"classlib":"VMatrix","description":"\nRotate the matrix","param":{"1":"ang","ang":"Angle to rotate by"}},{"ret":"inverted matrix","comment":["--- Inverts the matrix","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverse ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverse() )","","end",""],"class":"function","name":"vmatrix_methods:getInverse","summary":"\nInverts the matrix ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix","param":[]},{"ret":"inverted matrix","comment":["--- Inverts the matrix efficiently for translations and rotations","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverseTR ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverseTR() )","","end",""],"class":"function","name":"vmatrix_methods:getInverseTR","summary":"\nInverts the matrix efficiently for translations and rotations ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix efficiently for translations and rotations","param":[]},{"comment":["--- Scale the matrix","-- @param vec Vector to scale by"],"code":["function vmatrix_methods:scale ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Scale( vec )","end",""],"class":"function","name":"vmatrix_methods:scale","summary":"\nScale the matrix ","private":false,"classlib":"VMatrix","description":"\nScale the matrix","param":{"1":"vec","vec":"Vector to scale by"}},{"comment":["--- Scales the absolute translation","-- @param num Amount to scale by"],"code":["function vmatrix_methods:scaleTranslation ( num )","\tSF.CheckType( num, \"number\" )","","\tlocal v = unwrap( self )","\tv:ScaleTranslation( num )","end",""],"class":"function","name":"vmatrix_methods:scaleTranslation","summary":"\nScales the absolute translation ","private":false,"classlib":"VMatrix","description":"\nScales the absolute translation","param":{"1":"num","num":"Amount to scale by"}},{"comment":["--- Sets the angles","-- @param ang New angles"],"code":["function vmatrix_methods:setAngles ( ang )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","","\tlocal v = unwrap( self )","\tv:SetAngles( SF.UnwrapObject( ang ) )","end",""],"class":"function","name":"vmatrix_methods:setAngles","summary":"\nSets the angles ","private":false,"classlib":"VMatrix","description":"\nSets the angles","param":{"1":"ang","ang":"New angles"}},{"comment":["--- Sets the translation","-- @param vec New translation"],"code":["function vmatrix_methods:setTranslation ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:SetTranslation( vec )","end",""],"class":"function","name":"vmatrix_methods:setTranslation","summary":"\nSets the translation ","private":false,"classlib":"VMatrix","description":"\nSets the translation","param":{"1":"vec","vec":"New translation"}},{"comment":["--- Translate the matrix","-- @param vec Vector to translate by"],"code":["function vmatrix_methods:translate ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Translate( vec )","end","","function vmatrix_metamethods.__mul ( lhs, rhs )","\treturn vwrap( vunwrap( lhs ) * vunwrap( rhs ) )","end"],"class":"function","name":"vmatrix_methods:translate","summary":"\nTranslate the matrix ","private":false,"classlib":"VMatrix","description":"\nTranslate the matrix","param":{"1":"vec","vec":"Vector to translate by"}}],"tables":[],"description":"\nVMatrix type","summary":"\nVMatrix type "},"libs_sh/game.lua":{"libraries":{"1":"game","game":{"comment":["--- Game functions","-- @shared"],"functions":{"1":"getGamemode","2":"getHostname","3":"getMap","4":"getMaxPlayers","5":"isDedicated","6":"isLan","7":"isSinglePlayer","getMaxPlayers":{"comment":["--- Returns the maximum player limit"],"code":["function game_lib.getMaxPlayers ()","\treturn game.MaxPlayers()","end"],"class":"function","name":"game_lib.getMaxPlayers","summary":"\nReturns the maximum player limit ","private":false,"library":"game","description":"\nReturns the maximum player limit","param":[]},"isLan":{"comment":["--- Returns true if the server is on a LAN","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.isLan ()","\treturn GetConVar( \"sv_lan\" ):GetBool()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.isLan","summary":"\nReturns true if the server is on a LAN ","private":false,"library":"game","description":"\nReturns true if the server is on a LAN","param":[]},"getMap":{"comment":["--- Returns the map name"],"code":["function game_lib.getMap ()","\treturn game.GetMap()","end",""],"class":"function","name":"game_lib.getMap","summary":"\nReturns the map name ","private":false,"library":"game","description":"\nReturns the map name","param":[]},"isDedicated":{"comment":["--- Returns whether or not the server is a dedicated server"],"code":["function game_lib.isDedicated ()","\treturn game.IsDedicated()","end",""],"class":"function","name":"game_lib.isDedicated","summary":"\nReturns whether or not the server is a dedicated server ","private":false,"library":"game","description":"\nReturns whether or not the server is a dedicated server","param":[]},"isSinglePlayer":{"comment":["--- Returns whether or not the current game is single player"],"code":["function game_lib.isSinglePlayer ()","\treturn game.SinglePlayer()","end",""],"class":"function","name":"game_lib.isSinglePlayer","summary":"\nReturns whether or not the current game is single player ","private":false,"library":"game","description":"\nReturns whether or not the current game is single player","param":[]},"getGamemode":{"comment":["--- Returns the gamemode as a String"],"code":["function game_lib.getGamemode ()","\tlocal rtn = {}","\tlocal t = gmod.GetGamemode()","\tfor k, v in pairs( t ) do","\t\tif type( v ) ~= \"function\" and type( v ) ~= \"table\" then","\t\t\trtn[ k:gsub( \"^%u\", string.lower ) ] = v","\t\tend","\tend","\treturn SF.Sanitize( rtn )","end",""],"class":"function","name":"game_lib.getGamemode","summary":"\nReturns the gamemode as a String ","private":false,"library":"game","description":"\nReturns the gamemode as a String","param":[]},"getHostname":{"comment":["--- Returns The hostname","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.getHostname ()","\treturn GetConVar( \"hostname\" ):GetString()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.getHostname","summary":"\nReturns The hostname ","private":false,"library":"game","description":"\nReturns The hostname","param":[]}},"class":"library","summary":"\nGame functions ","code":["local game_lib, _ = SF.Libraries.Register( \"game\" )",""],"fields":[],"name":"game","client":true,"description":"\nGame functions","libtbl":"game_lib","tables":[],"server":true}},"type":"file","name":"libs_sh/game.lua","functions":{"1":"game_lib.getGamemode","2":"game_lib.getHostname","3":"game_lib.getMap","4":"game_lib.getMaxPlayers","5":"game_lib.isDedicated","6":"game_lib.isLan","7":"game_lib.isSinglePlayer","game_lib.getHostname":{"comment":["--- Returns The hostname","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.getHostname ()","\treturn GetConVar( \"hostname\" ):GetString()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.getHostname","summary":"\nReturns The hostname ","private":false,"library":"game","description":"\nReturns The hostname","param":[]},"game_lib.isSinglePlayer":{"comment":["--- Returns whether or not the current game is single player"],"code":["function game_lib.isSinglePlayer ()","\treturn game.SinglePlayer()","end",""],"class":"function","name":"game_lib.isSinglePlayer","summary":"\nReturns whether or not the current game is single player ","private":false,"library":"game","description":"\nReturns whether or not the current game is single player","param":[]},"game_lib.isDedicated":{"comment":["--- Returns whether or not the server is a dedicated server"],"code":["function game_lib.isDedicated ()","\treturn game.IsDedicated()","end",""],"class":"function","name":"game_lib.isDedicated","summary":"\nReturns whether or not the server is a dedicated server ","private":false,"library":"game","description":"\nReturns whether or not the server is a dedicated server","param":[]},"game_lib.getMap":{"comment":["--- Returns the map name"],"code":["function game_lib.getMap ()","\treturn game.GetMap()","end",""],"class":"function","name":"game_lib.getMap","summary":"\nReturns the map name ","private":false,"library":"game","description":"\nReturns the map name","param":[]},"game_lib.isLan":{"comment":["--- Returns true if the server is on a LAN","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.isLan ()","\treturn GetConVar( \"sv_lan\" ):GetBool()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.isLan","summary":"\nReturns true if the server is on a LAN ","private":false,"library":"game","description":"\nReturns true if the server is on a LAN","param":[]},"game_lib.getMaxPlayers":{"comment":["--- Returns the maximum player limit"],"code":["function game_lib.getMaxPlayers ()","\treturn game.MaxPlayers()","end"],"class":"function","name":"game_lib.getMaxPlayers","summary":"\nReturns the maximum player limit ","private":false,"library":"game","description":"\nReturns the maximum player limit","param":[]},"game_lib.getGamemode":{"comment":["--- Returns the gamemode as a String"],"code":["function game_lib.getGamemode ()","\tlocal rtn = {}","\tlocal t = gmod.GetGamemode()","\tfor k, v in pairs( t ) do","\t\tif type( v ) ~= \"function\" and type( v ) ~= \"table\" then","\t\t\trtn[ k:gsub( \"^%u\", string.lower ) ] = v","\t\tend","\tend","\treturn SF.Sanitize( rtn )","end",""],"class":"function","name":"game_lib.getGamemode","summary":"\nReturns the gamemode as a String ","private":false,"library":"game","description":"\nReturns the gamemode as a String","param":[]}},"doc":[{"summary":"\n \nGame library \n ","description":"\n \nGame library \n","comment":["-------------------------------------------------------------------------------","-- Game library","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- Game functions","-- @shared"],"functions":{"1":"getGamemode","2":"getHostname","3":"getMap","4":"getMaxPlayers","5":"isDedicated","6":"isLan","7":"isSinglePlayer","getMaxPlayers":{"comment":["--- Returns the maximum player limit"],"code":["function game_lib.getMaxPlayers ()","\treturn game.MaxPlayers()","end"],"class":"function","name":"game_lib.getMaxPlayers","summary":"\nReturns the maximum player limit ","private":false,"library":"game","description":"\nReturns the maximum player limit","param":[]},"isLan":{"comment":["--- Returns true if the server is on a LAN","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.isLan ()","\treturn GetConVar( \"sv_lan\" ):GetBool()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.isLan","summary":"\nReturns true if the server is on a LAN ","private":false,"library":"game","description":"\nReturns true if the server is on a LAN","param":[]},"getMap":{"comment":["--- Returns the map name"],"code":["function game_lib.getMap ()","\treturn game.GetMap()","end",""],"class":"function","name":"game_lib.getMap","summary":"\nReturns the map name ","private":false,"library":"game","description":"\nReturns the map name","param":[]},"isDedicated":{"comment":["--- Returns whether or not the server is a dedicated server"],"code":["function game_lib.isDedicated ()","\treturn game.IsDedicated()","end",""],"class":"function","name":"game_lib.isDedicated","summary":"\nReturns whether or not the server is a dedicated server ","private":false,"library":"game","description":"\nReturns whether or not the server is a dedicated server","param":[]},"isSinglePlayer":{"comment":["--- Returns whether or not the current game is single player"],"code":["function game_lib.isSinglePlayer ()","\treturn game.SinglePlayer()","end",""],"class":"function","name":"game_lib.isSinglePlayer","summary":"\nReturns whether or not the current game is single player ","private":false,"library":"game","description":"\nReturns whether or not the current game is single player","param":[]},"getGamemode":{"comment":["--- Returns the gamemode as a String"],"code":["function game_lib.getGamemode ()","\tlocal rtn = {}","\tlocal t = gmod.GetGamemode()","\tfor k, v in pairs( t ) do","\t\tif type( v ) ~= \"function\" and type( v ) ~= \"table\" then","\t\t\trtn[ k:gsub( \"^%u\", string.lower ) ] = v","\t\tend","\tend","\treturn SF.Sanitize( rtn )","end",""],"class":"function","name":"game_lib.getGamemode","summary":"\nReturns the gamemode as a String ","private":false,"library":"game","description":"\nReturns the gamemode as a String","param":[]},"getHostname":{"comment":["--- Returns The hostname","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.getHostname ()","\treturn GetConVar( \"hostname\" ):GetString()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.getHostname","summary":"\nReturns The hostname ","private":false,"library":"game","description":"\nReturns The hostname","param":[]}},"class":"library","summary":"\nGame functions ","code":["local game_lib, _ = SF.Libraries.Register( \"game\" )",""],"fields":[],"name":"game","client":true,"description":"\nGame functions","libtbl":"game_lib","tables":[],"server":true},{"comment":["--- Returns the map name"],"code":["function game_lib.getMap ()","\treturn game.GetMap()","end",""],"class":"function","name":"game_lib.getMap","summary":"\nReturns the map name ","private":false,"library":"game","description":"\nReturns the map name","param":[]},{"comment":["--- Returns The hostname","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.getHostname ()","\treturn GetConVar( \"hostname\" ):GetString()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.getHostname","summary":"\nReturns The hostname ","private":false,"library":"game","description":"\nReturns The hostname","param":[]},{"comment":["--- Returns true if the server is on a LAN","-- @deprecated Possibly add ConVar retrieval for users in future. Could implement with SF Script."],"code":["function game_lib.isLan ()","\treturn GetConVar( \"sv_lan\" ):GetBool()","end",""],"deprecated":"Possibly add ConVar retrieval for users in future. Could implement with SF Script.","class":"function","name":"game_lib.isLan","summary":"\nReturns true if the server is on a LAN ","private":false,"library":"game","description":"\nReturns true if the server is on a LAN","param":[]},{"comment":["--- Returns the gamemode as a String"],"code":["function game_lib.getGamemode ()","\tlocal rtn = {}","\tlocal t = gmod.GetGamemode()","\tfor k, v in pairs( t ) do","\t\tif type( v ) ~= \"function\" and type( v ) ~= \"table\" then","\t\t\trtn[ k:gsub( \"^%u\", string.lower ) ] = v","\t\tend","\tend","\treturn SF.Sanitize( rtn )","end",""],"class":"function","name":"game_lib.getGamemode","summary":"\nReturns the gamemode as a String ","private":false,"library":"game","description":"\nReturns the gamemode as a String","param":[]},{"comment":["--- Returns whether or not the current game is single player"],"code":["function game_lib.isSinglePlayer ()","\treturn game.SinglePlayer()","end",""],"class":"function","name":"game_lib.isSinglePlayer","summary":"\nReturns whether or not the current game is single player ","private":false,"library":"game","description":"\nReturns whether or not the current game is single player","param":[]},{"comment":["--- Returns whether or not the server is a dedicated server"],"code":["function game_lib.isDedicated ()","\treturn game.IsDedicated()","end",""],"class":"function","name":"game_lib.isDedicated","summary":"\nReturns whether or not the server is a dedicated server ","private":false,"library":"game","description":"\nReturns whether or not the server is a dedicated server","param":[]},{"comment":["--- Returns the maximum player limit"],"code":["function game_lib.getMaxPlayers ()","\treturn game.MaxPlayers()","end"],"class":"function","name":"game_lib.getMaxPlayers","summary":"\nReturns the maximum player limit ","private":false,"library":"game","description":"\nReturns the maximum player limit","param":[]}],"tables":[],"description":"\n \nGame library \n","summary":"\n \nGame library \n "},"libs_sh/timer.lua":{"libraries":{"1":"timer","timer":{"comment":["--- Deals with time and timers.","-- @shared"],"functions":{"1":"adjust","2":"create","3":"curtime","4":"exists","5":"frametime","6":"pause","7":"realtime","8":"remove","9":"simple","10":"start","11":"stop","12":"systime","13":"unpause","simple":{"comment":["--- Creates a simple timer, has no name, can't be stopped, paused, or destroyed.","-- @param delay the time, in second, to set the timer to","-- @param func the function to call when the timer is fired"],"code":["function timer_library.simple(delay, func)","\tSF.CheckType( delay, \"number\" )","\tSF.CheckType( func, \"function\" )","\t","\tlocal instance = SF.instance","\ttimer.Simple(delay, function()","\t\tif IsValid(instance.data.entity) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"simple timer errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend)","end","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.timers = {}","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tif instance.data.timers ~= nil then","\t\tfor name,_ in pairs(instance.data.timers) do","\t\t\tlocal realname = mangle_timer_name(instance,name)","\t\t\ttimer.Remove(realname)","\t\tend","\tend","\tinstance.data.timers = nil","end)"],"class":"function","name":"timer_library.simple","summary":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","private":false,"library":"timer","description":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","param":{"1":"delay","2":"func","delay":"the time, in second, to set the timer to","func":"the function to call when the timer is fired"}},"frametime":{"comment":["--- Returns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua"],"code":["function timer_library.frametime()","\treturn FrameTime()","end","","-- ------------------------- Timers ------------------------- --","","local function mangle_timer_name(instance, name)","\treturn string.format(\"sftimer_%s_%s\",tostring(instance),name)","end",""],"class":"function","name":"timer_library.frametime","summary":"\nReturns time between frames on client and ticks on server.","private":false,"library":"timer","description":"\nReturns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua","param":[]},"systime":{"comment":["--- Same as GLua's SysTime()"],"code":["function timer_library.systime()","\treturn SysTime()","end",""],"class":"function","name":"timer_library.systime","summary":"\nSame as GLua's SysTime() ","private":false,"library":"timer","description":"\nSame as GLua's SysTime()","param":[]},"adjust":{"comment":["--- Adjusts a timer","-- @param name The timer name"],"code":["function timer_library.adjust(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Adjust(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.adjust","summary":"\nAdjusts a timer ","private":false,"library":"timer","description":"\nAdjusts a timer","param":{"1":"name","name":"The timer name"}},"create":{"comment":["--- Creates (and starts) a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.create(name, delay, reps, func)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tSF.CheckType(func,\"function\")","\t","\tlocal instance = SF.instance","\tlocal timername = mangle_timer_name(instance,name)","\t","\tlocal function timercb()","\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\t\ttimer.Remove( timername )","\t\tend","\tend","\t","\ttimer.Create(timername, delay, reps, timercb )","\t","\tinstance.data.timers[name] = true","end",""],"class":"function","name":"timer_library.create","summary":"\nCreates (and starts) a timer ","private":false,"library":"timer","description":"\nCreates (and starts) a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"stop":{"comment":["--- Stops a timer","-- @param name The timer name"],"code":["function timer_library.stop(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Stop(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.stop","summary":"\nStops a timer ","private":false,"library":"timer","description":"\nStops a timer","param":{"1":"name","name":"The timer name"}},"remove":{"comment":["--- Removes a timer","-- @param name The timer name"],"code":["function timer_library.remove(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\ttimer.Stop(mangle_timer_name(instance,name))","\tinstance.data.timers[name] = nil","end",""],"class":"function","name":"timer_library.remove","summary":"\nRemoves a timer ","private":false,"library":"timer","description":"\nRemoves a timer","param":{"1":"name","name":"The timer name"}},"exists":{"ret":"bool if the timer exists","comment":["--- Checks if a timer exists","-- @param name The timer name","-- @return bool if the timer exists"],"code":["function timer_library.exists(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\treturn timer.Exists(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.exists","summary":"\nChecks if a timer exists ","private":false,"library":"timer","description":"\nChecks if a timer exists","param":{"1":"name","name":"The timer name"}},"unpause":{"comment":["--- Unpauses a timer","-- @param name The timer name"],"code":["function timer_library.unpause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.UnPause(mangle_timer_name(instance,name))","end","",""],"class":"function","name":"timer_library.unpause","summary":"\nUnpauses a timer ","private":false,"library":"timer","description":"\nUnpauses a timer","param":{"1":"name","name":"The timer name"}},"realtime":{"comment":["--- Same as GLua's RealTime()"],"code":["function timer_library.realtime()","\treturn RealTime()","end",""],"class":"function","name":"timer_library.realtime","summary":"\nSame as GLua's RealTime() ","private":false,"library":"timer","description":"\nSame as GLua's RealTime()","param":[]},"start":{"comment":["--- Starts a timer","-- @param name The timer name"],"code":["function timer_library.start(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Start(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.start","summary":"\nStarts a timer ","private":false,"library":"timer","description":"\nStarts a timer","param":{"1":"name","name":"The timer name"}},"pause":{"comment":["--- Pauses a timer","-- @param name The timer name"],"code":["function timer_library.pause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Pause(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.pause","summary":"\nPauses a timer ","private":false,"library":"timer","description":"\nPauses a timer","param":{"1":"name","name":"The timer name"}},"curtime":{"comment":["--- Same as GLua's CurTime()"],"code":["function timer_library.curtime()","\treturn CurTime()","end",""],"class":"function","name":"timer_library.curtime","summary":"\nSame as GLua's CurTime() ","private":false,"library":"timer","description":"\nSame as GLua's CurTime()","param":[]}},"class":"library","summary":"\nDeals with time and timers.","code":["local timer_library, _ = SF.Libraries.Register(\"timer\")","","-- ------------------------- Time ------------------------- --",""],"fields":[],"name":"timer","client":true,"description":"\nDeals with time and timers.","libtbl":"timer_library","tables":[],"server":true}},"type":"file","name":"libs_sh/timer.lua","functions":{"1":"timer_library.adjust","2":"timer_library.create","3":"timer_library.curtime","4":"timer_library.exists","5":"timer_library.frametime","6":"timer_library.pause","7":"timer_library.realtime","8":"timer_library.remove","9":"timer_library.simple","10":"timer_library.start","11":"timer_library.stop","12":"timer_library.systime","13":"timer_library.unpause","timer_library.simple":{"comment":["--- Creates a simple timer, has no name, can't be stopped, paused, or destroyed.","-- @param delay the time, in second, to set the timer to","-- @param func the function to call when the timer is fired"],"code":["function timer_library.simple(delay, func)","\tSF.CheckType( delay, \"number\" )","\tSF.CheckType( func, \"function\" )","\t","\tlocal instance = SF.instance","\ttimer.Simple(delay, function()","\t\tif IsValid(instance.data.entity) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"simple timer errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend)","end","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.timers = {}","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tif instance.data.timers ~= nil then","\t\tfor name,_ in pairs(instance.data.timers) do","\t\t\tlocal realname = mangle_timer_name(instance,name)","\t\t\ttimer.Remove(realname)","\t\tend","\tend","\tinstance.data.timers = nil","end)"],"class":"function","name":"timer_library.simple","summary":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","private":false,"library":"timer","description":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","param":{"1":"delay","2":"func","delay":"the time, in second, to set the timer to","func":"the function to call when the timer is fired"}},"timer_library.adjust":{"comment":["--- Adjusts a timer","-- @param name The timer name"],"code":["function timer_library.adjust(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Adjust(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.adjust","summary":"\nAdjusts a timer ","private":false,"library":"timer","description":"\nAdjusts a timer","param":{"1":"name","name":"The timer name"}},"timer_library.realtime":{"comment":["--- Same as GLua's RealTime()"],"code":["function timer_library.realtime()","\treturn RealTime()","end",""],"class":"function","name":"timer_library.realtime","summary":"\nSame as GLua's RealTime() ","private":false,"library":"timer","description":"\nSame as GLua's RealTime()","param":[]},"timer_library.exists":{"ret":"bool if the timer exists","comment":["--- Checks if a timer exists","-- @param name The timer name","-- @return bool if the timer exists"],"code":["function timer_library.exists(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\treturn timer.Exists(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.exists","summary":"\nChecks if a timer exists ","private":false,"library":"timer","description":"\nChecks if a timer exists","param":{"1":"name","name":"The timer name"}},"timer_library.systime":{"comment":["--- Same as GLua's SysTime()"],"code":["function timer_library.systime()","\treturn SysTime()","end",""],"class":"function","name":"timer_library.systime","summary":"\nSame as GLua's SysTime() ","private":false,"library":"timer","description":"\nSame as GLua's SysTime()","param":[]},"timer_library.unpause":{"comment":["--- Unpauses a timer","-- @param name The timer name"],"code":["function timer_library.unpause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.UnPause(mangle_timer_name(instance,name))","end","",""],"class":"function","name":"timer_library.unpause","summary":"\nUnpauses a timer ","private":false,"library":"timer","description":"\nUnpauses a timer","param":{"1":"name","name":"The timer name"}},"timer_library.curtime":{"comment":["--- Same as GLua's CurTime()"],"code":["function timer_library.curtime()","\treturn CurTime()","end",""],"class":"function","name":"timer_library.curtime","summary":"\nSame as GLua's CurTime() ","private":false,"library":"timer","description":"\nSame as GLua's CurTime()","param":[]},"timer_library.pause":{"comment":["--- Pauses a timer","-- @param name The timer name"],"code":["function timer_library.pause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Pause(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.pause","summary":"\nPauses a timer ","private":false,"library":"timer","description":"\nPauses a timer","param":{"1":"name","name":"The timer name"}},"timer_library.remove":{"comment":["--- Removes a timer","-- @param name The timer name"],"code":["function timer_library.remove(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\ttimer.Stop(mangle_timer_name(instance,name))","\tinstance.data.timers[name] = nil","end",""],"class":"function","name":"timer_library.remove","summary":"\nRemoves a timer ","private":false,"library":"timer","description":"\nRemoves a timer","param":{"1":"name","name":"The timer name"}},"timer_library.start":{"comment":["--- Starts a timer","-- @param name The timer name"],"code":["function timer_library.start(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Start(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.start","summary":"\nStarts a timer ","private":false,"library":"timer","description":"\nStarts a timer","param":{"1":"name","name":"The timer name"}},"timer_library.stop":{"comment":["--- Stops a timer","-- @param name The timer name"],"code":["function timer_library.stop(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Stop(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.stop","summary":"\nStops a timer ","private":false,"library":"timer","description":"\nStops a timer","param":{"1":"name","name":"The timer name"}},"timer_library.create":{"comment":["--- Creates (and starts) a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.create(name, delay, reps, func)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tSF.CheckType(func,\"function\")","\t","\tlocal instance = SF.instance","\tlocal timername = mangle_timer_name(instance,name)","\t","\tlocal function timercb()","\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\t\ttimer.Remove( timername )","\t\tend","\tend","\t","\ttimer.Create(timername, delay, reps, timercb )","\t","\tinstance.data.timers[name] = true","end",""],"class":"function","name":"timer_library.create","summary":"\nCreates (and starts) a timer ","private":false,"library":"timer","description":"\nCreates (and starts) a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"timer_library.frametime":{"comment":["--- Returns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua"],"code":["function timer_library.frametime()","\treturn FrameTime()","end","","-- ------------------------- Timers ------------------------- --","","local function mangle_timer_name(instance, name)","\treturn string.format(\"sftimer_%s_%s\",tostring(instance),name)","end",""],"class":"function","name":"timer_library.frametime","summary":"\nReturns time between frames on client and ticks on server.","private":false,"library":"timer","description":"\nReturns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua","param":[]}},"doc":[{"summary":"\n \nTime library \n ","description":"\n \nTime library \n","comment":["-------------------------------------------------------------------------------","-- Time library","-------------------------------------------------------------------------------"],"code":["","local timer = timer",""]},{"comment":["--- Deals with time and timers.","-- @shared"],"functions":{"1":"adjust","2":"create","3":"curtime","4":"exists","5":"frametime","6":"pause","7":"realtime","8":"remove","9":"simple","10":"start","11":"stop","12":"systime","13":"unpause","simple":{"comment":["--- Creates a simple timer, has no name, can't be stopped, paused, or destroyed.","-- @param delay the time, in second, to set the timer to","-- @param func the function to call when the timer is fired"],"code":["function timer_library.simple(delay, func)","\tSF.CheckType( delay, \"number\" )","\tSF.CheckType( func, \"function\" )","\t","\tlocal instance = SF.instance","\ttimer.Simple(delay, function()","\t\tif IsValid(instance.data.entity) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"simple timer errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend)","end","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.timers = {}","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tif instance.data.timers ~= nil then","\t\tfor name,_ in pairs(instance.data.timers) do","\t\t\tlocal realname = mangle_timer_name(instance,name)","\t\t\ttimer.Remove(realname)","\t\tend","\tend","\tinstance.data.timers = nil","end)"],"class":"function","name":"timer_library.simple","summary":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","private":false,"library":"timer","description":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","param":{"1":"delay","2":"func","delay":"the time, in second, to set the timer to","func":"the function to call when the timer is fired"}},"frametime":{"comment":["--- Returns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua"],"code":["function timer_library.frametime()","\treturn FrameTime()","end","","-- ------------------------- Timers ------------------------- --","","local function mangle_timer_name(instance, name)","\treturn string.format(\"sftimer_%s_%s\",tostring(instance),name)","end",""],"class":"function","name":"timer_library.frametime","summary":"\nReturns time between frames on client and ticks on server.","private":false,"library":"timer","description":"\nReturns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua","param":[]},"systime":{"comment":["--- Same as GLua's SysTime()"],"code":["function timer_library.systime()","\treturn SysTime()","end",""],"class":"function","name":"timer_library.systime","summary":"\nSame as GLua's SysTime() ","private":false,"library":"timer","description":"\nSame as GLua's SysTime()","param":[]},"adjust":{"comment":["--- Adjusts a timer","-- @param name The timer name"],"code":["function timer_library.adjust(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Adjust(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.adjust","summary":"\nAdjusts a timer ","private":false,"library":"timer","description":"\nAdjusts a timer","param":{"1":"name","name":"The timer name"}},"create":{"comment":["--- Creates (and starts) a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.create(name, delay, reps, func)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tSF.CheckType(func,\"function\")","\t","\tlocal instance = SF.instance","\tlocal timername = mangle_timer_name(instance,name)","\t","\tlocal function timercb()","\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\t\ttimer.Remove( timername )","\t\tend","\tend","\t","\ttimer.Create(timername, delay, reps, timercb )","\t","\tinstance.data.timers[name] = true","end",""],"class":"function","name":"timer_library.create","summary":"\nCreates (and starts) a timer ","private":false,"library":"timer","description":"\nCreates (and starts) a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},"stop":{"comment":["--- Stops a timer","-- @param name The timer name"],"code":["function timer_library.stop(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Stop(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.stop","summary":"\nStops a timer ","private":false,"library":"timer","description":"\nStops a timer","param":{"1":"name","name":"The timer name"}},"remove":{"comment":["--- Removes a timer","-- @param name The timer name"],"code":["function timer_library.remove(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\ttimer.Stop(mangle_timer_name(instance,name))","\tinstance.data.timers[name] = nil","end",""],"class":"function","name":"timer_library.remove","summary":"\nRemoves a timer ","private":false,"library":"timer","description":"\nRemoves a timer","param":{"1":"name","name":"The timer name"}},"exists":{"ret":"bool if the timer exists","comment":["--- Checks if a timer exists","-- @param name The timer name","-- @return bool if the timer exists"],"code":["function timer_library.exists(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\treturn timer.Exists(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.exists","summary":"\nChecks if a timer exists ","private":false,"library":"timer","description":"\nChecks if a timer exists","param":{"1":"name","name":"The timer name"}},"unpause":{"comment":["--- Unpauses a timer","-- @param name The timer name"],"code":["function timer_library.unpause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.UnPause(mangle_timer_name(instance,name))","end","",""],"class":"function","name":"timer_library.unpause","summary":"\nUnpauses a timer ","private":false,"library":"timer","description":"\nUnpauses a timer","param":{"1":"name","name":"The timer name"}},"realtime":{"comment":["--- Same as GLua's RealTime()"],"code":["function timer_library.realtime()","\treturn RealTime()","end",""],"class":"function","name":"timer_library.realtime","summary":"\nSame as GLua's RealTime() ","private":false,"library":"timer","description":"\nSame as GLua's RealTime()","param":[]},"start":{"comment":["--- Starts a timer","-- @param name The timer name"],"code":["function timer_library.start(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Start(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.start","summary":"\nStarts a timer ","private":false,"library":"timer","description":"\nStarts a timer","param":{"1":"name","name":"The timer name"}},"pause":{"comment":["--- Pauses a timer","-- @param name The timer name"],"code":["function timer_library.pause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Pause(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.pause","summary":"\nPauses a timer ","private":false,"library":"timer","description":"\nPauses a timer","param":{"1":"name","name":"The timer name"}},"curtime":{"comment":["--- Same as GLua's CurTime()"],"code":["function timer_library.curtime()","\treturn CurTime()","end",""],"class":"function","name":"timer_library.curtime","summary":"\nSame as GLua's CurTime() ","private":false,"library":"timer","description":"\nSame as GLua's CurTime()","param":[]}},"class":"library","summary":"\nDeals with time and timers.","code":["local timer_library, _ = SF.Libraries.Register(\"timer\")","","-- ------------------------- Time ------------------------- --",""],"fields":[],"name":"timer","client":true,"description":"\nDeals with time and timers.","libtbl":"timer_library","tables":[],"server":true},{"comment":["--- Same as GLua's CurTime()"],"code":["function timer_library.curtime()","\treturn CurTime()","end",""],"class":"function","name":"timer_library.curtime","summary":"\nSame as GLua's CurTime() ","private":false,"library":"timer","description":"\nSame as GLua's CurTime()","param":[]},{"comment":["--- Same as GLua's RealTime()"],"code":["function timer_library.realtime()","\treturn RealTime()","end",""],"class":"function","name":"timer_library.realtime","summary":"\nSame as GLua's RealTime() ","private":false,"library":"timer","description":"\nSame as GLua's RealTime()","param":[]},{"comment":["--- Same as GLua's SysTime()"],"code":["function timer_library.systime()","\treturn SysTime()","end",""],"class":"function","name":"timer_library.systime","summary":"\nSame as GLua's SysTime() ","private":false,"library":"timer","description":"\nSame as GLua's SysTime()","param":[]},{"comment":["--- Returns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua"],"code":["function timer_library.frametime()","\treturn FrameTime()","end","","-- ------------------------- Timers ------------------------- --","","local function mangle_timer_name(instance, name)","\treturn string.format(\"sftimer_%s_%s\",tostring(instance),name)","end",""],"class":"function","name":"timer_library.frametime","summary":"\nReturns time between frames on client and ticks on server.","private":false,"library":"timer","description":"\nReturns time between frames on client and ticks on server. Same thing as G.FrameTime in GLua","param":[]},{"comment":["--- Creates (and starts) a timer","-- @param name The timer name","-- @param delay The time, in seconds, to set the timer to.","-- @param reps The repititions of the tiemr. 0 = infinte, nil = 1","-- @param func The function to call when the tiemr is fired"],"code":["function timer_library.create(name, delay, reps, func)","\tSF.CheckType(name,\"string\")","\tSF.CheckType(delay,\"number\")","\treps = SF.CheckType(reps,\"number\",0,1)","\tSF.CheckType(func,\"function\")","\t","\tlocal instance = SF.instance","\tlocal timername = mangle_timer_name(instance,name)","\t","\tlocal function timercb()","\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\t\ttimer.Remove( timername )","\t\tend","\tend","\t","\ttimer.Create(timername, delay, reps, timercb )","\t","\tinstance.data.timers[name] = true","end",""],"class":"function","name":"timer_library.create","summary":"\nCreates (and starts) a timer ","private":false,"library":"timer","description":"\nCreates (and starts) a timer","param":{"1":"name","2":"delay","3":"reps","4":"func","func":"The function to call when the tiemr is fired","reps":"The repititions of the tiemr. 0 = infinte, nil = 1","delay":"The time, in seconds, to set the timer to.","name":"The timer name"}},{"comment":["--- Removes a timer","-- @param name The timer name"],"code":["function timer_library.remove(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\ttimer.Stop(mangle_timer_name(instance,name))","\tinstance.data.timers[name] = nil","end",""],"class":"function","name":"timer_library.remove","summary":"\nRemoves a timer ","private":false,"library":"timer","description":"\nRemoves a timer","param":{"1":"name","name":"The timer name"}},{"ret":"bool if the timer exists","comment":["--- Checks if a timer exists","-- @param name The timer name","-- @return bool if the timer exists"],"code":["function timer_library.exists(name)","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\t","\treturn timer.Exists(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.exists","summary":"\nChecks if a timer exists ","private":false,"library":"timer","description":"\nChecks if a timer exists","param":{"1":"name","name":"The timer name"}},{"comment":["--- Stops a timer","-- @param name The timer name"],"code":["function timer_library.stop(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Stop(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.stop","summary":"\nStops a timer ","private":false,"library":"timer","description":"\nStops a timer","param":{"1":"name","name":"The timer name"}},{"comment":["--- Starts a timer","-- @param name The timer name"],"code":["function timer_library.start(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Start(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.start","summary":"\nStarts a timer ","private":false,"library":"timer","description":"\nStarts a timer","param":{"1":"name","name":"The timer name"}},{"comment":["--- Adjusts a timer","-- @param name The timer name"],"code":["function timer_library.adjust(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Adjust(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.adjust","summary":"\nAdjusts a timer ","private":false,"library":"timer","description":"\nAdjusts a timer","param":{"1":"name","name":"The timer name"}},{"comment":["--- Pauses a timer","-- @param name The timer name"],"code":["function timer_library.pause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.Pause(mangle_timer_name(instance,name))","end",""],"class":"function","name":"timer_library.pause","summary":"\nPauses a timer ","private":false,"library":"timer","description":"\nPauses a timer","param":{"1":"name","name":"The timer name"}},{"comment":["--- Unpauses a timer","-- @param name The timer name"],"code":["function timer_library.unpause(name)","\tSF.CheckType(name,\"string\")","\t","\ttimer.UnPause(mangle_timer_name(instance,name))","end","",""],"class":"function","name":"timer_library.unpause","summary":"\nUnpauses a timer ","private":false,"library":"timer","description":"\nUnpauses a timer","param":{"1":"name","name":"The timer name"}},{"comment":["--- Creates a simple timer, has no name, can't be stopped, paused, or destroyed.","-- @param delay the time, in second, to set the timer to","-- @param func the function to call when the timer is fired"],"code":["function timer_library.simple(delay, func)","\tSF.CheckType( delay, \"number\" )","\tSF.CheckType( func, \"function\" )","\t","\tlocal instance = SF.instance","\ttimer.Simple(delay, function()","\t\tif IsValid(instance.data.entity) and not instance.error then","\t\t\tlocal ok, msg, traceback = instance:runFunction(func)","\t\t\tif not ok then","\t\t\t\tinstance:Error( \"simple timer errored with: \" .. msg, traceback )","\t\t\tend","\t\tend","\tend)","end","","SF.Libraries.AddHook(\"initialize\",function(instance)","\tinstance.data.timers = {}","end)","","SF.Libraries.AddHook(\"deinitialize\",function(instance)","\tif instance.data.timers ~= nil then","\t\tfor name,_ in pairs(instance.data.timers) do","\t\t\tlocal realname = mangle_timer_name(instance,name)","\t\t\ttimer.Remove(realname)","\t\tend","\tend","\tinstance.data.timers = nil","end)"],"class":"function","name":"timer_library.simple","summary":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","private":false,"library":"timer","description":"\nCreates a simple timer, has no name, can't be stopped, paused, or destroyed.","param":{"1":"delay","2":"func","delay":"the time, in second, to set the timer to","func":"the function to call when the timer is fired"}}],"tables":[],"description":"\n \nTime library \n","summary":"\n \nTime library \n "},"libs_cl/render.lua":{"libraries":{"1":"render","render":{"comment":["--- Render library. Screens are 512x512 units. Most functions require","-- that you be in the rendering hook to call, otherwise an error is","-- thrown. +x is right, +y is down","-- @entity starfall_screen","-- @field TEXT_ALIGN_LEFT","-- @field TEXT_ALIGN_CENTER","-- @field TEXT_ALIGN_RIGHT","-- @field TEXT_ALIGN_TOP","-- @field TEXT_ALIGN_BOTTOM"],"functions":{"1":"capturePixels","2":"clear","3":"createFont","4":"createPoly","5":"createRenderTarget","6":"cursorPos","7":"drawCircle","8":"drawLine","9":"drawPoly","10":"drawRect","11":"drawRectOutline","12":"drawText","13":"drawTexturedRect","14":"drawTexturedRectRotated","15":"drawTexturedRectUV","16":"getDefaultFont","17":"getScreenInfo","18":"getScreenPos","19":"getTextSize","20":"getTextureID","21":"popMatrix","22":"pushMatrix","23":"readPixel","24":"selectRenderTarget","25":"setColor","26":"setFont","27":"setRenderTargetTexture","28":"setTexture","drawTexturedRectUV":{"comment":["--- Draws a textured rectangle with UV coordinates","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param startU Texture mapping at rectangle origin","-- @param startV Texture mapping at rectangle origin","-- @param endV Texture mapping at rectangle end","-- @param endV Texture mapping at rectangle end"],"code":["function render_library.drawTexturedRectUV ( x, y, w, h, startU, startV, endU, endV )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( startU, \"number\" )","\tSF.CheckType( startV, \"number\" )","\tSF.CheckType( endU, \"number\" )","\tSF.CheckType( endV, \"number\" )","\tsurface.DrawTexturedRectUV( x, y, w, h, startU, startV, endU, endV )","end",""],"class":"function","name":"render_library.drawTexturedRectUV","summary":"\nDraws a textured rectangle with UV coordinates ","private":false,"library":"render","description":"\nDraws a textured rectangle with UV coordinates","param":{"1":"x","2":"y","3":"w","4":"h","5":"startU","6":"startV","7":"endU","8":"endV","y":"Top left corner y coordinate","h":"Height","endV":"Texture mapping at rectangle end","startU":"Texture mapping at rectangle origin","startV":"Texture mapping at rectangle origin","w":"Width","x":"Top left corner x coordinate"}},"drawTexturedRect":{"comment":["--- Draws a textured rectangle.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawTexturedRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawTexturedRect ( x, y, w, h )","end",""],"class":"function","name":"render_library.drawTexturedRect","summary":"\nDraws a textured rectangle.","private":false,"library":"render","description":"\nDraws a textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"drawRect":{"comment":["--- Draws a rectangle using the current color. ","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRect","summary":"\nDraws a rectangle using the current color.","private":false,"library":"render","description":"\nDraws a rectangle using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"drawCircle":{"comment":["--- Draws a circle outline","-- @param x Center x coordinate","-- @param y Center y coordinate","-- @param r Radius"],"code":["function render_library.drawCircle ( x, y, r )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( r, \"number\" )","\tsurface.DrawCircle( x, y, r, currentcolor )","end",""],"class":"function","name":"render_library.drawCircle","summary":"\nDraws a circle outline ","private":false,"library":"render","description":"\nDraws a circle outline","param":{"1":"x","2":"y","3":"r","y":"Center y coordinate","x":"Center x coordinate","r":"Radius"}},"readPixel":{"ret":"Color object with ( r, g, b, 255 ) from the specified pixel.","comment":["--- Reads the color of the specified pixel.","-- @param x Pixel x-coordinate.","-- @param y Pixel y-coordinate.","-- @return Color object with ( r, g, b, 255 ) from the specified pixel."],"code":["function render_library.readPixel ( x, y )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\t","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","","\tlocal r, g, b = render.ReadPixel( x, y )","\treturn SF.Color.Wrap( Color( r, g, b, 255 ) )","end",""],"class":"function","name":"render_library.readPixel","summary":"\nReads the color of the specified pixel.","private":false,"library":"render","description":"\nReads the color of the specified pixel.","param":{"1":"x","2":"y","y":"Pixel y-coordinate.","x":"Pixel x-coordinate."}},"pushMatrix":{"comment":["--- Pushes a matrix onto the matrix stack.","-- @param m The matrix"],"code":["function render_library.pushMatrix(m)","\tSF.CheckType(m,matrix_meta)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tlocal id = #matrix_stack","\tif id + 1 > MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tlocal newmatrix","\tif matrix_stack[id] then","\t\tnewmatrix = matrix_stack[id] * v_unwrap(m)","\telse","\t\tnewmatrix = v_unwrap(m)","\tend","\tmatrix_stack[id+1] = newmatrix","\tcam.PushModelMatrix(newmatrix)","end",""],"class":"function","name":"render_library.pushMatrix","summary":"\nPushes a matrix onto the matrix stack.","private":false,"library":"render","description":"\nPushes a matrix onto the matrix stack.","param":{"1":"m","m":"The matrix"}},"getScreenPos":{"ret":["The screen position","The screen angle"],"comment":["--- Returns the screen surface's world position and angle","-- @return The screen position","-- @return The screen angle"],"code":["function render_library.getScreenPos()","\tlocal gpu = SF.instance.data.render.gpu","\tif not gpu then return end","\tlocal _, pos, rot = gpu:GetInfo()","\treturn SF.WrapObject( pos ), SF.WrapObject( rot )","end","","local function findAvailableRT ()","\tfor k, v in pairs( globalRTs ) do","\t\tif v[ 2 ] then","\t\t\treturn k, v","\t\tend","\tend","\treturn nil","end",""],"class":"function","name":"render_library.getScreenPos","summary":"\nReturns the screen surface's world position and angle ","private":false,"library":"render","description":"\nReturns the screen surface's world position and angle","param":[]},"createFont":{"comment":["--- Creates a font. Does not require rendering hook","-- @param font Base font to use","-- @param size Font size","-- @param weight Font weight (default: 400)","-- @param antialias Antialias font?","-- @param additive If true, adds brightness to pixels behind it rather than drawing over them.","-- @param shadow Enable drop shadow?","-- @param outline Enable outline?","-- @param blue Enable blur?","-- @usage","-- Base font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall):","-- \\- DebugFixed","-- \\- DebugFixedSmall","-- \\- DefaultFixedOutline","-- \\- MenuItem","-- \\- Default","-- \\- TabLarge","-- \\- DefaultBold","-- \\- DefaultUnderline","-- \\- DefaultSmall","-- \\- DefaultSmallDropShadow","-- \\- DefaultVerySmall","-- \\- DefaultLarge","-- \\- UiBold","-- \\- MenuLarge","-- \\- ConsoleText","-- \\- Marlett","-- \\- Trebuchet18","-- \\- Trebuchet19","-- \\- Trebuchet20","-- \\- Trebuchet22","-- \\- Trebuchet24","-- \\- HUDNumber","-- \\- HUDNumber1","-- \\- HUDNumber2","-- \\- HUDNumber3","-- \\- HUDNumber4","-- \\- HUDNumber5","-- \\- HudHintTextLarge","-- \\- HudHintTextSmall","-- \\- CenterPrintText","-- \\- HudSelectionText","-- \\- DefaultFixed","-- \\- DefaultFixedDropShadow","-- \\- CloseCaption_Normal","-- \\- CloseCaption_Bold","-- \\- CloseCaption_BoldItalic","-- \\- TitleFont","-- \\- TitleFont2","-- \\- ChatFont","-- \\- TargetID","-- \\- TargetIDSmall","-- \\- HL2MPTypeDeath","-- \\- BudgetLabel","-- \\- DejaVu Sans Mono (shipped, monospaced)"],"code":["function render_library.createFont(font,size,weight,antialias,additive,shadow,outline,blur)","\tif not validfonts[font] then SF.throw( \"invalid font\", 2 ) end","\t","\tsize = tonumber(size) or 16","\tweight = tonumber(weight) or 400","\tblur = tonumber(blur) or 0","\tantialias = antialias and true or false","\tadditive = additive and true or false","\tshadow = shadow and true or false","\toutline = outline and true or false","\t","\tlocal name = string.format(\"sf_screen_font_%s_%d_%d_%d_%d%d%d%d\",","\t\tfont, size, weight, blur,","\t\tantialias and 1 or 0,","\t\tadditive and 1 or 0,","\t\tshadow and 1 or 0,","\t\toutline and 1 or 0)","\t","\tif not defined_fonts[name] then","\t\tsurface.CreateFont(name, {size = size, weight = weight,","\t\t\tantialias=antialias, additive = additive, font = font,","\t\t\tshadow = shadow, outline = outline, blur = blur})","\t\tdefined_fonts[name] = true","\tend","\treturn name","end",""],"class":"function","summary":"\nCreates a font.","name":"render_library.createFont","library":"render","private":false,"usage":"\nBase font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall): \n- DebugFixed \n- DebugFixedSmall \n- DefaultFixedOutline \n- MenuItem \n- Default \n- TabLarge \n- DefaultBold \n- DefaultUnderline \n- DefaultSmall \n- DefaultSmallDropShadow \n- DefaultVerySmall \n- DefaultLarge \n- UiBold \n- MenuLarge \n- ConsoleText \n- Marlett \n- Trebuchet18 \n- Trebuchet19 \n- Trebuchet20 \n- Trebuchet22 \n- Trebuchet24 \n- HUDNumber \n- HUDNumber1 \n- HUDNumber2 \n- HUDNumber3 \n- HUDNumber4 \n- HUDNumber5 \n- HudHintTextLarge \n- HudHintTextSmall \n- CenterPrintText \n- HudSelectionText \n- DefaultFixed \n- DefaultFixedDropShadow \n- CloseCaption_Normal \n- CloseCaption_Bold \n- CloseCaption_BoldItalic \n- TitleFont \n- TitleFont2 \n- ChatFont \n- TargetID \n- TargetIDSmall \n- HL2MPTypeDeath \n- BudgetLabel \n- DejaVu Sans Mono (shipped, monospaced)","description":"\nCreates a font. Does not require rendering hook","param":{"1":"font","2":"size","3":"weight","4":"antialias","5":"additive","6":"shadow","7":"outline","8":"blur","9":"blue","outline":"Enable outline?","shadow":"Enable drop shadow?","blue":"Enable blur?","weight":"Font weight (default: 400)","font":"Base font to use","additive":"If true, adds brightness to pixels behind it rather than drawing over them.","antialias":"Antialias font?","size":"Font size"}},"selectRenderTarget":{"comment":["--- Selects the render target to draw on.","-- Nil for the visible RT.","-- @param name Name of the render target to use"],"code":["function render_library.selectRenderTarget ( name )","\tlocal data = SF.instance.data.render","\tdata.oldRT = data.oldRT or render.GetRenderTarget()","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif not name then","\t\tif data.usingRT then","\t\t\tcam.End2D()","\t\t\trender.PopRenderTarget()","\t\t\tcam.Start2D()","\t\t\tdata.usingRT = false","\t\tend","\t\treturn","\tend","\tSF.CheckType( name, \"string\" )","\tlocal rt = globalRTs[ data.rendertargets[ name ] ][ 1 ]","\tif not rt then SF.Throw( \"Invalid Rendertarget\", 2 ) end","","\tcam.End2D()","\tif data.usingRT then","\t\trender.PopRenderTarget()","\tend","\trender.PushRenderTarget( rt, 0, 0, rt:Width(), rt:Height() )","\tcam.Start2D()","\tdata.usingRT = true","end",""],"class":"function","name":"render_library.selectRenderTarget","summary":"\nSelects the render target to draw on.","private":false,"library":"render","description":"\nSelects the render target to draw on. \nNil for the visible RT.","param":{"1":"name","name":"Name of the render target to use"}},"createRenderTarget":{"comment":["--- Creates a new render target to draw onto.","-- The dimensions will always be 1024x1024","-- @param name The name of the render target","-- @bug The drawing will be offset by 16 pixels to the left and 16 to the top and the resolution is actually 992x992. So drawing to 16,16 will draw in the top-left corner and 1007,1007 to the bottom-right."],"code":["function render_library.createRenderTarget ( name )","\tSF.CheckType( name, \"string\" )","","\tlocal data = SF.instance.data.render","\tdata.rendertargets = data.rendertargets or {}","\tdata.rendertargetcount = data.rendertargetcount or 0","","\tif data.rendertargetcount >= 2 then","\t\tSF.throw( \"Rendertarget limit reached\", 2 )","\tend","","\tdata.rendertargetcount = data.rendertargetcount + 1","\tlocal rtname, rt = findAvailableRT()","\tif not rt then","\t\tglobalRTcount = globalRTcount + 1","\t\trtname = \"Starfall_CustomRT_\" .. globalRTcount","\t\trt = { GetRenderTarget( rtname, 1024, 1024, false ) }","\t\tglobalRTs[ rtname ] = rt","\tend","\trt[ 2 ] = false","\tdata.rendertargets[ name ] = rtname","end",""],"class":"function","bug":"The drawing will be offset by 16 pixels to the left and 16 to the top and the resolution is actually 992x992. So drawing to 16,16 will draw in the top-left corner and 1007,1007 to the bottom-right.","name":"render_library.createRenderTarget","summary":"\nCreates a new render target to draw onto.","private":false,"library":"render","description":"\nCreates a new render target to draw onto. \nThe dimensions will always be 1024x1024","param":{"1":"name","name":"The name of the render target"}},"capturePixels":{"comment":["--- Dumps the current render target and allows the pixels to be accessed by render.readPixel."],"code":["function render_library.capturePixels ()","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\trender.CapturePixels()","end",""],"class":"function","name":"render_library.capturePixels","summary":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","private":false,"library":"render","description":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","param":[]},"setRenderTargetTexture":{"comment":["--- Sets the active texture to the render target with the specified name.","-- Nil to reset.","-- @param name Name of the render target to use"],"code":["function render_library.setRenderTargetTexture ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif not name then","\t\tdraw.NoTexture()","\telse","\t\tSF.CheckType( name, \"string\" )","\t\tlocal rtname = data.rendertargets[ name ]","\t\tlocal rt = globalRTs[ rtname ][ 1 ]","\t\tlocal mat = globalRTs[ rtname ][ 2 ] or CreateMaterial( rtname, \"UnlitGeneric\", {","\t\t\t[ \"$nolod\" ] = 1,","\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t[ \"$vertexalpha\" ] = 1","\t\t} )","\t\tmat:SetTexture( \"$basetexture\", rt )","\t\tsurface.SetMaterial( mat )","\tend","end",""],"class":"function","name":"render_library.setRenderTargetTexture","summary":"\nSets the active texture to the render target with the specified name.","private":false,"library":"render","description":"\nSets the active texture to the render target with the specified name. \nNil to reset.","param":{"1":"name","name":"Name of the render target to use"}},"clear":{"comment":["--- Clears the surface","-- @param clr Color type to clear with"],"code":["function render_library.clear ( clr )","    if clr == nil then","        if not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","        render.Clear( 0, 0, 0, 255 )","    else","        SF.CheckType( clr, SF.Types[ \"Color\" ] )","        if not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","        render.Clear( clr.r, clr.g, clr.b, clr.a )","    end","end",""],"class":"function","name":"render_library.clear","summary":"\nClears the surface ","private":false,"library":"render","description":"\nClears the surface","param":{"1":"clr","clr":"Color type to clear with"}},"getScreenInfo":{"ret":"A table describing the screen.","comment":["--- Returns information about the screen, such as dimentions and rotation.","-- Note: this does a table copy so move it out of your draw hook","-- @return A table describing the screen."],"code":["function render_library.getScreenInfo()","\tlocal gpu = SF.instance.data.render.gpu","\tif not gpu then return end","\tlocal info, _, _ = gpu:GetInfo()","\treturn table.Copy(info)","end",""],"class":"function","name":"render_library.getScreenInfo","summary":"\nReturns information about the screen, such as dimentions and rotation.","private":false,"library":"render","description":"\nReturns information about the screen, such as dimentions and rotation. \nNote: this does a table copy so move it out of your draw hook","param":[]},"drawLine":{"comment":["--- Draws a line","-- @param x1 X start coordinate","-- @param y1 Y start coordinate","-- @param x2 X end coordinate","-- @param y2 Y end coordinate"],"code":["function render_library.drawLine ( x1, y1, x2, y2 )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x1, \"number\" )","\tSF.CheckType( y1, \"number\" )","\tSF.CheckType( x2, \"number\" )","\tSF.CheckType( y2, \"number\" )","\tsurface.DrawLine( x1, y1, x2, y2 )","end",""],"class":"function","name":"render_library.drawLine","summary":"\nDraws a line ","private":false,"library":"render","description":"\nDraws a line","param":{"1":"x1","2":"y1","3":"x2","4":"y2","x2":"X end coordinate","y2":"Y end coordinate","y1":"Y start coordinate","x1":"X start coordinate"}},"getTextureID":{"comment":["--- Looks up a texture by file name. Use with render.setTexture to draw with it.","--- Make sure to store the texture to use it rather than calling this slow function repeatedly.","-- @param tx Texture file path, or a http url"],"code":["function render_library.getTextureID ( tx )","","\tif tx:sub(1,4)==\"http\" then","\t\ttx = string.gsub( tx, \"[^%w _~%.%-/:]\", function( str )","\t\t\treturn string.format( \"%%%02X\", string.byte( str ) )","\t\tend )","\t\t","\t\tlocal tbl = {}","\t\ttexturecache[ tbl ] = LoadURLMaterial( tx )","\t\treturn tbl","\telse","\t\tlocal id = surface.GetTextureID( tx )","\t\tif id then","\t\t\tlocal mat = Material( tx ) -- Hacky way to get ITexture, if there is a better way - do it!","\t\t\tlocal cacheentry = CreateMaterial( \"SF_TEXTURE_\" .. id, \"UnlitGeneric\", {","\t\t\t\t[ \"$nolod\" ] = 1,","\t\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t\t[ \"$vertexalpha\" ] = 1","\t\t\t} )","\t\t\tcacheentry:SetTexture( \"$basetexture\", mat:GetTexture( \"$basetexture\" ) )","\t\t\t","\t\t\tlocal tbl = {}","\t\t\ttexturecache[ tbl ] = cacheentry","\t\t\treturn tbl","\t\tend","\tend","\t","end",""],"class":"function","name":"render_library.getTextureID","summary":"\nLooks up a texture by file name.","private":false,"library":"render","description":"\nLooks up a texture by file name. Use with render.setTexture to draw with it. \nMake sure to store the texture to use it rather than calling this slow function repeatedly.","param":{"1":"tx","tx":"Texture file path, or a http url"}},"cursorPos":{"ret":["x position","y position"],"comment":["--- Gets a 2D cursor position where ply is aiming.","-- @param ply player to get cursor position from","-- @return x position","-- @return y position"],"code":["function render_library.cursorPos( ply )","\t-- Taken from EGPLib","\tlocal Normal, Pos, monitor, Ang","\tlocal screen = SF.instance.data.render.renderEnt","\tif not screen then return nil end","\t","\tply = SF.Entities.Unwrap( ply )","\tif not ply then SF.throw(\"Invalid Player\", 2) end","\t","\t-- Get monitor screen pos & size","\tmonitor = WireGPU_Monitors[ screen:GetModel() ]","\t\t","\t-- Monitor does not have a valid screen point","\tif not monitor then return nil end","\t\t","\tAng = screen:LocalToWorldAngles( monitor.rot )","\tPos = screen:LocalToWorld( monitor.offset )","\t\t","\tNormal = Ang:Up()","\t","\tlocal Start = ply:GetShootPos()","\tlocal Dir = ply:GetAimVector()","\t","\tlocal A = Normal:Dot(Dir)","\t","\t-- If ray is parallel or behind the screen","\tif A == 0 or A > 0 then return nil end","\t","\tlocal B = Normal:Dot(Pos-Start) / A","\t\tif (B >= 0) then","\t\tlocal HitPos = WorldToLocal( Start + Dir * B, Angle(), Pos, Ang )","\t\tlocal x = (0.5+HitPos.x/(monitor.RS*512/monitor.RatioX)) * 512","\t\tlocal y = (0.5-HitPos.y/(monitor.RS*512)) * 512\t","\t\tif x < 0 or x > 512 or y < 0 or y > 512 then return nil end -- Aiming off the screen ","\t\treturn x, y","\tend","\t","\treturn nil","end",""],"class":"function","name":"render_library.cursorPos","summary":"\nGets a 2D cursor position where ply is aiming.","private":false,"library":"render","description":"\nGets a 2D cursor position where ply is aiming.","param":{"1":"ply","ply":"player to get cursor position from"}},"setFont":{"comment":["--- Sets the font","-- @param font The font to use"],"code":["function render_library.setFont(font)","\tif not defined_fonts[font] then SF.throw( \"Font does not exist.\", 2 ) end","\tSF.instance.data.render.font = font","\t--surface.SetFont(font)","end",""],"class":"function","name":"render_library.setFont","summary":"\nSets the font ","private":false,"library":"render","description":"\nSets the font","param":{"1":"font","font":"The font to use"}},"drawPoly":{"comment":["--- Draws a polygon. Takes a compiled/uncompiled poly to draw.","-- Note that if you do use an uncompiled poly, you will use up ops","-- very quickly!","-- @param poly Compiled poly or array of vertexes"],"code":["function render_library.drawPoly(poly)","\tif dgetmeta(poly) ~= poly_metamethods then","\t\tSF.CheckType(poly,\"table\")","\t\tlocal verts = poly","\t\tpoly = {}","\t\tfor i=1,#verts do","\t\t\tlocal v = verts[i]","\t\t\tSF.CheckType(v,\"table\")","\t\t\tpoly[i] = checkvertex(v)","\t\tend","\telse","\t\tpoly = unwrappoly(poly)","\tend","\tsurface.DrawPoly(poly)","end",""],"class":"function","name":"render_library.drawPoly","summary":"\nDraws a polygon.","private":false,"library":"render","description":"\nDraws a polygon. Takes a compiled/uncompiled poly to draw. \nNote that if you do use an uncompiled poly, you will use up ops \nvery quickly!","param":{"1":"poly","poly":"Compiled poly or array of vertexes"}},"drawTexturedRectRotated":{"comment":["--- Draws a rotated, textured rectangle.","-- @param x X coordinate of center of rect","-- @param y Y coordinate of center of rect","-- @param w Width","-- @param h Height","-- @param rot Rotation in degrees"],"code":["function render_library.drawTexturedRectRotated ( x, y, w, h, rot )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( rot, \"number\" )","","\tsurface.DrawTexturedRectRotated( x, y, w, h, rot )","end",""],"class":"function","name":"render_library.drawTexturedRectRotated","summary":"\nDraws a rotated, textured rectangle.","private":false,"library":"render","description":"\nDraws a rotated, textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","5":"rot","y":"Y coordinate of center of rect","h":"Height","rot":"Rotation in degrees","w":"Width","x":"X coordinate of center of rect"}},"createPoly":{"ret":"compiled polygon","comment":["--- Compiles a 2D poly. This is needed so that poly don't have to be","-- type-checked each frame. Polys can be indexed by a number, in which","-- a copy of the vertex at that spot is returned. They can also be assigned","-- a new vertex at 1 <= i <= #poly+1. And the length of the poly can be taken.","-- @param verts Array of verticies to convert.","-- @return compiled polygon"],"code":["function render_library.createPoly(verts)","\tSF.CheckType(verts,\"table\")","\tlocal poly = {}","\tlocal wrappedpoly = wrappoly(poly)","\tfor i=1,#verts do","\t\tlocal v = verts[i]","\t\tSF.CheckType(v,\"table\")","\t\tpoly[i] = checkvertex(v)","\tend","\treturn wrappedpoly","end",""],"class":"function","name":"render_library.createPoly","summary":"\nCompiles a 2D poly.","private":false,"library":"render","description":"\nCompiles a 2D poly. This is needed so that poly don't have to be \ntype-checked each frame. Polys can be indexed by a number, in which \na copy of the vertex at that spot is returned. They can also be assigned \na new vertex at 1 <= i <= #poly+1. And the length of the poly can be taken.","param":{"1":"verts","verts":"Array of verticies to convert."}},"drawRectOutline":{"comment":["--- Draws a rectangle outline using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRectOutline ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawOutlinedRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRectOutline","summary":"\nDraws a rectangle outline using the current color.","private":false,"library":"render","description":"\nDraws a rectangle outline using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"getTextSize":{"ret":["width of the text","height of the text"],"comment":["--- Gets the size of the specified text. Don't forget to use setFont before calling this function","-- @param text Text to get the size of","-- @return width of the text","-- @return height of the text"],"code":["function render_library.getTextSize( text )","\tSF.CheckType(text,\"string\")","\t","\tsurface.SetFont(SF.instance.data.render.font or defaultFont)","\treturn surface.GetTextSize( text )","end",""],"class":"function","name":"render_library.getTextSize","summary":"\nGets the size of the specified text.","private":false,"library":"render","description":"\nGets the size of the specified text. Don't forget to use setFont before calling this function","param":{"1":"text","text":"Text to get the size of"}},"getDefaultFont":{"ret":"Default font","comment":["--- Gets the default font","-- @return Default font"],"code":["function render_library.getDefaultFont()","\treturn defaultFont","end",""],"class":"function","name":"render_library.getDefaultFont","summary":"\nGets the default font ","private":false,"library":"render","description":"\nGets the default font","param":[]},"popMatrix":{"comment":["--- Pops a matrix from the matrix stack."],"code":["function render_library.popMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif #matrix_stack <= 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tmatrix_stack[#matrix_stack] = nil","\tcam.PopModelMatrix()","end",""],"class":"function","name":"render_library.popMatrix","summary":"\nPops a matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a matrix from the matrix stack.","param":[]},"setTexture":{"comment":["--- Sets the texture","-- @param id Texture id or url to an online image."],"code":["function render_library.setTexture ( id )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif id and texturecache[ id ] then","\t\tsurface.SetMaterial( texturecache[ id ] )","\t\treturn","\tend","","\tdraw.NoTexture()","end",""],"class":"function","name":"render_library.setTexture","summary":"\nSets the texture ","private":false,"library":"render","description":"\nSets the texture","param":{"1":"id","id":"Texture id or url to an online image."}},"drawText":{"comment":["--- Draws text.","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param alignment Text alignment"],"code":["function render_library.drawText ( x, y, text, alignment )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif alignment then","\t\tSF.CheckType( alignment, \"number\" )","\tend","\t","\tlocal font = SF.instance.data.render.font or defaultFont","\t","\tdraw.DrawText( text, font, x, y, currentcolor, alignment or TEXT_ALIGN_LEFT )","end",""],"class":"function","name":"render_library.drawText","summary":"\nDraws text.","private":false,"library":"render","description":"\nDraws text.","param":{"1":"x","2":"y","3":"text","4":"alignment","y":"Y coordinate","x":"X coordinate","alignment":"Text alignment","text":"Text to draw"}},"setColor":{"comment":["--- Sets the draw color","-- @param clr Color type"],"code":["function render_library.setColor ( clr )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\tcurrentcolor = clr","\tsurface.SetDrawColor( clr )","\tsurface.SetTextColor( clr )","end",""],"class":"function","name":"render_library.setColor","summary":"\nSets the draw color ","private":false,"library":"render","description":"\nSets the draw color","param":{"1":"clr","clr":"Color type"}}},"class":"library","summary":"\nRender library.","code":["","local render_library, _ = SF.Libraries.RegisterLocal(\"render\")","","render_library.TEXT_ALIGN_LEFT = TEXT_ALIGN_LEFT","render_library.TEXT_ALIGN_CENTER = TEXT_ALIGN_CENTER","render_library.TEXT_ALIGN_RIGHT = TEXT_ALIGN_RIGHT","render_library.TEXT_ALIGN_TOP = TEXT_ALIGN_TOP","render_library.TEXT_ALIGN_BOTTOM = TEXT_ALIGN_BOTTOM",""],"fields":[],"name":"render","description":"\nRender library. Screens are 512x512 units. Most functions require \nthat you be in the rendering hook to call, otherwise an error is \nthrown. +x is right, +y is down","entity":"starfall_screen","libtbl":"render_library","tables":[],"field":{"1":"TEXT_ALIGN_LEFT","2":"TEXT_ALIGN_CENTER","3":"TEXT_ALIGN_RIGHT","4":"TEXT_ALIGN_TOP","5":"TEXT_ALIGN_BOTTOM","TEXT_ALIGN_CENTER":"","TEXT_ALIGN_TOP":"","TEXT_ALIGN_BOTTOM":"","TEXT_ALIGN_LEFT":"","TEXT_ALIGN_RIGHT":""}}},"type":"file","name":"libs_cl/render.lua","functions":{"1":"render_library.capturePixels","2":"render_library.clear","3":"render_library.createFont","4":"render_library.createPoly","5":"render_library.createRenderTarget","6":"render_library.cursorPos","7":"render_library.drawCircle","8":"render_library.drawLine","9":"render_library.drawPoly","10":"render_library.drawRect","11":"render_library.drawRectOutline","12":"render_library.drawText","13":"render_library.drawTexturedRect","14":"render_library.drawTexturedRectRotated","15":"render_library.drawTexturedRectUV","16":"render_library.getDefaultFont","17":"render_library.getScreenInfo","18":"render_library.getScreenPos","19":"render_library.getTextSize","20":"render_library.getTextureID","21":"render_library.popMatrix","22":"render_library.pushMatrix","23":"render_library.readPixel","24":"render_library.selectRenderTarget","25":"render_library.setColor","26":"render_library.setFont","27":"render_library.setRenderTargetTexture","28":"render_library.setTexture","render_library.createFont":{"comment":["--- Creates a font. Does not require rendering hook","-- @param font Base font to use","-- @param size Font size","-- @param weight Font weight (default: 400)","-- @param antialias Antialias font?","-- @param additive If true, adds brightness to pixels behind it rather than drawing over them.","-- @param shadow Enable drop shadow?","-- @param outline Enable outline?","-- @param blue Enable blur?","-- @usage","-- Base font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall):","-- \\- DebugFixed","-- \\- DebugFixedSmall","-- \\- DefaultFixedOutline","-- \\- MenuItem","-- \\- Default","-- \\- TabLarge","-- \\- DefaultBold","-- \\- DefaultUnderline","-- \\- DefaultSmall","-- \\- DefaultSmallDropShadow","-- \\- DefaultVerySmall","-- \\- DefaultLarge","-- \\- UiBold","-- \\- MenuLarge","-- \\- ConsoleText","-- \\- Marlett","-- \\- Trebuchet18","-- \\- Trebuchet19","-- \\- Trebuchet20","-- \\- Trebuchet22","-- \\- Trebuchet24","-- \\- HUDNumber","-- \\- HUDNumber1","-- \\- HUDNumber2","-- \\- HUDNumber3","-- \\- HUDNumber4","-- \\- HUDNumber5","-- \\- HudHintTextLarge","-- \\- HudHintTextSmall","-- \\- CenterPrintText","-- \\- HudSelectionText","-- \\- DefaultFixed","-- \\- DefaultFixedDropShadow","-- \\- CloseCaption_Normal","-- \\- CloseCaption_Bold","-- \\- CloseCaption_BoldItalic","-- \\- TitleFont","-- \\- TitleFont2","-- \\- ChatFont","-- \\- TargetID","-- \\- TargetIDSmall","-- \\- HL2MPTypeDeath","-- \\- BudgetLabel","-- \\- DejaVu Sans Mono (shipped, monospaced)"],"code":["function render_library.createFont(font,size,weight,antialias,additive,shadow,outline,blur)","\tif not validfonts[font] then SF.throw( \"invalid font\", 2 ) end","\t","\tsize = tonumber(size) or 16","\tweight = tonumber(weight) or 400","\tblur = tonumber(blur) or 0","\tantialias = antialias and true or false","\tadditive = additive and true or false","\tshadow = shadow and true or false","\toutline = outline and true or false","\t","\tlocal name = string.format(\"sf_screen_font_%s_%d_%d_%d_%d%d%d%d\",","\t\tfont, size, weight, blur,","\t\tantialias and 1 or 0,","\t\tadditive and 1 or 0,","\t\tshadow and 1 or 0,","\t\toutline and 1 or 0)","\t","\tif not defined_fonts[name] then","\t\tsurface.CreateFont(name, {size = size, weight = weight,","\t\t\tantialias=antialias, additive = additive, font = font,","\t\t\tshadow = shadow, outline = outline, blur = blur})","\t\tdefined_fonts[name] = true","\tend","\treturn name","end",""],"class":"function","summary":"\nCreates a font.","name":"render_library.createFont","library":"render","private":false,"usage":"\nBase font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall): \n- DebugFixed \n- DebugFixedSmall \n- DefaultFixedOutline \n- MenuItem \n- Default \n- TabLarge \n- DefaultBold \n- DefaultUnderline \n- DefaultSmall \n- DefaultSmallDropShadow \n- DefaultVerySmall \n- DefaultLarge \n- UiBold \n- MenuLarge \n- ConsoleText \n- Marlett \n- Trebuchet18 \n- Trebuchet19 \n- Trebuchet20 \n- Trebuchet22 \n- Trebuchet24 \n- HUDNumber \n- HUDNumber1 \n- HUDNumber2 \n- HUDNumber3 \n- HUDNumber4 \n- HUDNumber5 \n- HudHintTextLarge \n- HudHintTextSmall \n- CenterPrintText \n- HudSelectionText \n- DefaultFixed \n- DefaultFixedDropShadow \n- CloseCaption_Normal \n- CloseCaption_Bold \n- CloseCaption_BoldItalic \n- TitleFont \n- TitleFont2 \n- ChatFont \n- TargetID \n- TargetIDSmall \n- HL2MPTypeDeath \n- BudgetLabel \n- DejaVu Sans Mono (shipped, monospaced)","description":"\nCreates a font. Does not require rendering hook","param":{"1":"font","2":"size","3":"weight","4":"antialias","5":"additive","6":"shadow","7":"outline","8":"blur","9":"blue","outline":"Enable outline?","shadow":"Enable drop shadow?","blue":"Enable blur?","weight":"Font weight (default: 400)","font":"Base font to use","additive":"If true, adds brightness to pixels behind it rather than drawing over them.","antialias":"Antialias font?","size":"Font size"}},"render_library.drawRect":{"comment":["--- Draws a rectangle using the current color. ","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRect","summary":"\nDraws a rectangle using the current color.","private":false,"library":"render","description":"\nDraws a rectangle using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"render_library.drawTexturedRectUV":{"comment":["--- Draws a textured rectangle with UV coordinates","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param startU Texture mapping at rectangle origin","-- @param startV Texture mapping at rectangle origin","-- @param endV Texture mapping at rectangle end","-- @param endV Texture mapping at rectangle end"],"code":["function render_library.drawTexturedRectUV ( x, y, w, h, startU, startV, endU, endV )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( startU, \"number\" )","\tSF.CheckType( startV, \"number\" )","\tSF.CheckType( endU, \"number\" )","\tSF.CheckType( endV, \"number\" )","\tsurface.DrawTexturedRectUV( x, y, w, h, startU, startV, endU, endV )","end",""],"class":"function","name":"render_library.drawTexturedRectUV","summary":"\nDraws a textured rectangle with UV coordinates ","private":false,"library":"render","description":"\nDraws a textured rectangle with UV coordinates","param":{"1":"x","2":"y","3":"w","4":"h","5":"startU","6":"startV","7":"endU","8":"endV","y":"Top left corner y coordinate","h":"Height","endV":"Texture mapping at rectangle end","startU":"Texture mapping at rectangle origin","startV":"Texture mapping at rectangle origin","w":"Width","x":"Top left corner x coordinate"}},"render_library.readPixel":{"ret":"Color object with ( r, g, b, 255 ) from the specified pixel.","comment":["--- Reads the color of the specified pixel.","-- @param x Pixel x-coordinate.","-- @param y Pixel y-coordinate.","-- @return Color object with ( r, g, b, 255 ) from the specified pixel."],"code":["function render_library.readPixel ( x, y )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\t","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","","\tlocal r, g, b = render.ReadPixel( x, y )","\treturn SF.Color.Wrap( Color( r, g, b, 255 ) )","end",""],"class":"function","name":"render_library.readPixel","summary":"\nReads the color of the specified pixel.","private":false,"library":"render","description":"\nReads the color of the specified pixel.","param":{"1":"x","2":"y","y":"Pixel y-coordinate.","x":"Pixel x-coordinate."}},"render_library.getTextureID":{"comment":["--- Looks up a texture by file name. Use with render.setTexture to draw with it.","--- Make sure to store the texture to use it rather than calling this slow function repeatedly.","-- @param tx Texture file path, or a http url"],"code":["function render_library.getTextureID ( tx )","","\tif tx:sub(1,4)==\"http\" then","\t\ttx = string.gsub( tx, \"[^%w _~%.%-/:]\", function( str )","\t\t\treturn string.format( \"%%%02X\", string.byte( str ) )","\t\tend )","\t\t","\t\tlocal tbl = {}","\t\ttexturecache[ tbl ] = LoadURLMaterial( tx )","\t\treturn tbl","\telse","\t\tlocal id = surface.GetTextureID( tx )","\t\tif id then","\t\t\tlocal mat = Material( tx ) -- Hacky way to get ITexture, if there is a better way - do it!","\t\t\tlocal cacheentry = CreateMaterial( \"SF_TEXTURE_\" .. id, \"UnlitGeneric\", {","\t\t\t\t[ \"$nolod\" ] = 1,","\t\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t\t[ \"$vertexalpha\" ] = 1","\t\t\t} )","\t\t\tcacheentry:SetTexture( \"$basetexture\", mat:GetTexture( \"$basetexture\" ) )","\t\t\t","\t\t\tlocal tbl = {}","\t\t\ttexturecache[ tbl ] = cacheentry","\t\t\treturn tbl","\t\tend","\tend","\t","end",""],"class":"function","name":"render_library.getTextureID","summary":"\nLooks up a texture by file name.","private":false,"library":"render","description":"\nLooks up a texture by file name. Use with render.setTexture to draw with it. \nMake sure to store the texture to use it rather than calling this slow function repeatedly.","param":{"1":"tx","tx":"Texture file path, or a http url"}},"render_library.drawRectOutline":{"comment":["--- Draws a rectangle outline using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRectOutline ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawOutlinedRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRectOutline","summary":"\nDraws a rectangle outline using the current color.","private":false,"library":"render","description":"\nDraws a rectangle outline using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"render_library.capturePixels":{"comment":["--- Dumps the current render target and allows the pixels to be accessed by render.readPixel."],"code":["function render_library.capturePixels ()","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\trender.CapturePixels()","end",""],"class":"function","name":"render_library.capturePixels","summary":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","private":false,"library":"render","description":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","param":[]},"render_library.pushMatrix":{"comment":["--- Pushes a matrix onto the matrix stack.","-- @param m The matrix"],"code":["function render_library.pushMatrix(m)","\tSF.CheckType(m,matrix_meta)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tlocal id = #matrix_stack","\tif id + 1 > MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tlocal newmatrix","\tif matrix_stack[id] then","\t\tnewmatrix = matrix_stack[id] * v_unwrap(m)","\telse","\t\tnewmatrix = v_unwrap(m)","\tend","\tmatrix_stack[id+1] = newmatrix","\tcam.PushModelMatrix(newmatrix)","end",""],"class":"function","name":"render_library.pushMatrix","summary":"\nPushes a matrix onto the matrix stack.","private":false,"library":"render","description":"\nPushes a matrix onto the matrix stack.","param":{"1":"m","m":"The matrix"}},"render_library.setRenderTargetTexture":{"comment":["--- Sets the active texture to the render target with the specified name.","-- Nil to reset.","-- @param name Name of the render target to use"],"code":["function render_library.setRenderTargetTexture ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif not name then","\t\tdraw.NoTexture()","\telse","\t\tSF.CheckType( name, \"string\" )","\t\tlocal rtname = data.rendertargets[ name ]","\t\tlocal rt = globalRTs[ rtname ][ 1 ]","\t\tlocal mat = globalRTs[ rtname ][ 2 ] or CreateMaterial( rtname, \"UnlitGeneric\", {","\t\t\t[ \"$nolod\" ] = 1,","\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t[ \"$vertexalpha\" ] = 1","\t\t} )","\t\tmat:SetTexture( \"$basetexture\", rt )","\t\tsurface.SetMaterial( mat )","\tend","end",""],"class":"function","name":"render_library.setRenderTargetTexture","summary":"\nSets the active texture to the render target with the specified name.","private":false,"library":"render","description":"\nSets the active texture to the render target with the specified name. \nNil to reset.","param":{"1":"name","name":"Name of the render target to use"}},"render_library.drawPoly":{"comment":["--- Draws a polygon. Takes a compiled/uncompiled poly to draw.","-- Note that if you do use an uncompiled poly, you will use up ops","-- very quickly!","-- @param poly Compiled poly or array of vertexes"],"code":["function render_library.drawPoly(poly)","\tif dgetmeta(poly) ~= poly_metamethods then","\t\tSF.CheckType(poly,\"table\")","\t\tlocal verts = poly","\t\tpoly = {}","\t\tfor i=1,#verts do","\t\t\tlocal v = verts[i]","\t\t\tSF.CheckType(v,\"table\")","\t\t\tpoly[i] = checkvertex(v)","\t\tend","\telse","\t\tpoly = unwrappoly(poly)","\tend","\tsurface.DrawPoly(poly)","end",""],"class":"function","name":"render_library.drawPoly","summary":"\nDraws a polygon.","private":false,"library":"render","description":"\nDraws a polygon. Takes a compiled/uncompiled poly to draw. \nNote that if you do use an uncompiled poly, you will use up ops \nvery quickly!","param":{"1":"poly","poly":"Compiled poly or array of vertexes"}},"render_library.setTexture":{"comment":["--- Sets the texture","-- @param id Texture id or url to an online image."],"code":["function render_library.setTexture ( id )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif id and texturecache[ id ] then","\t\tsurface.SetMaterial( texturecache[ id ] )","\t\treturn","\tend","","\tdraw.NoTexture()","end",""],"class":"function","name":"render_library.setTexture","summary":"\nSets the texture ","private":false,"library":"render","description":"\nSets the texture","param":{"1":"id","id":"Texture id or url to an online image."}},"render_library.drawTexturedRectRotated":{"comment":["--- Draws a rotated, textured rectangle.","-- @param x X coordinate of center of rect","-- @param y Y coordinate of center of rect","-- @param w Width","-- @param h Height","-- @param rot Rotation in degrees"],"code":["function render_library.drawTexturedRectRotated ( x, y, w, h, rot )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( rot, \"number\" )","","\tsurface.DrawTexturedRectRotated( x, y, w, h, rot )","end",""],"class":"function","name":"render_library.drawTexturedRectRotated","summary":"\nDraws a rotated, textured rectangle.","private":false,"library":"render","description":"\nDraws a rotated, textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","5":"rot","y":"Y coordinate of center of rect","h":"Height","rot":"Rotation in degrees","w":"Width","x":"X coordinate of center of rect"}},"render_library.getScreenInfo":{"ret":"A table describing the screen.","comment":["--- Returns information about the screen, such as dimentions and rotation.","-- Note: this does a table copy so move it out of your draw hook","-- @return A table describing the screen."],"code":["function render_library.getScreenInfo()","\tlocal gpu = SF.instance.data.render.gpu","\tif not gpu then return end","\tlocal info, _, _ = gpu:GetInfo()","\treturn table.Copy(info)","end",""],"class":"function","name":"render_library.getScreenInfo","summary":"\nReturns information about the screen, such as dimentions and rotation.","private":false,"library":"render","description":"\nReturns information about the screen, such as dimentions and rotation. \nNote: this does a table copy so move it out of your draw hook","param":[]},"render_library.createRenderTarget":{"comment":["--- Creates a new render target to draw onto.","-- The dimensions will always be 1024x1024","-- @param name The name of the render target","-- @bug The drawing will be offset by 16 pixels to the left and 16 to the top and the resolution is actually 992x992. So drawing to 16,16 will draw in the top-left corner and 1007,1007 to the bottom-right."],"code":["function render_library.createRenderTarget ( name )","\tSF.CheckType( name, \"string\" )","","\tlocal data = SF.instance.data.render","\tdata.rendertargets = data.rendertargets or {}","\tdata.rendertargetcount = data.rendertargetcount or 0","","\tif data.rendertargetcount >= 2 then","\t\tSF.throw( \"Rendertarget limit reached\", 2 )","\tend","","\tdata.rendertargetcount = data.rendertargetcount + 1","\tlocal rtname, rt = findAvailableRT()","\tif not rt then","\t\tglobalRTcount = globalRTcount + 1","\t\trtname = \"Starfall_CustomRT_\" .. globalRTcount","\t\trt = { GetRenderTarget( rtname, 1024, 1024, false ) }","\t\tglobalRTs[ rtname ] = rt","\tend","\trt[ 2 ] = false","\tdata.rendertargets[ name ] = rtname","end",""],"class":"function","bug":"The drawing will be offset by 16 pixels to the left and 16 to the top and the resolution is actually 992x992. So drawing to 16,16 will draw in the top-left corner and 1007,1007 to the bottom-right.","name":"render_library.createRenderTarget","summary":"\nCreates a new render target to draw onto.","private":false,"library":"render","description":"\nCreates a new render target to draw onto. \nThe dimensions will always be 1024x1024","param":{"1":"name","name":"The name of the render target"}},"render_library.getScreenPos":{"ret":["The screen position","The screen angle"],"comment":["--- Returns the screen surface's world position and angle","-- @return The screen position","-- @return The screen angle"],"code":["function render_library.getScreenPos()","\tlocal gpu = SF.instance.data.render.gpu","\tif not gpu then return end","\tlocal _, pos, rot = gpu:GetInfo()","\treturn SF.WrapObject( pos ), SF.WrapObject( rot )","end","","local function findAvailableRT ()","\tfor k, v in pairs( globalRTs ) do","\t\tif v[ 2 ] then","\t\t\treturn k, v","\t\tend","\tend","\treturn nil","end",""],"class":"function","name":"render_library.getScreenPos","summary":"\nReturns the screen surface's world position and angle ","private":false,"library":"render","description":"\nReturns the screen surface's world position and angle","param":[]},"render_library.drawLine":{"comment":["--- Draws a line","-- @param x1 X start coordinate","-- @param y1 Y start coordinate","-- @param x2 X end coordinate","-- @param y2 Y end coordinate"],"code":["function render_library.drawLine ( x1, y1, x2, y2 )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x1, \"number\" )","\tSF.CheckType( y1, \"number\" )","\tSF.CheckType( x2, \"number\" )","\tSF.CheckType( y2, \"number\" )","\tsurface.DrawLine( x1, y1, x2, y2 )","end",""],"class":"function","name":"render_library.drawLine","summary":"\nDraws a line ","private":false,"library":"render","description":"\nDraws a line","param":{"1":"x1","2":"y1","3":"x2","4":"y2","x2":"X end coordinate","y2":"Y end coordinate","y1":"Y start coordinate","x1":"X start coordinate"}},"render_library.selectRenderTarget":{"comment":["--- Selects the render target to draw on.","-- Nil for the visible RT.","-- @param name Name of the render target to use"],"code":["function render_library.selectRenderTarget ( name )","\tlocal data = SF.instance.data.render","\tdata.oldRT = data.oldRT or render.GetRenderTarget()","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif not name then","\t\tif data.usingRT then","\t\t\tcam.End2D()","\t\t\trender.PopRenderTarget()","\t\t\tcam.Start2D()","\t\t\tdata.usingRT = false","\t\tend","\t\treturn","\tend","\tSF.CheckType( name, \"string\" )","\tlocal rt = globalRTs[ data.rendertargets[ name ] ][ 1 ]","\tif not rt then SF.Throw( \"Invalid Rendertarget\", 2 ) end","","\tcam.End2D()","\tif data.usingRT then","\t\trender.PopRenderTarget()","\tend","\trender.PushRenderTarget( rt, 0, 0, rt:Width(), rt:Height() )","\tcam.Start2D()","\tdata.usingRT = true","end",""],"class":"function","name":"render_library.selectRenderTarget","summary":"\nSelects the render target to draw on.","private":false,"library":"render","description":"\nSelects the render target to draw on. \nNil for the visible RT.","param":{"1":"name","name":"Name of the render target to use"}},"render_library.createPoly":{"ret":"compiled polygon","comment":["--- Compiles a 2D poly. This is needed so that poly don't have to be","-- type-checked each frame. Polys can be indexed by a number, in which","-- a copy of the vertex at that spot is returned. They can also be assigned","-- a new vertex at 1 <= i <= #poly+1. And the length of the poly can be taken.","-- @param verts Array of verticies to convert.","-- @return compiled polygon"],"code":["function render_library.createPoly(verts)","\tSF.CheckType(verts,\"table\")","\tlocal poly = {}","\tlocal wrappedpoly = wrappoly(poly)","\tfor i=1,#verts do","\t\tlocal v = verts[i]","\t\tSF.CheckType(v,\"table\")","\t\tpoly[i] = checkvertex(v)","\tend","\treturn wrappedpoly","end",""],"class":"function","name":"render_library.createPoly","summary":"\nCompiles a 2D poly.","private":false,"library":"render","description":"\nCompiles a 2D poly. This is needed so that poly don't have to be \ntype-checked each frame. Polys can be indexed by a number, in which \na copy of the vertex at that spot is returned. They can also be assigned \na new vertex at 1 <= i <= #poly+1. And the length of the poly can be taken.","param":{"1":"verts","verts":"Array of verticies to convert."}},"render_library.drawText":{"comment":["--- Draws text.","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param alignment Text alignment"],"code":["function render_library.drawText ( x, y, text, alignment )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif alignment then","\t\tSF.CheckType( alignment, \"number\" )","\tend","\t","\tlocal font = SF.instance.data.render.font or defaultFont","\t","\tdraw.DrawText( text, font, x, y, currentcolor, alignment or TEXT_ALIGN_LEFT )","end",""],"class":"function","name":"render_library.drawText","summary":"\nDraws text.","private":false,"library":"render","description":"\nDraws text.","param":{"1":"x","2":"y","3":"text","4":"alignment","y":"Y coordinate","x":"X coordinate","alignment":"Text alignment","text":"Text to draw"}},"render_library.cursorPos":{"ret":["x position","y position"],"comment":["--- Gets a 2D cursor position where ply is aiming.","-- @param ply player to get cursor position from","-- @return x position","-- @return y position"],"code":["function render_library.cursorPos( ply )","\t-- Taken from EGPLib","\tlocal Normal, Pos, monitor, Ang","\tlocal screen = SF.instance.data.render.renderEnt","\tif not screen then return nil end","\t","\tply = SF.Entities.Unwrap( ply )","\tif not ply then SF.throw(\"Invalid Player\", 2) end","\t","\t-- Get monitor screen pos & size","\tmonitor = WireGPU_Monitors[ screen:GetModel() ]","\t\t","\t-- Monitor does not have a valid screen point","\tif not monitor then return nil end","\t\t","\tAng = screen:LocalToWorldAngles( monitor.rot )","\tPos = screen:LocalToWorld( monitor.offset )","\t\t","\tNormal = Ang:Up()","\t","\tlocal Start = ply:GetShootPos()","\tlocal Dir = ply:GetAimVector()","\t","\tlocal A = Normal:Dot(Dir)","\t","\t-- If ray is parallel or behind the screen","\tif A == 0 or A > 0 then return nil end","\t","\tlocal B = Normal:Dot(Pos-Start) / A","\t\tif (B >= 0) then","\t\tlocal HitPos = WorldToLocal( Start + Dir * B, Angle(), Pos, Ang )","\t\tlocal x = (0.5+HitPos.x/(monitor.RS*512/monitor.RatioX)) * 512","\t\tlocal y = (0.5-HitPos.y/(monitor.RS*512)) * 512\t","\t\tif x < 0 or x > 512 or y < 0 or y > 512 then return nil end -- Aiming off the screen ","\t\treturn x, y","\tend","\t","\treturn nil","end",""],"class":"function","name":"render_library.cursorPos","summary":"\nGets a 2D cursor position where ply is aiming.","private":false,"library":"render","description":"\nGets a 2D cursor position where ply is aiming.","param":{"1":"ply","ply":"player to get cursor position from"}},"render_library.popMatrix":{"comment":["--- Pops a matrix from the matrix stack."],"code":["function render_library.popMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif #matrix_stack <= 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tmatrix_stack[#matrix_stack] = nil","\tcam.PopModelMatrix()","end",""],"class":"function","name":"render_library.popMatrix","summary":"\nPops a matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a matrix from the matrix stack.","param":[]},"render_library.setFont":{"comment":["--- Sets the font","-- @param font The font to use"],"code":["function render_library.setFont(font)","\tif not defined_fonts[font] then SF.throw( \"Font does not exist.\", 2 ) end","\tSF.instance.data.render.font = font","\t--surface.SetFont(font)","end",""],"class":"function","name":"render_library.setFont","summary":"\nSets the font ","private":false,"library":"render","description":"\nSets the font","param":{"1":"font","font":"The font to use"}},"render_library.getDefaultFont":{"ret":"Default font","comment":["--- Gets the default font","-- @return Default font"],"code":["function render_library.getDefaultFont()","\treturn defaultFont","end",""],"class":"function","name":"render_library.getDefaultFont","summary":"\nGets the default font ","private":false,"library":"render","description":"\nGets the default font","param":[]},"render_library.drawTexturedRect":{"comment":["--- Draws a textured rectangle.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawTexturedRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawTexturedRect ( x, y, w, h )","end",""],"class":"function","name":"render_library.drawTexturedRect","summary":"\nDraws a textured rectangle.","private":false,"library":"render","description":"\nDraws a textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"render_library.setColor":{"comment":["--- Sets the draw color","-- @param clr Color type"],"code":["function render_library.setColor ( clr )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\tcurrentcolor = clr","\tsurface.SetDrawColor( clr )","\tsurface.SetTextColor( clr )","end",""],"class":"function","name":"render_library.setColor","summary":"\nSets the draw color ","private":false,"library":"render","description":"\nSets the draw color","param":{"1":"clr","clr":"Color type"}},"render_library.drawCircle":{"comment":["--- Draws a circle outline","-- @param x Center x coordinate","-- @param y Center y coordinate","-- @param r Radius"],"code":["function render_library.drawCircle ( x, y, r )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( r, \"number\" )","\tsurface.DrawCircle( x, y, r, currentcolor )","end",""],"class":"function","name":"render_library.drawCircle","summary":"\nDraws a circle outline ","private":false,"library":"render","description":"\nDraws a circle outline","param":{"1":"x","2":"y","3":"r","y":"Center y coordinate","x":"Center x coordinate","r":"Radius"}},"render_library.getTextSize":{"ret":["width of the text","height of the text"],"comment":["--- Gets the size of the specified text. Don't forget to use setFont before calling this function","-- @param text Text to get the size of","-- @return width of the text","-- @return height of the text"],"code":["function render_library.getTextSize( text )","\tSF.CheckType(text,\"string\")","\t","\tsurface.SetFont(SF.instance.data.render.font or defaultFont)","\treturn surface.GetTextSize( text )","end",""],"class":"function","name":"render_library.getTextSize","summary":"\nGets the size of the specified text.","private":false,"library":"render","description":"\nGets the size of the specified text. Don't forget to use setFont before calling this function","param":{"1":"text","text":"Text to get the size of"}},"render_library.clear":{"comment":["--- Clears the surface","-- @param clr Color type to clear with"],"code":["function render_library.clear ( clr )","    if clr == nil then","        if not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","        render.Clear( 0, 0, 0, 255 )","    else","        SF.CheckType( clr, SF.Types[ \"Color\" ] )","        if not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","        render.Clear( clr.r, clr.g, clr.b, clr.a )","    end","end",""],"class":"function","name":"render_library.clear","summary":"\nClears the surface ","private":false,"library":"render","description":"\nClears the surface","param":{"1":"clr","clr":"Color type to clear with"}}},"doc":[{"summary":"\n \nRender library \n ","description":"\n \nRender library \n","comment":["-------------------------------------------------------------------------------","-- Render library","-------------------------------------------------------------------------------"],"code":[""]},{"description":"\nCalled when a frame is requested to be drawn. You may want to unhook from this if you don't need \nto render anything for a bit","code":[""],"class":"hook","classForced":true,"name":"render","summary":"\nCalled when a frame is requested to be drawn.","client":true,"comment":["--- Called when a frame is requested to be drawn. You may want to unhook from this if you don't need","-- to render anything for a bit","-- @name render","-- @class hook","-- @client"],"param":[]},{"comment":["--- Render library. Screens are 512x512 units. Most functions require","-- that you be in the rendering hook to call, otherwise an error is","-- thrown. +x is right, +y is down","-- @entity starfall_screen","-- @field TEXT_ALIGN_LEFT","-- @field TEXT_ALIGN_CENTER","-- @field TEXT_ALIGN_RIGHT","-- @field TEXT_ALIGN_TOP","-- @field TEXT_ALIGN_BOTTOM"],"functions":{"1":"capturePixels","2":"clear","3":"createFont","4":"createPoly","5":"createRenderTarget","6":"cursorPos","7":"drawCircle","8":"drawLine","9":"drawPoly","10":"drawRect","11":"drawRectOutline","12":"drawText","13":"drawTexturedRect","14":"drawTexturedRectRotated","15":"drawTexturedRectUV","16":"getDefaultFont","17":"getScreenInfo","18":"getScreenPos","19":"getTextSize","20":"getTextureID","21":"popMatrix","22":"pushMatrix","23":"readPixel","24":"selectRenderTarget","25":"setColor","26":"setFont","27":"setRenderTargetTexture","28":"setTexture","drawTexturedRectUV":{"comment":["--- Draws a textured rectangle with UV coordinates","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param startU Texture mapping at rectangle origin","-- @param startV Texture mapping at rectangle origin","-- @param endV Texture mapping at rectangle end","-- @param endV Texture mapping at rectangle end"],"code":["function render_library.drawTexturedRectUV ( x, y, w, h, startU, startV, endU, endV )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( startU, \"number\" )","\tSF.CheckType( startV, \"number\" )","\tSF.CheckType( endU, \"number\" )","\tSF.CheckType( endV, \"number\" )","\tsurface.DrawTexturedRectUV( x, y, w, h, startU, startV, endU, endV )","end",""],"class":"function","name":"render_library.drawTexturedRectUV","summary":"\nDraws a textured rectangle with UV coordinates ","private":false,"library":"render","description":"\nDraws a textured rectangle with UV coordinates","param":{"1":"x","2":"y","3":"w","4":"h","5":"startU","6":"startV","7":"endU","8":"endV","y":"Top left corner y coordinate","h":"Height","endV":"Texture mapping at rectangle end","startU":"Texture mapping at rectangle origin","startV":"Texture mapping at rectangle origin","w":"Width","x":"Top left corner x coordinate"}},"drawTexturedRect":{"comment":["--- Draws a textured rectangle.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawTexturedRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawTexturedRect ( x, y, w, h )","end",""],"class":"function","name":"render_library.drawTexturedRect","summary":"\nDraws a textured rectangle.","private":false,"library":"render","description":"\nDraws a textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"drawRect":{"comment":["--- Draws a rectangle using the current color. ","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRect","summary":"\nDraws a rectangle using the current color.","private":false,"library":"render","description":"\nDraws a rectangle using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"drawCircle":{"comment":["--- Draws a circle outline","-- @param x Center x coordinate","-- @param y Center y coordinate","-- @param r Radius"],"code":["function render_library.drawCircle ( x, y, r )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( r, \"number\" )","\tsurface.DrawCircle( x, y, r, currentcolor )","end",""],"class":"function","name":"render_library.drawCircle","summary":"\nDraws a circle outline ","private":false,"library":"render","description":"\nDraws a circle outline","param":{"1":"x","2":"y","3":"r","y":"Center y coordinate","x":"Center x coordinate","r":"Radius"}},"readPixel":{"ret":"Color object with ( r, g, b, 255 ) from the specified pixel.","comment":["--- Reads the color of the specified pixel.","-- @param x Pixel x-coordinate.","-- @param y Pixel y-coordinate.","-- @return Color object with ( r, g, b, 255 ) from the specified pixel."],"code":["function render_library.readPixel ( x, y )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\t","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","","\tlocal r, g, b = render.ReadPixel( x, y )","\treturn SF.Color.Wrap( Color( r, g, b, 255 ) )","end",""],"class":"function","name":"render_library.readPixel","summary":"\nReads the color of the specified pixel.","private":false,"library":"render","description":"\nReads the color of the specified pixel.","param":{"1":"x","2":"y","y":"Pixel y-coordinate.","x":"Pixel x-coordinate."}},"pushMatrix":{"comment":["--- Pushes a matrix onto the matrix stack.","-- @param m The matrix"],"code":["function render_library.pushMatrix(m)","\tSF.CheckType(m,matrix_meta)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tlocal id = #matrix_stack","\tif id + 1 > MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tlocal newmatrix","\tif matrix_stack[id] then","\t\tnewmatrix = matrix_stack[id] * v_unwrap(m)","\telse","\t\tnewmatrix = v_unwrap(m)","\tend","\tmatrix_stack[id+1] = newmatrix","\tcam.PushModelMatrix(newmatrix)","end",""],"class":"function","name":"render_library.pushMatrix","summary":"\nPushes a matrix onto the matrix stack.","private":false,"library":"render","description":"\nPushes a matrix onto the matrix stack.","param":{"1":"m","m":"The matrix"}},"getScreenPos":{"ret":["The screen position","The screen angle"],"comment":["--- Returns the screen surface's world position and angle","-- @return The screen position","-- @return The screen angle"],"code":["function render_library.getScreenPos()","\tlocal gpu = SF.instance.data.render.gpu","\tif not gpu then return end","\tlocal _, pos, rot = gpu:GetInfo()","\treturn SF.WrapObject( pos ), SF.WrapObject( rot )","end","","local function findAvailableRT ()","\tfor k, v in pairs( globalRTs ) do","\t\tif v[ 2 ] then","\t\t\treturn k, v","\t\tend","\tend","\treturn nil","end",""],"class":"function","name":"render_library.getScreenPos","summary":"\nReturns the screen surface's world position and angle ","private":false,"library":"render","description":"\nReturns the screen surface's world position and angle","param":[]},"createFont":{"comment":["--- Creates a font. Does not require rendering hook","-- @param font Base font to use","-- @param size Font size","-- @param weight Font weight (default: 400)","-- @param antialias Antialias font?","-- @param additive If true, adds brightness to pixels behind it rather than drawing over them.","-- @param shadow Enable drop shadow?","-- @param outline Enable outline?","-- @param blue Enable blur?","-- @usage","-- Base font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall):","-- \\- DebugFixed","-- \\- DebugFixedSmall","-- \\- DefaultFixedOutline","-- \\- MenuItem","-- \\- Default","-- \\- TabLarge","-- \\- DefaultBold","-- \\- DefaultUnderline","-- \\- DefaultSmall","-- \\- DefaultSmallDropShadow","-- \\- DefaultVerySmall","-- \\- DefaultLarge","-- \\- UiBold","-- \\- MenuLarge","-- \\- ConsoleText","-- \\- Marlett","-- \\- Trebuchet18","-- \\- Trebuchet19","-- \\- Trebuchet20","-- \\- Trebuchet22","-- \\- Trebuchet24","-- \\- HUDNumber","-- \\- HUDNumber1","-- \\- HUDNumber2","-- \\- HUDNumber3","-- \\- HUDNumber4","-- \\- HUDNumber5","-- \\- HudHintTextLarge","-- \\- HudHintTextSmall","-- \\- CenterPrintText","-- \\- HudSelectionText","-- \\- DefaultFixed","-- \\- DefaultFixedDropShadow","-- \\- CloseCaption_Normal","-- \\- CloseCaption_Bold","-- \\- CloseCaption_BoldItalic","-- \\- TitleFont","-- \\- TitleFont2","-- \\- ChatFont","-- \\- TargetID","-- \\- TargetIDSmall","-- \\- HL2MPTypeDeath","-- \\- BudgetLabel","-- \\- DejaVu Sans Mono (shipped, monospaced)"],"code":["function render_library.createFont(font,size,weight,antialias,additive,shadow,outline,blur)","\tif not validfonts[font] then SF.throw( \"invalid font\", 2 ) end","\t","\tsize = tonumber(size) or 16","\tweight = tonumber(weight) or 400","\tblur = tonumber(blur) or 0","\tantialias = antialias and true or false","\tadditive = additive and true or false","\tshadow = shadow and true or false","\toutline = outline and true or false","\t","\tlocal name = string.format(\"sf_screen_font_%s_%d_%d_%d_%d%d%d%d\",","\t\tfont, size, weight, blur,","\t\tantialias and 1 or 0,","\t\tadditive and 1 or 0,","\t\tshadow and 1 or 0,","\t\toutline and 1 or 0)","\t","\tif not defined_fonts[name] then","\t\tsurface.CreateFont(name, {size = size, weight = weight,","\t\t\tantialias=antialias, additive = additive, font = font,","\t\t\tshadow = shadow, outline = outline, blur = blur})","\t\tdefined_fonts[name] = true","\tend","\treturn name","end",""],"class":"function","summary":"\nCreates a font.","name":"render_library.createFont","library":"render","private":false,"usage":"\nBase font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall): \n- DebugFixed \n- DebugFixedSmall \n- DefaultFixedOutline \n- MenuItem \n- Default \n- TabLarge \n- DefaultBold \n- DefaultUnderline \n- DefaultSmall \n- DefaultSmallDropShadow \n- DefaultVerySmall \n- DefaultLarge \n- UiBold \n- MenuLarge \n- ConsoleText \n- Marlett \n- Trebuchet18 \n- Trebuchet19 \n- Trebuchet20 \n- Trebuchet22 \n- Trebuchet24 \n- HUDNumber \n- HUDNumber1 \n- HUDNumber2 \n- HUDNumber3 \n- HUDNumber4 \n- HUDNumber5 \n- HudHintTextLarge \n- HudHintTextSmall \n- CenterPrintText \n- HudSelectionText \n- DefaultFixed \n- DefaultFixedDropShadow \n- CloseCaption_Normal \n- CloseCaption_Bold \n- CloseCaption_BoldItalic \n- TitleFont \n- TitleFont2 \n- ChatFont \n- TargetID \n- TargetIDSmall \n- HL2MPTypeDeath \n- BudgetLabel \n- DejaVu Sans Mono (shipped, monospaced)","description":"\nCreates a font. Does not require rendering hook","param":{"1":"font","2":"size","3":"weight","4":"antialias","5":"additive","6":"shadow","7":"outline","8":"blur","9":"blue","outline":"Enable outline?","shadow":"Enable drop shadow?","blue":"Enable blur?","weight":"Font weight (default: 400)","font":"Base font to use","additive":"If true, adds brightness to pixels behind it rather than drawing over them.","antialias":"Antialias font?","size":"Font size"}},"selectRenderTarget":{"comment":["--- Selects the render target to draw on.","-- Nil for the visible RT.","-- @param name Name of the render target to use"],"code":["function render_library.selectRenderTarget ( name )","\tlocal data = SF.instance.data.render","\tdata.oldRT = data.oldRT or render.GetRenderTarget()","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif not name then","\t\tif data.usingRT then","\t\t\tcam.End2D()","\t\t\trender.PopRenderTarget()","\t\t\tcam.Start2D()","\t\t\tdata.usingRT = false","\t\tend","\t\treturn","\tend","\tSF.CheckType( name, \"string\" )","\tlocal rt = globalRTs[ data.rendertargets[ name ] ][ 1 ]","\tif not rt then SF.Throw( \"Invalid Rendertarget\", 2 ) end","","\tcam.End2D()","\tif data.usingRT then","\t\trender.PopRenderTarget()","\tend","\trender.PushRenderTarget( rt, 0, 0, rt:Width(), rt:Height() )","\tcam.Start2D()","\tdata.usingRT = true","end",""],"class":"function","name":"render_library.selectRenderTarget","summary":"\nSelects the render target to draw on.","private":false,"library":"render","description":"\nSelects the render target to draw on. \nNil for the visible RT.","param":{"1":"name","name":"Name of the render target to use"}},"createRenderTarget":{"comment":["--- Creates a new render target to draw onto.","-- The dimensions will always be 1024x1024","-- @param name The name of the render target","-- @bug The drawing will be offset by 16 pixels to the left and 16 to the top and the resolution is actually 992x992. So drawing to 16,16 will draw in the top-left corner and 1007,1007 to the bottom-right."],"code":["function render_library.createRenderTarget ( name )","\tSF.CheckType( name, \"string\" )","","\tlocal data = SF.instance.data.render","\tdata.rendertargets = data.rendertargets or {}","\tdata.rendertargetcount = data.rendertargetcount or 0","","\tif data.rendertargetcount >= 2 then","\t\tSF.throw( \"Rendertarget limit reached\", 2 )","\tend","","\tdata.rendertargetcount = data.rendertargetcount + 1","\tlocal rtname, rt = findAvailableRT()","\tif not rt then","\t\tglobalRTcount = globalRTcount + 1","\t\trtname = \"Starfall_CustomRT_\" .. globalRTcount","\t\trt = { GetRenderTarget( rtname, 1024, 1024, false ) }","\t\tglobalRTs[ rtname ] = rt","\tend","\trt[ 2 ] = false","\tdata.rendertargets[ name ] = rtname","end",""],"class":"function","bug":"The drawing will be offset by 16 pixels to the left and 16 to the top and the resolution is actually 992x992. So drawing to 16,16 will draw in the top-left corner and 1007,1007 to the bottom-right.","name":"render_library.createRenderTarget","summary":"\nCreates a new render target to draw onto.","private":false,"library":"render","description":"\nCreates a new render target to draw onto. \nThe dimensions will always be 1024x1024","param":{"1":"name","name":"The name of the render target"}},"capturePixels":{"comment":["--- Dumps the current render target and allows the pixels to be accessed by render.readPixel."],"code":["function render_library.capturePixels ()","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\trender.CapturePixels()","end",""],"class":"function","name":"render_library.capturePixels","summary":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","private":false,"library":"render","description":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","param":[]},"setRenderTargetTexture":{"comment":["--- Sets the active texture to the render target with the specified name.","-- Nil to reset.","-- @param name Name of the render target to use"],"code":["function render_library.setRenderTargetTexture ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif not name then","\t\tdraw.NoTexture()","\telse","\t\tSF.CheckType( name, \"string\" )","\t\tlocal rtname = data.rendertargets[ name ]","\t\tlocal rt = globalRTs[ rtname ][ 1 ]","\t\tlocal mat = globalRTs[ rtname ][ 2 ] or CreateMaterial( rtname, \"UnlitGeneric\", {","\t\t\t[ \"$nolod\" ] = 1,","\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t[ \"$vertexalpha\" ] = 1","\t\t} )","\t\tmat:SetTexture( \"$basetexture\", rt )","\t\tsurface.SetMaterial( mat )","\tend","end",""],"class":"function","name":"render_library.setRenderTargetTexture","summary":"\nSets the active texture to the render target with the specified name.","private":false,"library":"render","description":"\nSets the active texture to the render target with the specified name. \nNil to reset.","param":{"1":"name","name":"Name of the render target to use"}},"clear":{"comment":["--- Clears the surface","-- @param clr Color type to clear with"],"code":["function render_library.clear ( clr )","    if clr == nil then","        if not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","        render.Clear( 0, 0, 0, 255 )","    else","        SF.CheckType( clr, SF.Types[ \"Color\" ] )","        if not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","        render.Clear( clr.r, clr.g, clr.b, clr.a )","    end","end",""],"class":"function","name":"render_library.clear","summary":"\nClears the surface ","private":false,"library":"render","description":"\nClears the surface","param":{"1":"clr","clr":"Color type to clear with"}},"getScreenInfo":{"ret":"A table describing the screen.","comment":["--- Returns information about the screen, such as dimentions and rotation.","-- Note: this does a table copy so move it out of your draw hook","-- @return A table describing the screen."],"code":["function render_library.getScreenInfo()","\tlocal gpu = SF.instance.data.render.gpu","\tif not gpu then return end","\tlocal info, _, _ = gpu:GetInfo()","\treturn table.Copy(info)","end",""],"class":"function","name":"render_library.getScreenInfo","summary":"\nReturns information about the screen, such as dimentions and rotation.","private":false,"library":"render","description":"\nReturns information about the screen, such as dimentions and rotation. \nNote: this does a table copy so move it out of your draw hook","param":[]},"drawLine":{"comment":["--- Draws a line","-- @param x1 X start coordinate","-- @param y1 Y start coordinate","-- @param x2 X end coordinate","-- @param y2 Y end coordinate"],"code":["function render_library.drawLine ( x1, y1, x2, y2 )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x1, \"number\" )","\tSF.CheckType( y1, \"number\" )","\tSF.CheckType( x2, \"number\" )","\tSF.CheckType( y2, \"number\" )","\tsurface.DrawLine( x1, y1, x2, y2 )","end",""],"class":"function","name":"render_library.drawLine","summary":"\nDraws a line ","private":false,"library":"render","description":"\nDraws a line","param":{"1":"x1","2":"y1","3":"x2","4":"y2","x2":"X end coordinate","y2":"Y end coordinate","y1":"Y start coordinate","x1":"X start coordinate"}},"getTextureID":{"comment":["--- Looks up a texture by file name. Use with render.setTexture to draw with it.","--- Make sure to store the texture to use it rather than calling this slow function repeatedly.","-- @param tx Texture file path, or a http url"],"code":["function render_library.getTextureID ( tx )","","\tif tx:sub(1,4)==\"http\" then","\t\ttx = string.gsub( tx, \"[^%w _~%.%-/:]\", function( str )","\t\t\treturn string.format( \"%%%02X\", string.byte( str ) )","\t\tend )","\t\t","\t\tlocal tbl = {}","\t\ttexturecache[ tbl ] = LoadURLMaterial( tx )","\t\treturn tbl","\telse","\t\tlocal id = surface.GetTextureID( tx )","\t\tif id then","\t\t\tlocal mat = Material( tx ) -- Hacky way to get ITexture, if there is a better way - do it!","\t\t\tlocal cacheentry = CreateMaterial( \"SF_TEXTURE_\" .. id, \"UnlitGeneric\", {","\t\t\t\t[ \"$nolod\" ] = 1,","\t\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t\t[ \"$vertexalpha\" ] = 1","\t\t\t} )","\t\t\tcacheentry:SetTexture( \"$basetexture\", mat:GetTexture( \"$basetexture\" ) )","\t\t\t","\t\t\tlocal tbl = {}","\t\t\ttexturecache[ tbl ] = cacheentry","\t\t\treturn tbl","\t\tend","\tend","\t","end",""],"class":"function","name":"render_library.getTextureID","summary":"\nLooks up a texture by file name.","private":false,"library":"render","description":"\nLooks up a texture by file name. Use with render.setTexture to draw with it. \nMake sure to store the texture to use it rather than calling this slow function repeatedly.","param":{"1":"tx","tx":"Texture file path, or a http url"}},"cursorPos":{"ret":["x position","y position"],"comment":["--- Gets a 2D cursor position where ply is aiming.","-- @param ply player to get cursor position from","-- @return x position","-- @return y position"],"code":["function render_library.cursorPos( ply )","\t-- Taken from EGPLib","\tlocal Normal, Pos, monitor, Ang","\tlocal screen = SF.instance.data.render.renderEnt","\tif not screen then return nil end","\t","\tply = SF.Entities.Unwrap( ply )","\tif not ply then SF.throw(\"Invalid Player\", 2) end","\t","\t-- Get monitor screen pos & size","\tmonitor = WireGPU_Monitors[ screen:GetModel() ]","\t\t","\t-- Monitor does not have a valid screen point","\tif not monitor then return nil end","\t\t","\tAng = screen:LocalToWorldAngles( monitor.rot )","\tPos = screen:LocalToWorld( monitor.offset )","\t\t","\tNormal = Ang:Up()","\t","\tlocal Start = ply:GetShootPos()","\tlocal Dir = ply:GetAimVector()","\t","\tlocal A = Normal:Dot(Dir)","\t","\t-- If ray is parallel or behind the screen","\tif A == 0 or A > 0 then return nil end","\t","\tlocal B = Normal:Dot(Pos-Start) / A","\t\tif (B >= 0) then","\t\tlocal HitPos = WorldToLocal( Start + Dir * B, Angle(), Pos, Ang )","\t\tlocal x = (0.5+HitPos.x/(monitor.RS*512/monitor.RatioX)) * 512","\t\tlocal y = (0.5-HitPos.y/(monitor.RS*512)) * 512\t","\t\tif x < 0 or x > 512 or y < 0 or y > 512 then return nil end -- Aiming off the screen ","\t\treturn x, y","\tend","\t","\treturn nil","end",""],"class":"function","name":"render_library.cursorPos","summary":"\nGets a 2D cursor position where ply is aiming.","private":false,"library":"render","description":"\nGets a 2D cursor position where ply is aiming.","param":{"1":"ply","ply":"player to get cursor position from"}},"setFont":{"comment":["--- Sets the font","-- @param font The font to use"],"code":["function render_library.setFont(font)","\tif not defined_fonts[font] then SF.throw( \"Font does not exist.\", 2 ) end","\tSF.instance.data.render.font = font","\t--surface.SetFont(font)","end",""],"class":"function","name":"render_library.setFont","summary":"\nSets the font ","private":false,"library":"render","description":"\nSets the font","param":{"1":"font","font":"The font to use"}},"drawPoly":{"comment":["--- Draws a polygon. Takes a compiled/uncompiled poly to draw.","-- Note that if you do use an uncompiled poly, you will use up ops","-- very quickly!","-- @param poly Compiled poly or array of vertexes"],"code":["function render_library.drawPoly(poly)","\tif dgetmeta(poly) ~= poly_metamethods then","\t\tSF.CheckType(poly,\"table\")","\t\tlocal verts = poly","\t\tpoly = {}","\t\tfor i=1,#verts do","\t\t\tlocal v = verts[i]","\t\t\tSF.CheckType(v,\"table\")","\t\t\tpoly[i] = checkvertex(v)","\t\tend","\telse","\t\tpoly = unwrappoly(poly)","\tend","\tsurface.DrawPoly(poly)","end",""],"class":"function","name":"render_library.drawPoly","summary":"\nDraws a polygon.","private":false,"library":"render","description":"\nDraws a polygon. Takes a compiled/uncompiled poly to draw. \nNote that if you do use an uncompiled poly, you will use up ops \nvery quickly!","param":{"1":"poly","poly":"Compiled poly or array of vertexes"}},"drawTexturedRectRotated":{"comment":["--- Draws a rotated, textured rectangle.","-- @param x X coordinate of center of rect","-- @param y Y coordinate of center of rect","-- @param w Width","-- @param h Height","-- @param rot Rotation in degrees"],"code":["function render_library.drawTexturedRectRotated ( x, y, w, h, rot )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( rot, \"number\" )","","\tsurface.DrawTexturedRectRotated( x, y, w, h, rot )","end",""],"class":"function","name":"render_library.drawTexturedRectRotated","summary":"\nDraws a rotated, textured rectangle.","private":false,"library":"render","description":"\nDraws a rotated, textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","5":"rot","y":"Y coordinate of center of rect","h":"Height","rot":"Rotation in degrees","w":"Width","x":"X coordinate of center of rect"}},"createPoly":{"ret":"compiled polygon","comment":["--- Compiles a 2D poly. This is needed so that poly don't have to be","-- type-checked each frame. Polys can be indexed by a number, in which","-- a copy of the vertex at that spot is returned. They can also be assigned","-- a new vertex at 1 <= i <= #poly+1. And the length of the poly can be taken.","-- @param verts Array of verticies to convert.","-- @return compiled polygon"],"code":["function render_library.createPoly(verts)","\tSF.CheckType(verts,\"table\")","\tlocal poly = {}","\tlocal wrappedpoly = wrappoly(poly)","\tfor i=1,#verts do","\t\tlocal v = verts[i]","\t\tSF.CheckType(v,\"table\")","\t\tpoly[i] = checkvertex(v)","\tend","\treturn wrappedpoly","end",""],"class":"function","name":"render_library.createPoly","summary":"\nCompiles a 2D poly.","private":false,"library":"render","description":"\nCompiles a 2D poly. This is needed so that poly don't have to be \ntype-checked each frame. Polys can be indexed by a number, in which \na copy of the vertex at that spot is returned. They can also be assigned \na new vertex at 1 <= i <= #poly+1. And the length of the poly can be taken.","param":{"1":"verts","verts":"Array of verticies to convert."}},"drawRectOutline":{"comment":["--- Draws a rectangle outline using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRectOutline ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawOutlinedRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRectOutline","summary":"\nDraws a rectangle outline using the current color.","private":false,"library":"render","description":"\nDraws a rectangle outline using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},"getTextSize":{"ret":["width of the text","height of the text"],"comment":["--- Gets the size of the specified text. Don't forget to use setFont before calling this function","-- @param text Text to get the size of","-- @return width of the text","-- @return height of the text"],"code":["function render_library.getTextSize( text )","\tSF.CheckType(text,\"string\")","\t","\tsurface.SetFont(SF.instance.data.render.font or defaultFont)","\treturn surface.GetTextSize( text )","end",""],"class":"function","name":"render_library.getTextSize","summary":"\nGets the size of the specified text.","private":false,"library":"render","description":"\nGets the size of the specified text. Don't forget to use setFont before calling this function","param":{"1":"text","text":"Text to get the size of"}},"getDefaultFont":{"ret":"Default font","comment":["--- Gets the default font","-- @return Default font"],"code":["function render_library.getDefaultFont()","\treturn defaultFont","end",""],"class":"function","name":"render_library.getDefaultFont","summary":"\nGets the default font ","private":false,"library":"render","description":"\nGets the default font","param":[]},"popMatrix":{"comment":["--- Pops a matrix from the matrix stack."],"code":["function render_library.popMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif #matrix_stack <= 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tmatrix_stack[#matrix_stack] = nil","\tcam.PopModelMatrix()","end",""],"class":"function","name":"render_library.popMatrix","summary":"\nPops a matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a matrix from the matrix stack.","param":[]},"setTexture":{"comment":["--- Sets the texture","-- @param id Texture id or url to an online image."],"code":["function render_library.setTexture ( id )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif id and texturecache[ id ] then","\t\tsurface.SetMaterial( texturecache[ id ] )","\t\treturn","\tend","","\tdraw.NoTexture()","end",""],"class":"function","name":"render_library.setTexture","summary":"\nSets the texture ","private":false,"library":"render","description":"\nSets the texture","param":{"1":"id","id":"Texture id or url to an online image."}},"drawText":{"comment":["--- Draws text.","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param alignment Text alignment"],"code":["function render_library.drawText ( x, y, text, alignment )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif alignment then","\t\tSF.CheckType( alignment, \"number\" )","\tend","\t","\tlocal font = SF.instance.data.render.font or defaultFont","\t","\tdraw.DrawText( text, font, x, y, currentcolor, alignment or TEXT_ALIGN_LEFT )","end",""],"class":"function","name":"render_library.drawText","summary":"\nDraws text.","private":false,"library":"render","description":"\nDraws text.","param":{"1":"x","2":"y","3":"text","4":"alignment","y":"Y coordinate","x":"X coordinate","alignment":"Text alignment","text":"Text to draw"}},"setColor":{"comment":["--- Sets the draw color","-- @param clr Color type"],"code":["function render_library.setColor ( clr )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\tcurrentcolor = clr","\tsurface.SetDrawColor( clr )","\tsurface.SetTextColor( clr )","end",""],"class":"function","name":"render_library.setColor","summary":"\nSets the draw color ","private":false,"library":"render","description":"\nSets the draw color","param":{"1":"clr","clr":"Color type"}}},"class":"library","summary":"\nRender library.","code":["","local render_library, _ = SF.Libraries.RegisterLocal(\"render\")","","render_library.TEXT_ALIGN_LEFT = TEXT_ALIGN_LEFT","render_library.TEXT_ALIGN_CENTER = TEXT_ALIGN_CENTER","render_library.TEXT_ALIGN_RIGHT = TEXT_ALIGN_RIGHT","render_library.TEXT_ALIGN_TOP = TEXT_ALIGN_TOP","render_library.TEXT_ALIGN_BOTTOM = TEXT_ALIGN_BOTTOM",""],"fields":[],"name":"render","description":"\nRender library. Screens are 512x512 units. Most functions require \nthat you be in the rendering hook to call, otherwise an error is \nthrown. +x is right, +y is down","entity":"starfall_screen","libtbl":"render_library","tables":[],"field":{"1":"TEXT_ALIGN_LEFT","2":"TEXT_ALIGN_CENTER","3":"TEXT_ALIGN_RIGHT","4":"TEXT_ALIGN_TOP","5":"TEXT_ALIGN_BOTTOM","TEXT_ALIGN_CENTER":"","TEXT_ALIGN_TOP":"","TEXT_ALIGN_BOTTOM":"","TEXT_ALIGN_LEFT":"","TEXT_ALIGN_RIGHT":""}},{"description":"\nVertex format","code":["","local render = render","local surface = surface","local clamp = math.Clamp","local max = math.max","local cam = cam","local dgetmeta = debug.getmetatable","local matrix_meta = SF.VMatrix.Metatable --debug.getregistry().VMatrix","","local v_unwrap = SF.VMatrix.Unwrap","","local currentcolor","local MATRIX_STACK_LIMIT = 8","local matrix_stack = {}","","local globalRTs = {}","local globalRTcount = 0","","SF.Libraries.AddHook( \"prepare\", function ( instance )","\tif hook == \"render\" then","\t\tcurrentcolor = Color(0,0,0,0)","\tend","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance )","\tfor i=#matrix_stack,1,-1 do","\t\tcam.PopModelMatrix()","\t\tmatrix_stack[i] = nil","\tend","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tlocal data = instance.data.render","\tif data.rendertargets then","\t\tfor k, v in pairs( data.rendertargets ) do","\t\t\tglobalRTs[ v ][ 2 ] = true -- mark as available","\t\tend","\tend","end )",""],"class":"table","classForced":true,"name":"Vertex Format","summary":"\nVertex format ","field":{"1":"x","2":"y","3":"u","4":"v","y":"Y coordinate","x":"X coordinate","u":"U coordinate (optional, default is 0)","v":"V coordinate (optional, default is 0)"},"comment":["--- Vertex format","-- @name Vertex Format","-- @class table","-- @field x X coordinate","-- @field y Y coordinate","-- @field u U coordinate (optional, default is 0)","-- @field v V coordinate (optional, default is 0)"],"param":[]},{"comment":["---URL Textures"],"code":["local LoadingURLQueue = {}","","local texturecache","","local function CheckURLDownloads()","\tlocal numqueued = #LoadingURLQueue","\tlocal urltable = LoadingURLQueue[numqueued]","\t","\tif urltable then","\t\tif urltable.Panel then","\t\t\tif not urltable.Panel:IsLoading() then","\t\t\t\ttimer.Simple(0.2,function()","\t\t\t\t\tlocal tex = urltable.Panel:GetHTMLMaterial():GetTexture(\"$basetexture\")","\t\t\t\t\ttex:Download()","\t\t\t\t\turltable.Material:SetTexture(\"$basetexture\", tex)","\t\t\t\t\ttex:Download()","\t\t\t\t\turltable.Panel:Remove()","\t\t\t\t\tif urltable.cb then urltable.cb() end","\t\t\t\tend)\t\t","\t\t\t\ttexturecache[urltable.Url] = urltable.Material","\t\t\t\tLoadingURLQueue[numqueued] = nil\t\t\t\t\t","\t\t\telse","\t\t\t\tif CurTime() > urltable.Timeout then","\t\t\t\t\turltable.Panel:Remove()","\t\t\t\t\tLoadingURLQueue[numqueued] = nil","\t\t\t\tend","\t\t\tend","\t\t","\t\telse\t\t","\t\t\tlocal Panel = vgui.Create( \"DHTML\" )","\t\t\tPanel:SetSize( 1024, 1024 )","\t\t\tPanel:SetAlpha( 0 )","\t\t\tPanel:SetMouseInputEnabled( false )","\t\t\tPanel:SetHTML(","\t\t\t[[","\t\t\t\t<style type=\"text/css\">","\t\t\t\t\thtml ","\t\t\t\t\t{\t\t\t","\t\t\t\t\t\toverflow:hidden;","\t\t\t\t\t\tmargin: -7.5px -7.5px;","\t\t\t\t\t}","\t\t\t\t</style>","\t\t\t\t","\t\t\t\t<body>","\t\t\t\t\t<img src=\"]] .. urltable.Url .. [[\" alt=\"\" width=\"1024\" height=\"1024\" />","\t\t\t\t</body>","\t\t\t]]","\t\t\t)","\t\t\turltable.Timeout = CurTime()+20","\t\t\turltable.Panel = Panel","\t\tend","\tend","\t","\tif #LoadingURLQueue == 0 then","\t\ttimer.Destroy(\"SF_URLMaterialChecker\")","\tend","end","","local cv_max_url_materials = CreateConVar( \"sf_render_maxurlmaterials\", \"30\", { FCVAR_REPLICATED, FCVAR_ARCHIVE } ) ","","local function LoadURLMaterial( url, cb )","\t--Count the number of materials","\tlocal totalMaterials = 0, key","\twhile true do","\t\tkey = next(texturecache, key)","\t\tif not key then break end","\t\ttotalMaterials = totalMaterials + 1","\tend","\t","\tlocal queuesize = #LoadingURLQueue","\ttotalMaterials = totalMaterials + queuesize","\t","\tif totalMaterials>=cv_max_url_materials:GetInt() then","\t\treturn","\tend","\t","\tlocal ShaderInfo = {","\t\t[\"$vertexcolor\"] = 1,","\t\t[\"$vertexalpha\"] = 1,","\t\t[\"$ignorez\"] = 1,","\t\t[\"$nolod\"] = 1","\t}","\tlocal urlmaterial = CreateMaterial(\"SF_TEXTURE_\" .. util.CRC(url .. SysTime()), \"UnlitGeneric\", ShaderInfo)","\t\t\t\t","\tif queuesize == 0 then","\t\ttimer.Create(\"SF_URLMaterialChecker\",1,0,function() CheckURLDownloads() end)","\tend","\t","\tLoadingURLQueue[queuesize + 1] = {Material = urlmaterial, Url = url, cb = cb}","\treturn urlmaterial","end","","texturecache = setmetatable({},{__mode = \"k\"})","","local validfonts = {","\tDebugFixed = true,","\tDebugFixedSmall = true,","\tDefaultFixedOutline = true,","\tMenuItem = true,","\tDefault = true,","\tTabLarge = true,","\tDefaultBold = true,","\tDefaultUnderline = true,","\tDefaultSmall = true,","\tDefaultSmallDropShadow = true,","\tDefaultVerySmall = true,","\tDefaultLarge = true,","\tUiBold = true,","\tMenuLarge = true,","\tConsoleText = true,","\tMarlett = true,","\tTrebuchet18 = true,","\tTrebuchet19 = true,","\tTrebuchet20 = true,","\tTrebuchet22 = true,","\tTrebuchet24 = true,","\tHUDNumber = true,","\tHUDNumber1 = true,","\tHUDNumber2 = true,","\tHUDNumber3 = true,","\tHUDNumber4 = true,","\tHUDNumber5 = true,","\tHudHintTextLarge = true,","\tHudHintTextSmall = true,","\tCenterPrintText = true,","\tHudSelectionText = true,","\tDefaultFixed = true,","\tDefaultFixedDropShadow = true,","\tCloseCaption_Normal = true,","\tCloseCaption_Bold = true,","\tCloseCaption_BoldItalic = true,","\tTitleFont = true,","\tTitleFont2 = true,","\tChatFont = true,","\tTargetID = true,","\tTargetIDSmall = true,","\tHL2MPTypeDeath = true,","\tBudgetLabel = true,","\t[ \"DejaVu Sans Mono\" ] = true","}","","surface.CreateFont(\"sf_screen_font_Default_16_400_9_0000\", {size = 16, weight = 400,","\t\tantialias=false, additive = false, font = \"Default\",","\t\tshadow = false, outline = false, blur = 0})","","local defined_fonts = {","\t[\"sf_screen_font_Default_16_400_9_0000\"] = true","}","","local defaultFont = \"sf_screen_font_Default_16_400_9_0000\"","","local poly_methods, poly_metamethods = SF.Typedef(\"Polygon\")","local wrappoly, unwrappoly = SF.CreateWrapper(poly_metamethods)","","local function checkvertex(vert)","\treturn {","\t\tx = SF.CheckType(vert.x or vert[1],\"number\",1),","\t\ty = SF.CheckType(vert.y or vert[2],\"number\",1),","\t\tu = tonumber(vert.u or vert[3]) or 0,","\t\tv = tonumber(vert.v or vert[4]) or 0,","\t}","end","","function poly_metamethods:__index(k)","\tSF.CheckType(self,poly_metamethods)","\tSF.CheckType(k,\"number\")","\tlocal poly = unwrappoly(self)","\tif not poly then return nil end","\tif k <= 0 or k > #poly then return nil end","\treturn table.Copy(poly[k])","end","","function poly_metamethods:__len()","\tSF.CheckType(self,poly_metamethods)","\tlocal poly = unwrappoly(self)","\treturn poly and #poly or nil","end","","function poly_metamethods:__newindex(k,v)","\tSF.CheckType(self,poly_metamethods)","\tSF.CheckType(k,\"number\")","\tSF.CheckType(v,\"table\")","\tlocal poly = unwrappoly(self)","\tif not poly then return end","\tif k <= 0 or k > (#poly)+1 then return SF.throw( \"poly index out of bounds: \" .. k .. \" out of \" .. #poly, 2 ) end","\tpoly[k] = checkvertex(v)","end","","-- ------------------------------------------------------------------ --",""],"summary":"\nURL Textures ","description":"\nURL Textures","param":[]},{"comment":["--- Pushes a matrix onto the matrix stack.","-- @param m The matrix"],"code":["function render_library.pushMatrix(m)","\tSF.CheckType(m,matrix_meta)","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tlocal id = #matrix_stack","\tif id + 1 > MATRIX_STACK_LIMIT then SF.throw( \"Pushed too many matricies\", 2 ) end","\tlocal newmatrix","\tif matrix_stack[id] then","\t\tnewmatrix = matrix_stack[id] * v_unwrap(m)","\telse","\t\tnewmatrix = v_unwrap(m)","\tend","\tmatrix_stack[id+1] = newmatrix","\tcam.PushModelMatrix(newmatrix)","end",""],"class":"function","name":"render_library.pushMatrix","summary":"\nPushes a matrix onto the matrix stack.","private":false,"library":"render","description":"\nPushes a matrix onto the matrix stack.","param":{"1":"m","m":"The matrix"}},{"comment":["--- Pops a matrix from the matrix stack."],"code":["function render_library.popMatrix()","\tlocal renderdata = SF.instance.data.render","\tif not renderdata.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif #matrix_stack <= 0 then SF.throw( \"Popped too many matricies\", 2 ) end","\tmatrix_stack[#matrix_stack] = nil","\tcam.PopModelMatrix()","end",""],"class":"function","name":"render_library.popMatrix","summary":"\nPops a matrix from the matrix stack.","private":false,"library":"render","description":"\nPops a matrix from the matrix stack.","param":[]},{"comment":["--- Sets the draw color","-- @param clr Color type"],"code":["function render_library.setColor ( clr )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","\tcurrentcolor = clr","\tsurface.SetDrawColor( clr )","\tsurface.SetTextColor( clr )","end",""],"class":"function","name":"render_library.setColor","summary":"\nSets the draw color ","private":false,"library":"render","description":"\nSets the draw color","param":{"1":"clr","clr":"Color type"}},{"comment":["--- Looks up a texture by file name. Use with render.setTexture to draw with it.","--- Make sure to store the texture to use it rather than calling this slow function repeatedly.","-- @param tx Texture file path, or a http url"],"code":["function render_library.getTextureID ( tx )","","\tif tx:sub(1,4)==\"http\" then","\t\ttx = string.gsub( tx, \"[^%w _~%.%-/:]\", function( str )","\t\t\treturn string.format( \"%%%02X\", string.byte( str ) )","\t\tend )","\t\t","\t\tlocal tbl = {}","\t\ttexturecache[ tbl ] = LoadURLMaterial( tx )","\t\treturn tbl","\telse","\t\tlocal id = surface.GetTextureID( tx )","\t\tif id then","\t\t\tlocal mat = Material( tx ) -- Hacky way to get ITexture, if there is a better way - do it!","\t\t\tlocal cacheentry = CreateMaterial( \"SF_TEXTURE_\" .. id, \"UnlitGeneric\", {","\t\t\t\t[ \"$nolod\" ] = 1,","\t\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t\t[ \"$vertexalpha\" ] = 1","\t\t\t} )","\t\t\tcacheentry:SetTexture( \"$basetexture\", mat:GetTexture( \"$basetexture\" ) )","\t\t\t","\t\t\tlocal tbl = {}","\t\t\ttexturecache[ tbl ] = cacheentry","\t\t\treturn tbl","\t\tend","\tend","\t","end",""],"class":"function","name":"render_library.getTextureID","summary":"\nLooks up a texture by file name.","private":false,"library":"render","description":"\nLooks up a texture by file name. Use with render.setTexture to draw with it. \nMake sure to store the texture to use it rather than calling this slow function repeatedly.","param":{"1":"tx","tx":"Texture file path, or a http url"}},{"comment":["--- Sets the texture","-- @param id Texture id or url to an online image."],"code":["function render_library.setTexture ( id )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif id and texturecache[ id ] then","\t\tsurface.SetMaterial( texturecache[ id ] )","\t\treturn","\tend","","\tdraw.NoTexture()","end",""],"class":"function","name":"render_library.setTexture","summary":"\nSets the texture ","private":false,"library":"render","description":"\nSets the texture","param":{"1":"id","id":"Texture id or url to an online image."}},{"comment":["--- Clears the surface","-- @param clr Color type to clear with"],"code":["function render_library.clear ( clr )","    if clr == nil then","        if not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","        render.Clear( 0, 0, 0, 255 )","    else","        SF.CheckType( clr, SF.Types[ \"Color\" ] )","        if not SF.instance.data.render.isRendering then SF.throw( \"Not in a rendering hook.\", 2 ) end","        render.Clear( clr.r, clr.g, clr.b, clr.a )","    end","end",""],"class":"function","name":"render_library.clear","summary":"\nClears the surface ","private":false,"library":"render","description":"\nClears the surface","param":{"1":"clr","clr":"Color type to clear with"}},{"comment":["--- Draws a rectangle using the current color. ","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRect","summary":"\nDraws a rectangle using the current color.","private":false,"library":"render","description":"\nDraws a rectangle using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},{"comment":["--- Draws a rectangle outline using the current color.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawRectOutline ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawOutlinedRect( x, y, w, h )","end",""],"class":"function","name":"render_library.drawRectOutline","summary":"\nDraws a rectangle outline using the current color.","private":false,"library":"render","description":"\nDraws a rectangle outline using the current color.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},{"comment":["--- Draws a circle outline","-- @param x Center x coordinate","-- @param y Center y coordinate","-- @param r Radius"],"code":["function render_library.drawCircle ( x, y, r )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( r, \"number\" )","\tsurface.DrawCircle( x, y, r, currentcolor )","end",""],"class":"function","name":"render_library.drawCircle","summary":"\nDraws a circle outline ","private":false,"library":"render","description":"\nDraws a circle outline","param":{"1":"x","2":"y","3":"r","y":"Center y coordinate","x":"Center x coordinate","r":"Radius"}},{"comment":["--- Draws a textured rectangle.","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height"],"code":["function render_library.drawTexturedRect ( x, y, w, h )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tsurface.DrawTexturedRect ( x, y, w, h )","end",""],"class":"function","name":"render_library.drawTexturedRect","summary":"\nDraws a textured rectangle.","private":false,"library":"render","description":"\nDraws a textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","y":"Top left corner y coordinate","x":"Top left corner x coordinate","w":"Width","h":"Height"}},{"comment":["--- Draws a textured rectangle with UV coordinates","-- @param x Top left corner x coordinate","-- @param y Top left corner y coordinate","-- @param w Width","-- @param h Height","-- @param startU Texture mapping at rectangle origin","-- @param startV Texture mapping at rectangle origin","-- @param endV Texture mapping at rectangle end","-- @param endV Texture mapping at rectangle end"],"code":["function render_library.drawTexturedRectUV ( x, y, w, h, startU, startV, endU, endV )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( startU, \"number\" )","\tSF.CheckType( startV, \"number\" )","\tSF.CheckType( endU, \"number\" )","\tSF.CheckType( endV, \"number\" )","\tsurface.DrawTexturedRectUV( x, y, w, h, startU, startV, endU, endV )","end",""],"class":"function","name":"render_library.drawTexturedRectUV","summary":"\nDraws a textured rectangle with UV coordinates ","private":false,"library":"render","description":"\nDraws a textured rectangle with UV coordinates","param":{"1":"x","2":"y","3":"w","4":"h","5":"startU","6":"startV","7":"endU","8":"endV","y":"Top left corner y coordinate","h":"Height","endV":"Texture mapping at rectangle end","startU":"Texture mapping at rectangle origin","startV":"Texture mapping at rectangle origin","w":"Width","x":"Top left corner x coordinate"}},{"comment":["--- Draws a rotated, textured rectangle.","-- @param x X coordinate of center of rect","-- @param y Y coordinate of center of rect","-- @param w Width","-- @param h Height","-- @param rot Rotation in degrees"],"code":["function render_library.drawTexturedRectRotated ( x, y, w, h, rot )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( w, \"number\" )","\tSF.CheckType( h, \"number\" )","\tSF.CheckType( rot, \"number\" )","","\tsurface.DrawTexturedRectRotated( x, y, w, h, rot )","end",""],"class":"function","name":"render_library.drawTexturedRectRotated","summary":"\nDraws a rotated, textured rectangle.","private":false,"library":"render","description":"\nDraws a rotated, textured rectangle.","param":{"1":"x","2":"y","3":"w","4":"h","5":"rot","y":"Y coordinate of center of rect","h":"Height","rot":"Rotation in degrees","w":"Width","x":"X coordinate of center of rect"}},{"comment":["--- Draws a line","-- @param x1 X start coordinate","-- @param y1 Y start coordinate","-- @param x2 X end coordinate","-- @param y2 Y end coordinate"],"code":["function render_library.drawLine ( x1, y1, x2, y2 )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x1, \"number\" )","\tSF.CheckType( y1, \"number\" )","\tSF.CheckType( x2, \"number\" )","\tSF.CheckType( y2, \"number\" )","\tsurface.DrawLine( x1, y1, x2, y2 )","end",""],"class":"function","name":"render_library.drawLine","summary":"\nDraws a line ","private":false,"library":"render","description":"\nDraws a line","param":{"1":"x1","2":"y1","3":"x2","4":"y2","x2":"X end coordinate","y2":"Y end coordinate","y1":"Y start coordinate","x1":"X start coordinate"}},{"comment":["--- Creates a font. Does not require rendering hook","-- @param font Base font to use","-- @param size Font size","-- @param weight Font weight (default: 400)","-- @param antialias Antialias font?","-- @param additive If true, adds brightness to pixels behind it rather than drawing over them.","-- @param shadow Enable drop shadow?","-- @param outline Enable outline?","-- @param blue Enable blur?","-- @usage","-- Base font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall):","-- \\- DebugFixed","-- \\- DebugFixedSmall","-- \\- DefaultFixedOutline","-- \\- MenuItem","-- \\- Default","-- \\- TabLarge","-- \\- DefaultBold","-- \\- DefaultUnderline","-- \\- DefaultSmall","-- \\- DefaultSmallDropShadow","-- \\- DefaultVerySmall","-- \\- DefaultLarge","-- \\- UiBold","-- \\- MenuLarge","-- \\- ConsoleText","-- \\- Marlett","-- \\- Trebuchet18","-- \\- Trebuchet19","-- \\- Trebuchet20","-- \\- Trebuchet22","-- \\- Trebuchet24","-- \\- HUDNumber","-- \\- HUDNumber1","-- \\- HUDNumber2","-- \\- HUDNumber3","-- \\- HUDNumber4","-- \\- HUDNumber5","-- \\- HudHintTextLarge","-- \\- HudHintTextSmall","-- \\- CenterPrintText","-- \\- HudSelectionText","-- \\- DefaultFixed","-- \\- DefaultFixedDropShadow","-- \\- CloseCaption_Normal","-- \\- CloseCaption_Bold","-- \\- CloseCaption_BoldItalic","-- \\- TitleFont","-- \\- TitleFont2","-- \\- ChatFont","-- \\- TargetID","-- \\- TargetIDSmall","-- \\- HL2MPTypeDeath","-- \\- BudgetLabel","-- \\- DejaVu Sans Mono (shipped, monospaced)"],"code":["function render_library.createFont(font,size,weight,antialias,additive,shadow,outline,blur)","\tif not validfonts[font] then SF.throw( \"invalid font\", 2 ) end","\t","\tsize = tonumber(size) or 16","\tweight = tonumber(weight) or 400","\tblur = tonumber(blur) or 0","\tantialias = antialias and true or false","\tadditive = additive and true or false","\tshadow = shadow and true or false","\toutline = outline and true or false","\t","\tlocal name = string.format(\"sf_screen_font_%s_%d_%d_%d_%d%d%d%d\",","\t\tfont, size, weight, blur,","\t\tantialias and 1 or 0,","\t\tadditive and 1 or 0,","\t\tshadow and 1 or 0,","\t\toutline and 1 or 0)","\t","\tif not defined_fonts[name] then","\t\tsurface.CreateFont(name, {size = size, weight = weight,","\t\t\tantialias=antialias, additive = additive, font = font,","\t\t\tshadow = shadow, outline = outline, blur = blur})","\t\tdefined_fonts[name] = true","\tend","\treturn name","end",""],"class":"function","summary":"\nCreates a font.","name":"render_library.createFont","library":"render","private":false,"usage":"\nBase font can be one of (keep in mind that these may not exist on all clients if they are not shipped with starfall): \n- DebugFixed \n- DebugFixedSmall \n- DefaultFixedOutline \n- MenuItem \n- Default \n- TabLarge \n- DefaultBold \n- DefaultUnderline \n- DefaultSmall \n- DefaultSmallDropShadow \n- DefaultVerySmall \n- DefaultLarge \n- UiBold \n- MenuLarge \n- ConsoleText \n- Marlett \n- Trebuchet18 \n- Trebuchet19 \n- Trebuchet20 \n- Trebuchet22 \n- Trebuchet24 \n- HUDNumber \n- HUDNumber1 \n- HUDNumber2 \n- HUDNumber3 \n- HUDNumber4 \n- HUDNumber5 \n- HudHintTextLarge \n- HudHintTextSmall \n- CenterPrintText \n- HudSelectionText \n- DefaultFixed \n- DefaultFixedDropShadow \n- CloseCaption_Normal \n- CloseCaption_Bold \n- CloseCaption_BoldItalic \n- TitleFont \n- TitleFont2 \n- ChatFont \n- TargetID \n- TargetIDSmall \n- HL2MPTypeDeath \n- BudgetLabel \n- DejaVu Sans Mono (shipped, monospaced)","description":"\nCreates a font. Does not require rendering hook","param":{"1":"font","2":"size","3":"weight","4":"antialias","5":"additive","6":"shadow","7":"outline","8":"blur","9":"blue","outline":"Enable outline?","shadow":"Enable drop shadow?","blue":"Enable blur?","weight":"Font weight (default: 400)","font":"Base font to use","additive":"If true, adds brightness to pixels behind it rather than drawing over them.","antialias":"Antialias font?","size":"Font size"}},{"ret":["width of the text","height of the text"],"comment":["--- Gets the size of the specified text. Don't forget to use setFont before calling this function","-- @param text Text to get the size of","-- @return width of the text","-- @return height of the text"],"code":["function render_library.getTextSize( text )","\tSF.CheckType(text,\"string\")","\t","\tsurface.SetFont(SF.instance.data.render.font or defaultFont)","\treturn surface.GetTextSize( text )","end",""],"class":"function","name":"render_library.getTextSize","summary":"\nGets the size of the specified text.","private":false,"library":"render","description":"\nGets the size of the specified text. Don't forget to use setFont before calling this function","param":{"1":"text","text":"Text to get the size of"}},{"comment":["--- Sets the font","-- @param font The font to use"],"code":["function render_library.setFont(font)","\tif not defined_fonts[font] then SF.throw( \"Font does not exist.\", 2 ) end","\tSF.instance.data.render.font = font","\t--surface.SetFont(font)","end",""],"class":"function","name":"render_library.setFont","summary":"\nSets the font ","private":false,"library":"render","description":"\nSets the font","param":{"1":"font","font":"The font to use"}},{"ret":"Default font","comment":["--- Gets the default font","-- @return Default font"],"code":["function render_library.getDefaultFont()","\treturn defaultFont","end",""],"class":"function","name":"render_library.getDefaultFont","summary":"\nGets the default font ","private":false,"library":"render","description":"\nGets the default font","param":[]},{"comment":["--- Draws text.","-- @param x X coordinate","-- @param y Y coordinate","-- @param text Text to draw","-- @param alignment Text alignment"],"code":["function render_library.drawText ( x, y, text, alignment )","\tif not SF.instance.data.render.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","\tSF.CheckType( text, \"string\" )","\tif alignment then","\t\tSF.CheckType( alignment, \"number\" )","\tend","\t","\tlocal font = SF.instance.data.render.font or defaultFont","\t","\tdraw.DrawText( text, font, x, y, currentcolor, alignment or TEXT_ALIGN_LEFT )","end",""],"class":"function","name":"render_library.drawText","summary":"\nDraws text.","private":false,"library":"render","description":"\nDraws text.","param":{"1":"x","2":"y","3":"text","4":"alignment","y":"Y coordinate","x":"X coordinate","alignment":"Text alignment","text":"Text to draw"}},{"ret":"compiled polygon","comment":["--- Compiles a 2D poly. This is needed so that poly don't have to be","-- type-checked each frame. Polys can be indexed by a number, in which","-- a copy of the vertex at that spot is returned. They can also be assigned","-- a new vertex at 1 <= i <= #poly+1. And the length of the poly can be taken.","-- @param verts Array of verticies to convert.","-- @return compiled polygon"],"code":["function render_library.createPoly(verts)","\tSF.CheckType(verts,\"table\")","\tlocal poly = {}","\tlocal wrappedpoly = wrappoly(poly)","\tfor i=1,#verts do","\t\tlocal v = verts[i]","\t\tSF.CheckType(v,\"table\")","\t\tpoly[i] = checkvertex(v)","\tend","\treturn wrappedpoly","end",""],"class":"function","name":"render_library.createPoly","summary":"\nCompiles a 2D poly.","private":false,"library":"render","description":"\nCompiles a 2D poly. This is needed so that poly don't have to be \ntype-checked each frame. Polys can be indexed by a number, in which \na copy of the vertex at that spot is returned. They can also be assigned \na new vertex at 1 <= i <= #poly+1. And the length of the poly can be taken.","param":{"1":"verts","verts":"Array of verticies to convert."}},{"comment":["--- Draws a polygon. Takes a compiled/uncompiled poly to draw.","-- Note that if you do use an uncompiled poly, you will use up ops","-- very quickly!","-- @param poly Compiled poly or array of vertexes"],"code":["function render_library.drawPoly(poly)","\tif dgetmeta(poly) ~= poly_metamethods then","\t\tSF.CheckType(poly,\"table\")","\t\tlocal verts = poly","\t\tpoly = {}","\t\tfor i=1,#verts do","\t\t\tlocal v = verts[i]","\t\t\tSF.CheckType(v,\"table\")","\t\t\tpoly[i] = checkvertex(v)","\t\tend","\telse","\t\tpoly = unwrappoly(poly)","\tend","\tsurface.DrawPoly(poly)","end",""],"class":"function","name":"render_library.drawPoly","summary":"\nDraws a polygon.","private":false,"library":"render","description":"\nDraws a polygon. Takes a compiled/uncompiled poly to draw. \nNote that if you do use an uncompiled poly, you will use up ops \nvery quickly!","param":{"1":"poly","poly":"Compiled poly or array of vertexes"}},{"ret":["x position","y position"],"comment":["--- Gets a 2D cursor position where ply is aiming.","-- @param ply player to get cursor position from","-- @return x position","-- @return y position"],"code":["function render_library.cursorPos( ply )","\t-- Taken from EGPLib","\tlocal Normal, Pos, monitor, Ang","\tlocal screen = SF.instance.data.render.renderEnt","\tif not screen then return nil end","\t","\tply = SF.Entities.Unwrap( ply )","\tif not ply then SF.throw(\"Invalid Player\", 2) end","\t","\t-- Get monitor screen pos & size","\tmonitor = WireGPU_Monitors[ screen:GetModel() ]","\t\t","\t-- Monitor does not have a valid screen point","\tif not monitor then return nil end","\t\t","\tAng = screen:LocalToWorldAngles( monitor.rot )","\tPos = screen:LocalToWorld( monitor.offset )","\t\t","\tNormal = Ang:Up()","\t","\tlocal Start = ply:GetShootPos()","\tlocal Dir = ply:GetAimVector()","\t","\tlocal A = Normal:Dot(Dir)","\t","\t-- If ray is parallel or behind the screen","\tif A == 0 or A > 0 then return nil end","\t","\tlocal B = Normal:Dot(Pos-Start) / A","\t\tif (B >= 0) then","\t\tlocal HitPos = WorldToLocal( Start + Dir * B, Angle(), Pos, Ang )","\t\tlocal x = (0.5+HitPos.x/(monitor.RS*512/monitor.RatioX)) * 512","\t\tlocal y = (0.5-HitPos.y/(monitor.RS*512)) * 512\t","\t\tif x < 0 or x > 512 or y < 0 or y > 512 then return nil end -- Aiming off the screen ","\t\treturn x, y","\tend","\t","\treturn nil","end",""],"class":"function","name":"render_library.cursorPos","summary":"\nGets a 2D cursor position where ply is aiming.","private":false,"library":"render","description":"\nGets a 2D cursor position where ply is aiming.","param":{"1":"ply","ply":"player to get cursor position from"}},{"ret":"A table describing the screen.","comment":["--- Returns information about the screen, such as dimentions and rotation.","-- Note: this does a table copy so move it out of your draw hook","-- @return A table describing the screen."],"code":["function render_library.getScreenInfo()","\tlocal gpu = SF.instance.data.render.gpu","\tif not gpu then return end","\tlocal info, _, _ = gpu:GetInfo()","\treturn table.Copy(info)","end",""],"class":"function","name":"render_library.getScreenInfo","summary":"\nReturns information about the screen, such as dimentions and rotation.","private":false,"library":"render","description":"\nReturns information about the screen, such as dimentions and rotation. \nNote: this does a table copy so move it out of your draw hook","param":[]},{"ret":["The screen position","The screen angle"],"comment":["--- Returns the screen surface's world position and angle","-- @return The screen position","-- @return The screen angle"],"code":["function render_library.getScreenPos()","\tlocal gpu = SF.instance.data.render.gpu","\tif not gpu then return end","\tlocal _, pos, rot = gpu:GetInfo()","\treturn SF.WrapObject( pos ), SF.WrapObject( rot )","end","","local function findAvailableRT ()","\tfor k, v in pairs( globalRTs ) do","\t\tif v[ 2 ] then","\t\t\treturn k, v","\t\tend","\tend","\treturn nil","end",""],"class":"function","name":"render_library.getScreenPos","summary":"\nReturns the screen surface's world position and angle ","private":false,"library":"render","description":"\nReturns the screen surface's world position and angle","param":[]},{"comment":["--- Creates a new render target to draw onto.","-- The dimensions will always be 1024x1024","-- @param name The name of the render target","-- @bug The drawing will be offset by 16 pixels to the left and 16 to the top and the resolution is actually 992x992. So drawing to 16,16 will draw in the top-left corner and 1007,1007 to the bottom-right."],"code":["function render_library.createRenderTarget ( name )","\tSF.CheckType( name, \"string\" )","","\tlocal data = SF.instance.data.render","\tdata.rendertargets = data.rendertargets or {}","\tdata.rendertargetcount = data.rendertargetcount or 0","","\tif data.rendertargetcount >= 2 then","\t\tSF.throw( \"Rendertarget limit reached\", 2 )","\tend","","\tdata.rendertargetcount = data.rendertargetcount + 1","\tlocal rtname, rt = findAvailableRT()","\tif not rt then","\t\tglobalRTcount = globalRTcount + 1","\t\trtname = \"Starfall_CustomRT_\" .. globalRTcount","\t\trt = { GetRenderTarget( rtname, 1024, 1024, false ) }","\t\tglobalRTs[ rtname ] = rt","\tend","\trt[ 2 ] = false","\tdata.rendertargets[ name ] = rtname","end",""],"class":"function","bug":"The drawing will be offset by 16 pixels to the left and 16 to the top and the resolution is actually 992x992. So drawing to 16,16 will draw in the top-left corner and 1007,1007 to the bottom-right.","name":"render_library.createRenderTarget","summary":"\nCreates a new render target to draw onto.","private":false,"library":"render","description":"\nCreates a new render target to draw onto. \nThe dimensions will always be 1024x1024","param":{"1":"name","name":"The name of the render target"}},{"comment":["--- Selects the render target to draw on.","-- Nil for the visible RT.","-- @param name Name of the render target to use"],"code":["function render_library.selectRenderTarget ( name )","\tlocal data = SF.instance.data.render","\tdata.oldRT = data.oldRT or render.GetRenderTarget()","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif not name then","\t\tif data.usingRT then","\t\t\tcam.End2D()","\t\t\trender.PopRenderTarget()","\t\t\tcam.Start2D()","\t\t\tdata.usingRT = false","\t\tend","\t\treturn","\tend","\tSF.CheckType( name, \"string\" )","\tlocal rt = globalRTs[ data.rendertargets[ name ] ][ 1 ]","\tif not rt then SF.Throw( \"Invalid Rendertarget\", 2 ) end","","\tcam.End2D()","\tif data.usingRT then","\t\trender.PopRenderTarget()","\tend","\trender.PushRenderTarget( rt, 0, 0, rt:Width(), rt:Height() )","\tcam.Start2D()","\tdata.usingRT = true","end",""],"class":"function","name":"render_library.selectRenderTarget","summary":"\nSelects the render target to draw on.","private":false,"library":"render","description":"\nSelects the render target to draw on. \nNil for the visible RT.","param":{"1":"name","name":"Name of the render target to use"}},{"comment":["--- Sets the active texture to the render target with the specified name.","-- Nil to reset.","-- @param name Name of the render target to use"],"code":["function render_library.setRenderTargetTexture ( name )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then SF.throw( \"Not in rendering hook.\", 2 ) end","\tif not name then","\t\tdraw.NoTexture()","\telse","\t\tSF.CheckType( name, \"string\" )","\t\tlocal rtname = data.rendertargets[ name ]","\t\tlocal rt = globalRTs[ rtname ][ 1 ]","\t\tlocal mat = globalRTs[ rtname ][ 2 ] or CreateMaterial( rtname, \"UnlitGeneric\", {","\t\t\t[ \"$nolod\" ] = 1,","\t\t\t[ \"$ignorez\" ] = 1,","\t\t\t[ \"$vertexcolor\" ] = 1,","\t\t\t[ \"$vertexalpha\" ] = 1","\t\t} )","\t\tmat:SetTexture( \"$basetexture\", rt )","\t\tsurface.SetMaterial( mat )","\tend","end",""],"class":"function","name":"render_library.setRenderTargetTexture","summary":"\nSets the active texture to the render target with the specified name.","private":false,"library":"render","description":"\nSets the active texture to the render target with the specified name. \nNil to reset.","param":{"1":"name","name":"Name of the render target to use"}},{"comment":["--- Dumps the current render target and allows the pixels to be accessed by render.readPixel."],"code":["function render_library.capturePixels ()","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\trender.CapturePixels()","end",""],"class":"function","name":"render_library.capturePixels","summary":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","private":false,"library":"render","description":"\nDumps the current render target and allows the pixels to be accessed by render.readPixel.","param":[]},{"ret":"Color object with ( r, g, b, 255 ) from the specified pixel.","comment":["--- Reads the color of the specified pixel.","-- @param x Pixel x-coordinate.","-- @param y Pixel y-coordinate.","-- @return Color object with ( r, g, b, 255 ) from the specified pixel."],"code":["function render_library.readPixel ( x, y )","\tlocal data = SF.instance.data.render","\tif not data.isRendering then","\t\tSF.throw( \"Not in rendering hook.\", 2 )","\tend","\t","\tSF.CheckType( x, \"number\" )","\tSF.CheckType( y, \"number\" )","","\tlocal r, g, b = render.ReadPixel( x, y )","\treturn SF.Color.Wrap( Color( r, g, b, 255 ) )","end",""],"class":"function","name":"render_library.readPixel","summary":"\nReads the color of the specified pixel.","private":false,"library":"render","description":"\nReads the color of the specified pixel.","param":{"1":"x","2":"y","y":"Pixel y-coordinate.","x":"Pixel x-coordinate."}},{"classForced":true,"summary":"\nCalled when a player uses the screen ","comment":["--- Called when a player uses the screen","-- @name starfallUsed","-- @class hook","-- @param activator Player using the screen"],"code":[""],"description":"\nCalled when a player uses the screen","class":"hook","name":"starfallUsed","param":{"1":"activator","activator":"Player using the screen"}},{"classForced":true,"summary":"\n ","comment":["---","-- @name Screen information table","-- @class table","-- @field Name Pretty name of model","-- @field offset Offset of screen from prop","-- @field RS Resolution/scale","-- @field RatioX Inverted Aspect ratio (height divided by width)","-- @field x1 Corner of screen in local coordinates (relative to offset?)","-- @field x2 Corner of screen in local coordinates (relative to offset?)","-- @field y1 Corner of screen in local coordinates (relative to offset?)","-- @field y2 Corner of screen in local coordinates (relative to offset?)","-- @field z Screen plane offset in local coordinates (relative to offset?)","-- @field rot Screen rotation"],"code":[],"description":"\n","class":"table","name":"Screen information table","field":{"1":"Name","2":"offset","3":"RS","4":"RatioX","5":"x1","6":"x2","7":"y1","8":"y2","9":"z","10":"rot","offset":"Offset of screen from prop","x2":"Corner of screen in local coordinates (relative to offset?)","y2":"Corner of screen in local coordinates (relative to offset?)","y1":"Corner of screen in local coordinates (relative to offset?)","RS":"Resolution/scale","Name":"Pretty name of model","z":"Screen plane offset in local coordinates (relative to offset?)","RatioX":"Inverted Aspect ratio (height divided by width)","rot":"Screen rotation","x1":"Corner of screen in local coordinates (relative to offset?)"}}],"tables":{"1":"Screen information table","2":"Vertex Format","Vertex Format":{"description":"\nVertex format","code":["","local render = render","local surface = surface","local clamp = math.Clamp","local max = math.max","local cam = cam","local dgetmeta = debug.getmetatable","local matrix_meta = SF.VMatrix.Metatable --debug.getregistry().VMatrix","","local v_unwrap = SF.VMatrix.Unwrap","","local currentcolor","local MATRIX_STACK_LIMIT = 8","local matrix_stack = {}","","local globalRTs = {}","local globalRTcount = 0","","SF.Libraries.AddHook( \"prepare\", function ( instance )","\tif hook == \"render\" then","\t\tcurrentcolor = Color(0,0,0,0)","\tend","end )","","SF.Libraries.AddHook( \"cleanup\", function ( instance )","\tfor i=#matrix_stack,1,-1 do","\t\tcam.PopModelMatrix()","\t\tmatrix_stack[i] = nil","\tend","end )","","SF.Libraries.AddHook( \"deinitialize\", function ( instance )","\tlocal data = instance.data.render","\tif data.rendertargets then","\t\tfor k, v in pairs( data.rendertargets ) do","\t\t\tglobalRTs[ v ][ 2 ] = true -- mark as available","\t\tend","\tend","end )",""],"class":"table","classForced":true,"name":"Vertex Format","summary":"\nVertex format ","field":{"1":"x","2":"y","3":"u","4":"v","y":"Y coordinate","x":"X coordinate","u":"U coordinate (optional, default is 0)","v":"V coordinate (optional, default is 0)"},"comment":["--- Vertex format","-- @name Vertex Format","-- @class table","-- @field x X coordinate","-- @field y Y coordinate","-- @field u U coordinate (optional, default is 0)","-- @field v V coordinate (optional, default is 0)"],"param":[]},"Screen information table":{"classForced":true,"summary":"\n ","comment":["---","-- @name Screen information table","-- @class table","-- @field Name Pretty name of model","-- @field offset Offset of screen from prop","-- @field RS Resolution/scale","-- @field RatioX Inverted Aspect ratio (height divided by width)","-- @field x1 Corner of screen in local coordinates (relative to offset?)","-- @field x2 Corner of screen in local coordinates (relative to offset?)","-- @field y1 Corner of screen in local coordinates (relative to offset?)","-- @field y2 Corner of screen in local coordinates (relative to offset?)","-- @field z Screen plane offset in local coordinates (relative to offset?)","-- @field rot Screen rotation"],"code":[],"description":"\n","class":"table","name":"Screen information table","field":{"1":"Name","2":"offset","3":"RS","4":"RatioX","5":"x1","6":"x2","7":"y1","8":"y2","9":"z","10":"rot","offset":"Offset of screen from prop","x2":"Corner of screen in local coordinates (relative to offset?)","y2":"Corner of screen in local coordinates (relative to offset?)","y1":"Corner of screen in local coordinates (relative to offset?)","RS":"Resolution/scale","Name":"Pretty name of model","z":"Screen plane offset in local coordinates (relative to offset?)","RatioX":"Inverted Aspect ratio (height divided by width)","rot":"Screen rotation","x1":"Corner of screen in local coordinates (relative to offset?)"}}},"description":"\n \nRender library \n","summary":"\n \nRender library \n "},"libs_sv/entities.lua":{"libraries":[],"type":"file","name":"libs_sv/entities.lua","functions":{"1":"SF.Entities.GetOwner","2":"ents_methods:addCollisionListener","3":"ents_methods:applyAngForce","4":"ents_methods:applyDamage","5":"ents_methods:applyForceCenter","6":"ents_methods:applyForceOffset","7":"ents_methods:applyTorque","8":"ents_methods:destroy","9":"ents_methods:emitSound","10":"ents_methods:enableDrag","11":"ents_methods:enableGravity","12":"ents_methods:enableMotion","13":"ents_methods:getOwner","14":"ents_methods:isFrozen","15":"ents_methods:isWeldedTo","16":"ents_methods:remove","17":"ents_methods:setAngles","18":"ents_methods:setBodygroup","19":"ents_methods:setColor","20":"ents_methods:setFrozen","21":"ents_methods:setMass","22":"ents_methods:setMaterial","23":"ents_methods:setNoDraw","24":"ents_methods:setParent","25":"ents_methods:setPos","26":"ents_methods:setSkin","27":"ents_methods:setSolid","28":"ents_methods:setSubMaterial","29":"ents_methods:setVelocity","30":"ents_methods:unparent","ents_methods:destroy":{"comment":["--- Breaks an entity"],"code":["function ents_methods:destroy ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Fire( \"break\", 1, 0 )","end",""],"class":"function","name":"ents_methods:destroy","summary":"\nBreaks an entity ","private":false,"classlib":"Entity","description":"\nBreaks an entity","param":[]},"ents_methods:applyForceOffset":{"comment":["--- Applies linear force to the entity with an offset","-- @param vec The force vector","-- @param offset An optional offset position"],"code":["function ents_methods:applyForceOffset ( vec, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal offset = vunwrap( offset )","","\tif not check( vec ) or not check( offset ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceOffset( vec, offset )","end",""],"class":"function","name":"ents_methods:applyForceOffset","summary":"\nApplies linear force to the entity with an offset ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity with an offset","param":{"1":"vec","2":"offset","vec":"The force vector","offset":"An optional offset position"}},"ents_methods:getOwner":{"ret":"Owner","comment":["--- Gets the owner of the entity","-- @return Owner"],"code":["function ents_methods:getOwner ()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\treturn wrap( getOwner( ent ) )","end","","local function check ( v )","\treturn \t-math.huge < v.x and v.x < math.huge and","\t\t\t-math.huge < v.y and v.y < math.huge and","\t\t\t-math.huge < v.z and v.z < math.huge","end","","local function parent_check ( child, parent )","\twhile isValid( parent ) do","\t\tif child == parent then","\t\t\treturn false","\t\tend","\t\tparent = parent:GetParent()","\tend","\treturn true","end",""],"class":"function","name":"ents_methods:getOwner","summary":"\nGets the owner of the entity ","private":false,"classlib":"Entity","description":"\nGets the owner of the entity","param":[]},"ents_methods:applyAngForce":{"comment":["--- Applies angular force to the entity","-- @param ang The force angle"],"code":["function ents_methods:applyAngForce ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t-- assign vectors","\tlocal up = ent:GetUp()","\tlocal left = ent:GetRight() * -1","\tlocal forward = ent:GetForward()","","\t-- apply pitch force","\tif ang.p ~= 0 then","\t\tlocal pitch = up * ( ang.p * 0.5 )","\t\tphys:ApplyForceOffset( forward, pitch )","\t\tphys:ApplyForceOffset( forward * -1, pitch * -1 )","\tend","","\t-- apply yaw force","\tif ang.y ~= 0 then","\t\tlocal yaw = forward * ( ang.y * 0.5 )","\t\tphys:ApplyForceOffset( left, yaw )","\t\tphys:ApplyForceOffset( left * -1, yaw * -1 )","\tend","","\t-- apply roll force","\tif ang.r ~= 0 then","\t\tlocal roll = left * ( ang.r * 0.5 )","\t\tphys:ApplyForceOffset( up, roll )","\t\tphys:ApplyForceOffset( up * -1, roll * -1 )","\tend","end",""],"class":"function","name":"ents_methods:applyAngForce","summary":"\nApplies angular force to the entity ","private":false,"classlib":"Entity","description":"\nApplies angular force to the entity","param":{"1":"ang","ang":"The force angle"}},"ents_methods:isWeldedTo":{"comment":["--- Gets what the entity is welded to"],"code":["function ents_methods:isWeldedTo ()","\tlocal this = unwrap( self )","\tif not constraint.HasConstraints( this ) then return nil end","","\treturn wrap( ent1or2( this, constraint.FindConstraint( this, \"Weld\" ) ) )","end"],"class":"function","name":"ents_methods:isWeldedTo","summary":"\nGets what the entity is welded to ","private":false,"classlib":"Entity","description":"\nGets what the entity is welded to","param":[]},"ents_methods:enableMotion":{"comment":["--- Sets the entity movement state","-- @param move Bool should the entity move?"],"code":["function ents_methods:enableMotion ( move )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( move and true or false )","\tphys:Wake()","end","","","local function ent1or2 ( ent, con, num )","\tif not con then return nil end","\tif num then","\t\tcon = con[ num ]","\t\tif not con then return nil end","\tend","\tif con.Ent1 == ent then return con.Ent2 end","\treturn con.Ent1","end",""],"class":"function","name":"ents_methods:enableMotion","summary":"\nSets the entity movement state ","private":false,"classlib":"Entity","description":"\nSets the entity movement state","param":{"1":"move","move":"Bool should the entity move?"}},"ents_methods:enableDrag":{"comment":["--- Sets the entity drag state","-- @param drag Bool should the entity have air resistence?"],"code":["function ents_methods:enableDrag ( drag )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableDrag\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableDrag( drag and true or false )","end",""],"class":"function","name":"ents_methods:enableDrag","summary":"\nSets the entity drag state ","private":false,"classlib":"Entity","description":"\nSets the entity drag state","param":{"1":"drag","drag":"Bool should the entity have air resistence?"}},"ents_methods:isFrozen":{"ret":"True if entity is frozen","comment":["--- Checks the entities frozen state","-- @return True if entity is frozen"],"code":["function ents_methods:isFrozen ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = ent:GetPhysicsObject()","\tif phys:IsMoveable() then return false else return true end","end",""],"class":"function","name":"ents_methods:isFrozen","summary":"\nChecks the entities frozen state ","private":false,"classlib":"Entity","description":"\nChecks the entities frozen state","param":[]},"ents_methods:setMass":{"comment":["--- Sets the entity's mass","-- @param mass number mass"],"code":["function ents_methods:setMass ( mass )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetMass( math.Clamp(mass, 1, 50000) )","end",""],"class":"function","name":"ents_methods:setMass","summary":"\nSets the entity's mass ","private":false,"classlib":"Entity","description":"\nSets the entity's mass","param":{"1":"mass","mass":"number mass"}},"ents_methods:setSolid":{"comment":["--- Sets the entity to be Solid or not.","-- For more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","-- @param solid Boolean, Should the entity be solid?"],"code":["function ents_methods:setSolid ( solid )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:SetNotSolid( not solid )","end",""],"class":"function","name":"ents_methods:setSolid","summary":"\nSets the entity to be Solid or not.","private":false,"classlib":"Entity","description":"\nSets the entity to be Solid or not. \nFor more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","param":{"1":"solid","solid":"Boolean, Should the entity be solid?"}},"ents_methods:enableGravity":{"comment":["--- Sets entity gravity","-- @param grav Bool should the entity respect gravity?"],"code":["function ents_methods:enableGravity ( grav )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableGravity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableGravity( grav and true or false )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:enableGravity","summary":"\nSets entity gravity ","private":false,"classlib":"Entity","description":"\nSets entity gravity","param":{"1":"grav","grav":"Bool should the entity respect gravity?"}},"ents_methods:addCollisionListener":{"comment":["--- Allows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","-- @param func The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"],"code":["function ents_methods:addCollisionListener ( func )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( func, \"function\" )","\tlocal ent = unwrap( self )","\tif ent.SF_CollisionCallback then SF.throw( \"The entity is already listening to collisions!\", 2 ) end","\tent.SF_CollisionCallback = true","","\tlocal instance = SF.instance","\tent:AddCallback(\"PhysicsCollide\", function(ent, data)","\t\tlocal ok, msg, traceback = instance:runFunction( func, setmetatable({}, {","\t\t\t__index=function(t,k)","\t\t\t\treturn SF.WrapObject( data[k] )","\t\t\tend,","\t\t\t__metatable={}","\t\t}))","","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend)","end","","util.AddNetworkString( \"sf_setentityrenderproperty\" )","","local renderProperties = {","\t[1] = function( clr ) --Color","\t\tnet.WriteUInt( clr.r, 8 )","\t\tnet.WriteUInt( clr.g, 8 )","\t\tnet.WriteUInt( clr.b, 8 )","\t\tnet.WriteUInt( clr.a, 8 )","\tend,","\t[2] = function( draw ) --Nodraw","\t\tnet.WriteBit( draw )","\tend,","\t[3] = function( material ) --Material","\t\tnet.WriteString( material )","\tend,","\t[4] = function( index, material ) --Submaterial","\t\tnet.WriteUInt( index, 16 )","\t\tnet.WriteString( material )","\tend,","\t[5] = function( bodygroup, value ) --Bodygroup","\t\tnet.WriteUInt( bodygroup, 16 )","\t\tnet.WriteUInt( value, 16 )","\tend,","\t[6] = function( skin ) --Skin","\t\tnet.WriteUInt( skin, 16 )","\tend","}","","local function sendRenderPropertyToClient( ply, ent, func, ... )","\tSF.CheckType( ply, SF.Types[ \"Player\" ] )","\tply = unwrap( ply )","\tif isValid( ply ) and ply:IsPlayer() then","\t\tnet.Start( \"sf_setentityrenderproperty\" )","\t\tnet.WriteEntity( ent )","\t\tnet.WriteUInt( func, 4 )","\t\trenderProperties[ func ]( ... )","\t\tnet.Send( ply )","\tend","end",""],"class":"function","name":"ents_methods:addCollisionListener","summary":"\nAllows detecting collisions on an entity.","private":false,"classlib":"Entity","description":"\nAllows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","param":{"1":"func","func":"The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"}},"ents_methods:setAngles":{"comment":["--- Sets the entity's angles","-- @param ang New angles"],"code":["function ents_methods:setAngles ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setAngles\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setAng( ent, ang )","end",""],"class":"function","name":"ents_methods:setAngles","summary":"\nSets the entity's angles ","private":false,"classlib":"Entity","description":"\nSets the entity's angles","param":{"1":"ang","ang":"New angles"}},"ents_methods:setFrozen":{"comment":["--- Sets the entity frozen state","-- @param freeze Should the entity be frozen?"],"code":["function ents_methods:setFrozen ( freeze )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setFrozen\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( not ( freeze and true or false ) )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:setFrozen","summary":"\nSets the entity frozen state ","private":false,"classlib":"Entity","description":"\nSets the entity frozen state","param":{"1":"freeze","freeze":"Should the entity be frozen?"}},"ents_methods:remove":{"comment":["--- Removes an entity"],"code":["function ents_methods:remove ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not ent:IsValid() or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Remove()","end",""],"class":"function","name":"ents_methods:remove","summary":"\nRemoves an entity ","private":false,"classlib":"Entity","description":"\nRemoves an entity","param":[]},"ents_methods:setColor":{"comment":["--- Sets the color of the entity","-- @server","-- @param clr New color","-- @param ply Optional player arguement to set the entity's color only for that player"],"code":["function ents_methods:setColor ( clr, ply )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 1, clr )","\telse","\t\tent:SetColor( clr )","\t\tent:SetRenderMode( clr.a == 255 and RENDERMODE_NORMAL or RENDERMODE_TRANSALPHA )","\tend","","end",""],"class":"function","summary":"\nSets the color of the entity ","name":"ents_methods:setColor","classlib":"Entity","private":false,"server":true,"description":"\nSets the color of the entity","param":{"1":"clr","2":"ply","clr":"New color","ply":"Optional player arguement to set the entity's color only for that player"}},"SF.Entities.GetOwner":{"ret":"The entities owner, or nil if not found","comment":["--- Gets the entity's owner","-- TODO: Optimize this!","-- @return The entities owner, or nil if not found"],"code":["function SF.Entities.GetOwner ( entity )","\tif not isValid( entity ) then return end","","\tif entity.IsPlayer and entity:IsPlayer() then","\t\treturn entity","\tend","","\tif CPPI then","\t\tlocal owner = entity:CPPIGetOwner()","\t\tif isValid( owner ) then return owner end","\tend","","\tif entity.GetPlayer then","\t\tlocal ply = entity:GetPlayer()","\t\tif isValid( ply ) then return ply end","\tend","","\tif entity.owner and isValid( entity.owner ) and entity.owner:IsPlayer() then","\t\treturn entity.owner","\tend","","\tlocal OnDieFunctions = entity.OnDieFunctions","\tif OnDieFunctions then","\t\tif OnDieFunctions.GetCountUpdate and OnDieFunctions.GetCountUpdate.Args and OnDieFunctions.GetCountUpdate.Args[ 1 ] then","\t\t\treturn OnDieFunctions.GetCountUpdate.Args[ 1 ]","\t\telseif OnDieFunctions.undo1 and OnDieFunctions.undo1.Args and OnDieFunctions.undo1.Args[2] then","\t\t\treturn OnDieFunctions.undo1.Args[ 2 ]","\t\tend","\tend","","\tif entity.GetOwner then","\t\tlocal ply = entity:GetOwner()","\t\tif isValid( ply ) then return ply end","\tend","","\treturn nil","end","","local getPhysObject = SF.Entities.GetPhysObject","local getOwner = SF.Entities.GetOwner",""],"class":"function","name":"SF.Entities.GetOwner","private":false,"summary":"\nGets the entity's owner \nTODO: Optimize this! ","description":"\nGets the entity's owner \nTODO: Optimize this!","param":["entity"]},"ents_methods:setMaterial":{"comment":["--- Sets an entities' material","-- @server","-- @class function","-- @param material, string, New material name.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setMaterial ( material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if materialBlacklist[ material:lower() ] then SF.throw( \"This material has been blacklisted\", 2 ) end","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 3, material )","\telse","\t\tent:SetMaterial( material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' material ","name":"ents_methods:setMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' material","param":{"1":"material","2":"ply","ply":"Optional player arguement to set material of an entity only for that player","material":", string, New material name."}},"ents_methods:setSubMaterial":{"comment":["--- Sets an entities' submaterial","-- @server","-- @class function","-- @param index, number, submaterial index.","-- @param material, string, New material name.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setSubMaterial ( index, material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if materialBlacklist[ material:lower() ] then SF.throw( \"This material has been blacklisted\", 2 ) end","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 4, index, material )","\telse","\t\tent:SetSubMaterial( index, material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' submaterial ","name":"ents_methods:setSubMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' submaterial","param":{"1":"index","2":"material","3":"ply","material":", string, New material name.","index":", number, submaterial index.","ply":"Optional player arguement to set material of an entity only for that player"}},"ents_methods:setSkin":{"comment":["--- Sets the skin of the entity","-- @server","-- @class function","-- @param skinIndex Number, Index of the skin to use.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setSkin ( skinIndex, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( skinIndex, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 6, skinIndex )","\telse","\t\tent:SetSkin( skinIndex )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the skin of the entity ","name":"ents_methods:setSkin","classlib":"Entity","private":false,"server":true,"description":"\nSets the skin of the entity","param":{"1":"skinIndex","2":"ply","skinIndex":"Number, Index of the skin to use.","ply":"Optional player arguement to set material of an entity only for that player"}},"ents_methods:applyForceCenter":{"comment":["--- Applies linear force to the entity","-- @param vec The force vector"],"code":["function ents_methods:applyForceCenter ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","\tif not check( vec ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceCenter( vec )","end",""],"class":"function","name":"ents_methods:applyForceCenter","summary":"\nApplies linear force to the entity ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity","param":{"1":"vec","vec":"The force vector"}},"ents_methods:applyTorque":{"comment":["--- Applies torque","-- @param tq The torque vector","-- @param offset Optional offset position"],"code":["function ents_methods:applyTorque ( tq, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( tq, SF.Types[ \"Vector\" ] )","","\tlocal tq = vunwrap( tq )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal torqueamount = tq:Length()","","\tif offset then","\t\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","\t\toffset = vunwrap( offset )","\telse","\t\toffset = phys:GetPos()","\tend","\t-- Convert torque from local to world axis","\ttq = phys:LocalToWorld( tq ) - offset","","\t-- Find two vectors perpendicular to the torque axis","\tlocal off","\tif abs( tq.x ) > torqueamount * 0.1 or abs( tq.z ) > torqueamount * 0.1 then","\t\toff = Vector( -tq.z, 0, tq.x )","\telse","\t\toff = Vector( -tq.y, tq.x, 0 )","\tend","\toff = off:GetNormal() * torqueamount * 0.5","","\tlocal dir = ( tq:Cross( off ) ):GetNormal()","","\tif not check( dir ) or not check( off ) then SF.throw( \"infinite vector\", 2) end","","\tphys:ApplyForceOffset( dir, off )","\tphys:ApplyForceOffset( dir * -1, off * -1 )","end",""],"class":"function","name":"ents_methods:applyTorque","summary":"\nApplies torque ","private":false,"classlib":"Entity","description":"\nApplies torque","param":{"1":"tq","2":"offset","offset":"Optional offset position","tq":"The torque vector"}},"ents_methods:unparent":{"comment":["--- Unparents the entity from another entity"],"code":["function ents_methods:unparent ()","\tlocal this = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.unparent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tthis:SetParent( nil )","end",""],"class":"function","name":"ents_methods:unparent","summary":"\nUnparents the entity from another entity ","private":false,"classlib":"Entity","description":"\nUnparents the entity from another entity","param":[]},"ents_methods:setBodygroup":{"comment":["--- Sets an entities' bodygroup","-- @server","-- @class function","-- @param bodygroup Number, The ID of the bodygroup you're setting.","-- @param value Number, The value you're setting the bodygroup to.","-- @param ply Optional player arguement to set bodygroup of an entity only for that player"],"code":["function ents_methods:setBodygroup ( bodygroup, value, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( bodygroup, \"number\" )","    SF.CheckType( value, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 5, bodygroup, value )","\telse","\t\tent:SetBodyGroup( bodygroup, value )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' bodygroup ","name":"ents_methods:setBodygroup","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' bodygroup","param":{"1":"bodygroup","2":"value","3":"ply","value":"Number, The value you're setting the bodygroup to.","ply":"Optional player arguement to set bodygroup of an entity only for that player","bodygroup":"Number, The ID of the bodygroup you're setting."}},"ents_methods:setPos":{"comment":["--- Sets the entitiy's position","-- @param vec New position"],"code":["function ents_methods:setPos ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setPos\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setPos( ent, vec )","end",""],"class":"function","name":"ents_methods:setPos","summary":"\nSets the entitiy's position ","private":false,"classlib":"Entity","description":"\nSets the entitiy's position","param":{"1":"vec","vec":"New position"}},"ents_methods:emitSound":{"comment":["--- Plays a sound on the entity","-- @param snd string Sound path","-- @param lvl number soundLevel=75","-- @param pitch pitchPercent=100","-- @param volume volume=1","-- @param channel channel=CHAN_AUTO"],"code":["function ents_methods:emitSound ( snd, lvl, pitch, volume, channel )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( snd, \"string\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.emitSound\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:EmitSound(snd, lvl, pitch, volume, channel)","end",""],"class":"function","name":"ents_methods:emitSound","summary":"\nPlays a sound on the entity ","private":false,"classlib":"Entity","description":"\nPlays a sound on the entity","param":{"1":"snd","2":"lvl","3":"pitch","4":"volume","5":"channel","pitch":"pitchPercent=100","snd":"string Sound path","lvl":"number soundLevel=75","channel":"channel=CHAN_AUTO","volume":"volume=1"}},"ents_methods:setParent":{"comment":["--- Parents the entity to another entity","-- @param ent Entity to parent to"],"code":["function ents_methods:setParent ( ent )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( ent )","\tlocal this = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif not parent_check( this, ent ) then SF.throw( \"Cannot parent to self\", 2 ) end","","\tthis:SetParent( ent )","end",""],"class":"function","name":"ents_methods:setParent","summary":"\nParents the entity to another entity ","private":false,"classlib":"Entity","description":"\nParents the entity to another entity","param":{"1":"ent","ent":"Entity to parent to"}},"ents_methods:setNoDraw":{"comment":["--- Sets the whether an entity should be drawn or not","-- @server","-- @param draw Whether to draw the entity or not.","-- @param ply Optional player arguement to set drawing of an entity only for that player"],"code":["function ents_methods:setNoDraw ( draw, ply )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 2, draw and true or false )","\telse","\t\tent:SetNoDraw( draw and true or false )","\tend","end","","local materialBlacklist = {","\t[ \"pp/copy\" ] = true","}",""],"class":"function","summary":"\nSets the whether an entity should be drawn or not ","name":"ents_methods:setNoDraw","classlib":"Entity","private":false,"server":true,"description":"\nSets the whether an entity should be drawn or not","param":{"1":"draw","2":"ply","draw":"Whether to draw the entity or not.","ply":"Optional player arguement to set drawing of an entity only for that player"}},"ents_methods:setVelocity":{"comment":["--- Sets the entity's linear velocity","-- @param vel New velocity"],"code":["function ents_methods:setVelocity ( vel )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","","\tlocal vel = vunwrap( vel )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setVelocity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetVelocity( vel )","end",""],"class":"function","name":"ents_methods:setVelocity","summary":"\nSets the entity's linear velocity ","private":false,"classlib":"Entity","description":"\nSets the entity's linear velocity","param":{"1":"vel","vel":"New velocity"}},"ents_methods:applyDamage":{"comment":["--- Applies damage to an entity","-- @param amt damage amount","-- @param attacker damage attacker","-- @param inflictor damage inflictor"],"code":["function ents_methods:applyDamage( amt, attacker, inflictor )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( amt, \"number\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyDamage\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif attacker then","\t\tSF.CheckType( attacker, ents_metatable )","\t\tattacker = unwrap( attacker )","\t\tif not isValid( attacker ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","\tif inflictor then","\t\tSF.CheckType( inflictor, ents_metatable )","\t\tinflictor = unwrap( inflictor )","\t\tif not isValid( inflictor ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","","\tent:TakeDamage( amt, attacker, inflictor )","end","",""],"class":"function","name":"ents_methods:applyDamage","summary":"\nApplies damage to an entity ","private":false,"classlib":"Entity","description":"\nApplies damage to an entity","param":{"1":"amt","2":"attacker","3":"inflictor","inflictor":"damage inflictor","attacker":"damage attacker","amt":"damage amount"}}},"doc":[{"comment":["-------------------------------------------------------------------------------","-- Serverside Entity functions","-------------------------------------------------------------------------------"],"code":["","assert( SF.Entities )","","local huge = math.huge","local abs = math.abs","","local ents_lib = SF.Entities.Library","local ents_metatable = SF.Entities.Metatable",""],"summary":"\n \nServerside Entity functions \n ","description":"\n \nServerside Entity functions \n","param":[]},{"description":"\nEntity type","code":["local ents_methods = SF.Entities.Methods","local wrap, unwrap = SF.Entities.Wrap, SF.Entities.Unwrap","local vunwrap = SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"entities.parent\", \"Parent\", \"Allows the user to parent an entity to another entity\" )","\tP.registerPrivilege( \"entities.unparent\", \"Unparent\", \"Allows the user to remove the parent of an entity\" ) -- TODO: maybe merge with entities.parent?","\tP.registerPrivilege( \"entities.applyForce\", \"Apply force\", \"Allows the user to apply force to an entity\" )","\tP.registerPrivilege( \"entities.applyDamage\", \"Apply damage\", \"Allows the user to apply damage to an entity\" )","\tP.registerPrivilege( \"entities.setPos\", \"Set Position\", \"Allows the user to teleport an entity to another location\" )","\tP.registerPrivilege( \"entities.setAngles\", \"Set Angles\", \"Allows the user to teleport an entity to another orientation\" )","\tP.registerPrivilege( \"entities.setVelocity\", \"Set Velocity\", \"Allows the user to change the velocity of an entity\" )","\tP.registerPrivilege( \"entities.setFrozen\", \"Set Frozen\", \"Allows the user to freeze and unfreeze an entity\" )","\tP.registerPrivilege( \"entities.setSolid\", \"Set Solid\", \"Allows the user to change the solidity of an entity\" )","\tP.registerPrivilege( \"entities.setMass\", \"Set Mass\", \"Allows the user to change the mass of an entity\" )","\tP.registerPrivilege( \"entities.enableGravity\", \"Enable gravity\", \"Allows the user to change whether an entity is affected by gravity\" )","\tP.registerPrivilege( \"entities.enableMotion\", \"Set Motion\", \"Allows the user to disable an entity's motion\" )","\tP.registerPrivilege( \"entities.enableDrag\", \"Set Drag\", \"Allows the user to disable an entity's air resistence\" )","\tP.registerPrivilege( \"entities.remove\", \"Remove\", \"Allows the user to remove entities\" )","\tP.registerPrivilege( \"entities.emitSound\", \"Emitsound\", \"Allows the user to play sounds on entities\" )","\tP.registerPrivilege( \"entities.setRenderPropery\", \"RenderProperty\", \"Allows the user to change the rendering of an entity\" )","end","","local function fix_nan ( v )","\tif v < huge and v > -huge then return v else return 0 end","end","","local isValid = SF.Entities.IsValid","","-- ------------------------- Internal Library ------------------------- --",""],"class":"class","classForced":true,"fields":[],"name":"Entity","summary":"\nEntity type ","methods":{"1":"getOwner","2":"setParent","3":"unparent","4":"emitSound","5":"applyDamage","6":"applyForceCenter","7":"applyForceOffset","8":"applyAngForce","9":"applyTorque","10":"addCollisionListener","11":"setColor","12":"setNoDraw","13":"setMaterial","14":"setSubMaterial","15":"setBodygroup","16":"setSkin","17":"setPos","18":"setAngles","19":"setVelocity","20":"remove","21":"destroy","22":"setFrozen","23":"isFrozen","24":"setSolid","25":"setMass","26":"enableGravity","27":"enableDrag","28":"enableMotion","29":"isWeldedTo","getOwner":{"ret":"Owner","comment":["--- Gets the owner of the entity","-- @return Owner"],"code":["function ents_methods:getOwner ()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\treturn wrap( getOwner( ent ) )","end","","local function check ( v )","\treturn \t-math.huge < v.x and v.x < math.huge and","\t\t\t-math.huge < v.y and v.y < math.huge and","\t\t\t-math.huge < v.z and v.z < math.huge","end","","local function parent_check ( child, parent )","\twhile isValid( parent ) do","\t\tif child == parent then","\t\t\treturn false","\t\tend","\t\tparent = parent:GetParent()","\tend","\treturn true","end",""],"class":"function","name":"ents_methods:getOwner","summary":"\nGets the owner of the entity ","private":false,"classlib":"Entity","description":"\nGets the owner of the entity","param":[]},"isWeldedTo":{"comment":["--- Gets what the entity is welded to"],"code":["function ents_methods:isWeldedTo ()","\tlocal this = unwrap( self )","\tif not constraint.HasConstraints( this ) then return nil end","","\treturn wrap( ent1or2( this, constraint.FindConstraint( this, \"Weld\" ) ) )","end"],"class":"function","name":"ents_methods:isWeldedTo","summary":"\nGets what the entity is welded to ","private":false,"classlib":"Entity","description":"\nGets what the entity is welded to","param":[]},"setSubMaterial":{"comment":["--- Sets an entities' submaterial","-- @server","-- @class function","-- @param index, number, submaterial index.","-- @param material, string, New material name.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setSubMaterial ( index, material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if materialBlacklist[ material:lower() ] then SF.throw( \"This material has been blacklisted\", 2 ) end","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 4, index, material )","\telse","\t\tent:SetSubMaterial( index, material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' submaterial ","name":"ents_methods:setSubMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' submaterial","param":{"1":"index","2":"material","3":"ply","material":", string, New material name.","index":", number, submaterial index.","ply":"Optional player arguement to set material of an entity only for that player"}},"setMaterial":{"comment":["--- Sets an entities' material","-- @server","-- @class function","-- @param material, string, New material name.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setMaterial ( material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if materialBlacklist[ material:lower() ] then SF.throw( \"This material has been blacklisted\", 2 ) end","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 3, material )","\telse","\t\tent:SetMaterial( material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' material ","name":"ents_methods:setMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' material","param":{"1":"material","2":"ply","ply":"Optional player arguement to set material of an entity only for that player","material":", string, New material name."}},"enableMotion":{"comment":["--- Sets the entity movement state","-- @param move Bool should the entity move?"],"code":["function ents_methods:enableMotion ( move )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( move and true or false )","\tphys:Wake()","end","","","local function ent1or2 ( ent, con, num )","\tif not con then return nil end","\tif num then","\t\tcon = con[ num ]","\t\tif not con then return nil end","\tend","\tif con.Ent1 == ent then return con.Ent2 end","\treturn con.Ent1","end",""],"class":"function","name":"ents_methods:enableMotion","summary":"\nSets the entity movement state ","private":false,"classlib":"Entity","description":"\nSets the entity movement state","param":{"1":"move","move":"Bool should the entity move?"}},"applyForceOffset":{"comment":["--- Applies linear force to the entity with an offset","-- @param vec The force vector","-- @param offset An optional offset position"],"code":["function ents_methods:applyForceOffset ( vec, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal offset = vunwrap( offset )","","\tif not check( vec ) or not check( offset ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceOffset( vec, offset )","end",""],"class":"function","name":"ents_methods:applyForceOffset","summary":"\nApplies linear force to the entity with an offset ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity with an offset","param":{"1":"vec","2":"offset","vec":"The force vector","offset":"An optional offset position"}},"setPos":{"comment":["--- Sets the entitiy's position","-- @param vec New position"],"code":["function ents_methods:setPos ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setPos\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setPos( ent, vec )","end",""],"class":"function","name":"ents_methods:setPos","summary":"\nSets the entitiy's position ","private":false,"classlib":"Entity","description":"\nSets the entitiy's position","param":{"1":"vec","vec":"New position"}},"enableDrag":{"comment":["--- Sets the entity drag state","-- @param drag Bool should the entity have air resistence?"],"code":["function ents_methods:enableDrag ( drag )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableDrag\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableDrag( drag and true or false )","end",""],"class":"function","name":"ents_methods:enableDrag","summary":"\nSets the entity drag state ","private":false,"classlib":"Entity","description":"\nSets the entity drag state","param":{"1":"drag","drag":"Bool should the entity have air resistence?"}},"enableGravity":{"comment":["--- Sets entity gravity","-- @param grav Bool should the entity respect gravity?"],"code":["function ents_methods:enableGravity ( grav )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableGravity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableGravity( grav and true or false )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:enableGravity","summary":"\nSets entity gravity ","private":false,"classlib":"Entity","description":"\nSets entity gravity","param":{"1":"grav","grav":"Bool should the entity respect gravity?"}},"setMass":{"comment":["--- Sets the entity's mass","-- @param mass number mass"],"code":["function ents_methods:setMass ( mass )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetMass( math.Clamp(mass, 1, 50000) )","end",""],"class":"function","name":"ents_methods:setMass","summary":"\nSets the entity's mass ","private":false,"classlib":"Entity","description":"\nSets the entity's mass","param":{"1":"mass","mass":"number mass"}},"unparent":{"comment":["--- Unparents the entity from another entity"],"code":["function ents_methods:unparent ()","\tlocal this = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.unparent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tthis:SetParent( nil )","end",""],"class":"function","name":"ents_methods:unparent","summary":"\nUnparents the entity from another entity ","private":false,"classlib":"Entity","description":"\nUnparents the entity from another entity","param":[]},"applyForceCenter":{"comment":["--- Applies linear force to the entity","-- @param vec The force vector"],"code":["function ents_methods:applyForceCenter ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","\tif not check( vec ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceCenter( vec )","end",""],"class":"function","name":"ents_methods:applyForceCenter","summary":"\nApplies linear force to the entity ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity","param":{"1":"vec","vec":"The force vector"}},"setSolid":{"comment":["--- Sets the entity to be Solid or not.","-- For more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","-- @param solid Boolean, Should the entity be solid?"],"code":["function ents_methods:setSolid ( solid )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:SetNotSolid( not solid )","end",""],"class":"function","name":"ents_methods:setSolid","summary":"\nSets the entity to be Solid or not.","private":false,"classlib":"Entity","description":"\nSets the entity to be Solid or not. \nFor more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","param":{"1":"solid","solid":"Boolean, Should the entity be solid?"}},"destroy":{"comment":["--- Breaks an entity"],"code":["function ents_methods:destroy ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Fire( \"break\", 1, 0 )","end",""],"class":"function","name":"ents_methods:destroy","summary":"\nBreaks an entity ","private":false,"classlib":"Entity","description":"\nBreaks an entity","param":[]},"setVelocity":{"comment":["--- Sets the entity's linear velocity","-- @param vel New velocity"],"code":["function ents_methods:setVelocity ( vel )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","","\tlocal vel = vunwrap( vel )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setVelocity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetVelocity( vel )","end",""],"class":"function","name":"ents_methods:setVelocity","summary":"\nSets the entity's linear velocity ","private":false,"classlib":"Entity","description":"\nSets the entity's linear velocity","param":{"1":"vel","vel":"New velocity"}},"isFrozen":{"ret":"True if entity is frozen","comment":["--- Checks the entities frozen state","-- @return True if entity is frozen"],"code":["function ents_methods:isFrozen ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = ent:GetPhysicsObject()","\tif phys:IsMoveable() then return false else return true end","end",""],"class":"function","name":"ents_methods:isFrozen","summary":"\nChecks the entities frozen state ","private":false,"classlib":"Entity","description":"\nChecks the entities frozen state","param":[]},"applyDamage":{"comment":["--- Applies damage to an entity","-- @param amt damage amount","-- @param attacker damage attacker","-- @param inflictor damage inflictor"],"code":["function ents_methods:applyDamage( amt, attacker, inflictor )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( amt, \"number\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyDamage\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif attacker then","\t\tSF.CheckType( attacker, ents_metatable )","\t\tattacker = unwrap( attacker )","\t\tif not isValid( attacker ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","\tif inflictor then","\t\tSF.CheckType( inflictor, ents_metatable )","\t\tinflictor = unwrap( inflictor )","\t\tif not isValid( inflictor ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","","\tent:TakeDamage( amt, attacker, inflictor )","end","",""],"class":"function","name":"ents_methods:applyDamage","summary":"\nApplies damage to an entity ","private":false,"classlib":"Entity","description":"\nApplies damage to an entity","param":{"1":"amt","2":"attacker","3":"inflictor","inflictor":"damage inflictor","attacker":"damage attacker","amt":"damage amount"}},"emitSound":{"comment":["--- Plays a sound on the entity","-- @param snd string Sound path","-- @param lvl number soundLevel=75","-- @param pitch pitchPercent=100","-- @param volume volume=1","-- @param channel channel=CHAN_AUTO"],"code":["function ents_methods:emitSound ( snd, lvl, pitch, volume, channel )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( snd, \"string\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.emitSound\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:EmitSound(snd, lvl, pitch, volume, channel)","end",""],"class":"function","name":"ents_methods:emitSound","summary":"\nPlays a sound on the entity ","private":false,"classlib":"Entity","description":"\nPlays a sound on the entity","param":{"1":"snd","2":"lvl","3":"pitch","4":"volume","5":"channel","pitch":"pitchPercent=100","snd":"string Sound path","lvl":"number soundLevel=75","channel":"channel=CHAN_AUTO","volume":"volume=1"}},"addCollisionListener":{"comment":["--- Allows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","-- @param func The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"],"code":["function ents_methods:addCollisionListener ( func )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( func, \"function\" )","\tlocal ent = unwrap( self )","\tif ent.SF_CollisionCallback then SF.throw( \"The entity is already listening to collisions!\", 2 ) end","\tent.SF_CollisionCallback = true","","\tlocal instance = SF.instance","\tent:AddCallback(\"PhysicsCollide\", function(ent, data)","\t\tlocal ok, msg, traceback = instance:runFunction( func, setmetatable({}, {","\t\t\t__index=function(t,k)","\t\t\t\treturn SF.WrapObject( data[k] )","\t\t\tend,","\t\t\t__metatable={}","\t\t}))","","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend)","end","","util.AddNetworkString( \"sf_setentityrenderproperty\" )","","local renderProperties = {","\t[1] = function( clr ) --Color","\t\tnet.WriteUInt( clr.r, 8 )","\t\tnet.WriteUInt( clr.g, 8 )","\t\tnet.WriteUInt( clr.b, 8 )","\t\tnet.WriteUInt( clr.a, 8 )","\tend,","\t[2] = function( draw ) --Nodraw","\t\tnet.WriteBit( draw )","\tend,","\t[3] = function( material ) --Material","\t\tnet.WriteString( material )","\tend,","\t[4] = function( index, material ) --Submaterial","\t\tnet.WriteUInt( index, 16 )","\t\tnet.WriteString( material )","\tend,","\t[5] = function( bodygroup, value ) --Bodygroup","\t\tnet.WriteUInt( bodygroup, 16 )","\t\tnet.WriteUInt( value, 16 )","\tend,","\t[6] = function( skin ) --Skin","\t\tnet.WriteUInt( skin, 16 )","\tend","}","","local function sendRenderPropertyToClient( ply, ent, func, ... )","\tSF.CheckType( ply, SF.Types[ \"Player\" ] )","\tply = unwrap( ply )","\tif isValid( ply ) and ply:IsPlayer() then","\t\tnet.Start( \"sf_setentityrenderproperty\" )","\t\tnet.WriteEntity( ent )","\t\tnet.WriteUInt( func, 4 )","\t\trenderProperties[ func ]( ... )","\t\tnet.Send( ply )","\tend","end",""],"class":"function","name":"ents_methods:addCollisionListener","summary":"\nAllows detecting collisions on an entity.","private":false,"classlib":"Entity","description":"\nAllows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","param":{"1":"func","func":"The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"}},"remove":{"comment":["--- Removes an entity"],"code":["function ents_methods:remove ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not ent:IsValid() or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Remove()","end",""],"class":"function","name":"ents_methods:remove","summary":"\nRemoves an entity ","private":false,"classlib":"Entity","description":"\nRemoves an entity","param":[]},"setSkin":{"comment":["--- Sets the skin of the entity","-- @server","-- @class function","-- @param skinIndex Number, Index of the skin to use.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setSkin ( skinIndex, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( skinIndex, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 6, skinIndex )","\telse","\t\tent:SetSkin( skinIndex )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the skin of the entity ","name":"ents_methods:setSkin","classlib":"Entity","private":false,"server":true,"description":"\nSets the skin of the entity","param":{"1":"skinIndex","2":"ply","skinIndex":"Number, Index of the skin to use.","ply":"Optional player arguement to set material of an entity only for that player"}},"setBodygroup":{"comment":["--- Sets an entities' bodygroup","-- @server","-- @class function","-- @param bodygroup Number, The ID of the bodygroup you're setting.","-- @param value Number, The value you're setting the bodygroup to.","-- @param ply Optional player arguement to set bodygroup of an entity only for that player"],"code":["function ents_methods:setBodygroup ( bodygroup, value, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( bodygroup, \"number\" )","    SF.CheckType( value, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 5, bodygroup, value )","\telse","\t\tent:SetBodyGroup( bodygroup, value )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' bodygroup ","name":"ents_methods:setBodygroup","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' bodygroup","param":{"1":"bodygroup","2":"value","3":"ply","value":"Number, The value you're setting the bodygroup to.","ply":"Optional player arguement to set bodygroup of an entity only for that player","bodygroup":"Number, The ID of the bodygroup you're setting."}},"setParent":{"comment":["--- Parents the entity to another entity","-- @param ent Entity to parent to"],"code":["function ents_methods:setParent ( ent )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( ent )","\tlocal this = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif not parent_check( this, ent ) then SF.throw( \"Cannot parent to self\", 2 ) end","","\tthis:SetParent( ent )","end",""],"class":"function","name":"ents_methods:setParent","summary":"\nParents the entity to another entity ","private":false,"classlib":"Entity","description":"\nParents the entity to another entity","param":{"1":"ent","ent":"Entity to parent to"}},"setNoDraw":{"comment":["--- Sets the whether an entity should be drawn or not","-- @server","-- @param draw Whether to draw the entity or not.","-- @param ply Optional player arguement to set drawing of an entity only for that player"],"code":["function ents_methods:setNoDraw ( draw, ply )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 2, draw and true or false )","\telse","\t\tent:SetNoDraw( draw and true or false )","\tend","end","","local materialBlacklist = {","\t[ \"pp/copy\" ] = true","}",""],"class":"function","summary":"\nSets the whether an entity should be drawn or not ","name":"ents_methods:setNoDraw","classlib":"Entity","private":false,"server":true,"description":"\nSets the whether an entity should be drawn or not","param":{"1":"draw","2":"ply","draw":"Whether to draw the entity or not.","ply":"Optional player arguement to set drawing of an entity only for that player"}},"setAngles":{"comment":["--- Sets the entity's angles","-- @param ang New angles"],"code":["function ents_methods:setAngles ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setAngles\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setAng( ent, ang )","end",""],"class":"function","name":"ents_methods:setAngles","summary":"\nSets the entity's angles ","private":false,"classlib":"Entity","description":"\nSets the entity's angles","param":{"1":"ang","ang":"New angles"}},"applyTorque":{"comment":["--- Applies torque","-- @param tq The torque vector","-- @param offset Optional offset position"],"code":["function ents_methods:applyTorque ( tq, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( tq, SF.Types[ \"Vector\" ] )","","\tlocal tq = vunwrap( tq )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal torqueamount = tq:Length()","","\tif offset then","\t\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","\t\toffset = vunwrap( offset )","\telse","\t\toffset = phys:GetPos()","\tend","\t-- Convert torque from local to world axis","\ttq = phys:LocalToWorld( tq ) - offset","","\t-- Find two vectors perpendicular to the torque axis","\tlocal off","\tif abs( tq.x ) > torqueamount * 0.1 or abs( tq.z ) > torqueamount * 0.1 then","\t\toff = Vector( -tq.z, 0, tq.x )","\telse","\t\toff = Vector( -tq.y, tq.x, 0 )","\tend","\toff = off:GetNormal() * torqueamount * 0.5","","\tlocal dir = ( tq:Cross( off ) ):GetNormal()","","\tif not check( dir ) or not check( off ) then SF.throw( \"infinite vector\", 2) end","","\tphys:ApplyForceOffset( dir, off )","\tphys:ApplyForceOffset( dir * -1, off * -1 )","end",""],"class":"function","name":"ents_methods:applyTorque","summary":"\nApplies torque ","private":false,"classlib":"Entity","description":"\nApplies torque","param":{"1":"tq","2":"offset","offset":"Optional offset position","tq":"The torque vector"}},"applyAngForce":{"comment":["--- Applies angular force to the entity","-- @param ang The force angle"],"code":["function ents_methods:applyAngForce ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t-- assign vectors","\tlocal up = ent:GetUp()","\tlocal left = ent:GetRight() * -1","\tlocal forward = ent:GetForward()","","\t-- apply pitch force","\tif ang.p ~= 0 then","\t\tlocal pitch = up * ( ang.p * 0.5 )","\t\tphys:ApplyForceOffset( forward, pitch )","\t\tphys:ApplyForceOffset( forward * -1, pitch * -1 )","\tend","","\t-- apply yaw force","\tif ang.y ~= 0 then","\t\tlocal yaw = forward * ( ang.y * 0.5 )","\t\tphys:ApplyForceOffset( left, yaw )","\t\tphys:ApplyForceOffset( left * -1, yaw * -1 )","\tend","","\t-- apply roll force","\tif ang.r ~= 0 then","\t\tlocal roll = left * ( ang.r * 0.5 )","\t\tphys:ApplyForceOffset( up, roll )","\t\tphys:ApplyForceOffset( up * -1, roll * -1 )","\tend","end",""],"class":"function","name":"ents_methods:applyAngForce","summary":"\nApplies angular force to the entity ","private":false,"classlib":"Entity","description":"\nApplies angular force to the entity","param":{"1":"ang","ang":"The force angle"}},"setFrozen":{"comment":["--- Sets the entity frozen state","-- @param freeze Should the entity be frozen?"],"code":["function ents_methods:setFrozen ( freeze )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setFrozen\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( not ( freeze and true or false ) )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:setFrozen","summary":"\nSets the entity frozen state ","private":false,"classlib":"Entity","description":"\nSets the entity frozen state","param":{"1":"freeze","freeze":"Should the entity be frozen?"}},"setColor":{"comment":["--- Sets the color of the entity","-- @server","-- @param clr New color","-- @param ply Optional player arguement to set the entity's color only for that player"],"code":["function ents_methods:setColor ( clr, ply )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 1, clr )","\telse","\t\tent:SetColor( clr )","\t\tent:SetRenderMode( clr.a == 255 and RENDERMODE_NORMAL or RENDERMODE_TRANSALPHA )","\tend","","end",""],"class":"function","summary":"\nSets the color of the entity ","name":"ents_methods:setColor","classlib":"Entity","private":false,"server":true,"description":"\nSets the color of the entity","param":{"1":"clr","2":"ply","clr":"New color","ply":"Optional player arguement to set the entity's color only for that player"}}},"comment":["--- Entity type","--@class class","--@name Entity"],"typtbl":"ents_methods","param":[]},{"ret":"The entities owner, or nil if not found","comment":["--- Gets the entity's owner","-- TODO: Optimize this!","-- @return The entities owner, or nil if not found"],"code":["function SF.Entities.GetOwner ( entity )","\tif not isValid( entity ) then return end","","\tif entity.IsPlayer and entity:IsPlayer() then","\t\treturn entity","\tend","","\tif CPPI then","\t\tlocal owner = entity:CPPIGetOwner()","\t\tif isValid( owner ) then return owner end","\tend","","\tif entity.GetPlayer then","\t\tlocal ply = entity:GetPlayer()","\t\tif isValid( ply ) then return ply end","\tend","","\tif entity.owner and isValid( entity.owner ) and entity.owner:IsPlayer() then","\t\treturn entity.owner","\tend","","\tlocal OnDieFunctions = entity.OnDieFunctions","\tif OnDieFunctions then","\t\tif OnDieFunctions.GetCountUpdate and OnDieFunctions.GetCountUpdate.Args and OnDieFunctions.GetCountUpdate.Args[ 1 ] then","\t\t\treturn OnDieFunctions.GetCountUpdate.Args[ 1 ]","\t\telseif OnDieFunctions.undo1 and OnDieFunctions.undo1.Args and OnDieFunctions.undo1.Args[2] then","\t\t\treturn OnDieFunctions.undo1.Args[ 2 ]","\t\tend","\tend","","\tif entity.GetOwner then","\t\tlocal ply = entity:GetOwner()","\t\tif isValid( ply ) then return ply end","\tend","","\treturn nil","end","","local getPhysObject = SF.Entities.GetPhysObject","local getOwner = SF.Entities.GetOwner",""],"class":"function","name":"SF.Entities.GetOwner","private":false,"summary":"\nGets the entity's owner \nTODO: Optimize this! ","description":"\nGets the entity's owner \nTODO: Optimize this!","param":["entity"]},{"ret":"Owner","comment":["--- Gets the owner of the entity","-- @return Owner"],"code":["function ents_methods:getOwner ()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\treturn wrap( getOwner( ent ) )","end","","local function check ( v )","\treturn \t-math.huge < v.x and v.x < math.huge and","\t\t\t-math.huge < v.y and v.y < math.huge and","\t\t\t-math.huge < v.z and v.z < math.huge","end","","local function parent_check ( child, parent )","\twhile isValid( parent ) do","\t\tif child == parent then","\t\t\treturn false","\t\tend","\t\tparent = parent:GetParent()","\tend","\treturn true","end",""],"class":"function","name":"ents_methods:getOwner","summary":"\nGets the owner of the entity ","private":false,"classlib":"Entity","description":"\nGets the owner of the entity","param":[]},{"comment":["--- Parents the entity to another entity","-- @param ent Entity to parent to"],"code":["function ents_methods:setParent ( ent )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( ent )","\tlocal this = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif not parent_check( this, ent ) then SF.throw( \"Cannot parent to self\", 2 ) end","","\tthis:SetParent( ent )","end",""],"class":"function","name":"ents_methods:setParent","summary":"\nParents the entity to another entity ","private":false,"classlib":"Entity","description":"\nParents the entity to another entity","param":{"1":"ent","ent":"Entity to parent to"}},{"comment":["--- Unparents the entity from another entity"],"code":["function ents_methods:unparent ()","\tlocal this = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.unparent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tthis:SetParent( nil )","end",""],"class":"function","name":"ents_methods:unparent","summary":"\nUnparents the entity from another entity ","private":false,"classlib":"Entity","description":"\nUnparents the entity from another entity","param":[]},{"comment":["--- Plays a sound on the entity","-- @param snd string Sound path","-- @param lvl number soundLevel=75","-- @param pitch pitchPercent=100","-- @param volume volume=1","-- @param channel channel=CHAN_AUTO"],"code":["function ents_methods:emitSound ( snd, lvl, pitch, volume, channel )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( snd, \"string\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.emitSound\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:EmitSound(snd, lvl, pitch, volume, channel)","end",""],"class":"function","name":"ents_methods:emitSound","summary":"\nPlays a sound on the entity ","private":false,"classlib":"Entity","description":"\nPlays a sound on the entity","param":{"1":"snd","2":"lvl","3":"pitch","4":"volume","5":"channel","pitch":"pitchPercent=100","snd":"string Sound path","lvl":"number soundLevel=75","channel":"channel=CHAN_AUTO","volume":"volume=1"}},{"comment":["--- Applies damage to an entity","-- @param amt damage amount","-- @param attacker damage attacker","-- @param inflictor damage inflictor"],"code":["function ents_methods:applyDamage( amt, attacker, inflictor )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( amt, \"number\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyDamage\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif attacker then","\t\tSF.CheckType( attacker, ents_metatable )","\t\tattacker = unwrap( attacker )","\t\tif not isValid( attacker ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","\tif inflictor then","\t\tSF.CheckType( inflictor, ents_metatable )","\t\tinflictor = unwrap( inflictor )","\t\tif not isValid( inflictor ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","","\tent:TakeDamage( amt, attacker, inflictor )","end","",""],"class":"function","name":"ents_methods:applyDamage","summary":"\nApplies damage to an entity ","private":false,"classlib":"Entity","description":"\nApplies damage to an entity","param":{"1":"amt","2":"attacker","3":"inflictor","inflictor":"damage inflictor","attacker":"damage attacker","amt":"damage amount"}},{"comment":["--- Applies linear force to the entity","-- @param vec The force vector"],"code":["function ents_methods:applyForceCenter ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","\tif not check( vec ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceCenter( vec )","end",""],"class":"function","name":"ents_methods:applyForceCenter","summary":"\nApplies linear force to the entity ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity","param":{"1":"vec","vec":"The force vector"}},{"comment":["--- Applies linear force to the entity with an offset","-- @param vec The force vector","-- @param offset An optional offset position"],"code":["function ents_methods:applyForceOffset ( vec, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal offset = vunwrap( offset )","","\tif not check( vec ) or not check( offset ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceOffset( vec, offset )","end",""],"class":"function","name":"ents_methods:applyForceOffset","summary":"\nApplies linear force to the entity with an offset ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity with an offset","param":{"1":"vec","2":"offset","vec":"The force vector","offset":"An optional offset position"}},{"comment":["--- Applies angular force to the entity","-- @param ang The force angle"],"code":["function ents_methods:applyAngForce ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t-- assign vectors","\tlocal up = ent:GetUp()","\tlocal left = ent:GetRight() * -1","\tlocal forward = ent:GetForward()","","\t-- apply pitch force","\tif ang.p ~= 0 then","\t\tlocal pitch = up * ( ang.p * 0.5 )","\t\tphys:ApplyForceOffset( forward, pitch )","\t\tphys:ApplyForceOffset( forward * -1, pitch * -1 )","\tend","","\t-- apply yaw force","\tif ang.y ~= 0 then","\t\tlocal yaw = forward * ( ang.y * 0.5 )","\t\tphys:ApplyForceOffset( left, yaw )","\t\tphys:ApplyForceOffset( left * -1, yaw * -1 )","\tend","","\t-- apply roll force","\tif ang.r ~= 0 then","\t\tlocal roll = left * ( ang.r * 0.5 )","\t\tphys:ApplyForceOffset( up, roll )","\t\tphys:ApplyForceOffset( up * -1, roll * -1 )","\tend","end",""],"class":"function","name":"ents_methods:applyAngForce","summary":"\nApplies angular force to the entity ","private":false,"classlib":"Entity","description":"\nApplies angular force to the entity","param":{"1":"ang","ang":"The force angle"}},{"comment":["--- Applies torque","-- @param tq The torque vector","-- @param offset Optional offset position"],"code":["function ents_methods:applyTorque ( tq, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( tq, SF.Types[ \"Vector\" ] )","","\tlocal tq = vunwrap( tq )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal torqueamount = tq:Length()","","\tif offset then","\t\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","\t\toffset = vunwrap( offset )","\telse","\t\toffset = phys:GetPos()","\tend","\t-- Convert torque from local to world axis","\ttq = phys:LocalToWorld( tq ) - offset","","\t-- Find two vectors perpendicular to the torque axis","\tlocal off","\tif abs( tq.x ) > torqueamount * 0.1 or abs( tq.z ) > torqueamount * 0.1 then","\t\toff = Vector( -tq.z, 0, tq.x )","\telse","\t\toff = Vector( -tq.y, tq.x, 0 )","\tend","\toff = off:GetNormal() * torqueamount * 0.5","","\tlocal dir = ( tq:Cross( off ) ):GetNormal()","","\tif not check( dir ) or not check( off ) then SF.throw( \"infinite vector\", 2) end","","\tphys:ApplyForceOffset( dir, off )","\tphys:ApplyForceOffset( dir * -1, off * -1 )","end",""],"class":"function","name":"ents_methods:applyTorque","summary":"\nApplies torque ","private":false,"classlib":"Entity","description":"\nApplies torque","param":{"1":"tq","2":"offset","offset":"Optional offset position","tq":"The torque vector"}},{"comment":["--- Allows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","-- @param func The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"],"code":["function ents_methods:addCollisionListener ( func )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( func, \"function\" )","\tlocal ent = unwrap( self )","\tif ent.SF_CollisionCallback then SF.throw( \"The entity is already listening to collisions!\", 2 ) end","\tent.SF_CollisionCallback = true","","\tlocal instance = SF.instance","\tent:AddCallback(\"PhysicsCollide\", function(ent, data)","\t\tlocal ok, msg, traceback = instance:runFunction( func, setmetatable({}, {","\t\t\t__index=function(t,k)","\t\t\t\treturn SF.WrapObject( data[k] )","\t\t\tend,","\t\t\t__metatable={}","\t\t}))","","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend)","end","","util.AddNetworkString( \"sf_setentityrenderproperty\" )","","local renderProperties = {","\t[1] = function( clr ) --Color","\t\tnet.WriteUInt( clr.r, 8 )","\t\tnet.WriteUInt( clr.g, 8 )","\t\tnet.WriteUInt( clr.b, 8 )","\t\tnet.WriteUInt( clr.a, 8 )","\tend,","\t[2] = function( draw ) --Nodraw","\t\tnet.WriteBit( draw )","\tend,","\t[3] = function( material ) --Material","\t\tnet.WriteString( material )","\tend,","\t[4] = function( index, material ) --Submaterial","\t\tnet.WriteUInt( index, 16 )","\t\tnet.WriteString( material )","\tend,","\t[5] = function( bodygroup, value ) --Bodygroup","\t\tnet.WriteUInt( bodygroup, 16 )","\t\tnet.WriteUInt( value, 16 )","\tend,","\t[6] = function( skin ) --Skin","\t\tnet.WriteUInt( skin, 16 )","\tend","}","","local function sendRenderPropertyToClient( ply, ent, func, ... )","\tSF.CheckType( ply, SF.Types[ \"Player\" ] )","\tply = unwrap( ply )","\tif isValid( ply ) and ply:IsPlayer() then","\t\tnet.Start( \"sf_setentityrenderproperty\" )","\t\tnet.WriteEntity( ent )","\t\tnet.WriteUInt( func, 4 )","\t\trenderProperties[ func ]( ... )","\t\tnet.Send( ply )","\tend","end",""],"class":"function","name":"ents_methods:addCollisionListener","summary":"\nAllows detecting collisions on an entity.","private":false,"classlib":"Entity","description":"\nAllows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","param":{"1":"func","func":"The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"}},{"comment":["--- Sets the color of the entity","-- @server","-- @param clr New color","-- @param ply Optional player arguement to set the entity's color only for that player"],"code":["function ents_methods:setColor ( clr, ply )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 1, clr )","\telse","\t\tent:SetColor( clr )","\t\tent:SetRenderMode( clr.a == 255 and RENDERMODE_NORMAL or RENDERMODE_TRANSALPHA )","\tend","","end",""],"class":"function","summary":"\nSets the color of the entity ","name":"ents_methods:setColor","classlib":"Entity","private":false,"server":true,"description":"\nSets the color of the entity","param":{"1":"clr","2":"ply","clr":"New color","ply":"Optional player arguement to set the entity's color only for that player"}},{"comment":["--- Sets the whether an entity should be drawn or not","-- @server","-- @param draw Whether to draw the entity or not.","-- @param ply Optional player arguement to set drawing of an entity only for that player"],"code":["function ents_methods:setNoDraw ( draw, ply )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 2, draw and true or false )","\telse","\t\tent:SetNoDraw( draw and true or false )","\tend","end","","local materialBlacklist = {","\t[ \"pp/copy\" ] = true","}",""],"class":"function","summary":"\nSets the whether an entity should be drawn or not ","name":"ents_methods:setNoDraw","classlib":"Entity","private":false,"server":true,"description":"\nSets the whether an entity should be drawn or not","param":{"1":"draw","2":"ply","draw":"Whether to draw the entity or not.","ply":"Optional player arguement to set drawing of an entity only for that player"}},{"comment":["--- Sets an entities' material","-- @server","-- @class function","-- @param material, string, New material name.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setMaterial ( material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if materialBlacklist[ material:lower() ] then SF.throw( \"This material has been blacklisted\", 2 ) end","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 3, material )","\telse","\t\tent:SetMaterial( material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' material ","name":"ents_methods:setMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' material","param":{"1":"material","2":"ply","ply":"Optional player arguement to set material of an entity only for that player","material":", string, New material name."}},{"comment":["--- Sets an entities' submaterial","-- @server","-- @class function","-- @param index, number, submaterial index.","-- @param material, string, New material name.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setSubMaterial ( index, material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if materialBlacklist[ material:lower() ] then SF.throw( \"This material has been blacklisted\", 2 ) end","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 4, index, material )","\telse","\t\tent:SetSubMaterial( index, material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' submaterial ","name":"ents_methods:setSubMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' submaterial","param":{"1":"index","2":"material","3":"ply","material":", string, New material name.","index":", number, submaterial index.","ply":"Optional player arguement to set material of an entity only for that player"}},{"comment":["--- Sets an entities' bodygroup","-- @server","-- @class function","-- @param bodygroup Number, The ID of the bodygroup you're setting.","-- @param value Number, The value you're setting the bodygroup to.","-- @param ply Optional player arguement to set bodygroup of an entity only for that player"],"code":["function ents_methods:setBodygroup ( bodygroup, value, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( bodygroup, \"number\" )","    SF.CheckType( value, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 5, bodygroup, value )","\telse","\t\tent:SetBodyGroup( bodygroup, value )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' bodygroup ","name":"ents_methods:setBodygroup","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' bodygroup","param":{"1":"bodygroup","2":"value","3":"ply","value":"Number, The value you're setting the bodygroup to.","ply":"Optional player arguement to set bodygroup of an entity only for that player","bodygroup":"Number, The ID of the bodygroup you're setting."}},{"comment":["--- Sets the skin of the entity","-- @server","-- @class function","-- @param skinIndex Number, Index of the skin to use.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setSkin ( skinIndex, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( skinIndex, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 6, skinIndex )","\telse","\t\tent:SetSkin( skinIndex )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the skin of the entity ","name":"ents_methods:setSkin","classlib":"Entity","private":false,"server":true,"description":"\nSets the skin of the entity","param":{"1":"skinIndex","2":"ply","skinIndex":"Number, Index of the skin to use.","ply":"Optional player arguement to set material of an entity only for that player"}},{"comment":["--- Sets the entitiy's position","-- @param vec New position"],"code":["function ents_methods:setPos ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setPos\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setPos( ent, vec )","end",""],"class":"function","name":"ents_methods:setPos","summary":"\nSets the entitiy's position ","private":false,"classlib":"Entity","description":"\nSets the entitiy's position","param":{"1":"vec","vec":"New position"}},{"comment":["--- Sets the entity's angles","-- @param ang New angles"],"code":["function ents_methods:setAngles ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setAngles\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setAng( ent, ang )","end",""],"class":"function","name":"ents_methods:setAngles","summary":"\nSets the entity's angles ","private":false,"classlib":"Entity","description":"\nSets the entity's angles","param":{"1":"ang","ang":"New angles"}},{"comment":["--- Sets the entity's linear velocity","-- @param vel New velocity"],"code":["function ents_methods:setVelocity ( vel )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","","\tlocal vel = vunwrap( vel )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setVelocity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetVelocity( vel )","end",""],"class":"function","name":"ents_methods:setVelocity","summary":"\nSets the entity's linear velocity ","private":false,"classlib":"Entity","description":"\nSets the entity's linear velocity","param":{"1":"vel","vel":"New velocity"}},{"comment":["--- Removes an entity"],"code":["function ents_methods:remove ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not ent:IsValid() or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Remove()","end",""],"class":"function","name":"ents_methods:remove","summary":"\nRemoves an entity ","private":false,"classlib":"Entity","description":"\nRemoves an entity","param":[]},{"comment":["--- Breaks an entity"],"code":["function ents_methods:destroy ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Fire( \"break\", 1, 0 )","end",""],"class":"function","name":"ents_methods:destroy","summary":"\nBreaks an entity ","private":false,"classlib":"Entity","description":"\nBreaks an entity","param":[]},{"comment":["--- Sets the entity frozen state","-- @param freeze Should the entity be frozen?"],"code":["function ents_methods:setFrozen ( freeze )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setFrozen\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( not ( freeze and true or false ) )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:setFrozen","summary":"\nSets the entity frozen state ","private":false,"classlib":"Entity","description":"\nSets the entity frozen state","param":{"1":"freeze","freeze":"Should the entity be frozen?"}},{"ret":"True if entity is frozen","comment":["--- Checks the entities frozen state","-- @return True if entity is frozen"],"code":["function ents_methods:isFrozen ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = ent:GetPhysicsObject()","\tif phys:IsMoveable() then return false else return true end","end",""],"class":"function","name":"ents_methods:isFrozen","summary":"\nChecks the entities frozen state ","private":false,"classlib":"Entity","description":"\nChecks the entities frozen state","param":[]},{"comment":["--- Sets the entity to be Solid or not.","-- For more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","-- @param solid Boolean, Should the entity be solid?"],"code":["function ents_methods:setSolid ( solid )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:SetNotSolid( not solid )","end",""],"class":"function","name":"ents_methods:setSolid","summary":"\nSets the entity to be Solid or not.","private":false,"classlib":"Entity","description":"\nSets the entity to be Solid or not. \nFor more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","param":{"1":"solid","solid":"Boolean, Should the entity be solid?"}},{"comment":["--- Sets the entity's mass","-- @param mass number mass"],"code":["function ents_methods:setMass ( mass )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetMass( math.Clamp(mass, 1, 50000) )","end",""],"class":"function","name":"ents_methods:setMass","summary":"\nSets the entity's mass ","private":false,"classlib":"Entity","description":"\nSets the entity's mass","param":{"1":"mass","mass":"number mass"}},{"comment":["--- Sets entity gravity","-- @param grav Bool should the entity respect gravity?"],"code":["function ents_methods:enableGravity ( grav )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableGravity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableGravity( grav and true or false )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:enableGravity","summary":"\nSets entity gravity ","private":false,"classlib":"Entity","description":"\nSets entity gravity","param":{"1":"grav","grav":"Bool should the entity respect gravity?"}},{"comment":["--- Sets the entity drag state","-- @param drag Bool should the entity have air resistence?"],"code":["function ents_methods:enableDrag ( drag )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableDrag\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableDrag( drag and true or false )","end",""],"class":"function","name":"ents_methods:enableDrag","summary":"\nSets the entity drag state ","private":false,"classlib":"Entity","description":"\nSets the entity drag state","param":{"1":"drag","drag":"Bool should the entity have air resistence?"}},{"comment":["--- Sets the entity movement state","-- @param move Bool should the entity move?"],"code":["function ents_methods:enableMotion ( move )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( move and true or false )","\tphys:Wake()","end","","","local function ent1or2 ( ent, con, num )","\tif not con then return nil end","\tif num then","\t\tcon = con[ num ]","\t\tif not con then return nil end","\tend","\tif con.Ent1 == ent then return con.Ent2 end","\treturn con.Ent1","end",""],"class":"function","name":"ents_methods:enableMotion","summary":"\nSets the entity movement state ","private":false,"classlib":"Entity","description":"\nSets the entity movement state","param":{"1":"move","move":"Bool should the entity move?"}},{"comment":["--- Gets what the entity is welded to"],"code":["function ents_methods:isWeldedTo ()","\tlocal this = unwrap( self )","\tif not constraint.HasConstraints( this ) then return nil end","","\treturn wrap( ent1or2( this, constraint.FindConstraint( this, \"Weld\" ) ) )","end"],"class":"function","name":"ents_methods:isWeldedTo","summary":"\nGets what the entity is welded to ","private":false,"classlib":"Entity","description":"\nGets what the entity is welded to","param":[]}],"tables":[],"description":"\n \nServerside Entity functions \n","summary":"\n \nServerside Entity functions \n "},"libs_sh/json.lua":{"libraries":{"1":"json","json":{"comment":["--- JSON library","-- @shared"],"functions":{"1":"decode","2":"encode","encode":{"ret":"JSON encoded string representation of the table","comment":["--- Convert table to JSON string","--@param tbl Table to encode","--@return JSON encoded string representation of the table"],"code":["function json_library.encode ( tbl )","\tSF.CheckType( tbl, \"table\" )","\treturn util.TableToJSON( tbl )","end",""],"class":"function","name":"json_library.encode","summary":"\nConvert table to JSON string ","private":false,"library":"json","description":"\nConvert table to JSON string","param":{"1":"tbl","tbl":"Table to encode"}},"decode":{"ret":"Table representing the JSON object","comment":["--- Convert JSON string to table","-- @param s String to decode","-- @return Table representing the JSON object"],"code":["function json_library.decode ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.JSONToTable( s )","end"],"class":"function","name":"json_library.decode","summary":"\nConvert JSON string to table ","private":false,"library":"json","description":"\nConvert JSON string to table","param":{"1":"s","s":"String to decode"}}},"class":"library","summary":"\nJSON library ","code":["local json_library, _ = SF.Libraries.Register( \"json\" )","local util = util",""],"fields":[],"name":"json","client":true,"description":"\nJSON library","libtbl":"json_library","tables":[],"server":true}},"type":"file","name":"libs_sh/json.lua","functions":{"1":"json_library.decode","2":"json_library.encode","json_library.encode":{"ret":"JSON encoded string representation of the table","comment":["--- Convert table to JSON string","--@param tbl Table to encode","--@return JSON encoded string representation of the table"],"code":["function json_library.encode ( tbl )","\tSF.CheckType( tbl, \"table\" )","\treturn util.TableToJSON( tbl )","end",""],"class":"function","name":"json_library.encode","summary":"\nConvert table to JSON string ","private":false,"library":"json","description":"\nConvert table to JSON string","param":{"1":"tbl","tbl":"Table to encode"}},"json_library.decode":{"ret":"Table representing the JSON object","comment":["--- Convert JSON string to table","-- @param s String to decode","-- @return Table representing the JSON object"],"code":["function json_library.decode ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.JSONToTable( s )","end"],"class":"function","name":"json_library.decode","summary":"\nConvert JSON string to table ","private":false,"library":"json","description":"\nConvert JSON string to table","param":{"1":"s","s":"String to decode"}}},"doc":[{"summary":"\nJSON library ","description":"\nJSON library","comment":["--- JSON library"],"code":[""]},{"comment":["--- JSON library","-- @shared"],"functions":{"1":"decode","2":"encode","encode":{"ret":"JSON encoded string representation of the table","comment":["--- Convert table to JSON string","--@param tbl Table to encode","--@return JSON encoded string representation of the table"],"code":["function json_library.encode ( tbl )","\tSF.CheckType( tbl, \"table\" )","\treturn util.TableToJSON( tbl )","end",""],"class":"function","name":"json_library.encode","summary":"\nConvert table to JSON string ","private":false,"library":"json","description":"\nConvert table to JSON string","param":{"1":"tbl","tbl":"Table to encode"}},"decode":{"ret":"Table representing the JSON object","comment":["--- Convert JSON string to table","-- @param s String to decode","-- @return Table representing the JSON object"],"code":["function json_library.decode ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.JSONToTable( s )","end"],"class":"function","name":"json_library.decode","summary":"\nConvert JSON string to table ","private":false,"library":"json","description":"\nConvert JSON string to table","param":{"1":"s","s":"String to decode"}}},"class":"library","summary":"\nJSON library ","code":["local json_library, _ = SF.Libraries.Register( \"json\" )","local util = util",""],"fields":[],"name":"json","client":true,"description":"\nJSON library","libtbl":"json_library","tables":[],"server":true},{"ret":"JSON encoded string representation of the table","comment":["--- Convert table to JSON string","--@param tbl Table to encode","--@return JSON encoded string representation of the table"],"code":["function json_library.encode ( tbl )","\tSF.CheckType( tbl, \"table\" )","\treturn util.TableToJSON( tbl )","end",""],"class":"function","name":"json_library.encode","summary":"\nConvert table to JSON string ","private":false,"library":"json","description":"\nConvert table to JSON string","param":{"1":"tbl","tbl":"Table to encode"}},{"ret":"Table representing the JSON object","comment":["--- Convert JSON string to table","-- @param s String to decode","-- @return Table representing the JSON object"],"code":["function json_library.decode ( s )","\tSF.CheckType( s, \"string\" )","\treturn util.JSONToTable( s )","end"],"class":"function","name":"json_library.decode","summary":"\nConvert JSON string to table ","private":false,"library":"json","description":"\nConvert JSON string to table","param":{"1":"s","s":"String to decode"}}],"tables":[],"description":"\nJSON library","summary":"\nJSON library "},"instance.lua":{"libraries":[],"type":"file","name":"instance.lua","functions":{"1":"SF.Instance:Error","2":"SF.Instance:cleanup","3":"SF.Instance:deinitialize","4":"SF.Instance:initialize","5":"SF.Instance:iterScriptHook","6":"SF.Instance:iterTblScriptHook","7":"SF.Instance:prepare","8":"SF.Instance:runFunction","9":"SF.Instance:runFunctionT","10":"SF.Instance:runLibraryHook","11":"SF.Instance:runScriptHook","12":"SF.Instance:runScriptHookForResult","13":"SF.Instance:runWithOps","SF.Instance:runScriptHook":{"ret":["True if it executed ok, false if not or if there was no hook","If the first return value is false then the error message or nil if no hook was registered"],"comment":["--- Runs a script hook. This calls script code.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return True if it executed ok, false if not or if there was no hook","-- @return If the first return value is false then the error message or nil if no hook was registered"],"code":["function SF.Instance:runScriptHook(hook, ...)","\tfor ok,err,traceback in self:iterTblScriptHook(hook,...) do","\t\tif not ok then return false,err,traceback end","\tend","\treturn true","end",""],"class":"function","name":"SF.Instance:runScriptHook","private":false,"summary":"\nRuns a script hook.","description":"\nRuns a script hook. This calls script code.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},"SF.Instance:runWithOps":{"ret":["True if ok","A table of values that the hook returned"],"comment":["--- Internal function - do not call.","-- Runs a function while incrementing the instance ops coutner.","-- This does no setup work and shouldn't be called by client code","-- @param func The function to run","-- @param ... Arguments to func","-- @return True if ok","-- @return A table of values that the hook returned"],"code":["function SF.Instance:runWithOps(func,...)","","\tlocal args = { ... }","\tlocal traceback","","\tlocal wrapperfunc = function ()","\t\treturn { func( unpack( args ) ) }","\tend","","\tlocal function xpcall_callback ( err )","\t\tif type( err ) == \"table\" then","\t\t\tif err.message then","\t\t\t\tlocal line= err.line","\t\t\t\tlocal file = err.file","","\t\t\t\terr = ( file and ( file .. \":\" ) or \"\" ) .. ( line and ( line .. \": \" ) or \"\" ) .. err.message","\t\t\tend","\t\tend","\t\terr = tostring( err )","\t\ttraceback = debug.traceback( err, 2 )","\t\treturn err","\tend","","\tlocal oldSysTime = SysTime() - self.cpu_total","\t","\tlocal function cpuCheck ()","\t\tself.cpu_total = SysTime() - oldSysTime","","\t\tif self:movingCPUAverage() > self.context.cpuTime:getMax() then","\t\t\tdebug.sethook( nil )","\t\t\tSF.throw( \"CPU Quota exceeded.\", 0, true )","\t\tend","\tend","","\tlocal ok, rt","\tif self.instanceStack then","\t\tok, rt = xpcall( wrapperfunc, xpcall_callback )","\telse","\t\tdebug.sethook( cpuCheck, \"\", 500 )","\t\tok, rt = xpcall( wrapperfunc, xpcall_callback )","\t\tdebug.sethook( nil )","\tend","\t","\t","\tif ok then","\t\treturn true, rt","\telse","\t\treturn false, rt, traceback","\tend","end",""],"class":"function","name":"SF.Instance:runWithOps","private":false,"summary":"\nInternal function - do not call.","description":"\nInternal function - do not call. \nRuns a function while incrementing the instance ops coutner. \nThis does no setup work and shouldn't be called by client code","param":{"1":"func","2":"...","func":"The function to run","...":"Arguments to func"}},"SF.Instance:runFunctionT":{"summary":"\nExactly the same as runFunction except doesn't unpack the return values ","description":"\nExactly the same as runFunction except doesn't unpack the return values","comment":["--- Exactly the same as runFunction except doesn't unpack the return values","-- @param func Function to run","-- @param ... Arguments to pass to func"],"code":["function SF.Instance:runFunctionT(func,...)","\tself:prepare(\"_runFunction\",func)","\t","\tlocal ok, tbl, traceback = self:runWithOps(func,...)","\tif not ok then","\t\tself:cleanup(\"_runFunction\",func,true,tbl,traceback)","\t\tself.error = true","\t\treturn false, tbl, traceback","\tend","\t","\tself:cleanup(\"_runFunction\",func,false)","\treturn true, tbl","end",""],"private":false,"class":"function","name":"SF.Instance:runFunctionT","param":{"1":"func","2":"...","func":"Function to run","...":"Arguments to pass to func"}},"SF.Instance:deinitialize":{"summary":"\nDeinitializes the instance.","description":"\nDeinitializes the instance. After this, the instance should be discarded.","comment":["--- Deinitializes the instance. After this, the instance should be discarded."],"code":["function SF.Instance:deinitialize()","\tself:runLibraryHook(\"deinitialize\")","\tSF.allInstances[self] = nil","\tself.error = true","end",""],"private":false,"class":"function","name":"SF.Instance:deinitialize","param":[]},"SF.Instance:Error":{"summary":"\nErrors the instance.","description":"\nErrors the instance. Should only be called from the tips of the call tree (aka from places such as the hook library, timer library, the entity's think function, etc)","comment":["--- Errors the instance. Should only be called from the tips of the call tree (aka from places such as the hook library, timer library, the entity's think function, etc)"],"code":["function SF.Instance:Error(msg,traceback)","\t","\tif self.runOnError then -- We have a custom error function, use that instead","\t\tself.runOnError( msg, traceback )","\t\treturn","\tend","\t","\t-- Default behavior","\tself:deinitialize()","end","","function SF.Instance:movingCPUAverage()","\tlocal n = self.context.cpuTime:getBufferN()","\treturn (self.cpu_average * (n - 1) + self.cpu_total) / n","end"],"private":false,"class":"function","name":"SF.Instance:Error","param":["msg","traceback"]},"SF.Instance:iterTblScriptHook":{"ret":"An iterator function returning the ok status, then either the table of \nhook results or the error message and traceback","comment":["--- Like SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","-- @param ... Arguments to pass to the hook's registered function.","-- @return An iterator function returning the ok status, then either the table of","-- hook results or the error message and traceback"],"code":["function SF.Instance:iterTblScriptHook(hook,...)","\tlocal hooks = self.hooks[hook:lower()]","\tif not hooks then return noop end","\tlocal index = nil","\tlocal args = {...}","\treturn function()","\t\tif self.error then return end","\t\tlocal name, func = next(hooks,index)","\t\tif not name then return end","\t\tindex = name","\t\t","\t\tself:prepare(hook,name)","\t\t","\t\tlocal ok, tbl, traceback = self:runWithOps(func,unpack(args))","\t\tif not ok then","\t\t\tself:cleanup(hook,name,true,tbl,traceback)","\t\t\tself.error = true","\t\t\treturn false, tbl, traceback","\t\tend","\t\t","\t\tself:cleanup(hook,name,false)","\t\treturn true, tbl","\tend","end",""],"class":"function","name":"SF.Instance:iterTblScriptHook","private":false,"summary":"\nLike SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","description":"\nLike SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function."}},"SF.Instance:iterScriptHook":{"ret":"An iterator function returning the ok status, and then either the hook \nresults or the error message and traceback","comment":["--- Creates an iterator that calls each registered function for a hook.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return An iterator function returning the ok status, and then either the hook","-- results or the error message and traceback"],"code":["function SF.Instance:iterScriptHook(hook,...)","\tlocal hooks = self.hooks[hook:lower()]","\tif not hooks then return noop end","\tlocal index = nil","\tlocal args = {...}","\treturn function()","\t\tif self.error then return end","\t\tlocal name, func = next(hooks,index)","\t\tif not name then return end","\t\tindex = name","\t\t","\t\tself:prepare(hook,name)","\t\t","\t\tlocal ok, tbl, traceback = self:runWithOps(func,unpack(args))","\t\tif not ok then","\t\t\tself:cleanup(hook,name,true,tbl,traceback)","\t\t\tself.error = true","\t\t\treturn false, tbl, traceback","\t\tend","\t\t","\t\tself:cleanup(hook,name,false)","\t\treturn true, unpack(tbl)","\tend","end",""],"class":"function","name":"SF.Instance:iterScriptHook","private":false,"summary":"\nCreates an iterator that calls each registered function for a hook.","description":"\nCreates an iterator that calls each registered function for a hook.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},"SF.Instance:prepare":{"summary":"\nInternal function - Do not call.","description":"\nInternal function - Do not call. Prepares the script to be executed. \nThis is done automatically by Initialize and runScriptHook.","comment":["--- Internal function - Do not call. Prepares the script to be executed.","-- This is done automatically by Initialize and runScriptHook."],"code":["function SF.Instance:prepare(hook, name)","\tassert(self.initialized, \"Instance not initialized!\")","\tassert(not self.error, \"Instance is errored!\")","\t","\tif SF.instance ~= nil then","\t\tself.instanceStack = self.instanceStack or {}","\t\tself.instanceStack[#self.instanceStack + 1] = SF.instance","\t\tSF.instance = nil","\tend","\t","\tself:runLibraryHook(\"prepare\",hook, name)","\tSF.instance = self","end",""],"private":false,"class":"function","name":"SF.Instance:prepare","param":["hook","name"]},"SF.Instance:cleanup":{"summary":"\nInternal function - Do not call.","description":"\nInternal function - Do not call. Cleans up the script. \nThis is done automatically by Initialize and runScriptHook.","comment":["--- Internal function - Do not call. Cleans up the script.","-- This is done automatically by Initialize and runScriptHook."],"code":["function SF.Instance:cleanup(hook, name, ok, errmsg)","\tassert(SF.instance == self)","\tself:runLibraryHook(\"cleanup\",hook, name, ok, errmsg)","\t","\tif self.instanceStack then","\t\tSF.instance = self.instanceStack[#self.instanceStack]","\t\tif #self.instanceStack == 1 then self.instanceStack = nil","\t\telse self.instanceStack[#self.instanceStack] = nil","\t\tend","\telse","\t\tSF.instance = nil","\tend","\t","end",""],"private":false,"class":"function","name":"SF.Instance:cleanup","param":["hook","name","ok","errmsg"]},"SF.Instance:runFunction":{"summary":"\nRuns an arbitrary function under the SF instance.","description":"\nRuns an arbitrary function under the SF instance. This can be used \nto run your own hooks when using the integrated hook system doesn't \nmake sense (ex timers).","comment":["--- Runs an arbitrary function under the SF instance. This can be used","-- to run your own hooks when using the integrated hook system doesn't","-- make sense (ex timers).","-- @param func Function to run","-- @param ... Arguments to pass to func"],"code":["function SF.Instance:runFunction(func,...)","\tself:prepare(\"_runFunction\",func)","\t","\tlocal ok, tbl, traceback = self:runWithOps(func,...)","\tif not ok then","\t\tself:cleanup(\"_runFunction\",func,true,tbl,traceback)","\t\tself.error = true","\t\treturn false, tbl, traceback","\tend","\t","\tself:cleanup(\"_runFunction\",func,false)","\treturn true, unpack(tbl)","end",""],"private":false,"class":"function","name":"SF.Instance:runFunction","param":{"1":"func","2":"...","func":"Function to run","...":"Arguments to pass to func"}},"SF.Instance:runLibraryHook":{"summary":"\nRuns a library hook.","description":"\nRuns a library hook. Alias to SF.Libraries.CallHook(hook, self, ...).","comment":["--- Runs a library hook. Alias to SF.Libraries.CallHook(hook, self, ...).","-- @param hook Hook to run.","-- @param ... Additional arguments."],"code":["function SF.Instance:runLibraryHook(hook, ...)","\treturn SF.Libraries.CallHook(hook,self,...)","end",""],"private":false,"class":"function","name":"SF.Instance:runLibraryHook","param":{"1":"hook","2":"...","...":"Additional arguments.","hook":"Hook to run."}},"SF.Instance:runScriptHookForResult":{"ret":["True if it executed ok, false if not or if there was no hook","If the first return value is false then the error message or nil if no hook was registered. Else any values that the hook returned.","The traceback if the instance errored"],"comment":["--- Runs a script hook until one of them returns a true value. Returns those values.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return True if it executed ok, false if not or if there was no hook","-- @return If the first return value is false then the error message or nil if no hook was registered. Else any values that the hook returned.","-- @return The traceback if the instance errored"],"code":["function SF.Instance:runScriptHookForResult(hook,...)","\tfor ok,tbl,traceback in self:iterTblScriptHook(hook,...) do","\t\tif not ok then return false, tbl, traceback","\t\telseif tbl and tbl[1] then","\t\t\treturn true, unpack(tbl)","\t\tend","\tend","\treturn true","end","","-- Some small efficiency thing","local noop = function() end",""],"class":"function","name":"SF.Instance:runScriptHookForResult","private":false,"summary":"\nRuns a script hook until one of them returns a true value.","description":"\nRuns a script hook until one of them returns a true value. Returns those values.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},"SF.Instance:initialize":{"ret":["True if no script errors occured","The error message, if applicable","The error traceback, if applicable"],"comment":["--- Runs the scripts inside of the instance. This should be called once after","-- compiling/unpacking so that scripts can register hooks and such. It should","-- not be called more than once.","-- @return True if no script errors occured","-- @return The error message, if applicable","-- @return The error traceback, if applicable"],"code":["function SF.Instance:initialize()","\tassert(not self.initialized, \"Already initialized!\")","\tself.initialized = true","","\tself.cpu_total = 0","\tself.cpu_average = 0","","\tself:runLibraryHook(\"initialize\")","\tself:prepare(\"_initialize\",\"_initialize\")","\t","\tlocal func = self.scripts[self.mainfile]","\tlocal ok, err, traceback = self:runWithOps(func)","\tif not ok then","\t\tself:cleanup(\"_initialize\", true, err, traceback)","\t\tself.error = true","\t\treturn false, err, traceback","\tend","\t","\tSF.allInstances[self] = self","\t","\tself:cleanup(\"_initialize\",\"_initialize\",false)","\treturn true","end",""],"class":"function","name":"SF.Instance:initialize","private":false,"summary":"\nRuns the scripts inside of the instance.","description":"\nRuns the scripts inside of the instance. This should be called once after \ncompiling/unpacking so that scripts can register hooks and such. It should \nnot be called more than once.","param":[]}},"doc":[{"comment":["---------------------------------------------------------------------","-- SF Instance class.","-- Contains the compiled SF script and essential data. Essentially","-- the execution context.","---------------------------------------------------------------------"],"code":["","SF.Instance = {}","SF.Instance.__index = SF.Instance",""],"summary":"\n \nSF Instance class.","description":"\n \nSF Instance class. \nContains the compiled SF script and essential data. Essentially \nthe execution context. \n","param":[]},{"classForced":true,"summary":"\nInstance fields ","comment":["--- Instance fields","-- @name Instance","-- @class table","-- @field env Environment table for the script","-- @field data Data that libraries can store.","-- @field ppdata Preprocessor data","-- @field ops Currently used ops.","-- @field hooks Registered hooks","-- @field scripts The compiled script functions.","-- @field initialized True if initialized, nil if not.","-- @field error True if instance is errored and should not be executed","-- @field mainfile The main file","-- @field player The \"owner\" of the instance"],"code":[""],"description":"\nInstance fields","class":"table","name":"Instance","field":{"1":"env","2":"data","3":"ppdata","4":"ops","5":"hooks","6":"scripts","7":"initialized","8":"error","9":"mainfile","10":"player","initialized":"True if initialized, nil if not.","ppdata":"Preprocessor data","data":"Data that libraries can store.","ops":"Currently used ops.","player":"The \"owner\" of the instance","scripts":"The compiled script functions.","env":"Environment table for the script","mainfile":"The main file","error":"True if instance is errored and should not be executed","hooks":"Registered hooks"}},{"ret":["True if ok","A table of values that the hook returned"],"comment":["--- Internal function - do not call.","-- Runs a function while incrementing the instance ops coutner.","-- This does no setup work and shouldn't be called by client code","-- @param func The function to run","-- @param ... Arguments to func","-- @return True if ok","-- @return A table of values that the hook returned"],"code":["function SF.Instance:runWithOps(func,...)","","\tlocal args = { ... }","\tlocal traceback","","\tlocal wrapperfunc = function ()","\t\treturn { func( unpack( args ) ) }","\tend","","\tlocal function xpcall_callback ( err )","\t\tif type( err ) == \"table\" then","\t\t\tif err.message then","\t\t\t\tlocal line= err.line","\t\t\t\tlocal file = err.file","","\t\t\t\terr = ( file and ( file .. \":\" ) or \"\" ) .. ( line and ( line .. \": \" ) or \"\" ) .. err.message","\t\t\tend","\t\tend","\t\terr = tostring( err )","\t\ttraceback = debug.traceback( err, 2 )","\t\treturn err","\tend","","\tlocal oldSysTime = SysTime() - self.cpu_total","\t","\tlocal function cpuCheck ()","\t\tself.cpu_total = SysTime() - oldSysTime","","\t\tif self:movingCPUAverage() > self.context.cpuTime:getMax() then","\t\t\tdebug.sethook( nil )","\t\t\tSF.throw( \"CPU Quota exceeded.\", 0, true )","\t\tend","\tend","","\tlocal ok, rt","\tif self.instanceStack then","\t\tok, rt = xpcall( wrapperfunc, xpcall_callback )","\telse","\t\tdebug.sethook( cpuCheck, \"\", 500 )","\t\tok, rt = xpcall( wrapperfunc, xpcall_callback )","\t\tdebug.sethook( nil )","\tend","\t","\t","\tif ok then","\t\treturn true, rt","\telse","\t\treturn false, rt, traceback","\tend","end",""],"class":"function","name":"SF.Instance:runWithOps","private":false,"summary":"\nInternal function - do not call.","description":"\nInternal function - do not call. \nRuns a function while incrementing the instance ops coutner. \nThis does no setup work and shouldn't be called by client code","param":{"1":"func","2":"...","func":"The function to run","...":"Arguments to func"}},{"summary":"\nInternal function - Do not call.","description":"\nInternal function - Do not call. Prepares the script to be executed. \nThis is done automatically by Initialize and runScriptHook.","comment":["--- Internal function - Do not call. Prepares the script to be executed.","-- This is done automatically by Initialize and runScriptHook."],"code":["function SF.Instance:prepare(hook, name)","\tassert(self.initialized, \"Instance not initialized!\")","\tassert(not self.error, \"Instance is errored!\")","\t","\tif SF.instance ~= nil then","\t\tself.instanceStack = self.instanceStack or {}","\t\tself.instanceStack[#self.instanceStack + 1] = SF.instance","\t\tSF.instance = nil","\tend","\t","\tself:runLibraryHook(\"prepare\",hook, name)","\tSF.instance = self","end",""],"private":false,"class":"function","name":"SF.Instance:prepare","param":["hook","name"]},{"summary":"\nInternal function - Do not call.","description":"\nInternal function - Do not call. Cleans up the script. \nThis is done automatically by Initialize and runScriptHook.","comment":["--- Internal function - Do not call. Cleans up the script.","-- This is done automatically by Initialize and runScriptHook."],"code":["function SF.Instance:cleanup(hook, name, ok, errmsg)","\tassert(SF.instance == self)","\tself:runLibraryHook(\"cleanup\",hook, name, ok, errmsg)","\t","\tif self.instanceStack then","\t\tSF.instance = self.instanceStack[#self.instanceStack]","\t\tif #self.instanceStack == 1 then self.instanceStack = nil","\t\telse self.instanceStack[#self.instanceStack] = nil","\t\tend","\telse","\t\tSF.instance = nil","\tend","\t","end",""],"private":false,"class":"function","name":"SF.Instance:cleanup","param":["hook","name","ok","errmsg"]},{"ret":["True if no script errors occured","The error message, if applicable","The error traceback, if applicable"],"comment":["--- Runs the scripts inside of the instance. This should be called once after","-- compiling/unpacking so that scripts can register hooks and such. It should","-- not be called more than once.","-- @return True if no script errors occured","-- @return The error message, if applicable","-- @return The error traceback, if applicable"],"code":["function SF.Instance:initialize()","\tassert(not self.initialized, \"Already initialized!\")","\tself.initialized = true","","\tself.cpu_total = 0","\tself.cpu_average = 0","","\tself:runLibraryHook(\"initialize\")","\tself:prepare(\"_initialize\",\"_initialize\")","\t","\tlocal func = self.scripts[self.mainfile]","\tlocal ok, err, traceback = self:runWithOps(func)","\tif not ok then","\t\tself:cleanup(\"_initialize\", true, err, traceback)","\t\tself.error = true","\t\treturn false, err, traceback","\tend","\t","\tSF.allInstances[self] = self","\t","\tself:cleanup(\"_initialize\",\"_initialize\",false)","\treturn true","end",""],"class":"function","name":"SF.Instance:initialize","private":false,"summary":"\nRuns the scripts inside of the instance.","description":"\nRuns the scripts inside of the instance. This should be called once after \ncompiling/unpacking so that scripts can register hooks and such. It should \nnot be called more than once.","param":[]},{"ret":["True if it executed ok, false if not or if there was no hook","If the first return value is false then the error message or nil if no hook was registered"],"comment":["--- Runs a script hook. This calls script code.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return True if it executed ok, false if not or if there was no hook","-- @return If the first return value is false then the error message or nil if no hook was registered"],"code":["function SF.Instance:runScriptHook(hook, ...)","\tfor ok,err,traceback in self:iterTblScriptHook(hook,...) do","\t\tif not ok then return false,err,traceback end","\tend","\treturn true","end",""],"class":"function","name":"SF.Instance:runScriptHook","private":false,"summary":"\nRuns a script hook.","description":"\nRuns a script hook. This calls script code.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},{"ret":["True if it executed ok, false if not or if there was no hook","If the first return value is false then the error message or nil if no hook was registered. Else any values that the hook returned.","The traceback if the instance errored"],"comment":["--- Runs a script hook until one of them returns a true value. Returns those values.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return True if it executed ok, false if not or if there was no hook","-- @return If the first return value is false then the error message or nil if no hook was registered. Else any values that the hook returned.","-- @return The traceback if the instance errored"],"code":["function SF.Instance:runScriptHookForResult(hook,...)","\tfor ok,tbl,traceback in self:iterTblScriptHook(hook,...) do","\t\tif not ok then return false, tbl, traceback","\t\telseif tbl and tbl[1] then","\t\t\treturn true, unpack(tbl)","\t\tend","\tend","\treturn true","end","","-- Some small efficiency thing","local noop = function() end",""],"class":"function","name":"SF.Instance:runScriptHookForResult","private":false,"summary":"\nRuns a script hook until one of them returns a true value.","description":"\nRuns a script hook until one of them returns a true value. Returns those values.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},{"ret":"An iterator function returning the ok status, and then either the hook \nresults or the error message and traceback","comment":["--- Creates an iterator that calls each registered function for a hook.","-- @param hook The hook to call.","-- @param ... Arguments to pass to the hook's registered function.","-- @return An iterator function returning the ok status, and then either the hook","-- results or the error message and traceback"],"code":["function SF.Instance:iterScriptHook(hook,...)","\tlocal hooks = self.hooks[hook:lower()]","\tif not hooks then return noop end","\tlocal index = nil","\tlocal args = {...}","\treturn function()","\t\tif self.error then return end","\t\tlocal name, func = next(hooks,index)","\t\tif not name then return end","\t\tindex = name","\t\t","\t\tself:prepare(hook,name)","\t\t","\t\tlocal ok, tbl, traceback = self:runWithOps(func,unpack(args))","\t\tif not ok then","\t\t\tself:cleanup(hook,name,true,tbl,traceback)","\t\t\tself.error = true","\t\t\treturn false, tbl, traceback","\t\tend","\t\t","\t\tself:cleanup(hook,name,false)","\t\treturn true, unpack(tbl)","\tend","end",""],"class":"function","name":"SF.Instance:iterScriptHook","private":false,"summary":"\nCreates an iterator that calls each registered function for a hook.","description":"\nCreates an iterator that calls each registered function for a hook.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function.","hook":"The hook to call."}},{"ret":"An iterator function returning the ok status, then either the table of \nhook results or the error message and traceback","comment":["--- Like SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","-- @param ... Arguments to pass to the hook's registered function.","-- @return An iterator function returning the ok status, then either the table of","-- hook results or the error message and traceback"],"code":["function SF.Instance:iterTblScriptHook(hook,...)","\tlocal hooks = self.hooks[hook:lower()]","\tif not hooks then return noop end","\tlocal index = nil","\tlocal args = {...}","\treturn function()","\t\tif self.error then return end","\t\tlocal name, func = next(hooks,index)","\t\tif not name then return end","\t\tindex = name","\t\t","\t\tself:prepare(hook,name)","\t\t","\t\tlocal ok, tbl, traceback = self:runWithOps(func,unpack(args))","\t\tif not ok then","\t\t\tself:cleanup(hook,name,true,tbl,traceback)","\t\t\tself.error = true","\t\t\treturn false, tbl, traceback","\t\tend","\t\t","\t\tself:cleanup(hook,name,false)","\t\treturn true, tbl","\tend","end",""],"class":"function","name":"SF.Instance:iterTblScriptHook","private":false,"summary":"\nLike SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","description":"\nLike SF.Instance:iterSciptHook, except that it doesn't unpack the hook results.","param":{"1":"hook","2":"...","...":"Arguments to pass to the hook's registered function."}},{"summary":"\nRuns a library hook.","description":"\nRuns a library hook. Alias to SF.Libraries.CallHook(hook, self, ...).","comment":["--- Runs a library hook. Alias to SF.Libraries.CallHook(hook, self, ...).","-- @param hook Hook to run.","-- @param ... Additional arguments."],"code":["function SF.Instance:runLibraryHook(hook, ...)","\treturn SF.Libraries.CallHook(hook,self,...)","end",""],"private":false,"class":"function","name":"SF.Instance:runLibraryHook","param":{"1":"hook","2":"...","...":"Additional arguments.","hook":"Hook to run."}},{"summary":"\nRuns an arbitrary function under the SF instance.","description":"\nRuns an arbitrary function under the SF instance. This can be used \nto run your own hooks when using the integrated hook system doesn't \nmake sense (ex timers).","comment":["--- Runs an arbitrary function under the SF instance. This can be used","-- to run your own hooks when using the integrated hook system doesn't","-- make sense (ex timers).","-- @param func Function to run","-- @param ... Arguments to pass to func"],"code":["function SF.Instance:runFunction(func,...)","\tself:prepare(\"_runFunction\",func)","\t","\tlocal ok, tbl, traceback = self:runWithOps(func,...)","\tif not ok then","\t\tself:cleanup(\"_runFunction\",func,true,tbl,traceback)","\t\tself.error = true","\t\treturn false, tbl, traceback","\tend","\t","\tself:cleanup(\"_runFunction\",func,false)","\treturn true, unpack(tbl)","end",""],"private":false,"class":"function","name":"SF.Instance:runFunction","param":{"1":"func","2":"...","func":"Function to run","...":"Arguments to pass to func"}},{"summary":"\nExactly the same as runFunction except doesn't unpack the return values ","description":"\nExactly the same as runFunction except doesn't unpack the return values","comment":["--- Exactly the same as runFunction except doesn't unpack the return values","-- @param func Function to run","-- @param ... Arguments to pass to func"],"code":["function SF.Instance:runFunctionT(func,...)","\tself:prepare(\"_runFunction\",func)","\t","\tlocal ok, tbl, traceback = self:runWithOps(func,...)","\tif not ok then","\t\tself:cleanup(\"_runFunction\",func,true,tbl,traceback)","\t\tself.error = true","\t\treturn false, tbl, traceback","\tend","\t","\tself:cleanup(\"_runFunction\",func,false)","\treturn true, tbl","end",""],"private":false,"class":"function","name":"SF.Instance:runFunctionT","param":{"1":"func","2":"...","func":"Function to run","...":"Arguments to pass to func"}},{"summary":"\nDeinitializes the instance.","description":"\nDeinitializes the instance. After this, the instance should be discarded.","comment":["--- Deinitializes the instance. After this, the instance should be discarded."],"code":["function SF.Instance:deinitialize()","\tself:runLibraryHook(\"deinitialize\")","\tSF.allInstances[self] = nil","\tself.error = true","end",""],"private":false,"class":"function","name":"SF.Instance:deinitialize","param":[]},{"summary":"\nErrors the instance.","description":"\nErrors the instance. Should only be called from the tips of the call tree (aka from places such as the hook library, timer library, the entity's think function, etc)","comment":["--- Errors the instance. Should only be called from the tips of the call tree (aka from places such as the hook library, timer library, the entity's think function, etc)"],"code":["function SF.Instance:Error(msg,traceback)","\t","\tif self.runOnError then -- We have a custom error function, use that instead","\t\tself.runOnError( msg, traceback )","\t\treturn","\tend","\t","\t-- Default behavior","\tself:deinitialize()","end","","function SF.Instance:movingCPUAverage()","\tlocal n = self.context.cpuTime:getBufferN()","\treturn (self.cpu_average * (n - 1) + self.cpu_total) / n","end"],"private":false,"class":"function","name":"SF.Instance:Error","param":["msg","traceback"]}],"tables":{"1":"Instance","Instance":{"classForced":true,"summary":"\nInstance fields ","comment":["--- Instance fields","-- @name Instance","-- @class table","-- @field env Environment table for the script","-- @field data Data that libraries can store.","-- @field ppdata Preprocessor data","-- @field ops Currently used ops.","-- @field hooks Registered hooks","-- @field scripts The compiled script functions.","-- @field initialized True if initialized, nil if not.","-- @field error True if instance is errored and should not be executed","-- @field mainfile The main file","-- @field player The \"owner\" of the instance"],"code":[""],"description":"\nInstance fields","class":"table","name":"Instance","field":{"1":"env","2":"data","3":"ppdata","4":"ops","5":"hooks","6":"scripts","7":"initialized","8":"error","9":"mainfile","10":"player","initialized":"True if initialized, nil if not.","ppdata":"Preprocessor data","data":"Data that libraries can store.","ops":"Currently used ops.","player":"The \"owner\" of the instance","scripts":"The compiled script functions.","env":"Environment table for the script","mainfile":"The main file","error":"True if instance is errored and should not be executed","hooks":"Registered hooks"}}},"description":"\n \nSF Instance class. \nContains the compiled SF script and essential data. Essentially \nthe execution context. \n","summary":"\n \nSF Instance class."},"libraries.lua":{"libraries":[],"type":"file","name":"libraries.lua","functions":{"1":"SF.Libraries.AddHook","2":"SF.Libraries.CallHook","3":"SF.Libraries.CreateLocalTbl","4":"SF.Libraries.Get","5":"SF.Libraries.GetLocal","6":"SF.Libraries.Register","7":"SF.Libraries.RegisterLocal","SF.Libraries.CallHook":{"summary":"\nCalls a library hook.","description":"\nCalls a library hook.","comment":["--- Calls a library hook.","-- @param hookname The name of the hook.","-- @param ... The arguments to the functions that are called."],"code":["function SF.Libraries.CallHook(hookname, ...)","\tlocal hook = SF.Libraries.hooks[hookname]","\tif not hook then return end","\t","\tfor i=1,#hook do","\t\thook[i](...)","\tend","end"],"private":false,"class":"function","name":"SF.Libraries.CallHook","param":{"1":"hookname","2":"...","...":"The arguments to the functions that are called.","hookname":"The name of the hook."}},"SF.Libraries.Get":{"ret":"A metatable proxy of the library","comment":["--- Gets a global library by name","-- @param name The name of the library","-- @return A metatable proxy of the library"],"code":["function SF.Libraries.Get(name)","\treturn SF.Libraries.libraries[name] and setmetatable({},SF.Libraries.libraries[name])","end",""],"class":"function","name":"SF.Libraries.Get","private":false,"summary":"\nGets a global library by name ","description":"\nGets a global library by name","param":{"1":"name","name":"The name of the library"}},"SF.Libraries.AddHook":{"summary":"\nRegisters a library hook.","description":"\nRegisters a library hook. These hooks are only available to SF libraries, \nand are called by Libraries.CallHook.","comment":["--- Registers a library hook. These hooks are only available to SF libraries,","-- and are called by Libraries.CallHook.","-- @param hookname The name of the hook.","-- @param func The function to call"],"code":["function SF.Libraries.AddHook(hookname, func)","\tlocal hook = SF.Libraries.hooks[hookname]","\tif not hook then","\t\thook = {}","\t\tSF.Libraries.hooks[hookname] = hook","\tend","\t","\thook[#hook+1] = func","end",""],"private":false,"class":"function","name":"SF.Libraries.AddHook","param":{"1":"hookname","2":"func","func":"The function to call","hookname":"The name of the hook."}},"SF.Libraries.CreateLocalTbl":{"summary":"\nCreates a table for use in SF.CreateContext containing all of the \nlocal libraries in arr.","description":"\nCreates a table for use in SF.CreateContext containing all of the \nlocal libraries in arr.","comment":["--- Creates a table for use in SF.CreateContext containing all of the","-- local libraries in arr.","-- @param arr Array of local libraries to load"],"code":["function SF.Libraries.CreateLocalTbl(arr)","\tlocal tbl = {}","\tfor i=1,#arr do","\t\tlocal lib = arr[i]","\t\ttbl[lib] = SF.Libraries.Local[lib] or SF.throw( string.format( \"Requested nonexistant library '%s'\", lib ), 2 )","\tend","\treturn tbl","end",""],"private":false,"class":"function","name":"SF.Libraries.CreateLocalTbl","param":{"1":"arr","arr":"Array of local libraries to load"}},"SF.Libraries.Register":{"summary":"\nCreates and registers a global library.","description":"\nCreates and registers a global library. The library will be accessible from any Starfall Instance, regardless of context. \nThis will automatically set __index and __metatable.","comment":["--- Creates and registers a global library. The library will be accessible from any Starfall Instance, regardless of context.","-- This will automatically set __index and __metatable.","-- @param name The library name"],"code":["function SF.Libraries.Register ( name )","\tlocal methods, metamethods = SF.Typedef( \"Library: \" .. name )","\tSF.Libraries.libraries[ name ] = metamethods","\tSF.DefaultEnvironment[ name ] = setmetatable( {}, metamethods )","\treturn methods, metamethods","end",""],"private":false,"class":"function","name":"SF.Libraries.Register","param":{"1":"name","name":"The library name"}},"SF.Libraries.RegisterLocal":{"summary":"\nCreates and registers a local library.","description":"\nCreates and registers a local library. The library must be added to the context's \nlocal libraries field.","comment":["--- Creates and registers a local library. The library must be added to the context's","-- local libraries field."],"code":["function SF.Libraries.RegisterLocal(name)","\tlocal methods, metamethods = SF.Typedef(\"Library: \"..name)","\tSF.Libraries.Local[name] = metamethods","\treturn methods, metamethods","end",""],"private":false,"class":"function","name":"SF.Libraries.RegisterLocal","param":["name"]},"SF.Libraries.GetLocal":{"ret":"The library (not a metatable proxy!)","comment":["--- Gets a local library by name","-- @param name The name of the library","-- @return The library (not a metatable proxy!)"],"code":["function SF.Libraries.GetLocal(name)","\treturn SF.Libraries.Local[name]","end",""],"class":"function","name":"SF.Libraries.GetLocal","private":false,"summary":"\nGets a local library by name ","description":"\nGets a local library by name","param":{"1":"name","name":"The name of the library"}}},"doc":[{"comment":["---------------------------------------------------------------------","-- SF Global Library management","---------------------------------------------------------------------"],"code":["","SF.Libraries = {}","","SF.Libraries.libraries = {}","SF.Libraries.hooks = {}",""],"summary":"\n \nSF Global Library management \n ","description":"\n \nSF Global Library management \n","param":[]},{"classForced":true,"summary":"\nPlace to store local libraries ","comment":["--- Place to store local libraries","-- @name SF.Libraries.Local","-- @class table"],"code":["SF.Libraries.Local = {}",""],"name":"SF.Libraries.Local","class":"table","description":"\nPlace to store local libraries","param":[]},{"summary":"\nCreates and registers a global library.","description":"\nCreates and registers a global library. The library will be accessible from any Starfall Instance, regardless of context. \nThis will automatically set __index and __metatable.","comment":["--- Creates and registers a global library. The library will be accessible from any Starfall Instance, regardless of context.","-- This will automatically set __index and __metatable.","-- @param name The library name"],"code":["function SF.Libraries.Register ( name )","\tlocal methods, metamethods = SF.Typedef( \"Library: \" .. name )","\tSF.Libraries.libraries[ name ] = metamethods","\tSF.DefaultEnvironment[ name ] = setmetatable( {}, metamethods )","\treturn methods, metamethods","end",""],"private":false,"class":"function","name":"SF.Libraries.Register","param":{"1":"name","name":"The library name"}},{"summary":"\nCreates and registers a local library.","description":"\nCreates and registers a local library. The library must be added to the context's \nlocal libraries field.","comment":["--- Creates and registers a local library. The library must be added to the context's","-- local libraries field."],"code":["function SF.Libraries.RegisterLocal(name)","\tlocal methods, metamethods = SF.Typedef(\"Library: \"..name)","\tSF.Libraries.Local[name] = metamethods","\treturn methods, metamethods","end",""],"private":false,"class":"function","name":"SF.Libraries.RegisterLocal","param":["name"]},{"ret":"A metatable proxy of the library","comment":["--- Gets a global library by name","-- @param name The name of the library","-- @return A metatable proxy of the library"],"code":["function SF.Libraries.Get(name)","\treturn SF.Libraries.libraries[name] and setmetatable({},SF.Libraries.libraries[name])","end",""],"class":"function","name":"SF.Libraries.Get","private":false,"summary":"\nGets a global library by name ","description":"\nGets a global library by name","param":{"1":"name","name":"The name of the library"}},{"ret":"The library (not a metatable proxy!)","comment":["--- Gets a local library by name","-- @param name The name of the library","-- @return The library (not a metatable proxy!)"],"code":["function SF.Libraries.GetLocal(name)","\treturn SF.Libraries.Local[name]","end",""],"class":"function","name":"SF.Libraries.GetLocal","private":false,"summary":"\nGets a local library by name ","description":"\nGets a local library by name","param":{"1":"name","name":"The name of the library"}},{"summary":"\nCreates a table for use in SF.CreateContext containing all of the \nlocal libraries in arr.","description":"\nCreates a table for use in SF.CreateContext containing all of the \nlocal libraries in arr.","comment":["--- Creates a table for use in SF.CreateContext containing all of the","-- local libraries in arr.","-- @param arr Array of local libraries to load"],"code":["function SF.Libraries.CreateLocalTbl(arr)","\tlocal tbl = {}","\tfor i=1,#arr do","\t\tlocal lib = arr[i]","\t\ttbl[lib] = SF.Libraries.Local[lib] or SF.throw( string.format( \"Requested nonexistant library '%s'\", lib ), 2 )","\tend","\treturn tbl","end",""],"private":false,"class":"function","name":"SF.Libraries.CreateLocalTbl","param":{"1":"arr","arr":"Array of local libraries to load"}},{"summary":"\nRegisters a library hook.","description":"\nRegisters a library hook. These hooks are only available to SF libraries, \nand are called by Libraries.CallHook.","comment":["--- Registers a library hook. These hooks are only available to SF libraries,","-- and are called by Libraries.CallHook.","-- @param hookname The name of the hook.","-- @param func The function to call"],"code":["function SF.Libraries.AddHook(hookname, func)","\tlocal hook = SF.Libraries.hooks[hookname]","\tif not hook then","\t\thook = {}","\t\tSF.Libraries.hooks[hookname] = hook","\tend","\t","\thook[#hook+1] = func","end",""],"private":false,"class":"function","name":"SF.Libraries.AddHook","param":{"1":"hookname","2":"func","func":"The function to call","hookname":"The name of the hook."}},{"summary":"\nCalls a library hook.","description":"\nCalls a library hook.","comment":["--- Calls a library hook.","-- @param hookname The name of the hook.","-- @param ... The arguments to the functions that are called."],"code":["function SF.Libraries.CallHook(hookname, ...)","\tlocal hook = SF.Libraries.hooks[hookname]","\tif not hook then return end","\t","\tfor i=1,#hook do","\t\thook[i](...)","\tend","end"],"private":false,"class":"function","name":"SF.Libraries.CallHook","param":{"1":"hookname","2":"...","...":"The arguments to the functions that are called.","hookname":"The name of the hook."}}],"tables":{"1":"SF.Libraries.Local","SF.Libraries.Local":{"classForced":true,"summary":"\nPlace to store local libraries ","comment":["--- Place to store local libraries","-- @name SF.Libraries.Local","-- @class table"],"code":["SF.Libraries.Local = {}",""],"name":"SF.Libraries.Local","class":"table","description":"\nPlace to store local libraries","param":[]}},"description":"\n \nSF Global Library management \n","summary":"\n \nSF Global Library management \n "},"libs_sh/color.lua":{"libraries":[],"type":"file","name":"libs_sh/color.lua","functions":{"1":"SF.DefaultEnvironment.Color","2":"color_metatable.__concat","3":"color_metatable.__index","4":"color_metatable.__newindex","5":"color_metatable:__eq","6":"color_metatable:__tostring","7":"color_methods:hsvToRGB","8":"color_methods:rgbToHSV","color_methods:hsvToRGB":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from HSV to RGB.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:hsvToRGB ()","\treturn HSVToColor( self.r, self.g, self.b )","end"],"class":"function","summary":"\nConverts the color from HSV to RGB.","classlib":"Color","name":"color_methods:hsvToRGB","server":true,"private":false,"client":true,"description":"\nConverts the color from HSV to RGB.","param":[]},"color_methods:rgbToHSV":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from RGB to HSV.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:rgbToHSV ()","\treturn ColorToHSV( unwrap( self ) )","end",""],"class":"function","summary":"\nConverts the color from RGB to HSV.","classlib":"Color","name":"color_methods:rgbToHSV","server":true,"private":false,"client":true,"description":"\nConverts the color from RGB to HSV.","param":[]},"color_metatable:__tostring":{"summary":"\n__tostring metamethod ","description":"\n__tostring metamethod","comment":["--- __tostring metamethod"],"code":["function color_metatable:__tostring ()","\treturn self.r .. \" \" .. self.g .. \" \" .. self.b .. \" \" .. self.a","end",""],"private":false,"class":"function","name":"color_metatable:__tostring","param":[]},"color_metatable.__index":{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function color_metatable.__index ( t, k )","\tif rgb[ k ] then","\t\treturn rawget( SF.UnwrapObject( t ), rgb[ k ] )","\telse","\t\treturn _p[ k ]","\tend","end",""],"private":false,"class":"function","name":"color_metatable.__index","param":["t","k"]},"SF.DefaultEnvironment.Color":{"ret":"New color","comment":["--- Same as the Gmod Color type","-- @name SF.DefaultEnvironment.Color","-- @class function","-- @param r - Red","-- @param g - Green","-- @param b - Blue","-- @param a - Alpha","-- @return New color"],"code":["SF.DefaultEnvironment.Color = function ( ... )","\treturn wrap( Color( ... ) )","end","","-- Lookup table.","-- Index 1->4 have associative rgba for use in __index. Saves lots of checks","-- String based indexing returns string, just a pass through.","-- Think of rgb as a template for members of Color that are expected.","local rgb = { [ 1 ] = \"r\", [ 2 ] = \"g\", [ 3 ] = \"b\", [ 4 ] = \"a\", r = \"r\", g = \"g\", b = \"b\", a = \"a\" }",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.Color","private":false,"summary":"\nSame as the Gmod Color type ","description":"\nSame as the Gmod Color type","param":{"1":"...","2":"r","3":"g","4":"b","5":"a","a":"- Alpha","b":"- Blue","g":"- Green","r":"- Red"}},"color_metatable.__concat":{"summary":"\n__concat metamethod ","description":"\n__concat metamethod","comment":["--- __concat metamethod"],"code":["function color_metatable.__concat ( ... )","\tlocal t = { ... }","\treturn tostring( t[ 1 ] ) .. tostring( t[ 2 ] )","end",""],"private":false,"class":"function","name":"color_metatable.__concat","param":["..."]},"color_metatable:__eq":{"summary":"\n__eq metamethod ","description":"\n__eq metamethod","comment":["--- __eq metamethod"],"code":["function color_metatable:__eq ( c )","\tSF.CheckType( self, color_metatable )","\tSF.CheckType( c, color_metatable )","\treturn unwrap( self ):__eq( unwrap( c ) )","end",""],"private":false,"class":"function","name":"color_metatable:__eq","param":["c"]},"color_metatable.__newindex":{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function color_metatable.__newindex ( t, k, v )","\tif rgb[ k ] then","\t\trawset( SF.UnwrapObject( t ), rgb[ k ], v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = color_metatable.__index",""],"private":false,"class":"function","name":"color_metatable.__newindex","param":["t","k","v"]}},"doc":[{"comment":["--- Color type","--@shared"],"code":["local color_methods, color_metatable = SF.Typedef( \"Color\" )","","local wrap, unwrap = SF.CreateWrapper( color_metatable, true, false, debug.getregistry().Color )","","SF.Color.Methods = color_methods","SF.Color.Metatable = color_metatable","SF.Color.Wrap = wrap","SF.Color.Unwrap = unwrap",""],"typtbl":"color_methods","summary":"\nColor type ","fields":[],"name":"Color","server":true,"description":"\nColor type","client":true,"class":"class","methods":{"1":"hsvToRGB","2":"rgbToHSV","rgbToHSV":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from RGB to HSV.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:rgbToHSV ()","\treturn ColorToHSV( unwrap( self ) )","end",""],"class":"function","summary":"\nConverts the color from RGB to HSV.","classlib":"Color","name":"color_methods:rgbToHSV","server":true,"private":false,"client":true,"description":"\nConverts the color from RGB to HSV.","param":[]},"hsvToRGB":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from HSV to RGB.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:hsvToRGB ()","\treturn HSVToColor( self.r, self.g, self.b )","end"],"class":"function","summary":"\nConverts the color from HSV to RGB.","classlib":"Color","name":"color_methods:hsvToRGB","server":true,"private":false,"client":true,"description":"\nConverts the color from HSV to RGB.","param":[]}}},{"ret":"New color","comment":["--- Same as the Gmod Color type","-- @name SF.DefaultEnvironment.Color","-- @class function","-- @param r - Red","-- @param g - Green","-- @param b - Blue","-- @param a - Alpha","-- @return New color"],"code":["SF.DefaultEnvironment.Color = function ( ... )","\treturn wrap( Color( ... ) )","end","","-- Lookup table.","-- Index 1->4 have associative rgba for use in __index. Saves lots of checks","-- String based indexing returns string, just a pass through.","-- Think of rgb as a template for members of Color that are expected.","local rgb = { [ 1 ] = \"r\", [ 2 ] = \"g\", [ 3 ] = \"b\", [ 4 ] = \"a\", r = \"r\", g = \"g\", b = \"b\", a = \"a\" }",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.Color","private":false,"summary":"\nSame as the Gmod Color type ","description":"\nSame as the Gmod Color type","param":{"1":"...","2":"r","3":"g","4":"b","5":"a","a":"- Alpha","b":"- Blue","g":"- Green","r":"- Red"}},{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function color_metatable.__newindex ( t, k, v )","\tif rgb[ k ] then","\t\trawset( SF.UnwrapObject( t ), rgb[ k ], v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = color_metatable.__index",""],"private":false,"class":"function","name":"color_metatable.__newindex","param":["t","k","v"]},{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function color_metatable.__index ( t, k )","\tif rgb[ k ] then","\t\treturn rawget( SF.UnwrapObject( t ), rgb[ k ] )","\telse","\t\treturn _p[ k ]","\tend","end",""],"private":false,"class":"function","name":"color_metatable.__index","param":["t","k"]},{"summary":"\n__tostring metamethod ","description":"\n__tostring metamethod","comment":["--- __tostring metamethod"],"code":["function color_metatable:__tostring ()","\treturn self.r .. \" \" .. self.g .. \" \" .. self.b .. \" \" .. self.a","end",""],"private":false,"class":"function","name":"color_metatable:__tostring","param":[]},{"summary":"\n__concat metamethod ","description":"\n__concat metamethod","comment":["--- __concat metamethod"],"code":["function color_metatable.__concat ( ... )","\tlocal t = { ... }","\treturn tostring( t[ 1 ] ) .. tostring( t[ 2 ] )","end",""],"private":false,"class":"function","name":"color_metatable.__concat","param":["..."]},{"summary":"\n__eq metamethod ","description":"\n__eq metamethod","comment":["--- __eq metamethod"],"code":["function color_metatable:__eq ( c )","\tSF.CheckType( self, color_metatable )","\tSF.CheckType( c, color_metatable )","\treturn unwrap( self ):__eq( unwrap( c ) )","end",""],"private":false,"class":"function","name":"color_metatable:__eq","param":["c"]},{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from RGB to HSV.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:rgbToHSV ()","\treturn ColorToHSV( unwrap( self ) )","end",""],"class":"function","summary":"\nConverts the color from RGB to HSV.","classlib":"Color","name":"color_methods:rgbToHSV","server":true,"private":false,"client":true,"description":"\nConverts the color from RGB to HSV.","param":[]},{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from HSV to RGB.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:hsvToRGB ()","\treturn HSVToColor( self.r, self.g, self.b )","end"],"class":"function","summary":"\nConverts the color from HSV to RGB.","classlib":"Color","name":"color_methods:hsvToRGB","server":true,"private":false,"client":true,"description":"\nConverts the color from HSV to RGB.","param":[]}],"tables":[],"description":"\nColor type","summary":"\nColor type "},"libs_sh/builtins.lua":{"libraries":{"1":"builtin","builtin":{"description":"\nBuilt in values. These don't need to be loaded; they are in the default environment.","code":["","-- ------------------------- Lua Ports ------------------------- --","-- This part is messy because of LuaDoc stuff.","","local function pascalToCamel ( t, r )","\tlocal r = r or {}","\tfor k, v in pairs( t ) do","\t\tk = k:gsub( \"^%l\", string.lower )","\t\tr[ k ] = v","\tend","\treturn r","end",""],"summary":"\nBuilt in values.","class":"library","tables":{"1":"IN_KEY","2":"KEY","3":"MOUSE","4":"math","5":"os","6":"string","7":"table","string":{"description":"\nLua's (not glua's) string library","code":["SF.DefaultEnvironment.string = setmetatable( {}, string_metatable )","","-- Math library","local math_methods, math_metatable = SF.Typedef(\"Library: math\")","filterGmodLua(math,math_methods)","math_metatable.__newindex = function() end","math_methods.clamp = math.Clamp","math_methods.angnorm = math.NormalizeAngle","math_methods.sign = function(a) return a>0 and 1 or -1 end","math_methods.round = math.Round","math_methods.randfloat = math.Rand","math_methods.calcBSplineN = nil"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.string","summary":"\nLua's (not glua's) string library ","library":"builtin","comment":["--- Lua's (not glua's) string library","-- @name SF.DefaultEnvironment.string","-- @class table"],"param":[]},"os":{"description":"\nGLua's os library. http://wiki.garrysmod.com/page/Category:os, plus sortByKey, sortByMember","code":["SF.DefaultEnvironment.os = setmetatable( {}, os_metatable )","","local table_methods, table_metatable = SF.Typedef(\"Library: table\")","filterGmodLua(table,table_methods)","table_methods.sortByKey = table.SortByKey","table_methods.sortByMember = table.SortByMember","table_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.os","summary":"\nGLua's os library.","library":"builtin","comment":["--- GLua's os library. http://wiki.garrysmod.com/page/Category:os, plus sortByKey, sortByMember","-- @name SF.DefaultEnvironment.os","-- @class table"],"param":[]},"table":{"description":"\nLua's (not glua's) table library","code":["SF.DefaultEnvironment.table = setmetatable({},table_metatable)","","-- ------------------------- Functions ------------------------- --",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.table","summary":"\nLua's (not glua's) table library ","library":"builtin","comment":["--- Lua's (not glua's) table library","-- @name SF.DefaultEnvironment.table","-- @class table"],"param":[]},"math":{"description":"\nLua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN","code":["SF.DefaultEnvironment.math = setmetatable({},math_metatable)","","local os_methods, os_metatable = SF.Typedef( \"Library: os\" )","filterGmodLua( os, os_methods )","os_metatable.__newindex = function () end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.math","summary":"\nLua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN ","library":"builtin","comment":["--- Lua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN","-- @name SF.DefaultEnvironment.math","-- @class table"],"param":[]},"IN_KEY":{"description":"\nENUMs of in_keys for use with player:keyDown","code":["SF.DefaultEnvironment.IN_KEY = setmetatable( {}, {","\t__index = _INKEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.IN_KEY","summary":"\nENUMs of in_keys for use with player:keyDown ","library":"builtin","comment":["--- ENUMs of in_keys for use with player:keyDown","-- @name SF.DefaultEnvironment.IN_KEY","-- @class table"],"param":[]},"MOUSE":{"description":"\nENUMs of mouse buttons for use with input library","code":["SF.DefaultEnvironment.MOUSE = setmetatable( {}, {","\t__index = _MOUSE,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _INKEY = {","\t[ \"ALT1\" ] = IN_ALT1,","\t[ \"ALT2\" ] = IN_ALT2,","\t[ \"ATTACK\" ] = IN_ATTACK,","\t[ \"ATTACK2\" ] = IN_ATTACK2,","\t[ \"BACK\" ] = IN_BACK,","\t[ \"DUCK\" ] = IN_DUCK,","\t[ \"FORWARD\" ] = IN_FORWARD,","\t[ \"JUMP\" ] = IN_JUMP,","\t[ \"LEFT\" ] = IN_LEFT,","\t[ \"MOVELEFT\" ] = IN_MOVELEFT,","\t[ \"MOVERIGHT\" ] = IN_MOVERIGHT,","\t[ \"RELOAD\" ] = IN_RELOAD,","\t[ \"RIGHT\" ] = IN_RIGHT,","\t[ \"SCORE\" ] = IN_SCORE,","\t[ \"SPEED\" ] = IN_SPEED,","\t[ \"USE\" ] = IN_USE,","\t[ \"WALK\" ] = IN_WALK,","\t[ \"ZOOM\" ] = IN_ZOOM,","\t[ \"GRENADE1\" ] = IN_GRENADE1,","\t[ \"GRENADE2\" ] = IN_GRENADE2,","\t[ \"WEAPON1\" ] = IN_WEAPON1,","\t[ \"WEAPON2\" ] = IN_WEAPON2,","\t[ \"BULLRUSH\" ] = IN_BULLRUSH,","\t[ \"CANCEL\" ] = IN_CANCEL,","\t[ \"RUN\" ] = IN_RUN,","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.MOUSE","summary":"\nENUMs of mouse buttons for use with input library ","library":"builtin","comment":["--- ENUMs of mouse buttons for use with input library","-- @name SF.DefaultEnvironment.MOUSE","-- @class table"],"param":[]},"KEY":{"description":"\nENUMs of keyboard keys for use with input library","code":["SF.DefaultEnvironment.KEY = setmetatable( {}, {","\t__index = _KEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _MOUSE = {","\t[ \"MOUSE1\" ] = 107,","\t[ \"LEFT\" ] = 107,","\t[ \"MOUSE2\" ] = 108,","\t[ \"RIGHT\" ] = 108,","\t[ \"MOUSE3\" ] = 109,","\t[ \"MIDDLE\" ] = 109,","\t[ \"MOUSE4\" ] = 110,","\t[ \"4\" ] = 110,","\t[ \"MOUSE5\"] = 111,","\t[ \"5\" ] = 111,","\t[ \"MWHEELUP\" ] = 112,","\t[ \"WHEEL_UP\" ] = 112,","\t[ \"MWHEELDOWN\" ] = 113,","\t[ \"WHEEL_DOWN\" ] = 113,","\t[ \"COUNT\" ] = 7,","\t[ \"FIRST\" ] = 107,","\t[ \"LAST\" ] = 113","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.KEY","summary":"\nENUMs of keyboard keys for use with input library ","library":"builtin","comment":["--- ENUMs of keyboard keys for use with input library","-- @name SF.DefaultEnvironment.KEY","-- @class table"],"param":[]}},"functions":{"1":"assert","2":"concmd","3":"dodir","4":"dofile","5":"error","6":"getLibraries","7":"getfenv","8":"getmetatable","9":"ipairs","10":"loadstring","11":"next","12":"pairs","13":"print","14":"printTable","15":"quotaAverage","16":"quotaMax","17":"quotaUsed","18":"rawget","19":"rawset","20":"require","21":"requiredir","22":"setfenv","23":"setmetatable","24":"throw","25":"tonumber","26":"tostring","27":"try","28":"type","29":"unpack","getLibraries":{"ret":"Table containing the names of each available library","comment":["--- Gets a list of all libraries","-- @return Table containing the names of each available library"],"code":["function SF.DefaultEnvironment.getLibraries()","\tlocal ret = {}","\tfor k,v in pairs( SF.Libraries.libraries ) do","\t\tret[#ret+1] = k","\tend","\treturn ret","end","","","","if SERVER then"],"class":"function","name":"SF.DefaultEnvironment.getLibraries","summary":"\nGets a list of all libraries ","private":false,"library":"builtin","description":"\nGets a list of all libraries","param":[]},"printTable":{"comment":["--- Prints a table to player's chat","-- @param tbl Table to print"],"code":["function SF.DefaultEnvironment.printTable ( tbl )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tSF.CheckType( tbl, \"table\" )","","\tprintTableX( ( SERVER and SF.instance.player or LocalPlayer() ), tbl, 0, { t = true } )","end","",""],"class":"function","name":"SF.DefaultEnvironment.printTable","summary":"\nPrints a table to player's chat ","private":false,"library":"builtin","description":"\nPrints a table to player's chat","param":{"1":"tbl","tbl":"Table to print"}},"tostring":{"ret":"obj as string","description":"\nSame as Lua's tostring","code":["SF.DefaultEnvironment.tostring = tostring"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tostring","summary":"\nSame as Lua's tostring ","library":"builtin","comment":["--- Same as Lua's tostring","-- @name SF.DefaultEnvironment.tostring","-- @class function","-- @param obj","-- @return obj as string"],"param":{"1":"obj","obj":""}},"print":{"comment":["\t--- Prints a message to the player's chat.","\t-- @shared","\t-- @param ... Values to print"],"code":["\tfunction SF.DefaultEnvironment.print(...)","\t\tlocal str = \"\"","\t\tlocal tbl = {n=select('#', ...), ...}","\t\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t\tSF.instance.player:ChatPrint(str)","\tend","else","\t-- Prints a message to the player's chat.","\tfunction SF.DefaultEnvironment.print(...)","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tlocal str = \"\"","\t\tlocal tbl = {n=select('#', ...), ...}","\t\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t\tLocalPlayer():ChatPrint(str)","\tend","end","","local function printTableX ( target, t, indent, alreadyprinted )","\tfor k,v in SF.DefaultEnvironment.pairs( t ) do","\t\tif SF.GetType( v ) == \"table\" and not alreadyprinted[ v ] then","\t\t\talreadyprinted[ v ] = true","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \":\" )","\t\t\tprintTableX( target, v, indent + 1, alreadyprinted )","\t\telse","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \"\\t=\\t\" .. tostring( v ) )","\t\tend","\tend","end",""],"class":"function","summary":"\nPrints a message to the player's chat.","library":"builtin","name":"SF.DefaultEnvironment.print","server":true,"private":false,"client":true,"description":"\nPrints a message to the player's chat.","param":{"1":"...","...":"Values to print"}},"rawget":{"ret":"The value of the index","comment":["--- Gets the value of a table index without invoking a metamethod","--@param table The table to get the value from","--@param key The index of the table","--@return The value of the index"],"code":["function SF.DefaultEnvironment.rawget( table, key, value )","    SF.CheckType( table, \"table\" )","","    return rawget( table, key )","end","","-- ------------------------- Restrictions ------------------------- --","-- Restricts access to builtin type's metatables","","local _R = debug.getregistry()","local function restrict(instance, hook, name, ok, err)","\t_R.Vector.__metatable = \"Vector\"","\t_R.Angle.__metatable = \"Angle\"","\t_R.VMatrix.__metatable = \"VMatrix\"","end","","local function unrestrict(instance, hook, name, ok, err)","\t_R.Vector.__metatable = nil","\t_R.Angle.__metatable = nil","\t_R.VMatrix.__metatable = nil","end","","SF.Libraries.AddHook(\"prepare\", restrict)","SF.Libraries.AddHook(\"cleanup\", unrestrict)","",""],"class":"function","name":"SF.DefaultEnvironment.rawget","summary":"\nGets the value of a table index without invoking a metamethod ","private":false,"library":"builtin","description":"\nGets the value of a table index without invoking a metamethod","param":{"1":"table","2":"key","3":"value","key":"The index of the table","table":"The table to get the value from"}},"rawset":{"comment":["--- Set the value of a table index without invoking a metamethod","--@param table The table to modify","--@param key The index of the table","--@param value The value to set the index equal to"],"code":["function SF.DefaultEnvironment.rawset( table, key, value )","    SF.CheckType( table, \"table\" )","","    rawset( table, key, value )","end",""],"class":"function","name":"SF.DefaultEnvironment.rawset","summary":"\nSet the value of a table index without invoking a metamethod ","private":false,"library":"builtin","description":"\nSet the value of a table index without invoking a metamethod","param":{"1":"table","2":"key","3":"value","value":"The value to set the index equal to","key":"The index of the table","table":"The table to modify"}},"tonumber":{"ret":"obj as number","description":"\nSame as Lua's tonumber","code":["SF.DefaultEnvironment.tonumber = tonumber",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tonumber","summary":"\nSame as Lua's tonumber ","library":"builtin","comment":["--- Same as Lua's tonumber","-- @name SF.DefaultEnvironment.tonumber","-- @class function","-- @param obj","-- @return obj as number"],"param":{"1":"obj","obj":""}},"error":{"comment":["--- Throws a raw exception.","-- @param msg Exception message"],"code":["function SF.DefaultEnvironment.error ( msg )","\terror( msg or \"an unspecified error occured\", 2 )","end",""],"class":"function","name":"SF.DefaultEnvironment.error","summary":"\nThrows a raw exception.","private":false,"library":"builtin","description":"\nThrows a raw exception.","param":{"1":"msg","msg":"Exception message"}},"unpack":{"ret":"Elements of tbl","description":"\nSame as Lua's unpack","code":["SF.DefaultEnvironment.unpack = unpack",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.unpack","summary":"\nSame as Lua's unpack ","library":"builtin","comment":["--- Same as Lua's unpack","-- @name SF.DefaultEnvironment.unpack","-- @class function","-- @param tbl","-- @return Elements of tbl"],"param":{"1":"tbl","tbl":""}},"throw":{"comment":["--- Throws an exception","-- @param msg Message","-- @param level Which level in the stacktrace to blame. Defaults to one of invalid","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.DefaultEnvironment.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" )","\tif not filename then","\t\tinfo = debug.getinfo( 2, \"Sl\" )","\t\tfilename = info.short_src:match( \"^SF:(.*)$\" )","\tend","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"class":"function","name":"SF.DefaultEnvironment.throw","summary":"\nThrows an exception ","private":false,"library":"builtin","description":"\nThrows an exception","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame. Defaults to one of invalid"}},"try":{"comment":["--- Try to execute a function and catch possible exceptions","-- Similar to xpcall, but a bit more in-depth","-- @param func Function to execute","-- @param catch Optional function to execute in case func fails"],"code":["function SF.DefaultEnvironment.try ( func, catch )","\tlocal ok, err = pcall( func )","\tif ok then return end","","\tif type( err ) == \"table\" then","\t\tif err.uncatchable then","\t\t\terror( err )","\t\tend","\tend","\tif catch then catch( err ) end","end",""],"class":"function","name":"SF.DefaultEnvironment.try","summary":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth ","private":false,"library":"builtin","description":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth","param":{"1":"func","2":"catch","func":"Function to execute","catch":"Optional function to execute in case func fails"}},"require":{"ret":"Return value of the script","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.require(file)","\tSF.CheckType(file, \"string\")","\tlocal loaded = SF.instance.data.reqloaded","\tif not loaded then","\t\tloaded = {}","\t\tSF.instance.data.reqloaded = loaded","\tend","\t","\tif loaded[file] then","\t\treturn loaded[file]","\telse","\t\tlocal func = SF.instance.scripts[file]","\t\tif not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","\t\tloaded[file] = func() or true","\t\treturn loaded[file]","\tend","end",""],"class":"function","name":"SF.DefaultEnvironment.require","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"quotaUsed":{"ret":"Current quota used this Think","comment":["--- Returns the current count for this Think's CPU Time.","-- This value increases as more executions are done, may not be exactly as you want.","-- If used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","-- @return Current quota used this Think"],"code":["function SF.DefaultEnvironment.quotaUsed ()","\treturn SF.instance.cpu_total","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaUsed","summary":"\nReturns the current count for this Think's CPU Time.","private":false,"library":"builtin","description":"\nReturns the current count for this Think's CPU Time. \nThis value increases as more executions are done, may not be exactly as you want. \nIf used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","param":[]},"getfenv":{"ret":"Current environment","comment":["--- Simple version of Lua's getfenv","-- Returns the current environment","-- @return Current environment"],"code":["function SF.DefaultEnvironment.getfenv ()","\treturn getfenv()","end",""],"class":"function","name":"SF.DefaultEnvironment.getfenv","summary":"\nSimple version of Lua's getfenv \nReturns the current environment ","private":false,"library":"builtin","description":"\nSimple version of Lua's getfenv \nReturns the current environment","param":[]},"type":{"ret":"The name of the object's type.","comment":["--- Same as Lua's type","-- @name SF.DefaultEnvironment.type","-- @class function","-- @param obj Object to get type of","-- @return The name of the object's type."],"code":["SF.DefaultEnvironment.type = function( obj )","\tlocal tp = getmetatable( obj )","\treturn type(tp) == \"string\" and tp or type( obj )","end"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.type","summary":"\nSame as Lua's type ","private":false,"library":"builtin","description":"\nSame as Lua's type","param":{"1":"obj","obj":"Object to get type of"}},"pairs":{"ret":["Iterator function","Table tbl","nil as current index"],"description":"\nSame as Lua's pairs","code":["SF.DefaultEnvironment.pairs = pairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.pairs","summary":"\nSame as Lua's pairs ","library":"builtin","comment":["--- Same as Lua's pairs","-- @name SF.DefaultEnvironment.pairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return nil as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"next":{"ret":["Key or nil","Value or nil"],"description":"\nSame as Lua's next","code":["SF.DefaultEnvironment.next = next"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.next","summary":"\nSame as Lua's next ","library":"builtin","comment":["--- Same as Lua's next","-- @name SF.DefaultEnvironment.next","-- @class function","-- @param tbl Table to get the next key-value pair of","-- @param k Previous key (can be nil)","-- @return Key or nil","-- @return Value or nil"],"param":{"1":"tbl","2":"k","tbl":"Table to get the next key-value pair of","k":"Previous key (can be nil)"}},"setfenv":{"ret":"func with environment set to tbl","comment":["--- Lua's setfenv","-- Works like setfenv, but is restricted on functions","-- @param func Function to change environment of","-- @param tbl New environment","-- @return func with environment set to tbl"],"code":["function SF.DefaultEnvironment.setfenv ( func, tbl )","\tif type( func ) ~= \"function\" then SF.throw( \"Main Thread is protected!\", 2 ) end","\treturn setfenv( func, tbl )","end",""],"class":"function","name":"SF.DefaultEnvironment.setfenv","summary":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions ","private":false,"library":"builtin","description":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions","param":{"1":"func","2":"tbl","func":"Function to change environment of","tbl":"New environment"}},"assert":{"comment":["--- Same as Lua's assert.","-- @name SF.DefaultEnvironment.assert","-- @class function","-- @param condition","-- @param msg"],"code":["SF.DefaultEnvironment.assert = function ( condition, msg ) if not condition then SF.throw( msg or \"assertion failed!\", 2 ) end end"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.assert","summary":"\nSame as Lua's assert.","private":false,"library":"builtin","description":"\nSame as Lua's assert.","param":{"1":"condition","2":"msg","condition":"","msg":""}},"dodir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included directory, but does not cache the result.","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.dodir( dir, loadpriority )","    SF.CheckType( dir, \"string\" )","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","","    local returns = {}","","    if loadpriority then","        for i = 0, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.dofile( file )","                end","            end","        end","    end","","    for file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 then","\t\t\treturns[ file ] = SF.DefaultEnvironment.dofile( file )","\t\tend","    end","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.dodir","summary":"\nRuns an included directory, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included directory, but does not cache the result.","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"quotaAverage":{"ret":"Average CPU Time of the buffer.","comment":["--- Gets the Average CPU Time in the buffer","-- @return Average CPU Time of the buffer."],"code":["function SF.DefaultEnvironment.quotaAverage ()","\treturn SF.instance.cpu_average","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaAverage","summary":"\nGets the Average CPU Time in the buffer ","private":false,"library":"builtin","description":"\nGets the Average CPU Time in the buffer","param":[]},"loadstring":{"ret":"Function of str","comment":["--- GLua's loadstring","-- Works like loadstring, except that it executes by default in the main environment","-- @param str String to execute","-- @return Function of str"],"code":["function SF.DefaultEnvironment.loadstring ( str )","\tlocal func = CompileString( str, \"SF: \" .. tostring( SF.instance.env ), false )","\t","\t-- CompileString returns an error as a string, better check before setfenv","\tif type( func ) == \"function\" then","\t\treturn setfenv( func, SF.instance.env )","\tend","\t","\treturn func","end",""],"class":"function","name":"SF.DefaultEnvironment.loadstring","summary":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment ","private":false,"library":"builtin","description":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment","param":{"1":"str","str":"String to execute"}},"setmetatable":{"ret":"tbl with metatable set to meta","description":"\nSame as Lua's setmetatable. Doesn't work on most internal metatables","code":["SF.DefaultEnvironment.setmetatable = setmetatable",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.setmetatable","summary":"\nSame as Lua's setmetatable.","library":"builtin","comment":["--- Same as Lua's setmetatable. Doesn't work on most internal metatables","-- @name SF.DefaultEnvironment.setmetatable","-- @class function","-- @param tbl The table to set the metatable of","-- @param meta The metatable to use","-- @return tbl with metatable set to meta"],"param":{"1":"tbl","2":"meta","tbl":"The table to set the metatable of","meta":"The metatable to use"}},"requiredir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.requiredir( dir, loadpriority )","    SF.CheckType( dir, \"string\")","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","    ","    local returns = {}","","    if loadpriority then","        for i = 1, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.require( file )","                end","            end","        end","    end","","\tfor file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 and not returns[ file ] then","\t\t\treturns[ file ] = SF.DefaultEnvironment.require( file )","\t\tend","\tend","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.requiredir","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"dofile":{"ret":"Return value of the script","comment":["--- Runs an included script, but does not cache the result.","-- Pretty much like standard Lua dofile()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.dofile(file)","    SF.CheckType(file, \"string\")","    local func = SF.instance.scripts[file]","    if not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","    return func()","end",""],"class":"function","name":"SF.DefaultEnvironment.dofile","summary":"\nRuns an included script, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included script, but does not cache the result. \nPretty much like standard Lua dofile()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"ipairs":{"ret":["Iterator function","Table tbl","0 as current index"],"description":"\nSame as Lua's ipairs","code":["SF.DefaultEnvironment.ipairs = ipairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.ipairs","summary":"\nSame as Lua's ipairs ","library":"builtin","comment":["--- Same as Lua's ipairs","-- @name SF.DefaultEnvironment.ipairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return 0 as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"quotaMax":{"ret":"Max SysTime allowed to take for execution of the chip in a Think.","comment":["--- Gets the CPU Time max.","-- CPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","-- @return Max SysTime allowed to take for execution of the chip in a Think."],"code":["function SF.DefaultEnvironment.quotaMax ()","\treturn SF.instance.context.cpuTime.getMax()","end","","-- The below modules have the Gmod functions removed (the ones that begin with a capital letter),","-- as requested by Divran","","-- Filters Gmod Lua files based on Garry's naming convention.","local function filterGmodLua(lib, original, gm)","\toriginal = original or {}","\tgm = gm or {}","\tfor name, func in pairs(lib) do","\t\tif name:match(\"^[A-Z]\") then","\t\t\tgm[name] = func","\t\telse","\t\t\toriginal[name] = func","\t\tend","\tend","\treturn original, gm","end","","-- String library","local string_methods, string_metatable = SF.Typedef( \"Library: string\" )","filterGmodLua( string, string_methods )","string_metatable.__newindex = function () end",""],"class":"function","name":"SF.DefaultEnvironment.quotaMax","summary":"\nGets the CPU Time max.","private":false,"library":"builtin","description":"\nGets the CPU Time max. \nCPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","param":[]},"getmetatable":{"ret":"The metatable of tbl","comment":["--- Same as Lua's getmetatable. Doesn't work on most internal metatables","-- @param tbl Table to get metatable of","-- @return The metatable of tbl"],"code":["SF.DefaultEnvironment.getmetatable = function(tbl)","\tSF.CheckType(tbl,\"table\")","\treturn getmetatable(tbl)","end",""],"class":"function","name":"SF.DefaultEnvironment.getmetatable","summary":"\nSame as Lua's getmetatable.","private":false,"library":"builtin","description":"\nSame as Lua's getmetatable. Doesn't work on most internal metatables","param":{"1":"tbl","tbl":"Table to get metatable of"}},"concmd":{"comment":["--- Execute a console command","-- @param cmd Command to execute"],"code":["function SF.DefaultEnvironment.concmd ( cmd )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end -- only execute on owner of screen","\tSF.CheckType( cmd, \"string\" )","\tSF.instance.player:ConCommand( cmd )","end",""],"class":"function","name":"SF.DefaultEnvironment.concmd","summary":"\nExecute a console command ","private":false,"library":"builtin","description":"\nExecute a console command","param":{"1":"cmd","cmd":"Command to execute"}}},"classForced":true,"fields":{"1":"CLIENT","2":"SERVER","CLIENT":{"description":"\nConstant that denotes whether the code is executed on the client","code":["SF.DefaultEnvironment.CLIENT = CLIENT"],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.CLIENT","summary":"\nConstant that denotes whether the code is executed on the client ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the client","-- @name SF.DefaultEnvironment.CLIENT","-- @class field"],"param":[]},"SERVER":{"description":"\nConstant that denotes whether the code is executed on the server","code":["SF.DefaultEnvironment.SERVER = SERVER",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.SERVER","summary":"\nConstant that denotes whether the code is executed on the server ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the server","-- @name SF.DefaultEnvironment.SERVER","-- @class field"],"param":[]}},"name":"builtin","libtbl":"SF.DefaultEnvironment","server":true,"client":true,"comment":["--- Built in values. These don't need to be loaded; they are in the default environment.","-- @name builtin","-- @shared","-- @class library","-- @libtbl SF.DefaultEnvironment"],"param":[]}},"type":"file","name":"libs_sh/builtins.lua","functions":{"1":"SF.DefaultEnvironment.assert","2":"SF.DefaultEnvironment.concmd","3":"SF.DefaultEnvironment.dodir","4":"SF.DefaultEnvironment.dofile","5":"SF.DefaultEnvironment.error","6":"SF.DefaultEnvironment.getLibraries","7":"SF.DefaultEnvironment.getfenv","8":"SF.DefaultEnvironment.getmetatable","9":"SF.DefaultEnvironment.ipairs","10":"SF.DefaultEnvironment.loadstring","11":"SF.DefaultEnvironment.next","12":"SF.DefaultEnvironment.pairs","13":"SF.DefaultEnvironment.print","14":"SF.DefaultEnvironment.printTable","15":"SF.DefaultEnvironment.quotaAverage","16":"SF.DefaultEnvironment.quotaMax","17":"SF.DefaultEnvironment.quotaUsed","18":"SF.DefaultEnvironment.rawget","19":"SF.DefaultEnvironment.rawset","20":"SF.DefaultEnvironment.require","21":"SF.DefaultEnvironment.requiredir","22":"SF.DefaultEnvironment.setfenv","23":"SF.DefaultEnvironment.setmetatable","24":"SF.DefaultEnvironment.throw","25":"SF.DefaultEnvironment.tonumber","26":"SF.DefaultEnvironment.tostring","27":"SF.DefaultEnvironment.try","28":"SF.DefaultEnvironment.type","29":"SF.DefaultEnvironment.unpack","SF.DefaultEnvironment.rawget":{"ret":"The value of the index","comment":["--- Gets the value of a table index without invoking a metamethod","--@param table The table to get the value from","--@param key The index of the table","--@return The value of the index"],"code":["function SF.DefaultEnvironment.rawget( table, key, value )","    SF.CheckType( table, \"table\" )","","    return rawget( table, key )","end","","-- ------------------------- Restrictions ------------------------- --","-- Restricts access to builtin type's metatables","","local _R = debug.getregistry()","local function restrict(instance, hook, name, ok, err)","\t_R.Vector.__metatable = \"Vector\"","\t_R.Angle.__metatable = \"Angle\"","\t_R.VMatrix.__metatable = \"VMatrix\"","end","","local function unrestrict(instance, hook, name, ok, err)","\t_R.Vector.__metatable = nil","\t_R.Angle.__metatable = nil","\t_R.VMatrix.__metatable = nil","end","","SF.Libraries.AddHook(\"prepare\", restrict)","SF.Libraries.AddHook(\"cleanup\", unrestrict)","",""],"class":"function","name":"SF.DefaultEnvironment.rawget","summary":"\nGets the value of a table index without invoking a metamethod ","private":false,"library":"builtin","description":"\nGets the value of a table index without invoking a metamethod","param":{"1":"table","2":"key","3":"value","key":"The index of the table","table":"The table to get the value from"}},"SF.DefaultEnvironment.unpack":{"ret":"Elements of tbl","description":"\nSame as Lua's unpack","code":["SF.DefaultEnvironment.unpack = unpack",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.unpack","summary":"\nSame as Lua's unpack ","library":"builtin","comment":["--- Same as Lua's unpack","-- @name SF.DefaultEnvironment.unpack","-- @class function","-- @param tbl","-- @return Elements of tbl"],"param":{"1":"tbl","tbl":""}},"SF.DefaultEnvironment.tostring":{"ret":"obj as string","description":"\nSame as Lua's tostring","code":["SF.DefaultEnvironment.tostring = tostring"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tostring","summary":"\nSame as Lua's tostring ","library":"builtin","comment":["--- Same as Lua's tostring","-- @name SF.DefaultEnvironment.tostring","-- @class function","-- @param obj","-- @return obj as string"],"param":{"1":"obj","obj":""}},"SF.DefaultEnvironment.setfenv":{"ret":"func with environment set to tbl","comment":["--- Lua's setfenv","-- Works like setfenv, but is restricted on functions","-- @param func Function to change environment of","-- @param tbl New environment","-- @return func with environment set to tbl"],"code":["function SF.DefaultEnvironment.setfenv ( func, tbl )","\tif type( func ) ~= \"function\" then SF.throw( \"Main Thread is protected!\", 2 ) end","\treturn setfenv( func, tbl )","end",""],"class":"function","name":"SF.DefaultEnvironment.setfenv","summary":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions ","private":false,"library":"builtin","description":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions","param":{"1":"func","2":"tbl","func":"Function to change environment of","tbl":"New environment"}},"SF.DefaultEnvironment.tonumber":{"ret":"obj as number","description":"\nSame as Lua's tonumber","code":["SF.DefaultEnvironment.tonumber = tonumber",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tonumber","summary":"\nSame as Lua's tonumber ","library":"builtin","comment":["--- Same as Lua's tonumber","-- @name SF.DefaultEnvironment.tonumber","-- @class function","-- @param obj","-- @return obj as number"],"param":{"1":"obj","obj":""}},"SF.DefaultEnvironment.setmetatable":{"ret":"tbl with metatable set to meta","description":"\nSame as Lua's setmetatable. Doesn't work on most internal metatables","code":["SF.DefaultEnvironment.setmetatable = setmetatable",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.setmetatable","summary":"\nSame as Lua's setmetatable.","library":"builtin","comment":["--- Same as Lua's setmetatable. Doesn't work on most internal metatables","-- @name SF.DefaultEnvironment.setmetatable","-- @class function","-- @param tbl The table to set the metatable of","-- @param meta The metatable to use","-- @return tbl with metatable set to meta"],"param":{"1":"tbl","2":"meta","tbl":"The table to set the metatable of","meta":"The metatable to use"}},"SF.DefaultEnvironment.print":{"comment":["\t--- Prints a message to the player's chat.","\t-- @shared","\t-- @param ... Values to print"],"code":["\tfunction SF.DefaultEnvironment.print(...)","\t\tlocal str = \"\"","\t\tlocal tbl = {n=select('#', ...), ...}","\t\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t\tSF.instance.player:ChatPrint(str)","\tend","else","\t-- Prints a message to the player's chat.","\tfunction SF.DefaultEnvironment.print(...)","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tlocal str = \"\"","\t\tlocal tbl = {n=select('#', ...), ...}","\t\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t\tLocalPlayer():ChatPrint(str)","\tend","end","","local function printTableX ( target, t, indent, alreadyprinted )","\tfor k,v in SF.DefaultEnvironment.pairs( t ) do","\t\tif SF.GetType( v ) == \"table\" and not alreadyprinted[ v ] then","\t\t\talreadyprinted[ v ] = true","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \":\" )","\t\t\tprintTableX( target, v, indent + 1, alreadyprinted )","\t\telse","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \"\\t=\\t\" .. tostring( v ) )","\t\tend","\tend","end",""],"class":"function","summary":"\nPrints a message to the player's chat.","library":"builtin","name":"SF.DefaultEnvironment.print","server":true,"private":false,"client":true,"description":"\nPrints a message to the player's chat.","param":{"1":"...","...":"Values to print"}},"SF.DefaultEnvironment.throw":{"comment":["--- Throws an exception","-- @param msg Message","-- @param level Which level in the stacktrace to blame. Defaults to one of invalid","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.DefaultEnvironment.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" )","\tif not filename then","\t\tinfo = debug.getinfo( 2, \"Sl\" )","\t\tfilename = info.short_src:match( \"^SF:(.*)$\" )","\tend","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"class":"function","name":"SF.DefaultEnvironment.throw","summary":"\nThrows an exception ","private":false,"library":"builtin","description":"\nThrows an exception","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame. Defaults to one of invalid"}},"SF.DefaultEnvironment.dodir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included directory, but does not cache the result.","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.dodir( dir, loadpriority )","    SF.CheckType( dir, \"string\" )","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","","    local returns = {}","","    if loadpriority then","        for i = 0, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.dofile( file )","                end","            end","        end","    end","","    for file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 then","\t\t\treturns[ file ] = SF.DefaultEnvironment.dofile( file )","\t\tend","    end","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.dodir","summary":"\nRuns an included directory, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included directory, but does not cache the result.","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"SF.DefaultEnvironment.error":{"comment":["--- Throws a raw exception.","-- @param msg Exception message"],"code":["function SF.DefaultEnvironment.error ( msg )","\terror( msg or \"an unspecified error occured\", 2 )","end",""],"class":"function","name":"SF.DefaultEnvironment.error","summary":"\nThrows a raw exception.","private":false,"library":"builtin","description":"\nThrows a raw exception.","param":{"1":"msg","msg":"Exception message"}},"SF.DefaultEnvironment.rawset":{"comment":["--- Set the value of a table index without invoking a metamethod","--@param table The table to modify","--@param key The index of the table","--@param value The value to set the index equal to"],"code":["function SF.DefaultEnvironment.rawset( table, key, value )","    SF.CheckType( table, \"table\" )","","    rawset( table, key, value )","end",""],"class":"function","name":"SF.DefaultEnvironment.rawset","summary":"\nSet the value of a table index without invoking a metamethod ","private":false,"library":"builtin","description":"\nSet the value of a table index without invoking a metamethod","param":{"1":"table","2":"key","3":"value","value":"The value to set the index equal to","key":"The index of the table","table":"The table to modify"}},"SF.DefaultEnvironment.dofile":{"ret":"Return value of the script","comment":["--- Runs an included script, but does not cache the result.","-- Pretty much like standard Lua dofile()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.dofile(file)","    SF.CheckType(file, \"string\")","    local func = SF.instance.scripts[file]","    if not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","    return func()","end",""],"class":"function","name":"SF.DefaultEnvironment.dofile","summary":"\nRuns an included script, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included script, but does not cache the result. \nPretty much like standard Lua dofile()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"SF.DefaultEnvironment.pairs":{"ret":["Iterator function","Table tbl","nil as current index"],"description":"\nSame as Lua's pairs","code":["SF.DefaultEnvironment.pairs = pairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.pairs","summary":"\nSame as Lua's pairs ","library":"builtin","comment":["--- Same as Lua's pairs","-- @name SF.DefaultEnvironment.pairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return nil as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"SF.DefaultEnvironment.ipairs":{"ret":["Iterator function","Table tbl","0 as current index"],"description":"\nSame as Lua's ipairs","code":["SF.DefaultEnvironment.ipairs = ipairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.ipairs","summary":"\nSame as Lua's ipairs ","library":"builtin","comment":["--- Same as Lua's ipairs","-- @name SF.DefaultEnvironment.ipairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return 0 as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"SF.DefaultEnvironment.quotaAverage":{"ret":"Average CPU Time of the buffer.","comment":["--- Gets the Average CPU Time in the buffer","-- @return Average CPU Time of the buffer."],"code":["function SF.DefaultEnvironment.quotaAverage ()","\treturn SF.instance.cpu_average","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaAverage","summary":"\nGets the Average CPU Time in the buffer ","private":false,"library":"builtin","description":"\nGets the Average CPU Time in the buffer","param":[]},"SF.DefaultEnvironment.requiredir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.requiredir( dir, loadpriority )","    SF.CheckType( dir, \"string\")","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","    ","    local returns = {}","","    if loadpriority then","        for i = 1, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.require( file )","                end","            end","        end","    end","","\tfor file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 and not returns[ file ] then","\t\t\treturns[ file ] = SF.DefaultEnvironment.require( file )","\t\tend","\tend","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.requiredir","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"SF.DefaultEnvironment.loadstring":{"ret":"Function of str","comment":["--- GLua's loadstring","-- Works like loadstring, except that it executes by default in the main environment","-- @param str String to execute","-- @return Function of str"],"code":["function SF.DefaultEnvironment.loadstring ( str )","\tlocal func = CompileString( str, \"SF: \" .. tostring( SF.instance.env ), false )","\t","\t-- CompileString returns an error as a string, better check before setfenv","\tif type( func ) == \"function\" then","\t\treturn setfenv( func, SF.instance.env )","\tend","\t","\treturn func","end",""],"class":"function","name":"SF.DefaultEnvironment.loadstring","summary":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment ","private":false,"library":"builtin","description":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment","param":{"1":"str","str":"String to execute"}},"SF.DefaultEnvironment.concmd":{"comment":["--- Execute a console command","-- @param cmd Command to execute"],"code":["function SF.DefaultEnvironment.concmd ( cmd )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end -- only execute on owner of screen","\tSF.CheckType( cmd, \"string\" )","\tSF.instance.player:ConCommand( cmd )","end",""],"class":"function","name":"SF.DefaultEnvironment.concmd","summary":"\nExecute a console command ","private":false,"library":"builtin","description":"\nExecute a console command","param":{"1":"cmd","cmd":"Command to execute"}},"SF.DefaultEnvironment.type":{"ret":"The name of the object's type.","comment":["--- Same as Lua's type","-- @name SF.DefaultEnvironment.type","-- @class function","-- @param obj Object to get type of","-- @return The name of the object's type."],"code":["SF.DefaultEnvironment.type = function( obj )","\tlocal tp = getmetatable( obj )","\treturn type(tp) == \"string\" and tp or type( obj )","end"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.type","summary":"\nSame as Lua's type ","private":false,"library":"builtin","description":"\nSame as Lua's type","param":{"1":"obj","obj":"Object to get type of"}},"SF.DefaultEnvironment.try":{"comment":["--- Try to execute a function and catch possible exceptions","-- Similar to xpcall, but a bit more in-depth","-- @param func Function to execute","-- @param catch Optional function to execute in case func fails"],"code":["function SF.DefaultEnvironment.try ( func, catch )","\tlocal ok, err = pcall( func )","\tif ok then return end","","\tif type( err ) == \"table\" then","\t\tif err.uncatchable then","\t\t\terror( err )","\t\tend","\tend","\tif catch then catch( err ) end","end",""],"class":"function","name":"SF.DefaultEnvironment.try","summary":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth ","private":false,"library":"builtin","description":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth","param":{"1":"func","2":"catch","func":"Function to execute","catch":"Optional function to execute in case func fails"}},"SF.DefaultEnvironment.getfenv":{"ret":"Current environment","comment":["--- Simple version of Lua's getfenv","-- Returns the current environment","-- @return Current environment"],"code":["function SF.DefaultEnvironment.getfenv ()","\treturn getfenv()","end",""],"class":"function","name":"SF.DefaultEnvironment.getfenv","summary":"\nSimple version of Lua's getfenv \nReturns the current environment ","private":false,"library":"builtin","description":"\nSimple version of Lua's getfenv \nReturns the current environment","param":[]},"SF.DefaultEnvironment.getmetatable":{"ret":"The metatable of tbl","comment":["--- Same as Lua's getmetatable. Doesn't work on most internal metatables","-- @param tbl Table to get metatable of","-- @return The metatable of tbl"],"code":["SF.DefaultEnvironment.getmetatable = function(tbl)","\tSF.CheckType(tbl,\"table\")","\treturn getmetatable(tbl)","end",""],"class":"function","name":"SF.DefaultEnvironment.getmetatable","summary":"\nSame as Lua's getmetatable.","private":false,"library":"builtin","description":"\nSame as Lua's getmetatable. Doesn't work on most internal metatables","param":{"1":"tbl","tbl":"Table to get metatable of"}},"SF.DefaultEnvironment.printTable":{"comment":["--- Prints a table to player's chat","-- @param tbl Table to print"],"code":["function SF.DefaultEnvironment.printTable ( tbl )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tSF.CheckType( tbl, \"table\" )","","\tprintTableX( ( SERVER and SF.instance.player or LocalPlayer() ), tbl, 0, { t = true } )","end","",""],"class":"function","name":"SF.DefaultEnvironment.printTable","summary":"\nPrints a table to player's chat ","private":false,"library":"builtin","description":"\nPrints a table to player's chat","param":{"1":"tbl","tbl":"Table to print"}},"SF.DefaultEnvironment.next":{"ret":["Key or nil","Value or nil"],"description":"\nSame as Lua's next","code":["SF.DefaultEnvironment.next = next"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.next","summary":"\nSame as Lua's next ","library":"builtin","comment":["--- Same as Lua's next","-- @name SF.DefaultEnvironment.next","-- @class function","-- @param tbl Table to get the next key-value pair of","-- @param k Previous key (can be nil)","-- @return Key or nil","-- @return Value or nil"],"param":{"1":"tbl","2":"k","tbl":"Table to get the next key-value pair of","k":"Previous key (can be nil)"}},"SF.DefaultEnvironment.quotaMax":{"ret":"Max SysTime allowed to take for execution of the chip in a Think.","comment":["--- Gets the CPU Time max.","-- CPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","-- @return Max SysTime allowed to take for execution of the chip in a Think."],"code":["function SF.DefaultEnvironment.quotaMax ()","\treturn SF.instance.context.cpuTime.getMax()","end","","-- The below modules have the Gmod functions removed (the ones that begin with a capital letter),","-- as requested by Divran","","-- Filters Gmod Lua files based on Garry's naming convention.","local function filterGmodLua(lib, original, gm)","\toriginal = original or {}","\tgm = gm or {}","\tfor name, func in pairs(lib) do","\t\tif name:match(\"^[A-Z]\") then","\t\t\tgm[name] = func","\t\telse","\t\t\toriginal[name] = func","\t\tend","\tend","\treturn original, gm","end","","-- String library","local string_methods, string_metatable = SF.Typedef( \"Library: string\" )","filterGmodLua( string, string_methods )","string_metatable.__newindex = function () end",""],"class":"function","name":"SF.DefaultEnvironment.quotaMax","summary":"\nGets the CPU Time max.","private":false,"library":"builtin","description":"\nGets the CPU Time max. \nCPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","param":[]},"SF.DefaultEnvironment.quotaUsed":{"ret":"Current quota used this Think","comment":["--- Returns the current count for this Think's CPU Time.","-- This value increases as more executions are done, may not be exactly as you want.","-- If used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","-- @return Current quota used this Think"],"code":["function SF.DefaultEnvironment.quotaUsed ()","\treturn SF.instance.cpu_total","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaUsed","summary":"\nReturns the current count for this Think's CPU Time.","private":false,"library":"builtin","description":"\nReturns the current count for this Think's CPU Time. \nThis value increases as more executions are done, may not be exactly as you want. \nIf used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","param":[]},"SF.DefaultEnvironment.assert":{"comment":["--- Same as Lua's assert.","-- @name SF.DefaultEnvironment.assert","-- @class function","-- @param condition","-- @param msg"],"code":["SF.DefaultEnvironment.assert = function ( condition, msg ) if not condition then SF.throw( msg or \"assertion failed!\", 2 ) end end"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.assert","summary":"\nSame as Lua's assert.","private":false,"library":"builtin","description":"\nSame as Lua's assert.","param":{"1":"condition","2":"msg","condition":"","msg":""}},"SF.DefaultEnvironment.require":{"ret":"Return value of the script","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.require(file)","\tSF.CheckType(file, \"string\")","\tlocal loaded = SF.instance.data.reqloaded","\tif not loaded then","\t\tloaded = {}","\t\tSF.instance.data.reqloaded = loaded","\tend","\t","\tif loaded[file] then","\t\treturn loaded[file]","\telse","\t\tlocal func = SF.instance.scripts[file]","\t\tif not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","\t\tloaded[file] = func() or true","\t\treturn loaded[file]","\tend","end",""],"class":"function","name":"SF.DefaultEnvironment.require","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"SF.DefaultEnvironment.getLibraries":{"ret":"Table containing the names of each available library","comment":["--- Gets a list of all libraries","-- @return Table containing the names of each available library"],"code":["function SF.DefaultEnvironment.getLibraries()","\tlocal ret = {}","\tfor k,v in pairs( SF.Libraries.libraries ) do","\t\tret[#ret+1] = k","\tend","\treturn ret","end","","","","if SERVER then"],"class":"function","name":"SF.DefaultEnvironment.getLibraries","summary":"\nGets a list of all libraries ","private":false,"library":"builtin","description":"\nGets a list of all libraries","param":[]}},"doc":[{"summary":"\n \nBuiltins.","description":"\n \nBuiltins. \nFunctions built-in to the default environment \n","comment":["-------------------------------------------------------------------------------","-- Builtins.","-- Functions built-in to the default environment","-------------------------------------------------------------------------------"],"code":["","local dgetmeta = debug.getmetatable",""]},{"description":"\nBuilt in values. These don't need to be loaded; they are in the default environment.","code":["","-- ------------------------- Lua Ports ------------------------- --","-- This part is messy because of LuaDoc stuff.","","local function pascalToCamel ( t, r )","\tlocal r = r or {}","\tfor k, v in pairs( t ) do","\t\tk = k:gsub( \"^%l\", string.lower )","\t\tr[ k ] = v","\tend","\treturn r","end",""],"summary":"\nBuilt in values.","class":"library","tables":{"1":"IN_KEY","2":"KEY","3":"MOUSE","4":"math","5":"os","6":"string","7":"table","string":{"description":"\nLua's (not glua's) string library","code":["SF.DefaultEnvironment.string = setmetatable( {}, string_metatable )","","-- Math library","local math_methods, math_metatable = SF.Typedef(\"Library: math\")","filterGmodLua(math,math_methods)","math_metatable.__newindex = function() end","math_methods.clamp = math.Clamp","math_methods.angnorm = math.NormalizeAngle","math_methods.sign = function(a) return a>0 and 1 or -1 end","math_methods.round = math.Round","math_methods.randfloat = math.Rand","math_methods.calcBSplineN = nil"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.string","summary":"\nLua's (not glua's) string library ","library":"builtin","comment":["--- Lua's (not glua's) string library","-- @name SF.DefaultEnvironment.string","-- @class table"],"param":[]},"os":{"description":"\nGLua's os library. http://wiki.garrysmod.com/page/Category:os, plus sortByKey, sortByMember","code":["SF.DefaultEnvironment.os = setmetatable( {}, os_metatable )","","local table_methods, table_metatable = SF.Typedef(\"Library: table\")","filterGmodLua(table,table_methods)","table_methods.sortByKey = table.SortByKey","table_methods.sortByMember = table.SortByMember","table_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.os","summary":"\nGLua's os library.","library":"builtin","comment":["--- GLua's os library. http://wiki.garrysmod.com/page/Category:os, plus sortByKey, sortByMember","-- @name SF.DefaultEnvironment.os","-- @class table"],"param":[]},"table":{"description":"\nLua's (not glua's) table library","code":["SF.DefaultEnvironment.table = setmetatable({},table_metatable)","","-- ------------------------- Functions ------------------------- --",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.table","summary":"\nLua's (not glua's) table library ","library":"builtin","comment":["--- Lua's (not glua's) table library","-- @name SF.DefaultEnvironment.table","-- @class table"],"param":[]},"math":{"description":"\nLua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN","code":["SF.DefaultEnvironment.math = setmetatable({},math_metatable)","","local os_methods, os_metatable = SF.Typedef( \"Library: os\" )","filterGmodLua( os, os_methods )","os_metatable.__newindex = function () end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.math","summary":"\nLua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN ","library":"builtin","comment":["--- Lua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN","-- @name SF.DefaultEnvironment.math","-- @class table"],"param":[]},"IN_KEY":{"description":"\nENUMs of in_keys for use with player:keyDown","code":["SF.DefaultEnvironment.IN_KEY = setmetatable( {}, {","\t__index = _INKEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.IN_KEY","summary":"\nENUMs of in_keys for use with player:keyDown ","library":"builtin","comment":["--- ENUMs of in_keys for use with player:keyDown","-- @name SF.DefaultEnvironment.IN_KEY","-- @class table"],"param":[]},"MOUSE":{"description":"\nENUMs of mouse buttons for use with input library","code":["SF.DefaultEnvironment.MOUSE = setmetatable( {}, {","\t__index = _MOUSE,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _INKEY = {","\t[ \"ALT1\" ] = IN_ALT1,","\t[ \"ALT2\" ] = IN_ALT2,","\t[ \"ATTACK\" ] = IN_ATTACK,","\t[ \"ATTACK2\" ] = IN_ATTACK2,","\t[ \"BACK\" ] = IN_BACK,","\t[ \"DUCK\" ] = IN_DUCK,","\t[ \"FORWARD\" ] = IN_FORWARD,","\t[ \"JUMP\" ] = IN_JUMP,","\t[ \"LEFT\" ] = IN_LEFT,","\t[ \"MOVELEFT\" ] = IN_MOVELEFT,","\t[ \"MOVERIGHT\" ] = IN_MOVERIGHT,","\t[ \"RELOAD\" ] = IN_RELOAD,","\t[ \"RIGHT\" ] = IN_RIGHT,","\t[ \"SCORE\" ] = IN_SCORE,","\t[ \"SPEED\" ] = IN_SPEED,","\t[ \"USE\" ] = IN_USE,","\t[ \"WALK\" ] = IN_WALK,","\t[ \"ZOOM\" ] = IN_ZOOM,","\t[ \"GRENADE1\" ] = IN_GRENADE1,","\t[ \"GRENADE2\" ] = IN_GRENADE2,","\t[ \"WEAPON1\" ] = IN_WEAPON1,","\t[ \"WEAPON2\" ] = IN_WEAPON2,","\t[ \"BULLRUSH\" ] = IN_BULLRUSH,","\t[ \"CANCEL\" ] = IN_CANCEL,","\t[ \"RUN\" ] = IN_RUN,","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.MOUSE","summary":"\nENUMs of mouse buttons for use with input library ","library":"builtin","comment":["--- ENUMs of mouse buttons for use with input library","-- @name SF.DefaultEnvironment.MOUSE","-- @class table"],"param":[]},"KEY":{"description":"\nENUMs of keyboard keys for use with input library","code":["SF.DefaultEnvironment.KEY = setmetatable( {}, {","\t__index = _KEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _MOUSE = {","\t[ \"MOUSE1\" ] = 107,","\t[ \"LEFT\" ] = 107,","\t[ \"MOUSE2\" ] = 108,","\t[ \"RIGHT\" ] = 108,","\t[ \"MOUSE3\" ] = 109,","\t[ \"MIDDLE\" ] = 109,","\t[ \"MOUSE4\" ] = 110,","\t[ \"4\" ] = 110,","\t[ \"MOUSE5\"] = 111,","\t[ \"5\" ] = 111,","\t[ \"MWHEELUP\" ] = 112,","\t[ \"WHEEL_UP\" ] = 112,","\t[ \"MWHEELDOWN\" ] = 113,","\t[ \"WHEEL_DOWN\" ] = 113,","\t[ \"COUNT\" ] = 7,","\t[ \"FIRST\" ] = 107,","\t[ \"LAST\" ] = 113","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.KEY","summary":"\nENUMs of keyboard keys for use with input library ","library":"builtin","comment":["--- ENUMs of keyboard keys for use with input library","-- @name SF.DefaultEnvironment.KEY","-- @class table"],"param":[]}},"functions":{"1":"assert","2":"concmd","3":"dodir","4":"dofile","5":"error","6":"getLibraries","7":"getfenv","8":"getmetatable","9":"ipairs","10":"loadstring","11":"next","12":"pairs","13":"print","14":"printTable","15":"quotaAverage","16":"quotaMax","17":"quotaUsed","18":"rawget","19":"rawset","20":"require","21":"requiredir","22":"setfenv","23":"setmetatable","24":"throw","25":"tonumber","26":"tostring","27":"try","28":"type","29":"unpack","getLibraries":{"ret":"Table containing the names of each available library","comment":["--- Gets a list of all libraries","-- @return Table containing the names of each available library"],"code":["function SF.DefaultEnvironment.getLibraries()","\tlocal ret = {}","\tfor k,v in pairs( SF.Libraries.libraries ) do","\t\tret[#ret+1] = k","\tend","\treturn ret","end","","","","if SERVER then"],"class":"function","name":"SF.DefaultEnvironment.getLibraries","summary":"\nGets a list of all libraries ","private":false,"library":"builtin","description":"\nGets a list of all libraries","param":[]},"printTable":{"comment":["--- Prints a table to player's chat","-- @param tbl Table to print"],"code":["function SF.DefaultEnvironment.printTable ( tbl )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tSF.CheckType( tbl, \"table\" )","","\tprintTableX( ( SERVER and SF.instance.player or LocalPlayer() ), tbl, 0, { t = true } )","end","",""],"class":"function","name":"SF.DefaultEnvironment.printTable","summary":"\nPrints a table to player's chat ","private":false,"library":"builtin","description":"\nPrints a table to player's chat","param":{"1":"tbl","tbl":"Table to print"}},"tostring":{"ret":"obj as string","description":"\nSame as Lua's tostring","code":["SF.DefaultEnvironment.tostring = tostring"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tostring","summary":"\nSame as Lua's tostring ","library":"builtin","comment":["--- Same as Lua's tostring","-- @name SF.DefaultEnvironment.tostring","-- @class function","-- @param obj","-- @return obj as string"],"param":{"1":"obj","obj":""}},"print":{"comment":["\t--- Prints a message to the player's chat.","\t-- @shared","\t-- @param ... Values to print"],"code":["\tfunction SF.DefaultEnvironment.print(...)","\t\tlocal str = \"\"","\t\tlocal tbl = {n=select('#', ...), ...}","\t\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t\tSF.instance.player:ChatPrint(str)","\tend","else","\t-- Prints a message to the player's chat.","\tfunction SF.DefaultEnvironment.print(...)","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tlocal str = \"\"","\t\tlocal tbl = {n=select('#', ...), ...}","\t\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t\tLocalPlayer():ChatPrint(str)","\tend","end","","local function printTableX ( target, t, indent, alreadyprinted )","\tfor k,v in SF.DefaultEnvironment.pairs( t ) do","\t\tif SF.GetType( v ) == \"table\" and not alreadyprinted[ v ] then","\t\t\talreadyprinted[ v ] = true","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \":\" )","\t\t\tprintTableX( target, v, indent + 1, alreadyprinted )","\t\telse","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \"\\t=\\t\" .. tostring( v ) )","\t\tend","\tend","end",""],"class":"function","summary":"\nPrints a message to the player's chat.","library":"builtin","name":"SF.DefaultEnvironment.print","server":true,"private":false,"client":true,"description":"\nPrints a message to the player's chat.","param":{"1":"...","...":"Values to print"}},"rawget":{"ret":"The value of the index","comment":["--- Gets the value of a table index without invoking a metamethod","--@param table The table to get the value from","--@param key The index of the table","--@return The value of the index"],"code":["function SF.DefaultEnvironment.rawget( table, key, value )","    SF.CheckType( table, \"table\" )","","    return rawget( table, key )","end","","-- ------------------------- Restrictions ------------------------- --","-- Restricts access to builtin type's metatables","","local _R = debug.getregistry()","local function restrict(instance, hook, name, ok, err)","\t_R.Vector.__metatable = \"Vector\"","\t_R.Angle.__metatable = \"Angle\"","\t_R.VMatrix.__metatable = \"VMatrix\"","end","","local function unrestrict(instance, hook, name, ok, err)","\t_R.Vector.__metatable = nil","\t_R.Angle.__metatable = nil","\t_R.VMatrix.__metatable = nil","end","","SF.Libraries.AddHook(\"prepare\", restrict)","SF.Libraries.AddHook(\"cleanup\", unrestrict)","",""],"class":"function","name":"SF.DefaultEnvironment.rawget","summary":"\nGets the value of a table index without invoking a metamethod ","private":false,"library":"builtin","description":"\nGets the value of a table index without invoking a metamethod","param":{"1":"table","2":"key","3":"value","key":"The index of the table","table":"The table to get the value from"}},"rawset":{"comment":["--- Set the value of a table index without invoking a metamethod","--@param table The table to modify","--@param key The index of the table","--@param value The value to set the index equal to"],"code":["function SF.DefaultEnvironment.rawset( table, key, value )","    SF.CheckType( table, \"table\" )","","    rawset( table, key, value )","end",""],"class":"function","name":"SF.DefaultEnvironment.rawset","summary":"\nSet the value of a table index without invoking a metamethod ","private":false,"library":"builtin","description":"\nSet the value of a table index without invoking a metamethod","param":{"1":"table","2":"key","3":"value","value":"The value to set the index equal to","key":"The index of the table","table":"The table to modify"}},"tonumber":{"ret":"obj as number","description":"\nSame as Lua's tonumber","code":["SF.DefaultEnvironment.tonumber = tonumber",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tonumber","summary":"\nSame as Lua's tonumber ","library":"builtin","comment":["--- Same as Lua's tonumber","-- @name SF.DefaultEnvironment.tonumber","-- @class function","-- @param obj","-- @return obj as number"],"param":{"1":"obj","obj":""}},"error":{"comment":["--- Throws a raw exception.","-- @param msg Exception message"],"code":["function SF.DefaultEnvironment.error ( msg )","\terror( msg or \"an unspecified error occured\", 2 )","end",""],"class":"function","name":"SF.DefaultEnvironment.error","summary":"\nThrows a raw exception.","private":false,"library":"builtin","description":"\nThrows a raw exception.","param":{"1":"msg","msg":"Exception message"}},"unpack":{"ret":"Elements of tbl","description":"\nSame as Lua's unpack","code":["SF.DefaultEnvironment.unpack = unpack",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.unpack","summary":"\nSame as Lua's unpack ","library":"builtin","comment":["--- Same as Lua's unpack","-- @name SF.DefaultEnvironment.unpack","-- @class function","-- @param tbl","-- @return Elements of tbl"],"param":{"1":"tbl","tbl":""}},"throw":{"comment":["--- Throws an exception","-- @param msg Message","-- @param level Which level in the stacktrace to blame. Defaults to one of invalid","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.DefaultEnvironment.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" )","\tif not filename then","\t\tinfo = debug.getinfo( 2, \"Sl\" )","\t\tfilename = info.short_src:match( \"^SF:(.*)$\" )","\tend","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"class":"function","name":"SF.DefaultEnvironment.throw","summary":"\nThrows an exception ","private":false,"library":"builtin","description":"\nThrows an exception","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame. Defaults to one of invalid"}},"try":{"comment":["--- Try to execute a function and catch possible exceptions","-- Similar to xpcall, but a bit more in-depth","-- @param func Function to execute","-- @param catch Optional function to execute in case func fails"],"code":["function SF.DefaultEnvironment.try ( func, catch )","\tlocal ok, err = pcall( func )","\tif ok then return end","","\tif type( err ) == \"table\" then","\t\tif err.uncatchable then","\t\t\terror( err )","\t\tend","\tend","\tif catch then catch( err ) end","end",""],"class":"function","name":"SF.DefaultEnvironment.try","summary":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth ","private":false,"library":"builtin","description":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth","param":{"1":"func","2":"catch","func":"Function to execute","catch":"Optional function to execute in case func fails"}},"require":{"ret":"Return value of the script","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.require(file)","\tSF.CheckType(file, \"string\")","\tlocal loaded = SF.instance.data.reqloaded","\tif not loaded then","\t\tloaded = {}","\t\tSF.instance.data.reqloaded = loaded","\tend","\t","\tif loaded[file] then","\t\treturn loaded[file]","\telse","\t\tlocal func = SF.instance.scripts[file]","\t\tif not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","\t\tloaded[file] = func() or true","\t\treturn loaded[file]","\tend","end",""],"class":"function","name":"SF.DefaultEnvironment.require","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"quotaUsed":{"ret":"Current quota used this Think","comment":["--- Returns the current count for this Think's CPU Time.","-- This value increases as more executions are done, may not be exactly as you want.","-- If used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","-- @return Current quota used this Think"],"code":["function SF.DefaultEnvironment.quotaUsed ()","\treturn SF.instance.cpu_total","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaUsed","summary":"\nReturns the current count for this Think's CPU Time.","private":false,"library":"builtin","description":"\nReturns the current count for this Think's CPU Time. \nThis value increases as more executions are done, may not be exactly as you want. \nIf used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","param":[]},"getfenv":{"ret":"Current environment","comment":["--- Simple version of Lua's getfenv","-- Returns the current environment","-- @return Current environment"],"code":["function SF.DefaultEnvironment.getfenv ()","\treturn getfenv()","end",""],"class":"function","name":"SF.DefaultEnvironment.getfenv","summary":"\nSimple version of Lua's getfenv \nReturns the current environment ","private":false,"library":"builtin","description":"\nSimple version of Lua's getfenv \nReturns the current environment","param":[]},"type":{"ret":"The name of the object's type.","comment":["--- Same as Lua's type","-- @name SF.DefaultEnvironment.type","-- @class function","-- @param obj Object to get type of","-- @return The name of the object's type."],"code":["SF.DefaultEnvironment.type = function( obj )","\tlocal tp = getmetatable( obj )","\treturn type(tp) == \"string\" and tp or type( obj )","end"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.type","summary":"\nSame as Lua's type ","private":false,"library":"builtin","description":"\nSame as Lua's type","param":{"1":"obj","obj":"Object to get type of"}},"pairs":{"ret":["Iterator function","Table tbl","nil as current index"],"description":"\nSame as Lua's pairs","code":["SF.DefaultEnvironment.pairs = pairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.pairs","summary":"\nSame as Lua's pairs ","library":"builtin","comment":["--- Same as Lua's pairs","-- @name SF.DefaultEnvironment.pairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return nil as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"next":{"ret":["Key or nil","Value or nil"],"description":"\nSame as Lua's next","code":["SF.DefaultEnvironment.next = next"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.next","summary":"\nSame as Lua's next ","library":"builtin","comment":["--- Same as Lua's next","-- @name SF.DefaultEnvironment.next","-- @class function","-- @param tbl Table to get the next key-value pair of","-- @param k Previous key (can be nil)","-- @return Key or nil","-- @return Value or nil"],"param":{"1":"tbl","2":"k","tbl":"Table to get the next key-value pair of","k":"Previous key (can be nil)"}},"setfenv":{"ret":"func with environment set to tbl","comment":["--- Lua's setfenv","-- Works like setfenv, but is restricted on functions","-- @param func Function to change environment of","-- @param tbl New environment","-- @return func with environment set to tbl"],"code":["function SF.DefaultEnvironment.setfenv ( func, tbl )","\tif type( func ) ~= \"function\" then SF.throw( \"Main Thread is protected!\", 2 ) end","\treturn setfenv( func, tbl )","end",""],"class":"function","name":"SF.DefaultEnvironment.setfenv","summary":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions ","private":false,"library":"builtin","description":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions","param":{"1":"func","2":"tbl","func":"Function to change environment of","tbl":"New environment"}},"assert":{"comment":["--- Same as Lua's assert.","-- @name SF.DefaultEnvironment.assert","-- @class function","-- @param condition","-- @param msg"],"code":["SF.DefaultEnvironment.assert = function ( condition, msg ) if not condition then SF.throw( msg or \"assertion failed!\", 2 ) end end"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.assert","summary":"\nSame as Lua's assert.","private":false,"library":"builtin","description":"\nSame as Lua's assert.","param":{"1":"condition","2":"msg","condition":"","msg":""}},"dodir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included directory, but does not cache the result.","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.dodir( dir, loadpriority )","    SF.CheckType( dir, \"string\" )","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","","    local returns = {}","","    if loadpriority then","        for i = 0, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.dofile( file )","                end","            end","        end","    end","","    for file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 then","\t\t\treturns[ file ] = SF.DefaultEnvironment.dofile( file )","\t\tend","    end","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.dodir","summary":"\nRuns an included directory, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included directory, but does not cache the result.","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"quotaAverage":{"ret":"Average CPU Time of the buffer.","comment":["--- Gets the Average CPU Time in the buffer","-- @return Average CPU Time of the buffer."],"code":["function SF.DefaultEnvironment.quotaAverage ()","\treturn SF.instance.cpu_average","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaAverage","summary":"\nGets the Average CPU Time in the buffer ","private":false,"library":"builtin","description":"\nGets the Average CPU Time in the buffer","param":[]},"loadstring":{"ret":"Function of str","comment":["--- GLua's loadstring","-- Works like loadstring, except that it executes by default in the main environment","-- @param str String to execute","-- @return Function of str"],"code":["function SF.DefaultEnvironment.loadstring ( str )","\tlocal func = CompileString( str, \"SF: \" .. tostring( SF.instance.env ), false )","\t","\t-- CompileString returns an error as a string, better check before setfenv","\tif type( func ) == \"function\" then","\t\treturn setfenv( func, SF.instance.env )","\tend","\t","\treturn func","end",""],"class":"function","name":"SF.DefaultEnvironment.loadstring","summary":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment ","private":false,"library":"builtin","description":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment","param":{"1":"str","str":"String to execute"}},"setmetatable":{"ret":"tbl with metatable set to meta","description":"\nSame as Lua's setmetatable. Doesn't work on most internal metatables","code":["SF.DefaultEnvironment.setmetatable = setmetatable",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.setmetatable","summary":"\nSame as Lua's setmetatable.","library":"builtin","comment":["--- Same as Lua's setmetatable. Doesn't work on most internal metatables","-- @name SF.DefaultEnvironment.setmetatable","-- @class function","-- @param tbl The table to set the metatable of","-- @param meta The metatable to use","-- @return tbl with metatable set to meta"],"param":{"1":"tbl","2":"meta","tbl":"The table to set the metatable of","meta":"The metatable to use"}},"requiredir":{"ret":"Table of return values of the scripts","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.requiredir( dir, loadpriority )","    SF.CheckType( dir, \"string\")","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","    ","    local returns = {}","","    if loadpriority then","        for i = 1, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.require( file )","                end","            end","        end","    end","","\tfor file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 and not returns[ file ] then","\t\t\treturns[ file ] = SF.DefaultEnvironment.require( file )","\t\tend","\tend","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.requiredir","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},"dofile":{"ret":"Return value of the script","comment":["--- Runs an included script, but does not cache the result.","-- Pretty much like standard Lua dofile()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.dofile(file)","    SF.CheckType(file, \"string\")","    local func = SF.instance.scripts[file]","    if not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","    return func()","end",""],"class":"function","name":"SF.DefaultEnvironment.dofile","summary":"\nRuns an included script, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included script, but does not cache the result. \nPretty much like standard Lua dofile()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},"ipairs":{"ret":["Iterator function","Table tbl","0 as current index"],"description":"\nSame as Lua's ipairs","code":["SF.DefaultEnvironment.ipairs = ipairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.ipairs","summary":"\nSame as Lua's ipairs ","library":"builtin","comment":["--- Same as Lua's ipairs","-- @name SF.DefaultEnvironment.ipairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return 0 as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},"quotaMax":{"ret":"Max SysTime allowed to take for execution of the chip in a Think.","comment":["--- Gets the CPU Time max.","-- CPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","-- @return Max SysTime allowed to take for execution of the chip in a Think."],"code":["function SF.DefaultEnvironment.quotaMax ()","\treturn SF.instance.context.cpuTime.getMax()","end","","-- The below modules have the Gmod functions removed (the ones that begin with a capital letter),","-- as requested by Divran","","-- Filters Gmod Lua files based on Garry's naming convention.","local function filterGmodLua(lib, original, gm)","\toriginal = original or {}","\tgm = gm or {}","\tfor name, func in pairs(lib) do","\t\tif name:match(\"^[A-Z]\") then","\t\t\tgm[name] = func","\t\telse","\t\t\toriginal[name] = func","\t\tend","\tend","\treturn original, gm","end","","-- String library","local string_methods, string_metatable = SF.Typedef( \"Library: string\" )","filterGmodLua( string, string_methods )","string_metatable.__newindex = function () end",""],"class":"function","name":"SF.DefaultEnvironment.quotaMax","summary":"\nGets the CPU Time max.","private":false,"library":"builtin","description":"\nGets the CPU Time max. \nCPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","param":[]},"getmetatable":{"ret":"The metatable of tbl","comment":["--- Same as Lua's getmetatable. Doesn't work on most internal metatables","-- @param tbl Table to get metatable of","-- @return The metatable of tbl"],"code":["SF.DefaultEnvironment.getmetatable = function(tbl)","\tSF.CheckType(tbl,\"table\")","\treturn getmetatable(tbl)","end",""],"class":"function","name":"SF.DefaultEnvironment.getmetatable","summary":"\nSame as Lua's getmetatable.","private":false,"library":"builtin","description":"\nSame as Lua's getmetatable. Doesn't work on most internal metatables","param":{"1":"tbl","tbl":"Table to get metatable of"}},"concmd":{"comment":["--- Execute a console command","-- @param cmd Command to execute"],"code":["function SF.DefaultEnvironment.concmd ( cmd )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end -- only execute on owner of screen","\tSF.CheckType( cmd, \"string\" )","\tSF.instance.player:ConCommand( cmd )","end",""],"class":"function","name":"SF.DefaultEnvironment.concmd","summary":"\nExecute a console command ","private":false,"library":"builtin","description":"\nExecute a console command","param":{"1":"cmd","cmd":"Command to execute"}}},"classForced":true,"fields":{"1":"CLIENT","2":"SERVER","CLIENT":{"description":"\nConstant that denotes whether the code is executed on the client","code":["SF.DefaultEnvironment.CLIENT = CLIENT"],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.CLIENT","summary":"\nConstant that denotes whether the code is executed on the client ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the client","-- @name SF.DefaultEnvironment.CLIENT","-- @class field"],"param":[]},"SERVER":{"description":"\nConstant that denotes whether the code is executed on the server","code":["SF.DefaultEnvironment.SERVER = SERVER",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.SERVER","summary":"\nConstant that denotes whether the code is executed on the server ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the server","-- @name SF.DefaultEnvironment.SERVER","-- @class field"],"param":[]}},"name":"builtin","libtbl":"SF.DefaultEnvironment","server":true,"client":true,"comment":["--- Built in values. These don't need to be loaded; they are in the default environment.","-- @name builtin","-- @shared","-- @class library","-- @libtbl SF.DefaultEnvironment"],"param":[]},{"ret":"obj as string","description":"\nSame as Lua's tostring","code":["SF.DefaultEnvironment.tostring = tostring"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tostring","summary":"\nSame as Lua's tostring ","library":"builtin","comment":["--- Same as Lua's tostring","-- @name SF.DefaultEnvironment.tostring","-- @class function","-- @param obj","-- @return obj as string"],"param":{"1":"obj","obj":""}},{"ret":"obj as number","description":"\nSame as Lua's tonumber","code":["SF.DefaultEnvironment.tonumber = tonumber",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.tonumber","summary":"\nSame as Lua's tonumber ","library":"builtin","comment":["--- Same as Lua's tonumber","-- @name SF.DefaultEnvironment.tonumber","-- @class function","-- @param obj","-- @return obj as number"],"param":{"1":"obj","obj":""}},{"ret":["Iterator function","Table tbl","0 as current index"],"description":"\nSame as Lua's ipairs","code":["SF.DefaultEnvironment.ipairs = ipairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.ipairs","summary":"\nSame as Lua's ipairs ","library":"builtin","comment":["--- Same as Lua's ipairs","-- @name SF.DefaultEnvironment.ipairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return 0 as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},{"ret":["Iterator function","Table tbl","nil as current index"],"description":"\nSame as Lua's pairs","code":["SF.DefaultEnvironment.pairs = pairs",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.pairs","summary":"\nSame as Lua's pairs ","library":"builtin","comment":["--- Same as Lua's pairs","-- @name SF.DefaultEnvironment.pairs","-- @class function","-- @param tbl Table to iterate over","-- @return Iterator function","-- @return Table tbl","-- @return nil as current index"],"param":{"1":"tbl","tbl":"Table to iterate over"}},{"ret":"The name of the object's type.","comment":["--- Same as Lua's type","-- @name SF.DefaultEnvironment.type","-- @class function","-- @param obj Object to get type of","-- @return The name of the object's type."],"code":["SF.DefaultEnvironment.type = function( obj )","\tlocal tp = getmetatable( obj )","\treturn type(tp) == \"string\" and tp or type( obj )","end"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.type","summary":"\nSame as Lua's type ","private":false,"library":"builtin","description":"\nSame as Lua's type","param":{"1":"obj","obj":"Object to get type of"}},{"ret":["Key or nil","Value or nil"],"description":"\nSame as Lua's next","code":["SF.DefaultEnvironment.next = next"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.next","summary":"\nSame as Lua's next ","library":"builtin","comment":["--- Same as Lua's next","-- @name SF.DefaultEnvironment.next","-- @class function","-- @param tbl Table to get the next key-value pair of","-- @param k Previous key (can be nil)","-- @return Key or nil","-- @return Value or nil"],"param":{"1":"tbl","2":"k","tbl":"Table to get the next key-value pair of","k":"Previous key (can be nil)"}},{"comment":["--- Same as Lua's assert.","-- @name SF.DefaultEnvironment.assert","-- @class function","-- @param condition","-- @param msg"],"code":["SF.DefaultEnvironment.assert = function ( condition, msg ) if not condition then SF.throw( msg or \"assertion failed!\", 2 ) end end"],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.assert","summary":"\nSame as Lua's assert.","private":false,"library":"builtin","description":"\nSame as Lua's assert.","param":{"1":"condition","2":"msg","condition":"","msg":""}},{"ret":"Elements of tbl","description":"\nSame as Lua's unpack","code":["SF.DefaultEnvironment.unpack = unpack",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.unpack","summary":"\nSame as Lua's unpack ","library":"builtin","comment":["--- Same as Lua's unpack","-- @name SF.DefaultEnvironment.unpack","-- @class function","-- @param tbl","-- @return Elements of tbl"],"param":{"1":"tbl","tbl":""}},{"ret":"tbl with metatable set to meta","description":"\nSame as Lua's setmetatable. Doesn't work on most internal metatables","code":["SF.DefaultEnvironment.setmetatable = setmetatable",""],"class":"function","classForced":true,"name":"SF.DefaultEnvironment.setmetatable","summary":"\nSame as Lua's setmetatable.","library":"builtin","comment":["--- Same as Lua's setmetatable. Doesn't work on most internal metatables","-- @name SF.DefaultEnvironment.setmetatable","-- @class function","-- @param tbl The table to set the metatable of","-- @param meta The metatable to use","-- @return tbl with metatable set to meta"],"param":{"1":"tbl","2":"meta","tbl":"The table to set the metatable of","meta":"The metatable to use"}},{"ret":"The metatable of tbl","comment":["--- Same as Lua's getmetatable. Doesn't work on most internal metatables","-- @param tbl Table to get metatable of","-- @return The metatable of tbl"],"code":["SF.DefaultEnvironment.getmetatable = function(tbl)","\tSF.CheckType(tbl,\"table\")","\treturn getmetatable(tbl)","end",""],"class":"function","name":"SF.DefaultEnvironment.getmetatable","summary":"\nSame as Lua's getmetatable.","private":false,"library":"builtin","description":"\nSame as Lua's getmetatable. Doesn't work on most internal metatables","param":{"1":"tbl","tbl":"Table to get metatable of"}},{"description":"\nConstant that denotes whether the code is executed on the client","code":["SF.DefaultEnvironment.CLIENT = CLIENT"],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.CLIENT","summary":"\nConstant that denotes whether the code is executed on the client ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the client","-- @name SF.DefaultEnvironment.CLIENT","-- @class field"],"param":[]},{"description":"\nConstant that denotes whether the code is executed on the server","code":["SF.DefaultEnvironment.SERVER = SERVER",""],"class":"field","classForced":true,"name":"SF.DefaultEnvironment.SERVER","summary":"\nConstant that denotes whether the code is executed on the server ","library":"builtin","comment":["--- Constant that denotes whether the code is executed on the server","-- @name SF.DefaultEnvironment.SERVER","-- @class field"],"param":[]},{"ret":"Current quota used this Think","comment":["--- Returns the current count for this Think's CPU Time.","-- This value increases as more executions are done, may not be exactly as you want.","-- If used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","-- @return Current quota used this Think"],"code":["function SF.DefaultEnvironment.quotaUsed ()","\treturn SF.instance.cpu_total","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaUsed","summary":"\nReturns the current count for this Think's CPU Time.","private":false,"library":"builtin","description":"\nReturns the current count for this Think's CPU Time. \nThis value increases as more executions are done, may not be exactly as you want. \nIf used on screens, will show 0 if only rendering is done. Operations must be done in the Think loop for them to be counted.","param":[]},{"ret":"Average CPU Time of the buffer.","comment":["--- Gets the Average CPU Time in the buffer","-- @return Average CPU Time of the buffer."],"code":["function SF.DefaultEnvironment.quotaAverage ()","\treturn SF.instance.cpu_average","end",""],"class":"function","name":"SF.DefaultEnvironment.quotaAverage","summary":"\nGets the Average CPU Time in the buffer ","private":false,"library":"builtin","description":"\nGets the Average CPU Time in the buffer","param":[]},{"ret":"Max SysTime allowed to take for execution of the chip in a Think.","comment":["--- Gets the CPU Time max.","-- CPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","-- @return Max SysTime allowed to take for execution of the chip in a Think."],"code":["function SF.DefaultEnvironment.quotaMax ()","\treturn SF.instance.context.cpuTime.getMax()","end","","-- The below modules have the Gmod functions removed (the ones that begin with a capital letter),","-- as requested by Divran","","-- Filters Gmod Lua files based on Garry's naming convention.","local function filterGmodLua(lib, original, gm)","\toriginal = original or {}","\tgm = gm or {}","\tfor name, func in pairs(lib) do","\t\tif name:match(\"^[A-Z]\") then","\t\t\tgm[name] = func","\t\telse","\t\t\toriginal[name] = func","\t\tend","\tend","\treturn original, gm","end","","-- String library","local string_methods, string_metatable = SF.Typedef( \"Library: string\" )","filterGmodLua( string, string_methods )","string_metatable.__newindex = function () end",""],"class":"function","name":"SF.DefaultEnvironment.quotaMax","summary":"\nGets the CPU Time max.","private":false,"library":"builtin","description":"\nGets the CPU Time max. \nCPU Time is stored in a buffer of N elements, if the average of this exceeds quotaMax, the chip will error.","param":[]},{"description":"\nLua's (not glua's) string library","code":["SF.DefaultEnvironment.string = setmetatable( {}, string_metatable )","","-- Math library","local math_methods, math_metatable = SF.Typedef(\"Library: math\")","filterGmodLua(math,math_methods)","math_metatable.__newindex = function() end","math_methods.clamp = math.Clamp","math_methods.angnorm = math.NormalizeAngle","math_methods.sign = function(a) return a>0 and 1 or -1 end","math_methods.round = math.Round","math_methods.randfloat = math.Rand","math_methods.calcBSplineN = nil"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.string","summary":"\nLua's (not glua's) string library ","library":"builtin","comment":["--- Lua's (not glua's) string library","-- @name SF.DefaultEnvironment.string","-- @class table"],"param":[]},{"description":"\nLua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN","code":["SF.DefaultEnvironment.math = setmetatable({},math_metatable)","","local os_methods, os_metatable = SF.Typedef( \"Library: os\" )","filterGmodLua( os, os_methods )","os_metatable.__newindex = function () end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.math","summary":"\nLua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN ","library":"builtin","comment":["--- Lua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN","-- @name SF.DefaultEnvironment.math","-- @class table"],"param":[]},{"description":"\nGLua's os library. http://wiki.garrysmod.com/page/Category:os, plus sortByKey, sortByMember","code":["SF.DefaultEnvironment.os = setmetatable( {}, os_metatable )","","local table_methods, table_metatable = SF.Typedef(\"Library: table\")","filterGmodLua(table,table_methods)","table_methods.sortByKey = table.SortByKey","table_methods.sortByMember = table.SortByMember","table_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.os","summary":"\nGLua's os library.","library":"builtin","comment":["--- GLua's os library. http://wiki.garrysmod.com/page/Category:os, plus sortByKey, sortByMember","-- @name SF.DefaultEnvironment.os","-- @class table"],"param":[]},{"description":"\nLua's (not glua's) table library","code":["SF.DefaultEnvironment.table = setmetatable({},table_metatable)","","-- ------------------------- Functions ------------------------- --",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.table","summary":"\nLua's (not glua's) table library ","library":"builtin","comment":["--- Lua's (not glua's) table library","-- @name SF.DefaultEnvironment.table","-- @class table"],"param":[]},{"ret":"Table containing the names of each available library","comment":["--- Gets a list of all libraries","-- @return Table containing the names of each available library"],"code":["function SF.DefaultEnvironment.getLibraries()","\tlocal ret = {}","\tfor k,v in pairs( SF.Libraries.libraries ) do","\t\tret[#ret+1] = k","\tend","\treturn ret","end","","","","if SERVER then"],"class":"function","name":"SF.DefaultEnvironment.getLibraries","summary":"\nGets a list of all libraries ","private":false,"library":"builtin","description":"\nGets a list of all libraries","param":[]},{"comment":["\t--- Prints a message to the player's chat.","\t-- @shared","\t-- @param ... Values to print"],"code":["\tfunction SF.DefaultEnvironment.print(...)","\t\tlocal str = \"\"","\t\tlocal tbl = {n=select('#', ...), ...}","\t\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t\tSF.instance.player:ChatPrint(str)","\tend","else","\t-- Prints a message to the player's chat.","\tfunction SF.DefaultEnvironment.print(...)","\t\tif SF.instance.player ~= LocalPlayer() then return end","\t\tlocal str = \"\"","\t\tlocal tbl = {n=select('#', ...), ...}","\t\tfor i=1,tbl.n do str = str .. tostring(tbl[i]) .. (i == tbl.n and \"\" or \"\\t\") end","\t\tLocalPlayer():ChatPrint(str)","\tend","end","","local function printTableX ( target, t, indent, alreadyprinted )","\tfor k,v in SF.DefaultEnvironment.pairs( t ) do","\t\tif SF.GetType( v ) == \"table\" and not alreadyprinted[ v ] then","\t\t\talreadyprinted[ v ] = true","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \":\" )","\t\t\tprintTableX( target, v, indent + 1, alreadyprinted )","\t\telse","\t\t\ttarget:ChatPrint( string.rep( \"\\t\", indent ) .. tostring( k ) .. \"\\t=\\t\" .. tostring( v ) )","\t\tend","\tend","end",""],"class":"function","summary":"\nPrints a message to the player's chat.","library":"builtin","name":"SF.DefaultEnvironment.print","server":true,"private":false,"client":true,"description":"\nPrints a message to the player's chat.","param":{"1":"...","...":"Values to print"}},{"comment":["--- Prints a table to player's chat","-- @param tbl Table to print"],"code":["function SF.DefaultEnvironment.printTable ( tbl )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end","\tSF.CheckType( tbl, \"table\" )","","\tprintTableX( ( SERVER and SF.instance.player or LocalPlayer() ), tbl, 0, { t = true } )","end","",""],"class":"function","name":"SF.DefaultEnvironment.printTable","summary":"\nPrints a table to player's chat ","private":false,"library":"builtin","description":"\nPrints a table to player's chat","param":{"1":"tbl","tbl":"Table to print"}},{"ret":"Return value of the script","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.require(file)","\tSF.CheckType(file, \"string\")","\tlocal loaded = SF.instance.data.reqloaded","\tif not loaded then","\t\tloaded = {}","\t\tSF.instance.data.reqloaded = loaded","\tend","\t","\tif loaded[file] then","\t\treturn loaded[file]","\telse","\t\tlocal func = SF.instance.scripts[file]","\t\tif not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","\t\tloaded[file] = func() or true","\t\treturn loaded[file]","\tend","end",""],"class":"function","name":"SF.DefaultEnvironment.require","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},{"ret":"Table of return values of the scripts","comment":["--- Runs an included script and caches the result.","-- Works pretty much like standard Lua require()","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.requiredir( dir, loadpriority )","    SF.CheckType( dir, \"string\")","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","    ","    local returns = {}","","    if loadpriority then","        for i = 1, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.require( file )","                end","            end","        end","    end","","\tfor file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 and not returns[ file ] then","\t\t\treturns[ file ] = SF.DefaultEnvironment.require( file )","\t\tend","\tend","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.requiredir","summary":"\nRuns an included script and caches the result.","private":false,"library":"builtin","description":"\nRuns an included script and caches the result. \nWorks pretty much like standard Lua require()","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},{"ret":"Return value of the script","comment":["--- Runs an included script, but does not cache the result.","-- Pretty much like standard Lua dofile()","-- @param file The file to include. Make sure to --@include it","-- @return Return value of the script"],"code":["function SF.DefaultEnvironment.dofile(file)","    SF.CheckType(file, \"string\")","    local func = SF.instance.scripts[file]","    if not func then SF.throw( \"Can't find file '\" .. file .. \"' (did you forget to --@include it?)\", 2 ) end","    return func()","end",""],"class":"function","name":"SF.DefaultEnvironment.dofile","summary":"\nRuns an included script, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included script, but does not cache the result. \nPretty much like standard Lua dofile()","param":{"1":"file","file":"The file to include. Make sure to --@include it"}},{"ret":"Table of return values of the scripts","comment":["--- Runs an included directory, but does not cache the result.","-- @param dir The directory to include. Make sure to --@includedir it","-- @param loadpriority Table of files that should be loaded before any others in the directory","-- @return Table of return values of the scripts"],"code":["function SF.DefaultEnvironment.dodir( dir, loadpriority )","    SF.CheckType( dir, \"string\" )","    if loadpriority then SF.CheckType( loadpriority, \"table\" ) end","","    local returns = {}","","    if loadpriority then","        for i = 0, #loadpriority do","            for file, _ in pairs( SF.instance.scripts ) do","                if string.find( file, dir .. \"/\" .. loadpriority[ i ] , 1 ) == 1 then","                    returns[ file ] = SF.DefaultEnvironment.dofile( file )","                end","            end","        end","    end","","    for file, _ in pairs( SF.instance.scripts ) do","\t\tif string.find( file, dir, 1 ) == 1 then","\t\t\treturns[ file ] = SF.DefaultEnvironment.dofile( file )","\t\tend","    end","","    return returns","end",""],"class":"function","name":"SF.DefaultEnvironment.dodir","summary":"\nRuns an included directory, but does not cache the result.","private":false,"library":"builtin","description":"\nRuns an included directory, but does not cache the result.","param":{"1":"dir","2":"loadpriority","loadpriority":"Table of files that should be loaded before any others in the directory","dir":"The directory to include. Make sure to --@includedir it"}},{"ret":"Function of str","comment":["--- GLua's loadstring","-- Works like loadstring, except that it executes by default in the main environment","-- @param str String to execute","-- @return Function of str"],"code":["function SF.DefaultEnvironment.loadstring ( str )","\tlocal func = CompileString( str, \"SF: \" .. tostring( SF.instance.env ), false )","\t","\t-- CompileString returns an error as a string, better check before setfenv","\tif type( func ) == \"function\" then","\t\treturn setfenv( func, SF.instance.env )","\tend","\t","\treturn func","end",""],"class":"function","name":"SF.DefaultEnvironment.loadstring","summary":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment ","private":false,"library":"builtin","description":"\nGLua's loadstring \nWorks like loadstring, except that it executes by default in the main environment","param":{"1":"str","str":"String to execute"}},{"ret":"func with environment set to tbl","comment":["--- Lua's setfenv","-- Works like setfenv, but is restricted on functions","-- @param func Function to change environment of","-- @param tbl New environment","-- @return func with environment set to tbl"],"code":["function SF.DefaultEnvironment.setfenv ( func, tbl )","\tif type( func ) ~= \"function\" then SF.throw( \"Main Thread is protected!\", 2 ) end","\treturn setfenv( func, tbl )","end",""],"class":"function","name":"SF.DefaultEnvironment.setfenv","summary":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions ","private":false,"library":"builtin","description":"\nLua's setfenv \nWorks like setfenv, but is restricted on functions","param":{"1":"func","2":"tbl","func":"Function to change environment of","tbl":"New environment"}},{"ret":"Current environment","comment":["--- Simple version of Lua's getfenv","-- Returns the current environment","-- @return Current environment"],"code":["function SF.DefaultEnvironment.getfenv ()","\treturn getfenv()","end",""],"class":"function","name":"SF.DefaultEnvironment.getfenv","summary":"\nSimple version of Lua's getfenv \nReturns the current environment ","private":false,"library":"builtin","description":"\nSimple version of Lua's getfenv \nReturns the current environment","param":[]},{"comment":["--- Try to execute a function and catch possible exceptions","-- Similar to xpcall, but a bit more in-depth","-- @param func Function to execute","-- @param catch Optional function to execute in case func fails"],"code":["function SF.DefaultEnvironment.try ( func, catch )","\tlocal ok, err = pcall( func )","\tif ok then return end","","\tif type( err ) == \"table\" then","\t\tif err.uncatchable then","\t\t\terror( err )","\t\tend","\tend","\tif catch then catch( err ) end","end",""],"class":"function","name":"SF.DefaultEnvironment.try","summary":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth ","private":false,"library":"builtin","description":"\nTry to execute a function and catch possible exceptions \nSimilar to xpcall, but a bit more in-depth","param":{"1":"func","2":"catch","func":"Function to execute","catch":"Optional function to execute in case func fails"}},{"comment":["--- Throws an exception","-- @param msg Message","-- @param level Which level in the stacktrace to blame. Defaults to one of invalid","-- @param uncatchable Makes this exception uncatchable"],"code":["function SF.DefaultEnvironment.throw ( msg, level, uncatchable )","\tlocal info = debug.getinfo( 1 + ( level or 1 ), \"Sl\" )","\tlocal filename = info.short_src:match( \"^SF:(.*)$\" )","\tif not filename then","\t\tinfo = debug.getinfo( 2, \"Sl\" )","\t\tfilename = info.short_src:match( \"^SF:(.*)$\" )","\tend","\tlocal err = {","\t\tuncatchable = false,","\t\tfile = filename,","\t\tline = info.currentline,","\t\tmessage = msg,","\t\tuncatchable = uncatchable","\t}","\terror( err )","end",""],"class":"function","name":"SF.DefaultEnvironment.throw","summary":"\nThrows an exception ","private":false,"library":"builtin","description":"\nThrows an exception","param":{"1":"msg","2":"level","3":"uncatchable","msg":"Message","uncatchable":"Makes this exception uncatchable","level":"Which level in the stacktrace to blame. Defaults to one of invalid"}},{"comment":["--- Throws a raw exception.","-- @param msg Exception message"],"code":["function SF.DefaultEnvironment.error ( msg )","\terror( msg or \"an unspecified error occured\", 2 )","end",""],"class":"function","name":"SF.DefaultEnvironment.error","summary":"\nThrows a raw exception.","private":false,"library":"builtin","description":"\nThrows a raw exception.","param":{"1":"msg","msg":"Exception message"}},{"comment":["--- Execute a console command","-- @param cmd Command to execute"],"code":["function SF.DefaultEnvironment.concmd ( cmd )","\tif CLIENT and SF.instance.player ~= LocalPlayer() then return end -- only execute on owner of screen","\tSF.CheckType( cmd, \"string\" )","\tSF.instance.player:ConCommand( cmd )","end",""],"class":"function","name":"SF.DefaultEnvironment.concmd","summary":"\nExecute a console command ","private":false,"library":"builtin","description":"\nExecute a console command","param":{"1":"cmd","cmd":"Command to execute"}},{"comment":["--- Set the value of a table index without invoking a metamethod","--@param table The table to modify","--@param key The index of the table","--@param value The value to set the index equal to"],"code":["function SF.DefaultEnvironment.rawset( table, key, value )","    SF.CheckType( table, \"table\" )","","    rawset( table, key, value )","end",""],"class":"function","name":"SF.DefaultEnvironment.rawset","summary":"\nSet the value of a table index without invoking a metamethod ","private":false,"library":"builtin","description":"\nSet the value of a table index without invoking a metamethod","param":{"1":"table","2":"key","3":"value","value":"The value to set the index equal to","key":"The index of the table","table":"The table to modify"}},{"ret":"The value of the index","comment":["--- Gets the value of a table index without invoking a metamethod","--@param table The table to get the value from","--@param key The index of the table","--@return The value of the index"],"code":["function SF.DefaultEnvironment.rawget( table, key, value )","    SF.CheckType( table, \"table\" )","","    return rawget( table, key )","end","","-- ------------------------- Restrictions ------------------------- --","-- Restricts access to builtin type's metatables","","local _R = debug.getregistry()","local function restrict(instance, hook, name, ok, err)","\t_R.Vector.__metatable = \"Vector\"","\t_R.Angle.__metatable = \"Angle\"","\t_R.VMatrix.__metatable = \"VMatrix\"","end","","local function unrestrict(instance, hook, name, ok, err)","\t_R.Vector.__metatable = nil","\t_R.Angle.__metatable = nil","\t_R.VMatrix.__metatable = nil","end","","SF.Libraries.AddHook(\"prepare\", restrict)","SF.Libraries.AddHook(\"cleanup\", unrestrict)","",""],"class":"function","name":"SF.DefaultEnvironment.rawget","summary":"\nGets the value of a table index without invoking a metamethod ","private":false,"library":"builtin","description":"\nGets the value of a table index without invoking a metamethod","param":{"1":"table","2":"key","3":"value","key":"The index of the table","table":"The table to get the value from"}},{"comment":["--------------------------- ENUMS -----------------------------------"],"code":["","local _KEY = {","\t[ \"FIRST\" ] = 0,","\t[ \"NONE\" ] = 0,","\t[ \"0\" ] = 1,","\t[ \"1\" ] = 2,","\t[ \"2\" ] = 3,","\t[ \"3\" ] = 4,","\t[ \"4\" ] = 5,","\t[ \"5\" ] = 6,","\t[ \"6\" ] = 7,","\t[ \"7\" ] = 8,","\t[ \"8\" ] = 9,","\t[ \"9\" ] = 10,","\t[ \"A\" ] = 11,","\t[ \"B\" ] = 12,","\t[ \"C\" ] = 13,","\t[ \"D\" ] = 14,","\t[ \"E\" ] = 15,","\t[ \"F\" ] = 16,","\t[ \"G\" ] = 17,","\t[ \"H\" ] = 18,","\t[ \"I\" ] = 19,","\t[ \"J\" ] = 20,","\t[ \"K\" ] = 21,","\t[ \"L\" ] = 22,","\t[ \"M\" ] = 23,","\t[ \"N\" ] = 24,","\t[ \"O\" ] = 25,","\t[ \"P\" ] = 26,","\t[ \"Q\" ] = 27,","\t[ \"R\" ] = 28,","\t[ \"S\" ] = 29,","\t[ \"T\" ] = 30,","\t[ \"U\" ] = 31,","\t[ \"V\" ] = 32,","\t[ \"W\" ] = 33,","\t[ \"X\" ] = 34,","\t[ \"Y\" ] = 35,","\t[ \"Z\" ] = 36,","\t[ \"KP_INS\" ] = 37,","\t[ \"PAD_0\" ] = 37,","\t[ \"KP_END\" ] = 38,","\t[ \"PAD_1\" ] = 38,","\t[ \"KP_DOWNARROW \" ] = 39,","\t[ \"PAD_2\" ] = 39,","\t[ \"KP_PGDN\" ] = 40,","\t[ \"PAD_3\" ] = 40,","\t[ \"KP_LEFTARROW\" ] = 41,","\t[ \"PAD_4\" ] = 41,","\t[ \"KP_5 \" ] = 42,","\t[ \"PAD_5\" ] = 42,","\t[ \"KP_RIGHTARROW\" ] = 43,","\t[ \"PAD_6\" ] = 43,","\t[ \"KP_HOME\" ] = 44,","\t[ \"PAD_7\" ] = 44,","\t[ \"KP_UPARROW\" ] = 45,","\t[ \"PAD_8\" ] = 45,","\t[ \"KP_PGUP\" ] = 46,","\t[ \"PAD_9\" ] = 46,","\t[ \"PAD_DIVIDE\" ] = 47,","\t[ \"KP_SLASH\" ] = 47,","\t[ \"KP_MULTIPLY\" ] = 48,","\t[ \"PAD_MULTIPLY\" ] = 48,","\t[ \"KP_MINUS\" ] = 49,","\t[ \"PAD_MINUS\" ] = 49,","\t[ \"KP_PLUS\" ] = 50,","\t[ \"PAD_PLUS\" ] = 50,","\t[ \"KP_ENTER\" ] = 51,","\t[ \"PAD_ENTER\" ] = 51,","\t[ \"KP_DEL\" ] = 52,","\t[ \"PAD_DECIMAL\" ] = 52,","\t[ \"[\" ] = 53,","\t[ \"LBRACKET\" ] = 53,","\t[ \"]\" ] = 54,","\t[ \"RBRACKET\" ] = 54,","\t[ \"SEMICOLON\" ] = 55,","\t[ \"'\" ] = 56,","\t[ \"APOSTROPHE\" ] = 56,","\t[ \"`\" ] = 57,","\t[ \"BACKQUOTE\" ] = 57,","\t[ \",\" ] = 58,","\t[ \"COMMA\" ] = 58,","\t[ \".\" ] = 59,","\t[ \"PERIOD\" ] = 59,","\t[ \"/\" ] = 60,","\t[ \"SLASH\" ] = 60,","\t[ \"\\\\\" ] = 61,","\t[ \"BACKSLASH\" ] = 61,","\t[ \"-\" ] = 62,","\t[ \"MINUS\" ] = 62,","\t[ \"=\" ] = 63,","\t[ \"EQUAL\" ] = 63,","\t[ \"ENTER\" ] = 64,","\t[ \"SPACE\" ] = 65,","\t[ \"BACKSPACE\" ] = 66,","\t[ \"TAB\" ] = 67,","\t[ \"CAPSLOCK\" ] = 68,","\t[ \"NUMLOCK\" ] = 69,","\t[ \"ESCAPE\" ] = 70,","\t[ \"SCROLLLOCK\" ] = 71,","\t[ \"INS\" ] = 72,","\t[ \"INSERT\" ] = 72,","\t[ \"DEL\" ] = 73,","\t[ \"DELETE\" ] = 73,","\t[ \"HOME\" ] = 74,","\t[ \"END\" ] = 75,","\t[ \"PGUP\" ] = 76,","\t[ \"PAGEUP\" ] = 76,","\t[ \"PGDN\" ] = 77,","\t[ \"PAGEDOWN\" ] = 77,","\t[ \"PAUSE\" ] = 78,","\t[ \"BREAK\" ] = 78,","\t[ \"SHIFT\" ] = 79,","\t[ \"LSHIFT\" ] = 79,","\t[ \"RSHIFT\" ] = 80,","\t[ \"ALT\" ] = 81,","\t[ \"LALT\" ] = 81,","\t[ \"RALT\" ] = 82,","\t[ \"CTRL\" ] = 83,","\t[ \"LCONTROL\" ] = 83,","\t[ \"RCTRL\" ] = 84,","\t[ \"RCONTROL\" ] = 84,","\t[ \"LWIN\" ] = 85,","\t[ \"RWIN\" ] = 86,","\t[ \"APP\" ] = 87,","\t[ \"UPARROW\" ] = 88,","\t[ \"UP\" ] = 88,","\t[ \"LEFTARROW\" ] = 89,","\t[ \"LEFT\" ] = 89,","\t[ \"DOWNARROW\" ] = 90,","\t[ \"DOWN\" ] = 90,","\t[ \"RIGHTARROW\" ] = 91,","\t[ \"RIGHT\" ] = 91,","\t[ \"F1\" ] = 92,","\t[ \"F2\" ] = 93,","\t[ \"F3\" ] = 94,","\t[ \"F4\" ] = 95,","\t[ \"F5\" ] = 96,","\t[ \"F6\" ] = 97,","\t[ \"F7\" ] = 98,","\t[ \"F8\" ] = 99,","\t[ \"F9\" ] = 100,","\t[ \"F10\" ] = 101,","\t[ \"F11\" ] = 102,","\t[ \"F12\" ] = 103,","\t[ \"CAPSLOCKTOGGLE\" ] = 104,","\t[ \"NUMLOCKTOGGLE\" ] = 105,","\t[ \"SCROLLLOCKTOGGLE\" ] = 106,","\t[ \"LAST\" ] = 106,","\t[ \"COUNT\" ] = 106","}",""],"summary":"\nENUMS ----------------------------------- ","description":"\nENUMS -----------------------------------","param":[]},{"description":"\nENUMs of keyboard keys for use with input library","code":["SF.DefaultEnvironment.KEY = setmetatable( {}, {","\t__index = _KEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _MOUSE = {","\t[ \"MOUSE1\" ] = 107,","\t[ \"LEFT\" ] = 107,","\t[ \"MOUSE2\" ] = 108,","\t[ \"RIGHT\" ] = 108,","\t[ \"MOUSE3\" ] = 109,","\t[ \"MIDDLE\" ] = 109,","\t[ \"MOUSE4\" ] = 110,","\t[ \"4\" ] = 110,","\t[ \"MOUSE5\"] = 111,","\t[ \"5\" ] = 111,","\t[ \"MWHEELUP\" ] = 112,","\t[ \"WHEEL_UP\" ] = 112,","\t[ \"MWHEELDOWN\" ] = 113,","\t[ \"WHEEL_DOWN\" ] = 113,","\t[ \"COUNT\" ] = 7,","\t[ \"FIRST\" ] = 107,","\t[ \"LAST\" ] = 113","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.KEY","summary":"\nENUMs of keyboard keys for use with input library ","library":"builtin","comment":["--- ENUMs of keyboard keys for use with input library","-- @name SF.DefaultEnvironment.KEY","-- @class table"],"param":[]},{"description":"\nENUMs of mouse buttons for use with input library","code":["SF.DefaultEnvironment.MOUSE = setmetatable( {}, {","\t__index = _MOUSE,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _INKEY = {","\t[ \"ALT1\" ] = IN_ALT1,","\t[ \"ALT2\" ] = IN_ALT2,","\t[ \"ATTACK\" ] = IN_ATTACK,","\t[ \"ATTACK2\" ] = IN_ATTACK2,","\t[ \"BACK\" ] = IN_BACK,","\t[ \"DUCK\" ] = IN_DUCK,","\t[ \"FORWARD\" ] = IN_FORWARD,","\t[ \"JUMP\" ] = IN_JUMP,","\t[ \"LEFT\" ] = IN_LEFT,","\t[ \"MOVELEFT\" ] = IN_MOVELEFT,","\t[ \"MOVERIGHT\" ] = IN_MOVERIGHT,","\t[ \"RELOAD\" ] = IN_RELOAD,","\t[ \"RIGHT\" ] = IN_RIGHT,","\t[ \"SCORE\" ] = IN_SCORE,","\t[ \"SPEED\" ] = IN_SPEED,","\t[ \"USE\" ] = IN_USE,","\t[ \"WALK\" ] = IN_WALK,","\t[ \"ZOOM\" ] = IN_ZOOM,","\t[ \"GRENADE1\" ] = IN_GRENADE1,","\t[ \"GRENADE2\" ] = IN_GRENADE2,","\t[ \"WEAPON1\" ] = IN_WEAPON1,","\t[ \"WEAPON2\" ] = IN_WEAPON2,","\t[ \"BULLRUSH\" ] = IN_BULLRUSH,","\t[ \"CANCEL\" ] = IN_CANCEL,","\t[ \"RUN\" ] = IN_RUN,","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.MOUSE","summary":"\nENUMs of mouse buttons for use with input library ","library":"builtin","comment":["--- ENUMs of mouse buttons for use with input library","-- @name SF.DefaultEnvironment.MOUSE","-- @class table"],"param":[]},{"description":"\nENUMs of in_keys for use with player:keyDown","code":["SF.DefaultEnvironment.IN_KEY = setmetatable( {}, {","\t__index = _INKEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.IN_KEY","summary":"\nENUMs of in_keys for use with player:keyDown ","library":"builtin","comment":["--- ENUMs of in_keys for use with player:keyDown","-- @name SF.DefaultEnvironment.IN_KEY","-- @class table"],"param":[]}],"tables":{"1":"SF.DefaultEnvironment.IN_KEY","2":"SF.DefaultEnvironment.KEY","3":"SF.DefaultEnvironment.MOUSE","4":"SF.DefaultEnvironment.math","5":"SF.DefaultEnvironment.os","6":"SF.DefaultEnvironment.string","7":"SF.DefaultEnvironment.table","SF.DefaultEnvironment.string":{"description":"\nLua's (not glua's) string library","code":["SF.DefaultEnvironment.string = setmetatable( {}, string_metatable )","","-- Math library","local math_methods, math_metatable = SF.Typedef(\"Library: math\")","filterGmodLua(math,math_methods)","math_metatable.__newindex = function() end","math_methods.clamp = math.Clamp","math_methods.angnorm = math.NormalizeAngle","math_methods.sign = function(a) return a>0 and 1 or -1 end","math_methods.round = math.Round","math_methods.randfloat = math.Rand","math_methods.calcBSplineN = nil"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.string","summary":"\nLua's (not glua's) string library ","library":"builtin","comment":["--- Lua's (not glua's) string library","-- @name SF.DefaultEnvironment.string","-- @class table"],"param":[]},"SF.DefaultEnvironment.IN_KEY":{"description":"\nENUMs of in_keys for use with player:keyDown","code":["SF.DefaultEnvironment.IN_KEY = setmetatable( {}, {","\t__index = _INKEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.IN_KEY","summary":"\nENUMs of in_keys for use with player:keyDown ","library":"builtin","comment":["--- ENUMs of in_keys for use with player:keyDown","-- @name SF.DefaultEnvironment.IN_KEY","-- @class table"],"param":[]},"SF.DefaultEnvironment.MOUSE":{"description":"\nENUMs of mouse buttons for use with input library","code":["SF.DefaultEnvironment.MOUSE = setmetatable( {}, {","\t__index = _MOUSE,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _INKEY = {","\t[ \"ALT1\" ] = IN_ALT1,","\t[ \"ALT2\" ] = IN_ALT2,","\t[ \"ATTACK\" ] = IN_ATTACK,","\t[ \"ATTACK2\" ] = IN_ATTACK2,","\t[ \"BACK\" ] = IN_BACK,","\t[ \"DUCK\" ] = IN_DUCK,","\t[ \"FORWARD\" ] = IN_FORWARD,","\t[ \"JUMP\" ] = IN_JUMP,","\t[ \"LEFT\" ] = IN_LEFT,","\t[ \"MOVELEFT\" ] = IN_MOVELEFT,","\t[ \"MOVERIGHT\" ] = IN_MOVERIGHT,","\t[ \"RELOAD\" ] = IN_RELOAD,","\t[ \"RIGHT\" ] = IN_RIGHT,","\t[ \"SCORE\" ] = IN_SCORE,","\t[ \"SPEED\" ] = IN_SPEED,","\t[ \"USE\" ] = IN_USE,","\t[ \"WALK\" ] = IN_WALK,","\t[ \"ZOOM\" ] = IN_ZOOM,","\t[ \"GRENADE1\" ] = IN_GRENADE1,","\t[ \"GRENADE2\" ] = IN_GRENADE2,","\t[ \"WEAPON1\" ] = IN_WEAPON1,","\t[ \"WEAPON2\" ] = IN_WEAPON2,","\t[ \"BULLRUSH\" ] = IN_BULLRUSH,","\t[ \"CANCEL\" ] = IN_CANCEL,","\t[ \"RUN\" ] = IN_RUN,","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.MOUSE","summary":"\nENUMs of mouse buttons for use with input library ","library":"builtin","comment":["--- ENUMs of mouse buttons for use with input library","-- @name SF.DefaultEnvironment.MOUSE","-- @class table"],"param":[]},"SF.DefaultEnvironment.os":{"description":"\nGLua's os library. http://wiki.garrysmod.com/page/Category:os, plus sortByKey, sortByMember","code":["SF.DefaultEnvironment.os = setmetatable( {}, os_metatable )","","local table_methods, table_metatable = SF.Typedef(\"Library: table\")","filterGmodLua(table,table_methods)","table_methods.sortByKey = table.SortByKey","table_methods.sortByMember = table.SortByMember","table_metatable.__newindex = function() end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.os","summary":"\nGLua's os library.","library":"builtin","comment":["--- GLua's os library. http://wiki.garrysmod.com/page/Category:os, plus sortByKey, sortByMember","-- @name SF.DefaultEnvironment.os","-- @class table"],"param":[]},"SF.DefaultEnvironment.math":{"description":"\nLua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN","code":["SF.DefaultEnvironment.math = setmetatable({},math_metatable)","","local os_methods, os_metatable = SF.Typedef( \"Library: os\" )","filterGmodLua( os, os_methods )","os_metatable.__newindex = function () end"],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.math","summary":"\nLua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN ","library":"builtin","comment":["--- Lua's (not glua's) math library, plus clamp, angnorm, sign, round, and randfloat, calcBSplineN","-- @name SF.DefaultEnvironment.math","-- @class table"],"param":[]},"SF.DefaultEnvironment.table":{"description":"\nLua's (not glua's) table library","code":["SF.DefaultEnvironment.table = setmetatable({},table_metatable)","","-- ------------------------- Functions ------------------------- --",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.table","summary":"\nLua's (not glua's) table library ","library":"builtin","comment":["--- Lua's (not glua's) table library","-- @name SF.DefaultEnvironment.table","-- @class table"],"param":[]},"SF.DefaultEnvironment.KEY":{"description":"\nENUMs of keyboard keys for use with input library","code":["SF.DefaultEnvironment.KEY = setmetatable( {}, {","\t__index = _KEY,","\t__newindex = function( )","\tend,","\t__metatable = false","} )","","local _MOUSE = {","\t[ \"MOUSE1\" ] = 107,","\t[ \"LEFT\" ] = 107,","\t[ \"MOUSE2\" ] = 108,","\t[ \"RIGHT\" ] = 108,","\t[ \"MOUSE3\" ] = 109,","\t[ \"MIDDLE\" ] = 109,","\t[ \"MOUSE4\" ] = 110,","\t[ \"4\" ] = 110,","\t[ \"MOUSE5\"] = 111,","\t[ \"5\" ] = 111,","\t[ \"MWHEELUP\" ] = 112,","\t[ \"WHEEL_UP\" ] = 112,","\t[ \"MWHEELDOWN\" ] = 113,","\t[ \"WHEEL_DOWN\" ] = 113,","\t[ \"COUNT\" ] = 7,","\t[ \"FIRST\" ] = 107,","\t[ \"LAST\" ] = 113","}",""],"class":"table","classForced":true,"name":"SF.DefaultEnvironment.KEY","summary":"\nENUMs of keyboard keys for use with input library ","library":"builtin","comment":["--- ENUMs of keyboard keys for use with input library","-- @name SF.DefaultEnvironment.KEY","-- @class table"],"param":[]}},"description":"\n \nBuiltins. \nFunctions built-in to the default environment \n","summary":"\n \nBuiltins."},"libs_sh/globaltables.lua":{"libraries":{"1":"globaltables","globaltables":{"comment":["--- Cross-instance tables","-- @shared"],"functions":[],"class":"library","summary":"\nCross-instance tables ","code":["local gtables_library, gtables_metamethods = SF.Libraries.Register(\"globaltables\")","","SF.GlobalTables = {}","","SF.GlobalTables.Global = {}","SF.GlobalTables.Players = {}",""],"fields":[],"name":"globaltables","client":true,"description":"\nCross-instance tables","libtbl":"gtables_library","tables":{"1":"global","2":"player","global":{"description":"\nGlobal table shared by all instances on the same side.","code":["gtables_library.global = SF.GlobalTables.Global",""],"class":"table","classForced":true,"name":"gtables_library.global","summary":"\nGlobal table shared by all instances on the same side.","library":"globaltables","comment":["--- Global table shared by all instances on the same side.","-- @name gtables_library.global","-- @class table"],"param":[]},"player":{"description":"\nPlayer-unique global table.","code":["","hook.Add(\"PlayerInitialSpawn\", \"SF_GlobalTables_cn\", function(ply)","\tSF.GlobalTables.Players[ply] = {}","end)","","hook.Add(\"PlayerDisconnected\", \"SF_GlobalTables_dc\", function(ply)","\tSF.GlobalTables.Players[ply] = nil","end)","","local oldindex = gtables_metamethods.__index","function gtables_metamethods:__index(k)","\tif k == \"player\" then","\t\treturn SF.GlobalTables.Players[SF.instance.player]","\telse","\t\treturn oldindex[k]","\tend","end"],"class":"table","classForced":true,"name":"gtables_library.player","summary":"\nPlayer-unique global table.","library":"globaltables","comment":["--- Player-unique global table.","-- @name gtables_library.player","-- @class table"],"param":[]}},"server":true}},"type":"file","name":"libs_sh/globaltables.lua","functions":[],"doc":[{"comment":["--- Cross-instance tables","-- @shared"],"functions":[],"class":"library","summary":"\nCross-instance tables ","code":["local gtables_library, gtables_metamethods = SF.Libraries.Register(\"globaltables\")","","SF.GlobalTables = {}","","SF.GlobalTables.Global = {}","SF.GlobalTables.Players = {}",""],"fields":[],"name":"globaltables","client":true,"description":"\nCross-instance tables","libtbl":"gtables_library","tables":{"1":"global","2":"player","global":{"description":"\nGlobal table shared by all instances on the same side.","code":["gtables_library.global = SF.GlobalTables.Global",""],"class":"table","classForced":true,"name":"gtables_library.global","summary":"\nGlobal table shared by all instances on the same side.","library":"globaltables","comment":["--- Global table shared by all instances on the same side.","-- @name gtables_library.global","-- @class table"],"param":[]},"player":{"description":"\nPlayer-unique global table.","code":["","hook.Add(\"PlayerInitialSpawn\", \"SF_GlobalTables_cn\", function(ply)","\tSF.GlobalTables.Players[ply] = {}","end)","","hook.Add(\"PlayerDisconnected\", \"SF_GlobalTables_dc\", function(ply)","\tSF.GlobalTables.Players[ply] = nil","end)","","local oldindex = gtables_metamethods.__index","function gtables_metamethods:__index(k)","\tif k == \"player\" then","\t\treturn SF.GlobalTables.Players[SF.instance.player]","\telse","\t\treturn oldindex[k]","\tend","end"],"class":"table","classForced":true,"name":"gtables_library.player","summary":"\nPlayer-unique global table.","library":"globaltables","comment":["--- Player-unique global table.","-- @name gtables_library.player","-- @class table"],"param":[]}},"server":true},{"description":"\nGlobal table shared by all instances on the same side.","code":["gtables_library.global = SF.GlobalTables.Global",""],"class":"table","classForced":true,"name":"gtables_library.global","summary":"\nGlobal table shared by all instances on the same side.","library":"globaltables","comment":["--- Global table shared by all instances on the same side.","-- @name gtables_library.global","-- @class table"],"param":[]},{"description":"\nPlayer-unique global table.","code":["","hook.Add(\"PlayerInitialSpawn\", \"SF_GlobalTables_cn\", function(ply)","\tSF.GlobalTables.Players[ply] = {}","end)","","hook.Add(\"PlayerDisconnected\", \"SF_GlobalTables_dc\", function(ply)","\tSF.GlobalTables.Players[ply] = nil","end)","","local oldindex = gtables_metamethods.__index","function gtables_metamethods:__index(k)","\tif k == \"player\" then","\t\treturn SF.GlobalTables.Players[SF.instance.player]","\telse","\t\treturn oldindex[k]","\tend","end"],"class":"table","classForced":true,"name":"gtables_library.player","summary":"\nPlayer-unique global table.","library":"globaltables","comment":["--- Player-unique global table.","-- @name gtables_library.player","-- @class table"],"param":[]}],"tables":{"1":"gtables_library.global","2":"gtables_library.player","gtables_library.player":{"description":"\nPlayer-unique global table.","code":["","hook.Add(\"PlayerInitialSpawn\", \"SF_GlobalTables_cn\", function(ply)","\tSF.GlobalTables.Players[ply] = {}","end)","","hook.Add(\"PlayerDisconnected\", \"SF_GlobalTables_dc\", function(ply)","\tSF.GlobalTables.Players[ply] = nil","end)","","local oldindex = gtables_metamethods.__index","function gtables_metamethods:__index(k)","\tif k == \"player\" then","\t\treturn SF.GlobalTables.Players[SF.instance.player]","\telse","\t\treturn oldindex[k]","\tend","end"],"class":"table","classForced":true,"name":"gtables_library.player","summary":"\nPlayer-unique global table.","library":"globaltables","comment":["--- Player-unique global table.","-- @name gtables_library.player","-- @class table"],"param":[]},"gtables_library.global":{"description":"\nGlobal table shared by all instances on the same side.","code":["gtables_library.global = SF.GlobalTables.Global",""],"class":"table","classForced":true,"name":"gtables_library.global","summary":"\nGlobal table shared by all instances on the same side.","library":"globaltables","comment":["--- Global table shared by all instances on the same side.","-- @name gtables_library.global","-- @class table"],"param":[]}},"description":"\nCross-instance tables","summary":"\nCross-instance tables "},"libs_sh/find.lua":{"libraries":{"1":"find","find":{"comment":["--- Find library. Finds entities in various shapes.","-- @shared"],"functions":{"1":"all","2":"allPlayers","3":"byClass","4":"byModel","5":"inBox","6":"inCone","7":"inSphere","inBox":{"ret":"An array of found entities","comment":["--- Finds entities in a box","-- @param min Bottom corner","-- @param max Top corner","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inBox ( min, max, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( min, SF.Types[ \"Vector\" ] )","\tSF.CheckType( max, SF.Types[ \"Vector\" ] )","","\tlocal min, max = vunwrap( min ), vunwrap( max )","","\treturn convert( ents.FindInBox( min, max ), filter )","end",""],"class":"function","name":"find_library.inBox","summary":"\nFinds entities in a box ","private":false,"library":"find","description":"\nFinds entities in a box","param":{"1":"min","2":"max","3":"filter","max":"Top corner","min":"Bottom corner","filter":"Optional function to filter results"}},"inSphere":{"ret":"An array of found entities","comment":["--- Finds entities in a sphere","-- @param center Center of the sphere","-- @param radius Sphere radius","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inSphere ( center, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( center, SF.Types[ \"Vector\" ] )","\tSF.CheckType( radius, \"number\" )","","\tlocal center = vunwrap( center )","\t","\treturn convert( ents.FindInSphere( center, radius ), filter )","end",""],"class":"function","name":"find_library.inSphere","summary":"\nFinds entities in a sphere ","private":false,"library":"find","description":"\nFinds entities in a sphere","param":{"1":"center","2":"radius","3":"filter","radius":"Sphere radius","center":"Center of the sphere","filter":"Optional function to filter results"}},"byClass":{"ret":"An array of found entities","comment":["--- Finds entities by class name","-- @param class The class name","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byClass(class, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(class,\"string\")","\t\t","\treturn convert(ents.FindByClass(class), filter)","end",""],"class":"function","name":"find_library.byClass","summary":"\nFinds entities by class name ","private":false,"library":"find","description":"\nFinds entities by class name","param":{"1":"class","2":"filter","filter":"Optional function to filter results","class":"The class name"}},"allPlayers":{"ret":"An array of found entities","comment":["--- Finds all players (including bots)","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.allPlayers(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(player.GetAll(), filter)","end",""],"class":"function","name":"find_library.allPlayers","summary":"\nFinds all players (including bots) ","private":false,"library":"find","description":"\nFinds all players (including bots)","param":{"1":"filter","filter":"Optional function to filter results"}},"all":{"ret":"An array of found entities","comment":["--- Finds all entitites","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.all(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(ents.GetAll(), filter)","end"],"class":"function","name":"find_library.all","summary":"\nFinds all entitites ","private":false,"library":"find","description":"\nFinds all entitites","param":{"1":"filter","filter":"Optional function to filter results"}},"byModel":{"ret":"An array of found entities","comment":["--- Finds entities by model","-- @param model The model file","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byModel(model, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(model,\"string\")","\t\t","\treturn convert(ents.FindByModel(model), filter)","end",""],"class":"function","name":"find_library.byModel","summary":"\nFinds entities by model ","private":false,"library":"find","description":"\nFinds entities by model","param":{"1":"model","2":"filter","filter":"Optional function to filter results","model":"The model file"}},"inCone":{"ret":"An array of found entities","comment":["--- Finds entities in a cone","-- @param pos The cone vertex position","-- @param dir The direction to project the cone","-- @param distance The length to project the cone","-- @param radius The angle of the cone","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inCone ( pos, dir, distance, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( dir, SF.Types[ \"Vector\" ] )","\tSF.CheckType( distance, \"number\" )","\tSF.CheckType( radius, \"number\" )","","\tlocal pos, dir = vunwrap( pos ), vunwrap( dir )","\t","\treturn convert( ents.FindInCone( pos, dir, distance, radius ), filter )","end",""],"class":"function","name":"find_library.inCone","summary":"\nFinds entities in a cone ","private":false,"library":"find","description":"\nFinds entities in a cone","param":{"1":"pos","2":"dir","3":"distance","4":"radius","5":"filter","radius":"The angle of the cone","dir":"The direction to project the cone","distance":"The length to project the cone","filter":"Optional function to filter results","pos":"The cone vertex position"}}},"class":"library","summary":"\nFind library.","code":["local find_library, _ = SF.Libraries.Register(\"find\")","","local vunwrap = SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"find\", \"Find\", \"Allows the user to access the find library\" )","end","","local function convert(results, func)","\tif func then SF.CheckType(func,\"function\") end","\tlocal wrap = SF.WrapObject","\t","\tlocal t = {}","\tlocal count = 1","\tfor i=1,#results do","\t\tlocal e = wrap(results[i])","\t\tif not func or func(e) then","\t\t\tt[count] = e","\t\t\tcount = count + 1","\t\tend","\tend","\treturn t","end",""],"fields":[],"name":"find","client":true,"description":"\nFind library. Finds entities in various shapes.","libtbl":"find_library","tables":[],"server":true}},"type":"file","name":"libs_sh/find.lua","functions":{"1":"find_library.all","2":"find_library.allPlayers","3":"find_library.byClass","4":"find_library.byModel","5":"find_library.inBox","6":"find_library.inCone","7":"find_library.inSphere","find_library.inCone":{"ret":"An array of found entities","comment":["--- Finds entities in a cone","-- @param pos The cone vertex position","-- @param dir The direction to project the cone","-- @param distance The length to project the cone","-- @param radius The angle of the cone","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inCone ( pos, dir, distance, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( dir, SF.Types[ \"Vector\" ] )","\tSF.CheckType( distance, \"number\" )","\tSF.CheckType( radius, \"number\" )","","\tlocal pos, dir = vunwrap( pos ), vunwrap( dir )","\t","\treturn convert( ents.FindInCone( pos, dir, distance, radius ), filter )","end",""],"class":"function","name":"find_library.inCone","summary":"\nFinds entities in a cone ","private":false,"library":"find","description":"\nFinds entities in a cone","param":{"1":"pos","2":"dir","3":"distance","4":"radius","5":"filter","radius":"The angle of the cone","dir":"The direction to project the cone","distance":"The length to project the cone","filter":"Optional function to filter results","pos":"The cone vertex position"}},"find_library.inBox":{"ret":"An array of found entities","comment":["--- Finds entities in a box","-- @param min Bottom corner","-- @param max Top corner","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inBox ( min, max, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( min, SF.Types[ \"Vector\" ] )","\tSF.CheckType( max, SF.Types[ \"Vector\" ] )","","\tlocal min, max = vunwrap( min ), vunwrap( max )","","\treturn convert( ents.FindInBox( min, max ), filter )","end",""],"class":"function","name":"find_library.inBox","summary":"\nFinds entities in a box ","private":false,"library":"find","description":"\nFinds entities in a box","param":{"1":"min","2":"max","3":"filter","max":"Top corner","min":"Bottom corner","filter":"Optional function to filter results"}},"find_library.all":{"ret":"An array of found entities","comment":["--- Finds all entitites","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.all(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(ents.GetAll(), filter)","end"],"class":"function","name":"find_library.all","summary":"\nFinds all entitites ","private":false,"library":"find","description":"\nFinds all entitites","param":{"1":"filter","filter":"Optional function to filter results"}},"find_library.byModel":{"ret":"An array of found entities","comment":["--- Finds entities by model","-- @param model The model file","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byModel(model, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(model,\"string\")","\t\t","\treturn convert(ents.FindByModel(model), filter)","end",""],"class":"function","name":"find_library.byModel","summary":"\nFinds entities by model ","private":false,"library":"find","description":"\nFinds entities by model","param":{"1":"model","2":"filter","filter":"Optional function to filter results","model":"The model file"}},"find_library.byClass":{"ret":"An array of found entities","comment":["--- Finds entities by class name","-- @param class The class name","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byClass(class, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(class,\"string\")","\t\t","\treturn convert(ents.FindByClass(class), filter)","end",""],"class":"function","name":"find_library.byClass","summary":"\nFinds entities by class name ","private":false,"library":"find","description":"\nFinds entities by class name","param":{"1":"class","2":"filter","filter":"Optional function to filter results","class":"The class name"}},"find_library.allPlayers":{"ret":"An array of found entities","comment":["--- Finds all players (including bots)","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.allPlayers(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(player.GetAll(), filter)","end",""],"class":"function","name":"find_library.allPlayers","summary":"\nFinds all players (including bots) ","private":false,"library":"find","description":"\nFinds all players (including bots)","param":{"1":"filter","filter":"Optional function to filter results"}},"find_library.inSphere":{"ret":"An array of found entities","comment":["--- Finds entities in a sphere","-- @param center Center of the sphere","-- @param radius Sphere radius","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inSphere ( center, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( center, SF.Types[ \"Vector\" ] )","\tSF.CheckType( radius, \"number\" )","","\tlocal center = vunwrap( center )","\t","\treturn convert( ents.FindInSphere( center, radius ), filter )","end",""],"class":"function","name":"find_library.inSphere","summary":"\nFinds entities in a sphere ","private":false,"library":"find","description":"\nFinds entities in a sphere","param":{"1":"center","2":"radius","3":"filter","radius":"Sphere radius","center":"Center of the sphere","filter":"Optional function to filter results"}}},"doc":[{"summary":"\n \nFind functions \n ","description":"\n \nFind functions \n","comment":["-------------------------------------------------------------------------------","-- Find functions","-------------------------------------------------------------------------------"],"code":[""]},{"comment":["--- Find library. Finds entities in various shapes.","-- @shared"],"functions":{"1":"all","2":"allPlayers","3":"byClass","4":"byModel","5":"inBox","6":"inCone","7":"inSphere","inBox":{"ret":"An array of found entities","comment":["--- Finds entities in a box","-- @param min Bottom corner","-- @param max Top corner","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inBox ( min, max, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( min, SF.Types[ \"Vector\" ] )","\tSF.CheckType( max, SF.Types[ \"Vector\" ] )","","\tlocal min, max = vunwrap( min ), vunwrap( max )","","\treturn convert( ents.FindInBox( min, max ), filter )","end",""],"class":"function","name":"find_library.inBox","summary":"\nFinds entities in a box ","private":false,"library":"find","description":"\nFinds entities in a box","param":{"1":"min","2":"max","3":"filter","max":"Top corner","min":"Bottom corner","filter":"Optional function to filter results"}},"inSphere":{"ret":"An array of found entities","comment":["--- Finds entities in a sphere","-- @param center Center of the sphere","-- @param radius Sphere radius","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inSphere ( center, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( center, SF.Types[ \"Vector\" ] )","\tSF.CheckType( radius, \"number\" )","","\tlocal center = vunwrap( center )","\t","\treturn convert( ents.FindInSphere( center, radius ), filter )","end",""],"class":"function","name":"find_library.inSphere","summary":"\nFinds entities in a sphere ","private":false,"library":"find","description":"\nFinds entities in a sphere","param":{"1":"center","2":"radius","3":"filter","radius":"Sphere radius","center":"Center of the sphere","filter":"Optional function to filter results"}},"byClass":{"ret":"An array of found entities","comment":["--- Finds entities by class name","-- @param class The class name","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byClass(class, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(class,\"string\")","\t\t","\treturn convert(ents.FindByClass(class), filter)","end",""],"class":"function","name":"find_library.byClass","summary":"\nFinds entities by class name ","private":false,"library":"find","description":"\nFinds entities by class name","param":{"1":"class","2":"filter","filter":"Optional function to filter results","class":"The class name"}},"allPlayers":{"ret":"An array of found entities","comment":["--- Finds all players (including bots)","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.allPlayers(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(player.GetAll(), filter)","end",""],"class":"function","name":"find_library.allPlayers","summary":"\nFinds all players (including bots) ","private":false,"library":"find","description":"\nFinds all players (including bots)","param":{"1":"filter","filter":"Optional function to filter results"}},"all":{"ret":"An array of found entities","comment":["--- Finds all entitites","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.all(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(ents.GetAll(), filter)","end"],"class":"function","name":"find_library.all","summary":"\nFinds all entitites ","private":false,"library":"find","description":"\nFinds all entitites","param":{"1":"filter","filter":"Optional function to filter results"}},"byModel":{"ret":"An array of found entities","comment":["--- Finds entities by model","-- @param model The model file","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byModel(model, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(model,\"string\")","\t\t","\treturn convert(ents.FindByModel(model), filter)","end",""],"class":"function","name":"find_library.byModel","summary":"\nFinds entities by model ","private":false,"library":"find","description":"\nFinds entities by model","param":{"1":"model","2":"filter","filter":"Optional function to filter results","model":"The model file"}},"inCone":{"ret":"An array of found entities","comment":["--- Finds entities in a cone","-- @param pos The cone vertex position","-- @param dir The direction to project the cone","-- @param distance The length to project the cone","-- @param radius The angle of the cone","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inCone ( pos, dir, distance, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( dir, SF.Types[ \"Vector\" ] )","\tSF.CheckType( distance, \"number\" )","\tSF.CheckType( radius, \"number\" )","","\tlocal pos, dir = vunwrap( pos ), vunwrap( dir )","\t","\treturn convert( ents.FindInCone( pos, dir, distance, radius ), filter )","end",""],"class":"function","name":"find_library.inCone","summary":"\nFinds entities in a cone ","private":false,"library":"find","description":"\nFinds entities in a cone","param":{"1":"pos","2":"dir","3":"distance","4":"radius","5":"filter","radius":"The angle of the cone","dir":"The direction to project the cone","distance":"The length to project the cone","filter":"Optional function to filter results","pos":"The cone vertex position"}}},"class":"library","summary":"\nFind library.","code":["local find_library, _ = SF.Libraries.Register(\"find\")","","local vunwrap = SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"find\", \"Find\", \"Allows the user to access the find library\" )","end","","local function convert(results, func)","\tif func then SF.CheckType(func,\"function\") end","\tlocal wrap = SF.WrapObject","\t","\tlocal t = {}","\tlocal count = 1","\tfor i=1,#results do","\t\tlocal e = wrap(results[i])","\t\tif not func or func(e) then","\t\t\tt[count] = e","\t\t\tcount = count + 1","\t\tend","\tend","\treturn t","end",""],"fields":[],"name":"find","client":true,"description":"\nFind library. Finds entities in various shapes.","libtbl":"find_library","tables":[],"server":true},{"ret":"An array of found entities","comment":["--- Finds entities in a box","-- @param min Bottom corner","-- @param max Top corner","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inBox ( min, max, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( min, SF.Types[ \"Vector\" ] )","\tSF.CheckType( max, SF.Types[ \"Vector\" ] )","","\tlocal min, max = vunwrap( min ), vunwrap( max )","","\treturn convert( ents.FindInBox( min, max ), filter )","end",""],"class":"function","name":"find_library.inBox","summary":"\nFinds entities in a box ","private":false,"library":"find","description":"\nFinds entities in a box","param":{"1":"min","2":"max","3":"filter","max":"Top corner","min":"Bottom corner","filter":"Optional function to filter results"}},{"ret":"An array of found entities","comment":["--- Finds entities in a sphere","-- @param center Center of the sphere","-- @param radius Sphere radius","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inSphere ( center, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( center, SF.Types[ \"Vector\" ] )","\tSF.CheckType( radius, \"number\" )","","\tlocal center = vunwrap( center )","\t","\treturn convert( ents.FindInSphere( center, radius ), filter )","end",""],"class":"function","name":"find_library.inSphere","summary":"\nFinds entities in a sphere ","private":false,"library":"find","description":"\nFinds entities in a sphere","param":{"1":"center","2":"radius","3":"filter","radius":"Sphere radius","center":"Center of the sphere","filter":"Optional function to filter results"}},{"ret":"An array of found entities","comment":["--- Finds entities in a cone","-- @param pos The cone vertex position","-- @param dir The direction to project the cone","-- @param distance The length to project the cone","-- @param radius The angle of the cone","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.inCone ( pos, dir, distance, radius, filter )","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tSF.CheckType( dir, SF.Types[ \"Vector\" ] )","\tSF.CheckType( distance, \"number\" )","\tSF.CheckType( radius, \"number\" )","","\tlocal pos, dir = vunwrap( pos ), vunwrap( dir )","\t","\treturn convert( ents.FindInCone( pos, dir, distance, radius ), filter )","end",""],"class":"function","name":"find_library.inCone","summary":"\nFinds entities in a cone ","private":false,"library":"find","description":"\nFinds entities in a cone","param":{"1":"pos","2":"dir","3":"distance","4":"radius","5":"filter","radius":"The angle of the cone","dir":"The direction to project the cone","distance":"The length to project the cone","filter":"Optional function to filter results","pos":"The cone vertex position"}},{"ret":"An array of found entities","comment":["--- Finds entities by class name","-- @param class The class name","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byClass(class, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(class,\"string\")","\t\t","\treturn convert(ents.FindByClass(class), filter)","end",""],"class":"function","name":"find_library.byClass","summary":"\nFinds entities by class name ","private":false,"library":"find","description":"\nFinds entities by class name","param":{"1":"class","2":"filter","filter":"Optional function to filter results","class":"The class name"}},{"ret":"An array of found entities","comment":["--- Finds entities by model","-- @param model The model file","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.byModel(model, filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(model,\"string\")","\t\t","\treturn convert(ents.FindByModel(model), filter)","end",""],"class":"function","name":"find_library.byModel","summary":"\nFinds entities by model ","private":false,"library":"find","description":"\nFinds entities by model","param":{"1":"model","2":"filter","filter":"Optional function to filter results","model":"The model file"}},{"ret":"An array of found entities","comment":["--- Finds all players (including bots)","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.allPlayers(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(player.GetAll(), filter)","end",""],"class":"function","name":"find_library.allPlayers","summary":"\nFinds all players (including bots) ","private":false,"library":"find","description":"\nFinds all players (including bots)","param":{"1":"filter","filter":"Optional function to filter results"}},{"ret":"An array of found entities","comment":["--- Finds all entitites","-- @param filter Optional function to filter results","-- @return An array of found entities"],"code":["function find_library.all(filter)","\tif not SF.Permissions.check( SF.instance.player, nil, \"find\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\treturn convert(ents.GetAll(), filter)","end"],"class":"function","name":"find_library.all","summary":"\nFinds all entitites ","private":false,"library":"find","description":"\nFinds all entitites","param":{"1":"filter","filter":"Optional function to filter results"}}],"tables":[],"description":"\n \nFind functions \n","summary":"\n \nFind functions \n "},"libs_sh/angles.lua":{"libraries":[],"type":"file","name":"libs_sh/angles.lua","functions":{"1":"ang_metamethods.__index","2":"ang_metamethods.__newindex","3":"ang_metamethods:__add","4":"ang_metamethods:__eq","5":"ang_metamethods:__mul","6":"ang_metamethods:__sub","7":"ang_metamethods:__tostring","8":"ang_metamethods:__unm","9":"ang_methods:getForward","10":"ang_methods:getRight","11":"ang_methods:getUp","12":"ang_methods:isZero","13":"ang_methods:normalize","14":"ang_methods:rotateAroundAxis","15":"ang_methods:set","16":"ang_methods:setZero","ang_metamethods:__unm":{"ret":"resultant angle.","comment":["--- __unm metamethod -ang.","-- @return resultant angle."],"code":["function ang_metamethods:__unm ()","\treturn SF.WrapObject( unwrap( self ):__unm() )","end",""],"class":"function","name":"ang_metamethods:__unm","private":false,"summary":"\n__unm metamethod -ang.","description":"\n__unm metamethod -ang.","param":[]},"ang_methods:setZero":{"ret":"nil","comment":["--- Sets p,y,r to 0. This is faster than doing it manually.","-- @return nil"],"code":["function ang_methods:setZero ()","\tunwrap( self ):Zero()","end"],"class":"function","name":"ang_methods:setZero","summary":"\nSets p,y,r to 0.","private":false,"classlib":"Angle","description":"\nSets p,y,r to 0. This is faster than doing it manually.","param":[]},"ang_methods:rotateAroundAxis":{"ret":"nil","comment":["--- Rotates the angle around the specified axis by the specified degrees.","-- @param v Axis","-- @param r Number of degrees.","-- @return nil"],"code":["function ang_methods:rotateAroundAxis ( v, r )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tSF.CheckType( r, \"number\" )","\tunwrap( self ):RotateAroundAxis( SF.UnwrapObject( v ), r )","end",""],"class":"function","name":"ang_methods:rotateAroundAxis","summary":"\nRotates the angle around the specified axis by the specified degrees.","private":false,"classlib":"Angle","description":"\nRotates the angle around the specified axis by the specified degrees.","param":{"1":"v","2":"r","r":"Number of degrees.","v":"Axis"}},"ang_methods:getUp":{"ret":"vector normalised.","comment":["--- Return the Up Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods:getUp ()","\treturn SF.WrapObject( unwrap( self ):Up() )","end",""],"class":"function","name":"ang_methods:getUp","summary":"\nReturn the Up Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Up Vector relative to the angle dir.","param":[]},"ang_metamethods:__eq":{"ret":"bool","comment":["--- __eq metamethod ang1 == ang2.","-- @param a Angle to check against.","-- @return bool"],"code":["function ang_metamethods:__eq ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\treturn SF.WrapObject( unwrap( self ):__eq( unwrap( a ) ) )","end",""],"class":"function","name":"ang_metamethods:__eq","private":false,"summary":"\n__eq metamethod ang1 == ang2.","description":"\n__eq metamethod ang1 == ang2.","param":{"1":"a","a":"Angle to check against."}},"ang_metamethods:__add":{"ret":"resultant angle.","comment":["--- __add metamethod ang1 + ang2.","-- @param a Angle to add.","-- @return resultant angle."],"code":["function ang_metamethods:__add ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\treturn SF.WrapObject( unwrap( self ):__add( unwrap( a ) ) )","end",""],"class":"function","name":"ang_metamethods:__add","private":false,"summary":"\n__add metamethod ang1 + ang2.","description":"\n__add metamethod ang1 + ang2.","param":{"1":"a","a":"Angle to add."}},"ang_metamethods.__index":{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function ang_metamethods.__index ( t, k )","\tif type( k ) == \"number\" and k >= 1 and k <= 3 then","\t\t\treturn unwrap( t )[ k ]","\telseif k == \"p\" or k == \"y\" or k == \"r\" then","\t\treturn unwrap( t )[ k ]","\tend","\treturn _p[ k ]","end",""],"private":false,"class":"function","name":"ang_metamethods.__index","param":["t","k"]},"ang_metamethods.__newindex":{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function ang_metamethods.__newindex ( t, k, v )","\tif type( k ) == \"number\" and k >= 1 and k <= 3 then","\t\t\tSF.UnwrapObject( t ).__newindex( SF.UnwrapObject( t ), k, v )","\telseif k == \"p\" or k == \"y\" or k == \"r\" then","\t\tSF.UnwrapObject( t ).__newindex( SF.UnwrapObject( t ), k, v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = ang_metamethods.__index"],"private":false,"class":"function","name":"ang_metamethods.__newindex","param":["t","k","v"]},"ang_methods:set":{"ret":"nil","comment":["--- Copies p,y,r from second angle to the first.","-- @param a Angle to copy from.","-- @return nil"],"code":["function ang_methods:set ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\tunwrap( self ):Set( unwrap( a ) )","end",""],"class":"function","name":"ang_methods:set","summary":"\nCopies p,y,r from second angle to the first.","private":false,"classlib":"Angle","description":"\nCopies p,y,r from second angle to the first.","param":{"1":"a","a":"Angle to copy from."}},"ang_methods:getRight":{"ret":"vector normalised.","comment":["--- Return the Right Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods:getRight ()","\treturn SF.WrapObject( unwrap( self ):Right() )","end",""],"class":"function","name":"ang_methods:getRight","summary":"\nReturn the Right Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Right Vector relative to the angle dir.","param":[]},"ang_methods:normalize":{"ret":"nil","comment":["--- Normalise angles eg (0,181,1) -> (0,-179,1).","-- @return nil"],"code":["function ang_methods:normalize ()","\tunwrap( self ):Normalize()","end",""],"class":"function","name":"ang_methods:normalize","summary":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","private":false,"classlib":"Angle","description":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","param":[]},"ang_metamethods:__sub":{"ret":"resultant angle.","comment":["--- __sub metamethod ang1 - ang2.","-- @param a Angle to subtract.","-- @return resultant angle."],"code":["function ang_metamethods:__sub ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\treturn SF.WrapObject( unwrap( self ):__sub( unwrap( a ) ) )","end","",""],"class":"function","name":"ang_metamethods:__sub","private":false,"summary":"\n__sub metamethod ang1 - ang2.","description":"\n__sub metamethod ang1 - ang2.","param":{"1":"a","a":"Angle to subtract."}},"ang_methods:getForward":{"ret":"vector normalised.","comment":["--- Return the Forward Vector ( direction the angle points ).","-- @return vector normalised."],"code":["function ang_methods:getForward ()","\treturn SF.WrapObject( unwrap( self ):Forward() )","end",""],"class":"function","name":"ang_methods:getForward","summary":"\nReturn the Forward Vector ( direction the angle points ).","private":false,"classlib":"Angle","description":"\nReturn the Forward Vector ( direction the angle points ).","param":[]},"ang_methods:isZero":{"ret":"boolean","comment":["--- Returns if p,y,r are all 0.","-- @return boolean"],"code":["function ang_methods:isZero ()","\treturn unwrap( self ):IsZero()","end",""],"class":"function","name":"ang_methods:isZero","summary":"\nReturns if p,y,r are all 0.","private":false,"classlib":"Angle","description":"\nReturns if p,y,r are all 0.","param":[]},"ang_metamethods:__mul":{"ret":"resultant angle.","comment":["--- __mul metamethod ang1 * ang2.","-- @param a Angle to multiply by.","-- @return resultant angle."],"code":["function ang_metamethods:__mul ( n )","\tSF.CheckType( n, \"number\" )","\treturn SF.WrapObject( unwrap( self ):__mul( n ) )","end",""],"class":"function","name":"ang_metamethods:__mul","private":false,"summary":"\n__mul metamethod ang1 * ang2.","description":"\n__mul metamethod ang1 * ang2.","param":{"1":"n","2":"a","a":"Angle to multiply by."}},"ang_metamethods:__tostring":{"ret":"string representing the angle.","comment":["--- tostring metamethod.","-- @return string representing the angle."],"code":["function ang_metamethods:__tostring ()","\treturn unwrap( self ):__tostring()","end",""],"class":"function","name":"ang_metamethods:__tostring","private":false,"summary":"\ntostring metamethod.","description":"\ntostring metamethod.","param":[]}},"doc":[{"comment":["--- Angle Type","-- @shared"],"code":["local ang_methods, ang_metamethods = SF.Typedef( \"Angle\" )","local wrap, unwrap = SF.CreateWrapper( ang_metamethods, true, false, debug.getregistry().Angle )","","SF.DefaultEnvironment.Angle = function ( ... )","\treturn wrap( Angle( ... ) )","end","","SF.Angles.Wrap = wrap","SF.Angles.Unwrap = unwrap","SF.Angles.Methods = ang_methods","SF.Angles.Metatable = ang_metamethods",""],"typtbl":"ang_methods","summary":"\nAngle Type ","fields":[],"name":"Angle","server":true,"description":"\nAngle Type","client":true,"class":"class","methods":{"1":"getForward","2":"getRight","3":"getUp","4":"isZero","5":"normalize","6":"rotateAroundAxis","7":"set","8":"setZero","getUp":{"ret":"vector normalised.","comment":["--- Return the Up Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods:getUp ()","\treturn SF.WrapObject( unwrap( self ):Up() )","end",""],"class":"function","name":"ang_methods:getUp","summary":"\nReturn the Up Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Up Vector relative to the angle dir.","param":[]},"getRight":{"ret":"vector normalised.","comment":["--- Return the Right Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods:getRight ()","\treturn SF.WrapObject( unwrap( self ):Right() )","end",""],"class":"function","name":"ang_methods:getRight","summary":"\nReturn the Right Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Right Vector relative to the angle dir.","param":[]},"normalize":{"ret":"nil","comment":["--- Normalise angles eg (0,181,1) -> (0,-179,1).","-- @return nil"],"code":["function ang_methods:normalize ()","\tunwrap( self ):Normalize()","end",""],"class":"function","name":"ang_methods:normalize","summary":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","private":false,"classlib":"Angle","description":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","param":[]},"getForward":{"ret":"vector normalised.","comment":["--- Return the Forward Vector ( direction the angle points ).","-- @return vector normalised."],"code":["function ang_methods:getForward ()","\treturn SF.WrapObject( unwrap( self ):Forward() )","end",""],"class":"function","name":"ang_methods:getForward","summary":"\nReturn the Forward Vector ( direction the angle points ).","private":false,"classlib":"Angle","description":"\nReturn the Forward Vector ( direction the angle points ).","param":[]},"isZero":{"ret":"boolean","comment":["--- Returns if p,y,r are all 0.","-- @return boolean"],"code":["function ang_methods:isZero ()","\treturn unwrap( self ):IsZero()","end",""],"class":"function","name":"ang_methods:isZero","summary":"\nReturns if p,y,r are all 0.","private":false,"classlib":"Angle","description":"\nReturns if p,y,r are all 0.","param":[]},"setZero":{"ret":"nil","comment":["--- Sets p,y,r to 0. This is faster than doing it manually.","-- @return nil"],"code":["function ang_methods:setZero ()","\tunwrap( self ):Zero()","end"],"class":"function","name":"ang_methods:setZero","summary":"\nSets p,y,r to 0.","private":false,"classlib":"Angle","description":"\nSets p,y,r to 0. This is faster than doing it manually.","param":[]},"set":{"ret":"nil","comment":["--- Copies p,y,r from second angle to the first.","-- @param a Angle to copy from.","-- @return nil"],"code":["function ang_methods:set ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\tunwrap( self ):Set( unwrap( a ) )","end",""],"class":"function","name":"ang_methods:set","summary":"\nCopies p,y,r from second angle to the first.","private":false,"classlib":"Angle","description":"\nCopies p,y,r from second angle to the first.","param":{"1":"a","a":"Angle to copy from."}},"rotateAroundAxis":{"ret":"nil","comment":["--- Rotates the angle around the specified axis by the specified degrees.","-- @param v Axis","-- @param r Number of degrees.","-- @return nil"],"code":["function ang_methods:rotateAroundAxis ( v, r )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tSF.CheckType( r, \"number\" )","\tunwrap( self ):RotateAroundAxis( SF.UnwrapObject( v ), r )","end",""],"class":"function","name":"ang_methods:rotateAroundAxis","summary":"\nRotates the angle around the specified axis by the specified degrees.","private":false,"classlib":"Angle","description":"\nRotates the angle around the specified axis by the specified degrees.","param":{"1":"v","2":"r","r":"Number of degrees.","v":"Axis"}}}},{"summary":"\n__newindex metamethod ","description":"\n__newindex metamethod","comment":["--- __newindex metamethod"],"code":["function ang_metamethods.__newindex ( t, k, v )","\tif type( k ) == \"number\" and k >= 1 and k <= 3 then","\t\t\tSF.UnwrapObject( t ).__newindex( SF.UnwrapObject( t ), k, v )","\telseif k == \"p\" or k == \"y\" or k == \"r\" then","\t\tSF.UnwrapObject( t ).__newindex( SF.UnwrapObject( t ), k, v )","\telse","\t\trawset( t, k, v )","\tend","end","","local _p = ang_metamethods.__index"],"private":false,"class":"function","name":"ang_metamethods.__newindex","param":["t","k","v"]},{"summary":"\n__index metamethod ","description":"\n__index metamethod","comment":["--- __index metamethod"],"code":["function ang_metamethods.__index ( t, k )","\tif type( k ) == \"number\" and k >= 1 and k <= 3 then","\t\t\treturn unwrap( t )[ k ]","\telseif k == \"p\" or k == \"y\" or k == \"r\" then","\t\treturn unwrap( t )[ k ]","\tend","\treturn _p[ k ]","end",""],"private":false,"class":"function","name":"ang_metamethods.__index","param":["t","k"]},{"ret":"string representing the angle.","comment":["--- tostring metamethod.","-- @return string representing the angle."],"code":["function ang_metamethods:__tostring ()","\treturn unwrap( self ):__tostring()","end",""],"class":"function","name":"ang_metamethods:__tostring","private":false,"summary":"\ntostring metamethod.","description":"\ntostring metamethod.","param":[]},{"ret":"resultant angle.","comment":["--- __mul metamethod ang1 * ang2.","-- @param a Angle to multiply by.","-- @return resultant angle."],"code":["function ang_metamethods:__mul ( n )","\tSF.CheckType( n, \"number\" )","\treturn SF.WrapObject( unwrap( self ):__mul( n ) )","end",""],"class":"function","name":"ang_metamethods:__mul","private":false,"summary":"\n__mul metamethod ang1 * ang2.","description":"\n__mul metamethod ang1 * ang2.","param":{"1":"n","2":"a","a":"Angle to multiply by."}},{"ret":"resultant angle.","comment":["--- __unm metamethod -ang.","-- @return resultant angle."],"code":["function ang_metamethods:__unm ()","\treturn SF.WrapObject( unwrap( self ):__unm() )","end",""],"class":"function","name":"ang_metamethods:__unm","private":false,"summary":"\n__unm metamethod -ang.","description":"\n__unm metamethod -ang.","param":[]},{"ret":"bool","comment":["--- __eq metamethod ang1 == ang2.","-- @param a Angle to check against.","-- @return bool"],"code":["function ang_metamethods:__eq ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\treturn SF.WrapObject( unwrap( self ):__eq( unwrap( a ) ) )","end",""],"class":"function","name":"ang_metamethods:__eq","private":false,"summary":"\n__eq metamethod ang1 == ang2.","description":"\n__eq metamethod ang1 == ang2.","param":{"1":"a","a":"Angle to check against."}},{"ret":"resultant angle.","comment":["--- __add metamethod ang1 + ang2.","-- @param a Angle to add.","-- @return resultant angle."],"code":["function ang_metamethods:__add ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\treturn SF.WrapObject( unwrap( self ):__add( unwrap( a ) ) )","end",""],"class":"function","name":"ang_metamethods:__add","private":false,"summary":"\n__add metamethod ang1 + ang2.","description":"\n__add metamethod ang1 + ang2.","param":{"1":"a","a":"Angle to add."}},{"ret":"resultant angle.","comment":["--- __sub metamethod ang1 - ang2.","-- @param a Angle to subtract.","-- @return resultant angle."],"code":["function ang_metamethods:__sub ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\treturn SF.WrapObject( unwrap( self ):__sub( unwrap( a ) ) )","end","",""],"class":"function","name":"ang_metamethods:__sub","private":false,"summary":"\n__sub metamethod ang1 - ang2.","description":"\n__sub metamethod ang1 - ang2.","param":{"1":"a","a":"Angle to subtract."}},{"ret":"vector normalised.","comment":["--- Return the Forward Vector ( direction the angle points ).","-- @return vector normalised."],"code":["function ang_methods:getForward ()","\treturn SF.WrapObject( unwrap( self ):Forward() )","end",""],"class":"function","name":"ang_methods:getForward","summary":"\nReturn the Forward Vector ( direction the angle points ).","private":false,"classlib":"Angle","description":"\nReturn the Forward Vector ( direction the angle points ).","param":[]},{"ret":"boolean","comment":["--- Returns if p,y,r are all 0.","-- @return boolean"],"code":["function ang_methods:isZero ()","\treturn unwrap( self ):IsZero()","end",""],"class":"function","name":"ang_methods:isZero","summary":"\nReturns if p,y,r are all 0.","private":false,"classlib":"Angle","description":"\nReturns if p,y,r are all 0.","param":[]},{"ret":"nil","comment":["--- Normalise angles eg (0,181,1) -> (0,-179,1).","-- @return nil"],"code":["function ang_methods:normalize ()","\tunwrap( self ):Normalize()","end",""],"class":"function","name":"ang_methods:normalize","summary":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","private":false,"classlib":"Angle","description":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","param":[]},{"ret":"vector normalised.","comment":["--- Return the Right Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods:getRight ()","\treturn SF.WrapObject( unwrap( self ):Right() )","end",""],"class":"function","name":"ang_methods:getRight","summary":"\nReturn the Right Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Right Vector relative to the angle dir.","param":[]},{"ret":"nil","comment":["--- Rotates the angle around the specified axis by the specified degrees.","-- @param v Axis","-- @param r Number of degrees.","-- @return nil"],"code":["function ang_methods:rotateAroundAxis ( v, r )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tSF.CheckType( r, \"number\" )","\tunwrap( self ):RotateAroundAxis( SF.UnwrapObject( v ), r )","end",""],"class":"function","name":"ang_methods:rotateAroundAxis","summary":"\nRotates the angle around the specified axis by the specified degrees.","private":false,"classlib":"Angle","description":"\nRotates the angle around the specified axis by the specified degrees.","param":{"1":"v","2":"r","r":"Number of degrees.","v":"Axis"}},{"ret":"nil","comment":["--- Copies p,y,r from second angle to the first.","-- @param a Angle to copy from.","-- @return nil"],"code":["function ang_methods:set ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\tunwrap( self ):Set( unwrap( a ) )","end",""],"class":"function","name":"ang_methods:set","summary":"\nCopies p,y,r from second angle to the first.","private":false,"classlib":"Angle","description":"\nCopies p,y,r from second angle to the first.","param":{"1":"a","a":"Angle to copy from."}},{"ret":"vector normalised.","comment":["--- Return the Up Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods:getUp ()","\treturn SF.WrapObject( unwrap( self ):Up() )","end",""],"class":"function","name":"ang_methods:getUp","summary":"\nReturn the Up Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Up Vector relative to the angle dir.","param":[]},{"ret":"nil","comment":["--- Sets p,y,r to 0. This is faster than doing it manually.","-- @return nil"],"code":["function ang_methods:setZero ()","\tunwrap( self ):Zero()","end"],"class":"function","name":"ang_methods:setZero","summary":"\nSets p,y,r to 0.","private":false,"classlib":"Angle","description":"\nSets p,y,r to 0. This is faster than doing it manually.","param":[]}],"tables":[],"description":"\nAngle Type","summary":"\nAngle Type "}},"classes":{"1":"Angle","2":"Bass","3":"Color","4":"Entity","5":"Hologram","6":"Player","7":"Quaternion","8":"Sound","9":"VMatrix","10":"Vector","11":"Vehicle","12":"Weapon","13":"Wirelink","Quaternion":{"comment":["--- Quaternion type"],"code":["local quat_methods, quat_metamethods = SF.Typedef(\"Quaternion\")","--[[quat_metamethods = {__index = quat_lib}","quat_lib.__metatable = quat_metamethods","quat_metamethods.__type = \"Quaternion\"","setmetatable(quat_lib, quat_metamethods)]]","","--****************************** Helper functions ******************************--","","local function quicknew(r, i, j, k)","\tlocal new = {r, i, j, k}","\tsetmetatable( new, quat_metamethods )","\treturn new","end","","local function qmul(lhs, rhs)","\tlocal lhs1, lhs2, lhs3, lhs4 = lhs[1], lhs[2], lhs[3], lhs[4]","\tlocal rhs1, rhs2, rhs3, rhs4 = rhs[1], rhs[2], rhs[3], rhs[4]","\treturn quicknew(","\t\tlhs1 * rhs1 - lhs2 * rhs2 - lhs3 * rhs3 - lhs4 * rhs4,","\t\tlhs1 * rhs2 + lhs2 * rhs1 + lhs3 * rhs4 - lhs4 * rhs3,","\t\tlhs1 * rhs3 + lhs3 * rhs1 + lhs4 * rhs2 - lhs2 * rhs4,","\t\tlhs1 * rhs4 + lhs4 * rhs1 + lhs2 * rhs3 - lhs3 * rhs2","\t)","end","","local function qexp(q)","\tlocal m = sqrt(q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","\tlocal u","\tif m ~= 0 then","\t\tu = { q[2]*sin(m)/m, q[3]*sin(m)/m, q[4]*sin(m)/m }","\telse","\t\tu = { 0, 0, 0 }","\tend","\tlocal r = exp(q[1])","\treturn quicknew( r*cos(m), r*u[1], r*u[2], r*u[3] )","end","","local function qlog(q)","\tlocal l = sqrt(q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4])","\tif l == 0 then return { -1e+100, 0, 0, 0 } end","\tlocal u = { q[1]/l, q[2]/l, q[3]/l, q[4]/l }","\tlocal a = acos(u[1])","\tlocal m = sqrt(u[2]*u[2] + u[3]*u[3] + u[4]*u[4])","\tif abs(m) > delta then","\t\treturn quicknew( log(l), a*u[2]/m, a*u[3]/m, a*u[4]/m )","\telse","\t\treturn quicknew( log(l), 0, 0, 0 )  --when m is 0, u[2], u[3] and u[4] are 0 too","\tend","end","","--******************************************************************************--","","local argTypesToQuat = {}"],"typtbl":"quat_methods","fields":[],"name":"Quaternion","summary":"\nQuaternion type ","description":"\nQuaternion type","class":"class","methods":{"1":"conj","2":"forward","3":"i","4":"j","5":"k","6":"r","7":"real","8":"right","9":"up","conj":{"comment":["--- Returns the conj of self"],"code":["function quat_methods:conj()","\treturn quat_lib.conj( self )","end","","function quat_methods:inv()","\treturn quat_lib.inv( self )","end",""],"class":"function","name":"quat_methods:conj","summary":"\nReturns the conj of self ","private":false,"classlib":"Quaternion","description":"\nReturns the conj of self","param":[]},"r":{"comment":["--- Alias for :real() as r is easier"],"code":["function quat_methods:r()","\treturn self:real()","end","",""],"class":"function","name":"quat_methods:r","summary":"\nAlias for :real() as r is easier ","private":false,"classlib":"Quaternion","description":"\nAlias for :real() as r is easier","param":[]},"right":{"comment":["--- Returns vector pointing right for <this>"],"code":["function quat_methods:right()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt4 * this1 - t2 * this3,","\tthis2 * this2 - this1 * this1 + this4 * this4 - this3 * this3,","\t- t2 * this1 - t3 * this4","\t) )","end",""],"class":"function","name":"quat_methods:right","summary":"\nReturns vector pointing right for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing right for <this>","param":[]},"real":{"comment":["--- Returns the real component of the quaternion"],"code":["function quat_methods:real()","\treturn self[1]","end",""],"class":"function","name":"quat_methods:real","summary":"\nReturns the real component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the real component of the quaternion","param":[]},"i":{"comment":["--- Returns the i component of the quaternion"],"code":["function quat_methods:i()","\treturn self[2]","end",""],"class":"function","name":"quat_methods:i","summary":"\nReturns the i component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the i component of the quaternion","param":[]},"k":{"comment":["--- Returns the k component of the quaternion"],"code":["function quat_methods:k()","\treturn self[4]","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:k","summary":"\nReturns the k component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the k component of the quaternion","param":[]},"j":{"comment":["--- Returns the j component of the quaternion"],"code":["function quat_methods:j()","\treturn self[3]","end",""],"class":"function","name":"quat_methods:j","summary":"\nReturns the j component of the quaternion ","private":false,"classlib":"Quaternion","description":"\nReturns the j component of the quaternion","param":[]},"forward":{"comment":["--- Returns vector pointing forward for <this>"],"code":["function quat_methods:forward()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tthis1 * this1 + this2 * this2 - this3 * this3 - this4 * this4,","\tt3 * this2 + t4 * this1,","\tt4 * this2 - t3 * this1","\t) )","end",""],"class":"function","name":"quat_methods:forward","summary":"\nReturns vector pointing forward for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing forward for <this>","param":[]},"up":{"comment":["--- Returns vector pointing up for <this>"],"code":["function quat_methods:up()","\tlocal this1, this2, this3, this4 = self[1], self[2], self[3], self[4]","\tlocal t2, t3, t4 = this2 * 2, this3 * 2, this4 * 2","","\treturn vwrap( Vector(","\tt3 * this1 + t2 * this4,","\tt3 * this4 - t2 * this1,","\tthis1 * this1 - this2 * this2 - this3 * this3 + this4 * this4","\t) )","end","","--[[****************************************************************************]]",""],"class":"function","name":"quat_methods:up","summary":"\nReturns vector pointing up for <this> ","private":false,"classlib":"Quaternion","description":"\nReturns vector pointing up for <this>","param":[]}}},"Hologram":{"comment":["--- Hologram type"],"code":["local hologram_methods, hologram_metamethods = SF.Typedef(\"Hologram\", SF.Entities.Metatable)","","local vunwrap = SF.UnwrapObject","","SF.Holograms = {}","SF.Holograms.defaultquota = CreateConVar( \"sf_holograms_defaultquota\", \"7200\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of holograms allowed to spawn via Starfall scripts across all instances\" )","","SF.Holograms.personalquota = CreateConVar( \"sf_holograms_personalquota\", \"300\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The number of holograms allowed to spawn via Starfall scripts for a single instance\" )","","SF.Holograms.burstmax = CreateConVar( \"sf_holograms_burstmax\", \"10\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","    \"The number of holograms allowed to spawn in a short interval of time via Starfall scripts for a single instance ( burst )\" )","\t","SF.Holograms.burstrate = CreateConVar( \"sf_holograms_burstrate\", \"4\", {FCVAR_ARCHIVE,FCVAR_REPLICATED},","\t\"The rate at which the burst regenerates per second.\" )","","SF.Holograms.Methods = hologram_methods","SF.Holograms.Metatable = hologram_metamethods","","local dsetmeta = debug.setmetatable","local old_ent_wrap = SF.Entities.Wrap","function SF.Entities.Wrap(obj)","\tlocal w = old_ent_wrap(obj)","\tif IsValid(obj) and obj:IsValid() and obj:GetClass() == \"starfall_hologram\" then","\t\tdsetmeta(w, hologram_metamethods)","\tend","\treturn w","end","","local insts = {}","local plyCount = setmetatable({}, {__mode=\"k\"})","","SF.Libraries.AddHook(\"initialize\",function(inst)","\tinst.data.holograms = {","\t\tholos = {},","\t\tburst = SF.Holograms.burstmax:GetInt() or 10","\t}","","\tinsts[inst] = true","\tplyCount[inst.player] = plyCount[inst.player] or 0","end)","","SF.Libraries.AddHook(\"deinitialize\", function(inst)","\tlocal holos = inst.data.holograms.holos","\tlocal holo = next(holos)","\twhile holo do","\t\tlocal holoent = SF.Entities.Unwrap(holo)","\t\tif IsValid(holoent) then","\t\t\tholoent:Remove()","\t\tend","\t\tholos[holo] = nil","\t\tholo = next(holos)","\tend","\tinsts[inst]= nil","end)","","local function hologramOnDestroy(holoent, holodata, ply)","\tplyCount[ply] = plyCount[ply] - 1","\tif not holodata.holos then return end","\tlocal holo = SF.Entities.Wrap(holoent)","\tif holodata.holos[holo] then","\t\tholodata.holos[holo] = nil\t\t","\tend","end","","-- ------------------------------------------------------------------------- --",""],"typtbl":"hologram_methods","fields":[],"name":"Hologram","summary":"\nHologram type ","description":"\nHologram type","class":"class","methods":{"1":"getAnimationLength","2":"getAnimationNumber","3":"getFlexes","4":"getPose","5":"remove","6":"setAng","7":"setAngVel","8":"setAnimation","9":"setClip","10":"setFlexScale","11":"setFlexWeight","12":"setModel","13":"setParent","14":"setPos","15":"setPose","16":"setScale","17":"setVel","18":"suppressEngineLighting","getAnimationNumber":{"ret":"Animation index","comment":["--- Convert animation name into animation number","-- @server","-- @param animation Name of the animation","-- @return Animation index"],"code":["function hologram_methods:getAnimationNumber( animation )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return 0 end","\t","\treturn Holo:LookupSequence(animation) or 0","end",""],"class":"function","summary":"\nConvert animation name into animation number ","name":"hologram_methods:getAnimationNumber","classlib":"Hologram","private":false,"server":true,"description":"\nConvert animation name into animation number","param":{"1":"animation","animation":"Name of the animation"}},"setFlexWeight":{"comment":["--- Sets the weight (value) of a flex."],"code":["function hologram_methods:setFlexWeight(flexid, weight)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(flexid, \"number\")","\tSF.CheckType(weight, \"number\")","\tflexid = math.floor(flexid)","\tif flexid < 0 or flexid >= holoent:GetFlexNum() then","\t\tSF.throw( \"Invalid flex: \"..flexid, 2 )","\tend","\tlocal holoent = SF.Entities.Unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexWeight(self, weight)","\tend","end",""],"class":"function","name":"hologram_methods:setFlexWeight","summary":"\nSets the weight (value) of a flex.","private":false,"classlib":"Hologram","description":"\nSets the weight (value) of a flex.","param":["flexid","weight"]},"setAnimation":{"comment":["--- Animates a hologram","-- @server","-- @class function","-- @param animation number or string name","-- @param frame The starting frame number","-- @param rate Frame speed. (1 is normal)"],"code":["function hologram_methods:setAnimation(animation, frame, rate)","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","","\tif type(animation)==\"string\" then","\t\tanimation = Holo:LookupSequence(animation)","\tend","\t","\tframe = frame or 0","\trate = rate or 1","\t","\tif not Holo.Animated then","\t\t-- This must be run once on entities that will be animated","\t\tHolo.Animated = true","\t\tHolo.AutomaticFrameAdvance = true","\t\t","\t\tlocal OldThink = Holo.Think","\t\tfunction Holo:Think()","\t\t\tOldThink(self)","\t\t\tself:NextThink( CurTime() )","\t\t\treturn true","\t\tend","\tend","\tHolo:ResetSequence(animation)","\tHolo:SetCycle(frame)","\tHolo:SetPlaybackRate(rate)","end",""],"class":"function","classForced":true,"summary":"\nAnimates a hologram ","name":"hologram_methods:setAnimation","classlib":"Hologram","private":false,"server":true,"description":"\nAnimates a hologram","param":{"1":"animation","2":"frame","3":"rate","frame":"The starting frame number","rate":"Frame speed. (1 is normal)","animation":"number or string name"}},"remove":{"comment":["--- Deletes the hologram","-- @server"],"code":["function hologram_methods:remove()","    SF.CheckType(self, hologram_metamethods)","    local holoent = SF.Entities.Unwrap(self)","    if IsValid(holoent) then","        holoent:Remove()","    end","end",""],"class":"function","summary":"\nDeletes the hologram ","name":"hologram_methods:remove","classlib":"Hologram","private":false,"server":true,"description":"\nDeletes the hologram","param":[]},"setAng":{"comment":["--- Sets the hologram angle","-- @param ang New angles"],"code":["function hologram_methods:setAng ( ang )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetAngles( SF.Angles.Unwrap( ang ) ) end","end",""],"class":"function","name":"hologram_methods:setAng","summary":"\nSets the hologram angle ","private":false,"classlib":"Hologram","description":"\nSets the hologram angle","param":{"1":"ang","ang":"New angles"}},"setVel":{"comment":["--- Sets the hologram linear velocity","-- @param vel New velocity"],"code":["function hologram_methods:setVel ( vel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","\tlocal vel = vunwrap( vel )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetLocalVelocity( vel ) end","end",""],"class":"function","name":"hologram_methods:setVel","summary":"\nSets the hologram linear velocity ","private":false,"classlib":"Hologram","description":"\nSets the hologram linear velocity","param":{"1":"vel","vel":"New velocity"}},"setClip":{"comment":["--- Updates a clip plane"],"code":["function hologram_methods:setClip ( index, enabled, origin, normal, islocal )","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(index, \"number\")","\tSF.CheckType(enabled, \"boolean\")","\tSF.CheckType(origin, SF.Types[ \"Vector\" ] )","\tSF.CheckType(normal, SF.Types[ \"Vector\" ] )","\tSF.CheckType(islocal, \"boolean\")","","\tlocal origin, normal = vunwrap( origin ), vunwrap( normal )","","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then","\t\tholo:UpdateClip( index, enabled, origin, normal, islocal )","\tend","end",""],"class":"function","name":"hologram_methods:setClip","summary":"\nUpdates a clip plane ","private":false,"classlib":"Hologram","description":"\nUpdates a clip plane","param":["index","enabled","origin","normal","islocal"]},"setScale":{"comment":["--- Sets the hologram scale","-- @param scale New scale"],"code":["function hologram_methods:setScale ( scale )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( scale, SF.Types[ \"Vector\" ] )","\tlocal scale = vunwrap( scale )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then","\t\tholo:SetScale( scale )","\tend","end",""],"class":"function","name":"hologram_methods:setScale","summary":"\nSets the hologram scale ","private":false,"classlib":"Hologram","description":"\nSets the hologram scale","param":{"1":"scale","scale":"New scale"}},"getFlexes":{"comment":["--- Returns a table of flexname -> flexid pairs for use in flex functions.","-- These IDs become invalid when the hologram's model changes."],"code":["function hologram_methods:getFlexes()","\tSF.CheckType(self, hologram_metamethods)","\tlocal holoent = SF.Entities.Unwrap(self)","\tlocal flexes = {}","\tfor i=0,holoent:GetFlexNum()-1 do","\t\tflexes[holoent:GetFlexName(i)] = i","\tend","\treturn flexes","end",""],"class":"function","name":"hologram_methods:getFlexes","summary":"\nReturns a table of flexname -> flexid pairs for use in flex functions.","private":false,"classlib":"Hologram","description":"\nReturns a table of flexname -> flexid pairs for use in flex functions. \nThese IDs become invalid when the hologram's model changes.","param":[]},"getAnimationLength":{"ret":"Length of current animation in seconds","comment":["--- Get the length of the current animation","-- @server","-- @class function","-- @return Length of current animation in seconds"],"code":["function hologram_methods:getAnimationLength( )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return -1 end","\t","\treturn Holo:SequenceDuration()","end",""],"class":"function","classForced":true,"summary":"\nGet the length of the current animation ","name":"hologram_methods:getAnimationLength","classlib":"Hologram","private":false,"server":true,"description":"\nGet the length of the current animation","param":[]},"setAngVel":{"comment":["--- Sets the hologram's angular velocity.","-- @param angvel *Vector* angular velocity."],"code":["function hologram_methods:setAngVel ( angvel )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( angvel, SF.Types[ \"Angle\" ] )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetLocalAngularVelocity( SF.Angles.Unwrap( angvel ) ) end","end",""],"class":"function","name":"hologram_methods:setAngVel","summary":"\nSets the hologram's angular velocity.","private":false,"classlib":"Hologram","description":"\nSets the hologram's angular velocity.","param":{"1":"angvel","angvel":"*Vector* angular velocity."}},"setParent":{"comment":["--- Parents this hologram to the specified hologram"],"code":["function hologram_methods:setParent(parent, attachment)","\tSF.CheckType(self, hologram_metamethods)","\tlocal child = SF.Entities.Unwrap(self)","\tif not child then return end","\t","\tif parent then","\t\tSF.CheckType(parent, SF.Entities.Metatable)","\t\tlocal parent = SF.Entities.Unwrap(parent)","\t\tif not parent then return end","\t\t","\t\t-- Prevent cyclic parenting ( = crashes )","\t\tlocal checkparent = parent","\t\trepeat","\t\t\tif checkparent == child then return end","\t\t\tcheckparent = checkparent:GetParent()","\t\tuntil not IsValid(checkparent)","\t\t","\t\tchild:SetParent(parent)","\t\t","\t\tif attachment then","\t\t\tSF.CheckType(attachment, \"string\")","\t\t\tchild:Fire(\"SetParentAttachmentMaintainOffset\", attachment, 0.01)","\t\tend","\telse","\t\tchild:SetParent(nil)","\tend","end",""],"class":"function","name":"hologram_methods:setParent","summary":"\nParents this hologram to the specified hologram ","private":false,"classlib":"Hologram","description":"\nParents this hologram to the specified hologram","param":["parent","attachment"]},"getPose":{"ret":"Value of the pose parameter","comment":["--- Get the pose value of an animation","-- @server","-- @class function","-- @param pose Pose parameter name","-- @return Value of the pose parameter"],"code":["function hologram_methods:getPose( pose )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\treturn Holo:GetPoseParameter( pose )","end","",""],"class":"function","classForced":true,"summary":"\nGet the pose value of an animation ","name":"hologram_methods:getPose","classlib":"Hologram","private":false,"server":true,"description":"\nGet the pose value of an animation","param":{"1":"pose","pose":"Pose parameter name"}},"setPose":{"comment":["--- Set the pose value of an animation. Turret/Head angles for example.","-- @server","-- @class function","-- @param pose Name of the pose parameter","-- @param value Value to set it to."],"code":["function hologram_methods:setPose( pose, value )","\tlocal Holo = SF.Entities.Unwrap( self )","\tif not IsValid( Holo ) then return end","\t","\tHolo:SetPoseParameter( pose, value )","end",""],"class":"function","classForced":true,"summary":"\nSet the pose value of an animation.","name":"hologram_methods:setPose","classlib":"Hologram","private":false,"server":true,"description":"\nSet the pose value of an animation. Turret/Head angles for example.","param":{"1":"pose","2":"value","pose":"Name of the pose parameter","value":"Value to set it to."}},"setModel":{"comment":["--- Sets the model of a hologram","-- @server","-- @class function","-- @param model string model path"],"code":["function hologram_methods:setModel ( model )","    SF.CheckType( model, \"string\" )","","    local this = SF.Entities.Unwrap( self )","    if IsValid( this ) then","        this:SetModel( model )","    end","end",""],"class":"function","classForced":true,"summary":"\nSets the model of a hologram ","name":"hologram_methods:setModel","classlib":"Hologram","private":false,"server":true,"description":"\nSets the model of a hologram","param":{"1":"model","model":"string model path"}},"suppressEngineLighting":{"comment":["--- Suppress Engine Lighting of a hologram. Disabled by default.","-- @server","-- @class function","-- @param suppress Boolean to represent if shading should be set or not."],"code":["function hologram_methods:suppressEngineLighting ( suppress )","    SF.CheckType( suppress, \"boolean\" )","","    local this = SF.Entities.Unwrap( self )","    if IsValid( this ) then","        this:SetNetworkedBool( \"suppressEngineLighting\", suppress )","    end","end",""],"class":"function","classForced":true,"summary":"\nSuppress Engine Lighting of a hologram.","name":"hologram_methods:suppressEngineLighting","classlib":"Hologram","private":false,"server":true,"description":"\nSuppress Engine Lighting of a hologram. Disabled by default.","param":{"1":"suppress","suppress":"Boolean to represent if shading should be set or not."}},"setFlexScale":{"comment":["--- Sets the scale of all flexes of a hologram"],"code":["function hologram_methods:setFlexScale(scale)","\tSF.CheckType(self, hologram_metamethods)","\tSF.CheckType(scale, \"number\")","\tlocal holoent = SF.Entities.Unwrap(self)","\tif IsValid(holoent) then","\t\tholoent:SetFlexScale(scale)","\tend","end","",""],"class":"function","name":"hologram_methods:setFlexScale","summary":"\nSets the scale of all flexes of a hologram ","private":false,"classlib":"Hologram","description":"\nSets the scale of all flexes of a hologram","param":["scale"]},"setPos":{"comment":["--- Sets the hologram position.","-- @param pos New position"],"code":["function hologram_methods:setPos ( pos )","\tSF.CheckType( self, hologram_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\tlocal pos = vunwrap( pos )","\tlocal holo = SF.Entities.Unwrap( self )","\tif holo then holo:SetPos( pos ) end","end",""],"class":"function","name":"hologram_methods:setPos","summary":"\nSets the hologram position.","private":false,"classlib":"Hologram","description":"\nSets the hologram position.","param":{"1":"pos","pos":"New position"}}}},"Bass":{"comment":["--- Bass type","-- @client"],"code":["local bass_methods, bass_metamethods = SF.Typedef( \"Bass\" )","local wrap, unwrap = SF.CreateWrapper( bass_metamethods, true, false, debug.getregistry().IGModAudioChannel )",""],"typtbl":"bass_methods","fields":[],"name":"Bass","summary":"\nBass type ","description":"\nBass type","client":true,"class":"class","methods":{"1":"getLength","2":"play","3":"setFade","4":"setLooping","5":"setPitch","6":"setPos","7":"setVolume","8":"stop","getLength":{"ret":"Length in seconds of the sound","comment":["--- Gets the length of a sound","-- @return Length in seconds of the sound"],"code":["function bass_methods:getLength ()","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\treturn uw:GetLength()","\tend","end","",""],"class":"function","name":"bass_methods:getLength","summary":"\nGets the length of a sound ","private":false,"classlib":"Bass","description":"\nGets the length of a sound","param":[]},"setPos":{"comment":["--- Sets the position of the sound","-- @param pos Where to position the sound"],"code":["function bass_methods:setPos ( pos )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pos, SF.Types[ \"Vector\" ] )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPos( SF.UnwrapObject( pos ) )","\tend","end",""],"class":"function","name":"bass_methods:setPos","summary":"\nSets the position of the sound ","private":false,"classlib":"Bass","description":"\nSets the position of the sound","param":{"1":"pos","pos":"Where to position the sound"}},"stop":{"comment":["--- Stops playing the sound."],"code":["function bass_methods:stop ( )","\tlocal uw =  unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Stop()","\tend","end",""],"class":"function","name":"bass_methods:stop","summary":"\nStops playing the sound.","private":false,"classlib":"Bass","description":"\nStops playing the sound.","param":[]},"setLooping":{"comment":["--- Sets if the sound should loop or not.","-- @param loop Boolean if the sound should loop or not."],"code":["function bass_methods:setLooping ( loop )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:EnableLooping( loop )","\tend","end",""],"class":"function","name":"bass_methods:setLooping","summary":"\nSets if the sound should loop or not.","private":false,"classlib":"Bass","description":"\nSets if the sound should loop or not.","param":{"1":"loop","loop":"Boolean if the sound should loop or not."}},"setFade":{"comment":["--- Sets the fade distance of the sound","-- @param min The channel's volume is at maximum when the listener is within this distance","-- @param max The channel's volume stops decreasing when the listener is beyond this distance."],"code":["function bass_methods:setFade ( min, max )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:Set3DFadeDistance( math.Clamp(min,50,1000), math.Clamp(max,10000,200000) )","\tend","end",""],"class":"function","name":"bass_methods:setFade","summary":"\nSets the fade distance of the sound ","private":false,"classlib":"Bass","description":"\nSets the fade distance of the sound","param":{"1":"min","2":"max","min":"The channel's volume is at maximum when the listener is within this distance","max":"The channel's volume stops decreasing when the listener is beyond this distance."}},"setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1."],"code":["function bass_methods:setVolume ( vol )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( vol, \"number\" )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetVolume( math.Clamp( vol, 0, 1 ) )","\tend","end",""],"class":"function","name":"bass_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Bass","description":"\nSets the volume of the sound.","param":{"1":"vol","vol":"Volume to set to, between 0 and 1."}},"play":{"comment":["--- Starts to play the sound."],"code":["function bass_methods:play ()","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\t","\tif IsValid(uw) then","\t\tuw:Play()","\tend","end",""],"class":"function","name":"bass_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Bass","description":"\nStarts to play the sound.","param":[]},"setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 3."],"code":["function bass_methods:setPitch ( pitch )","\tlocal uw = unwrap( self )","\tSF.CheckType( self, bass_metamethods )","\tSF.CheckType( pitch, \"number\" )","\t\t","\tif not SF.Permissions.check( SF.instance.player, uw, \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif IsValid(uw) then","\t\tuw:SetPlaybackRate( math.Clamp( pitch, 0, 3 ) )","\tend","end",""],"class":"function","name":"bass_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Bass","description":"\nSets the pitch of the sound.","param":{"1":"pitch","pitch":"Pitch to set to, between 0 and 3."}}}},"Color":{"comment":["--- Color type","--@shared"],"code":["local color_methods, color_metatable = SF.Typedef( \"Color\" )","","local wrap, unwrap = SF.CreateWrapper( color_metatable, true, false, debug.getregistry().Color )","","SF.Color.Methods = color_methods","SF.Color.Metatable = color_metatable","SF.Color.Wrap = wrap","SF.Color.Unwrap = unwrap",""],"typtbl":"color_methods","summary":"\nColor type ","fields":[],"name":"Color","server":true,"description":"\nColor type","client":true,"class":"class","methods":{"1":"hsvToRGB","2":"rgbToHSV","rgbToHSV":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from RGB to HSV.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:rgbToHSV ()","\treturn ColorToHSV( unwrap( self ) )","end",""],"class":"function","summary":"\nConverts the color from RGB to HSV.","classlib":"Color","name":"color_methods:rgbToHSV","server":true,"private":false,"client":true,"description":"\nConverts the color from RGB to HSV.","param":[]},"hsvToRGB":{"ret":"A triplet of numbers representing HSV.","comment":["--- Converts the color from HSV to RGB.","--@shared","--@return A triplet of numbers representing HSV."],"code":["function color_methods:hsvToRGB ()","\treturn HSVToColor( self.r, self.g, self.b )","end"],"class":"function","summary":"\nConverts the color from HSV to RGB.","classlib":"Color","name":"color_methods:hsvToRGB","server":true,"private":false,"client":true,"description":"\nConverts the color from HSV to RGB.","param":[]}}},"Wirelink":{"comment":["--- Wirelink type","-- @server"],"code":["local wirelink_methods, wirelink_metatable = SF.Typedef(\"Wirelink\")","local wlwrap, wlunwrap = SF.CreateWrapper(wirelink_metatable,true,true)","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","-- Register privileges","do","\tlocal P = SF.Permissions","\tP.registerPrivilege( \"wire.setOutputs\", \"Set outputs\", \"Allows the user to specify the set of outputs\" )","\tP.registerPrivilege( \"wire.setInputs\", \"Set inputs\", \"Allows the user to specify the set of inputs\" )","\tP.registerPrivilege( \"wire.output\", \"Output\", \"Allows the user to set the value of an output\" )","\tP.registerPrivilege( \"wire.input\", \"Input\", \"Allows the user to read the value of an input\" )","\tP.registerPrivilege( \"wire.wirelink.read\", \"Wirelink Read\", \"Allows the user to read from wirelink\" )","\tP.registerPrivilege( \"wire.wirelink.write\", \"Wirelink Write\", \"Allows the user to write to wirelink\" )","\tP.registerPrivilege( \"wire.createWire\", \"Create Wire\", \"Allows the user to create a wire between two entities\" )","\tP.registerPrivilege( \"wire.deleteWire\", \"Delete Wire\", \"Allows the user to delete a wire between two entities\" )","\tP.registerPrivilege( \"wire.getInputs\", \"Get Inputs\", \"Allows the user to get Inputs of an entity\" )","\tP.registerPrivilege( \"wire.getOutputs\", \"Get Outputs\", \"Allows the user to get Outputs of an entity\" )","end",""],"typtbl":"wirelink_methods","fields":[],"name":"Wirelink","summary":"\nWirelink type ","server":true,"description":"\nWirelink type","class":"class","methods":{"1":"entity","2":"inputType","3":"inputs","4":"isValid","5":"isWired","6":"outputType","7":"outputs","isValid":{"comment":["--- Checks if a wirelink is valid. (ie. doesn't point to an invalid entity)"],"code":["function wirelink_methods:isValid()","\tSF.CheckType(self,wirelink_metatable)","\treturn wlunwrap(self) and true or false","end",""],"class":"function","name":"wirelink_methods:isValid","summary":"\nChecks if a wirelink is valid.","private":false,"classlib":"Wirelink","description":"\nChecks if a wirelink is valid. (ie. doesn't point to an invalid entity)","param":[]},"inputType":{"comment":["--- Returns the type of input name, or nil if it doesn't exist"],"code":["function wirelink_methods:inputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal input = wl.Inputs[name]","\treturn input and input.Type","end",""],"class":"function","name":"wirelink_methods:inputType","summary":"\nReturns the type of input name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of input name, or nil if it doesn't exist","param":["name"]},"outputType":{"comment":["--- Returns the type of output name, or nil if it doesn't exist"],"code":["function wirelink_methods:outputType(name)","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return end","\tlocal output = wl.Outputs[name]","\treturn output and output.Type","end",""],"class":"function","name":"wirelink_methods:outputType","summary":"\nReturns the type of output name, or nil if it doesn't exist ","private":false,"classlib":"Wirelink","description":"\nReturns the type of output name, or nil if it doesn't exist","param":["name"]},"entity":{"comment":["--- Returns the entity that the wirelink represents"],"code":["function wirelink_methods:entity()","\tSF.CheckType(self,wirelink_metatable)","\treturn SF.Entities.Wrap(wlunwrap(self))","end",""],"class":"function","name":"wirelink_methods:entity","summary":"\nReturns the entity that the wirelink represents ","private":false,"classlib":"Wirelink","description":"\nReturns the entity that the wirelink represents","param":[]},"isWired":{"comment":["--- Checks if an input is wired."],"code":["function wirelink_methods:isWired(name)","\tSF.CheckType(self,wirelink_metatable)","\tSF.CheckType(name,\"string\")","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal input = wl.Inputs[name]","\tif input and input.Src and input.Src:IsValid() then return true","\telse return false end","end","","-- ------------------------- Ports Metatable ------------------------- --","local wire_ports_methods, wire_ports_metamethods = SF.Typedef(\"Ports\")","","function wire_ports_metamethods:__index ( name )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.input\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal input = ent.Inputs[name]","\tif not (input and input.Src and input.Src:IsValid()) then","\t\treturn nil","\tend","\treturn inputConverters[ent.Inputs[name].Type](ent.Inputs[name].Value)","end","","function wire_ports_metamethods:__newindex ( name, value )","\tif not SF.Permissions.check( SF.instance.player, nil, \"wire.output\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType(name,\"string\")","\tlocal instance = SF.instance","\tlocal ent = instance.data.entity","\tif not ent then SF.throw( \"No entity\", 2 ) end","","\tlocal output = ent.Outputs[name]","\tif not output then return end","\t","\tWire_TriggerOutput(ent, name, outputConverters[output.Type](value))","end",""],"class":"function","name":"wirelink_methods:isWired","summary":"\nChecks if an input is wired.","private":false,"classlib":"Wirelink","description":"\nChecks if an input is wired.","param":["name"]},"inputs":{"comment":["--- Returns a table of all of the wirelink's inputs"],"code":["function wirelink_methods:inputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Inputs = wl.Inputs","\tif not Inputs then return {} end","\t","\tlocal inputNames = {}","\tfor _,port in pairs(Inputs) do","\t\tinputNames[#inputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Inputs[a].Num < Inputs[b].Num","\tend","\ttable.sort(inputNames, portsSorter)","\t","\treturn inputNames","end",""],"class":"function","name":"wirelink_methods:inputs","summary":"\nReturns a table of all of the wirelink's inputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's inputs","param":[]},"outputs":{"comment":["--- Returns a table of all of the wirelink's outputs"],"code":["function wirelink_methods:outputs()","\tSF.CheckType(self,wirelink_metatable)","\tlocal wl = wlunwrap(self)","\tif not wl then return nil end","\tlocal Outputs = wl.Outputs","\tif not Outputs then return {} end","\t","\tlocal outputNames = {}","\tfor _,port in pairs(Outputs) do","\t\toutputNames[#outputNames+1] = port.Name","\tend","\t","\tlocal function portsSorter(a,b)","\t\treturn Outputs[a].Num < Outputs[b].Num","\tend","\ttable.sort(outputNames, portsSorter)","\t","\treturn outputNames","end",""],"class":"function","name":"wirelink_methods:outputs","summary":"\nReturns a table of all of the wirelink's outputs ","private":false,"classlib":"Wirelink","description":"\nReturns a table of all of the wirelink's outputs","param":[]}}},"VMatrix":{"comment":["--- VMatrix type"],"code":["local vmatrix_methods, vmatrix_metamethods = SF.Typedef( \"VMatrix\" )","local wrap, unwrap = SF.CreateWrapper( vmatrix_metamethods, true, false, debug.getregistry().VMatrix )","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject","","SF.VMatrix.Methods = vmatrix_methods","SF.VMatrix.Metatable = vmatrix_metamethods","SF.VMatrix.Wrap = wrap","SF.VMatrix.Unwrap = unwrap",""],"typtbl":"vmatrix_methods","fields":[],"name":"VMatrix","summary":"\nVMatrix type ","description":"\nVMatrix type","class":"class","methods":{"1":"getAngles","2":"getInverse","3":"getInverseTR","4":"getScale","5":"getTranslation","6":"rotate","7":"scale","8":"scaleTranslation","9":"setAngles","10":"setTranslation","11":"translate","scale":{"comment":["--- Scale the matrix","-- @param vec Vector to scale by"],"code":["function vmatrix_methods:scale ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Scale( vec )","end",""],"class":"function","name":"vmatrix_methods:scale","summary":"\nScale the matrix ","private":false,"classlib":"VMatrix","description":"\nScale the matrix","param":{"1":"vec","vec":"Vector to scale by"}},"getScale":{"ret":"Scale","comment":["--- Returns scale","-- @return Scale"],"code":["function vmatrix_methods:getScale ()","\treturn SF.WrapObject( unwrap( self ):GetScale() )","end",""],"class":"function","name":"vmatrix_methods:getScale","summary":"\nReturns scale ","private":false,"classlib":"VMatrix","description":"\nReturns scale","param":[]},"getAngles":{"ret":"Angles","comment":["--- Returns angles","-- @return Angles"],"code":["function vmatrix_methods:getAngles ()","\treturn SF.WrapObject( unwrap( self ):GetAngles() )","end",""],"class":"function","name":"vmatrix_methods:getAngles","summary":"\nReturns angles ","private":false,"classlib":"VMatrix","description":"\nReturns angles","param":[]},"translate":{"comment":["--- Translate the matrix","-- @param vec Vector to translate by"],"code":["function vmatrix_methods:translate ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:Translate( vec )","end","","function vmatrix_metamethods.__mul ( lhs, rhs )","\treturn vwrap( vunwrap( lhs ) * vunwrap( rhs ) )","end"],"class":"function","name":"vmatrix_methods:translate","summary":"\nTranslate the matrix ","private":false,"classlib":"VMatrix","description":"\nTranslate the matrix","param":{"1":"vec","vec":"Vector to translate by"}},"getTranslation":{"ret":"Translation","comment":["--- Returns translation","-- @return Translation"],"code":["function vmatrix_methods:getTranslation ()","\treturn SF.WrapObject( unwrap( self ):GetTranslation() )","end",""],"class":"function","name":"vmatrix_methods:getTranslation","summary":"\nReturns translation ","private":false,"classlib":"VMatrix","description":"\nReturns translation","param":[]},"setTranslation":{"comment":["--- Sets the translation","-- @param vec New translation"],"code":["function vmatrix_methods:setTranslation ( vec )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","","\tlocal v = unwrap( self )","\tv:SetTranslation( vec )","end",""],"class":"function","name":"vmatrix_methods:setTranslation","summary":"\nSets the translation ","private":false,"classlib":"VMatrix","description":"\nSets the translation","param":{"1":"vec","vec":"New translation"}},"getInverse":{"ret":"inverted matrix","comment":["--- Inverts the matrix","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverse ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverse() )","","end",""],"class":"function","name":"vmatrix_methods:getInverse","summary":"\nInverts the matrix ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix","param":[]},"setAngles":{"comment":["--- Sets the angles","-- @param ang New angles"],"code":["function vmatrix_methods:setAngles ( ang )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","","\tlocal v = unwrap( self )","\tv:SetAngles( SF.UnwrapObject( ang ) )","end",""],"class":"function","name":"vmatrix_methods:setAngles","summary":"\nSets the angles ","private":false,"classlib":"VMatrix","description":"\nSets the angles","param":{"1":"ang","ang":"New angles"}},"rotate":{"comment":["--- Rotate the matrix","-- @param ang Angle to rotate by"],"code":["function vmatrix_methods:rotate ( ang )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","","\tlocal v = unwrap( self )","\tv:Rotate( SF.UnwrapObject( ang ) )","","end",""],"class":"function","name":"vmatrix_methods:rotate","summary":"\nRotate the matrix ","private":false,"classlib":"VMatrix","description":"\nRotate the matrix","param":{"1":"ang","ang":"Angle to rotate by"}},"getInverseTR":{"ret":"inverted matrix","comment":["--- Inverts the matrix efficiently for translations and rotations","-- @return inverted matrix"],"code":["function vmatrix_methods:getInverseTR ( )","","\tlocal v = unwrap( self )","\treturn wrap( v:GetInverseTR() )","","end",""],"class":"function","name":"vmatrix_methods:getInverseTR","summary":"\nInverts the matrix efficiently for translations and rotations ","private":false,"classlib":"VMatrix","description":"\nInverts the matrix efficiently for translations and rotations","param":[]},"scaleTranslation":{"comment":["--- Scales the absolute translation","-- @param num Amount to scale by"],"code":["function vmatrix_methods:scaleTranslation ( num )","\tSF.CheckType( num, \"number\" )","","\tlocal v = unwrap( self )","\tv:ScaleTranslation( num )","end",""],"class":"function","name":"vmatrix_methods:scaleTranslation","summary":"\nScales the absolute translation ","private":false,"classlib":"VMatrix","description":"\nScales the absolute translation","param":{"1":"num","num":"Amount to scale by"}}}},"Player":{"comment":["--- Player type"],"code":["local player_methods, player_metamethods = SF.Typedef(\"Player\", SF.Entities.Metatable)","","local vwrap = SF.WrapObject","","SF.Players.Methods = player_methods","SF.Players.Metatable = player_metamethods",""],"typtbl":"player_methods","fields":[],"name":"Player","summary":"\nPlayer type ","description":"\nPlayer type","class":"class","methods":{"1":"getActiveWeapon","2":"getAimVector","3":"getArmor","4":"getDeaths","5":"getEyeTrace","6":"getFOV","7":"getFrags","8":"getFriendStatus","9":"getJumpPower","10":"getMaxSpeed","11":"getName","12":"getPing","13":"getRunSpeed","14":"getShootPos","15":"getSteamID","16":"getSteamID64","17":"getTeam","18":"getTeamName","19":"getUniqueID","20":"getUserID","21":"inVehicle","22":"isAdmin","23":"isAlive","24":"isBot","25":"isConnected","26":"isCrouching","27":"isFlashlightOn","28":"isFrozen","29":"isMuted","30":"isNPC","31":"isPlayer","32":"isSuperAdmin","33":"isUserGroup","34":"keyDown","isUserGroup":{"ret":"True if player belongs to group","comment":["--- Returns whether the player belongs to a usergroup","-- @shared","-- @param group Group to check against","-- @return True if player belongs to group"],"code":["function player_methods:isUserGroup( group )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsUserGroup( group )","end",""],"class":"function","summary":"\nReturns whether the player belongs to a usergroup ","classlib":"Player","name":"player_methods:isUserGroup","server":true,"private":false,"client":true,"description":"\nReturns whether the player belongs to a usergroup","param":{"1":"group","group":"Group to check against"}},"isBot":{"ret":"True if player is a bot","comment":["--- Returns whether the player is a bot","-- @shared","-- @return True if player is a bot"],"code":["function player_methods:isBot( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsBot( )","end",""],"class":"function","summary":"\nReturns whether the player is a bot ","classlib":"Player","name":"player_methods:isBot","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a bot","param":[]},"getJumpPower":{"ret":"Jump power","comment":["--- Returns the player's jump power","-- @shared","-- @return Jump power"],"code":["function player_methods:getJumpPower ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetJumpPower()","end",""],"class":"function","summary":"\nReturns the player's jump power ","classlib":"Player","name":"player_methods:getJumpPower","server":true,"private":false,"client":true,"description":"\nReturns the player's jump power","param":[]},"inVehicle":{"ret":"True if player in vehicle","comment":["--- Returns whether the player is in a vehicle","-- @shared","-- @return True if player in vehicle"],"code":["function player_methods:inVehicle( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:InVehicle()","end",""],"class":"function","summary":"\nReturns whether the player is in a vehicle ","classlib":"Player","name":"player_methods:inVehicle","server":true,"private":false,"client":true,"description":"\nReturns whether the player is in a vehicle","param":[]},"keyDown":{"ret":"table trace data","comment":["--- Returns whether or not the player is pushing the key.","-- @shared","-- @param key Key to check.","---IN_KEY.ALT1","---IN_KEY.ALT2","---IN_KEY.ATTACK","---IN_KEY.ATTACK2","---IN_KEY.BACK","---IN_KEY.DUCK","---IN_KEY.FORWARD","---IN_KEY.JUMP","---IN_KEY.LEFT","---IN_KEY.MOVELEFT","---IN_KEY.MOVERIGHT","---IN_KEY.RELOAD","---IN_KEY.RIGHT","---IN_KEY.SCORE","---IN_KEY.SPEED","---IN_KEY.USE","---IN_KEY.WALK","---IN_KEY.ZOOM","---IN_KEY.GRENADE1","---IN_KEY.GRENADE2","---IN_KEY.WEAPON1","---IN_KEY.WEAPON2","---IN_KEY.BULLRUSH","---IN_KEY.CANCEL","---IN_KEY.RUN","-- @return table trace data"],"code":["function player_methods:keyDown ( key )","\tSF.CheckType( self, player_metamethods )","\tSF.CheckType( key, \"number\" )","\t","\tlocal ent = SF.Entities.Unwrap( self )","\tif not IsValid( ent ) then return false end","\t","\treturn ent:KeyDown( key )","end","","if CLIENT then"],"class":"function","summary":"\nReturns whether or not the player is pushing the key.","classlib":"Player","name":"player_methods:keyDown","server":true,"private":false,"client":true,"description":"\nReturns whether or not the player is pushing the key.","param":{"1":"key","key":"Key to check. \nIN_KEY.ALT1 \nIN_KEY.ALT2 \nIN_KEY.ATTACK \nIN_KEY.ATTACK2 \nIN_KEY.BACK \nIN_KEY.DUCK \nIN_KEY.FORWARD \nIN_KEY.JUMP \nIN_KEY.LEFT \nIN_KEY.MOVELEFT \nIN_KEY.MOVERIGHT \nIN_KEY.RELOAD \nIN_KEY.RIGHT \nIN_KEY.SCORE \nIN_KEY.SPEED \nIN_KEY.USE \nIN_KEY.WALK \nIN_KEY.ZOOM \nIN_KEY.GRENADE1 \nIN_KEY.GRENADE2 \nIN_KEY.WEAPON1 \nIN_KEY.WEAPON2 \nIN_KEY.BULLRUSH \nIN_KEY.CANCEL \nIN_KEY.RUN"}},"getFOV":{"ret":"Field of view","comment":["--- Returns the player's field of view","-- @shared","-- @return Field of view"],"code":["function player_methods:getFOV ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetFOV()","end",""],"class":"function","summary":"\nReturns the player's field of view ","classlib":"Player","name":"player_methods:getFOV","server":true,"private":false,"client":true,"description":"\nReturns the player's field of view","param":[]},"getShootPos":{"ret":"Shoot position","comment":["--- Returns the player's shoot position","-- @shared","-- @return Shoot position"],"code":["function player_methods:getShootPos ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and vwrap( ent:GetShootPos() )","end",""],"class":"function","summary":"\nReturns the player's shoot position ","classlib":"Player","name":"player_methods:getShootPos","server":true,"private":false,"client":true,"description":"\nReturns the player's shoot position","param":[]},"getTeam":{"ret":"team","comment":["--- Returns the player's current team","-- @shared","-- @return team"],"code":["function player_methods:getTeam ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Team()","end",""],"class":"function","summary":"\nReturns the player's current team ","classlib":"Player","name":"player_methods:getTeam","server":true,"private":false,"client":true,"description":"\nReturns the player's current team","param":[]},"getArmor":{"ret":"Armor","comment":["--- Returns the players armor","-- @shared","-- @return Armor"],"code":["function player_methods:getArmor ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Armor()","end",""],"class":"function","summary":"\nReturns the players armor ","classlib":"Player","name":"player_methods:getArmor","server":true,"private":false,"client":true,"description":"\nReturns the players armor","param":[]},"getSteamID":{"ret":"steam ID","comment":["--- Returns the player's steam ID","-- @shared","-- @return steam ID"],"code":["function player_methods:getSteamID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:SteamID()","end",""],"class":"function","summary":"\nReturns the player's steam ID ","classlib":"Player","name":"player_methods:getSteamID","server":true,"private":false,"client":true,"description":"\nReturns the player's steam ID","param":[]},"isConnected":{"ret":"True if player is connected","comment":["--- Returns whether the player is connected","-- @shared","-- @return True if player is connected"],"code":["function player_methods:isConnected( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsConnected( )","end",""],"class":"function","summary":"\nReturns whether the player is connected ","classlib":"Player","name":"player_methods:isConnected","server":true,"private":false,"client":true,"description":"\nReturns whether the player is connected","param":[]},"getUserID":{"ret":"user ID","comment":["--- Returns the player's user ID","-- @shared","-- @return user ID"],"code":["function player_methods:getUserID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:UserID()","end",""],"class":"function","summary":"\nReturns the player's user ID ","classlib":"Player","name":"player_methods:getUserID","server":true,"private":false,"client":true,"description":"\nReturns the player's user ID","param":[]},"getMaxSpeed":{"ret":"Maximum speed","comment":["--- Returns the player's maximum speed","-- @shared","-- @return Maximum speed"],"code":["function player_methods:getMaxSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetMaxSpeed()","end",""],"class":"function","summary":"\nReturns the player's maximum speed ","classlib":"Player","name":"player_methods:getMaxSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's maximum speed","param":[]},"getSteamID64":{"ret":"community ID","comment":["--- Returns the player's community ID","-- @shared","-- @return community ID"],"code":["function player_methods:getSteamID64 ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:SteamID64( )","end",""],"class":"function","summary":"\nReturns the player's community ID ","classlib":"Player","name":"player_methods:getSteamID64","server":true,"private":false,"client":true,"description":"\nReturns the player's community ID","param":[]},"getRunSpeed":{"ret":"Running speed","comment":["--- Returns the player's running speed","-- @shared","-- @return Running speed"],"code":["function player_methods:getRunSpeed ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetRunSpeed()","end",""],"class":"function","summary":"\nReturns the player's running speed ","classlib":"Player","name":"player_methods:getRunSpeed","server":true,"private":false,"client":true,"description":"\nReturns the player's running speed","param":[]},"getAimVector":{"ret":"Aim vector","comment":["--- Returns the player's aim vector","-- @shared","-- @return Aim vector"],"code":["function player_methods:getAimVector ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and vwrap( ent:GetAimVector() )","end",""],"class":"function","summary":"\nReturns the player's aim vector ","classlib":"Player","name":"player_methods:getAimVector","server":true,"private":false,"client":true,"description":"\nReturns the player's aim vector","param":[]},"getUniqueID":{"ret":"unique ID","comment":["--- Returns the player's unique ID","-- @shared","-- @return unique ID"],"code":["function player_methods:getUniqueID ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:UniqueID()","end",""],"class":"function","summary":"\nReturns the player's unique ID ","classlib":"Player","name":"player_methods:getUniqueID","server":true,"private":false,"client":true,"description":"\nReturns the player's unique ID","param":[]},"getFriendStatus":{"ret":"One of: \"friend\", \"blocked\", \"none\", \"requested\"","comment":["\t--- Returns the relationship of the player to the local client","\t-- @return One of: \"friend\", \"blocked\", \"none\", \"requested\""],"code":["\tfunction player_methods:getFriendStatus( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent and ent:GetFriendStatus( )","\tend","\t"],"class":"function","name":"player_methods:getFriendStatus","summary":"\nReturns the relationship of the player to the local client ","private":false,"classlib":"Player","description":"\nReturns the relationship of the player to the local client","param":[]},"getFrags":{"ret":"Amount of kills","comment":["--- Returns the amount of kills of the player","-- @shared","-- @return Amount of kills"],"code":["function player_methods:getFrags ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Frags()","end",""],"class":"function","summary":"\nReturns the amount of kills of the player ","classlib":"Player","name":"player_methods:getFrags","server":true,"private":false,"client":true,"description":"\nReturns the amount of kills of the player","param":[]},"isPlayer":{"ret":"True if player is player","comment":["--- Returns whether the player is a player","-- @shared","-- @return True if player is player"],"code":["function player_methods:isPlayer( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsPlayer()","end",""],"class":"function","summary":"\nReturns whether the player is a player ","classlib":"Player","name":"player_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a player","param":[]},"getPing":{"ret":"ping","comment":["--- Returns the player's current ping","-- @shared","-- @return ping"],"code":["function player_methods:getPing ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Ping()","end",""],"class":"function","summary":"\nReturns the player's current ping ","classlib":"Player","name":"player_methods:getPing","server":true,"private":false,"client":true,"description":"\nReturns the player's current ping","param":[]},"isMuted":{"ret":"True if the player was muted","comment":["\t--- Returns whether the local player has muted the player","\t-- @return True if the player was muted"],"code":["\tfunction player_methods:isMuted( )","\t\tSF.CheckType( self, player_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent and ent:IsMuted( )","\tend","end"],"class":"function","name":"player_methods:isMuted","summary":"\nReturns whether the local player has muted the player ","private":false,"classlib":"Player","description":"\nReturns whether the local player has muted the player","param":[]},"isAlive":{"ret":"True if player alive","comment":["--- Returns whether the player is alive","-- @shared","-- @return True if player alive"],"code":["function player_methods:isAlive ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Alive()","end",""],"class":"function","summary":"\nReturns whether the player is alive ","classlib":"Player","name":"player_methods:isAlive","server":true,"private":false,"client":true,"description":"\nReturns whether the player is alive","param":[]},"isFlashlightOn":{"ret":"True if player has flashlight on","comment":["--- Returns whether the player's flashlight is on","-- @shared","-- @return True if player has flashlight on"],"code":["function player_methods:isFlashlightOn( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:FlashlightIsOn()","end",""],"class":"function","summary":"\nReturns whether the player's flashlight is on ","classlib":"Player","name":"player_methods:isFlashlightOn","server":true,"private":false,"client":true,"description":"\nReturns whether the player's flashlight is on","param":[]},"getName":{"ret":"Name","comment":["--- Returns the player's name","-- @shared","-- @return Name"],"code":["function player_methods:getName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:GetName()","end",""],"class":"function","summary":"\nReturns the player's name ","classlib":"Player","name":"player_methods:getName","server":true,"private":false,"client":true,"description":"\nReturns the player's name","param":[]},"isNPC":{"ret":"True if player is an NPC","comment":["--- Returns whether the player is an NPC","-- @shared","-- @return True if player is an NPC"],"code":["function player_methods:isNPC( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsNPC( )","end",""],"class":"function","summary":"\nReturns whether the player is an NPC ","classlib":"Player","name":"player_methods:isNPC","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an NPC","param":[]},"getEyeTrace":{"ret":"table trace data","comment":["--- Returns a table with information of what the player is looking at","-- @shared","-- @return table trace data"],"code":["function player_methods:getEyeTrace ()","\tif not SF.Permissions.check( SF.instance.player, SF.UnwrapObject( self ), \"trace\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\treturn SF.Sanitize( SF.UnwrapObject( self ):GetEyeTrace() )","end",""],"class":"function","summary":"\nReturns a table with information of what the player is looking at ","classlib":"Player","name":"player_methods:getEyeTrace","server":true,"private":false,"client":true,"description":"\nReturns a table with information of what the player is looking at","param":[]},"isAdmin":{"ret":"True if player is admin","comment":["--- Returns whether the player is an admin","-- @shared","-- @return True if player is admin"],"code":["function player_methods:isAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is an admin ","classlib":"Player","name":"player_methods:isAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is an admin","param":[]},"isSuperAdmin":{"ret":"True if player is super admin","comment":["--- Returns whether the player is a super admin","-- @shared","-- @return True if player is super admin"],"code":["function player_methods:isSuperAdmin( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsSuperAdmin( )","end",""],"class":"function","summary":"\nReturns whether the player is a super admin ","classlib":"Player","name":"player_methods:isSuperAdmin","server":true,"private":false,"client":true,"description":"\nReturns whether the player is a super admin","param":[]},"isCrouching":{"ret":"True if player crouching","comment":["--- Returns whether the player is crouching","-- @shared","-- @return True if player crouching"],"code":["function player_methods:isCrouching ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Crouching()","end",""],"class":"function","summary":"\nReturns whether the player is crouching ","classlib":"Player","name":"player_methods:isCrouching","server":true,"private":false,"client":true,"description":"\nReturns whether the player is crouching","param":[]},"getTeamName":{"ret":"team name","comment":["--- Returns the name of the player's current team","-- @shared","-- @return team name"],"code":["function player_methods:getTeamName ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and team.GetName(ent:Team())","end",""],"class":"function","summary":"\nReturns the name of the player's current team ","classlib":"Player","name":"player_methods:getTeamName","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's current team","param":[]},"getDeaths":{"ret":"Amount of deaths","comment":["--- Returns the amount of deaths of the player","-- @shared","-- @return Amount of deaths"],"code":["function player_methods:getDeaths ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:Deaths()","end",""],"class":"function","summary":"\nReturns the amount of deaths of the player ","classlib":"Player","name":"player_methods:getDeaths","server":true,"private":false,"client":true,"description":"\nReturns the amount of deaths of the player","param":[]},"getActiveWeapon":{"ret":"The weapon","comment":["--- Returns the name of the player's active weapon","-- @shared","-- @return The weapon"],"code":["function player_methods:getActiveWeapon ()","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and SF.WrapObject( ent:GetActiveWeapon() )","end",""],"class":"function","summary":"\nReturns the name of the player's active weapon ","classlib":"Player","name":"player_methods:getActiveWeapon","server":true,"private":false,"client":true,"description":"\nReturns the name of the player's active weapon","param":[]},"isFrozen":{"ret":"True if player is frozen","comment":["--- Returns whether the player is frozen","-- @shared","-- @return True if player is frozen"],"code":["function player_methods:isFrozen( )","\tSF.CheckType( self, player_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent and ent:IsFrozen( )","end",""],"class":"function","summary":"\nReturns whether the player is frozen ","classlib":"Player","name":"player_methods:isFrozen","server":true,"private":false,"client":true,"description":"\nReturns whether the player is frozen","param":[]}}},"Vector":{"comment":["--- Vector type","-- @shared"],"code":["local vec_methods, vec_metamethods = SF.Typedef( \"Vector\" )","local wrap, unwrap = SF.CreateWrapper( vec_metamethods, true, false, debug.getregistry().Vector )","","SF.DefaultEnvironment.Vector = function ( ... )","\treturn wrap( Vector( ... ) )","end","","SF.Vectors.Wrap = wrap","SF.Vectors.Unwrap = unwrap","SF.Vectors.Methods = vec_methods","SF.Vectors.Metatable = vec_metamethods",""],"typtbl":"vec_methods","summary":"\nVector type ","fields":[],"name":"Vector","server":true,"description":"\nVector type","client":true,"class":"class","methods":{"1":"add","2":"cross","3":"dot","4":"getAngle","5":"getAngleEx","6":"getDistance","7":"getDistanceSqr","8":"getLength","9":"getLength2D","10":"getLength2DSqr","11":"getLengthSqr","12":"getNormalized","13":"isEqualTol","14":"isZero","15":"mul","16":"normalize","17":"rotate","18":"set","19":"setZero","20":"sub","21":"toScreen","22":"withinAABox","isEqualTol":{"ret":"bool True/False.","comment":["--- Is this vector and v equal within tolerance t.","-- @param v Second Vector","-- @param t Tolerance number.","-- @return bool True/False."],"code":["function vec_methods:isEqualTol ( v, t )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tSF.CheckType( t, \"number\" )","\treturn unwrap( self ):IsEqualTol( unwrap( v ), t )","end",""],"class":"function","name":"vec_methods:isEqualTol","summary":"\nIs this vector and v equal within tolerance t.","private":false,"classlib":"Vector","description":"\nIs this vector and v equal within tolerance t.","param":{"1":"v","2":"t","t":"Tolerance number.","v":"Second Vector"}},"getAngle":{"ret":"Angle","comment":["--- Get the vector's angle.","-- @return Angle"],"code":["function vec_methods:getAngle ()","\treturn SF.WrapObject( unwrap( self ):Angle() )","end",""],"class":"function","name":"vec_methods:getAngle","summary":"\nGet the vector's angle.","private":false,"classlib":"Vector","description":"\nGet the vector's angle.","param":[]},"getLength2D":{"ret":"number length","comment":["--- Returns the length of the vector in two dimensions, without the Z axis.","-- @return number length"],"code":["function vec_methods:getLength2D ()","\treturn unwrap( self ):Length2D()","end",""],"class":"function","name":"vec_methods:getLength2D","summary":"\nReturns the length of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length of the vector in two dimensions, without the Z axis.","param":[]},"getLength":{"ret":"number Length.","comment":["--- Get the vector's Length.","-- @return number Length."],"code":["function vec_methods:getLength ()","\treturn unwrap( self ):Length()","end",""],"class":"function","name":"vec_methods:getLength","summary":"\nGet the vector's Length.","private":false,"classlib":"Vector","description":"\nGet the vector's Length.","param":[]},"normalize":{"ret":"nil","comment":["--- Normalise the vector, same direction, length 0. Self-Modifies.","-- @return nil"],"code":["function vec_methods:normalize ()","\tunwrap( self ):Normalize()","end",""],"class":"function","name":"vec_methods:normalize","summary":"\nNormalise the vector, same direction, length 0.","private":false,"classlib":"Vector","description":"\nNormalise the vector, same direction, length 0. Self-Modifies.","param":[]},"getDistanceSqr":{"ret":"Number","comment":["--- Returns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:getDistanceSqr ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):DistToSqr( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:getDistanceSqr","summary":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","private":false,"classlib":"Vector","description":"\nReturns the squared distance of 2 vectors, this is faster Vector:getDistance as calculating the square root is an expensive process.","param":{"1":"v","v":"Second Vector"}},"getDistance":{"ret":"Number","comment":["--- Returns the pythagorean distance between the vector and the other vector.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:getDistance ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):Distance( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:getDistance","summary":"\nReturns the pythagorean distance between the vector and the other vector.","private":false,"classlib":"Vector","description":"\nReturns the pythagorean distance between the vector and the other vector.","param":{"1":"v","v":"Second Vector"}},"setZero":{"ret":"nil","comment":["--- Set's all vector fields to 0.","-- @return nil"],"code":["function vec_methods:setZero ()","\tunwrap( self ):Zero()","end",""],"class":"function","name":"vec_methods:setZero","summary":"\nSet's all vector fields to 0.","private":false,"classlib":"Vector","description":"\nSet's all vector fields to 0.","param":[]},"getLength2DSqr":{"ret":"number length squared.","comment":["--- Returns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","-- @return number length squared."],"code":["function vec_methods:getLength2DSqr ()","\treturn unwrap( self ):Length2DSqr()","end",""],"class":"function","name":"vec_methods:getLength2DSqr","summary":"\nReturns the length squared of the vector in two dimensions, without the Z axis.","private":false,"classlib":"Vector","description":"\nReturns the length squared of the vector in two dimensions, without the Z axis. ( Saves computation by skipping the square root )","param":[]},"sub":{"ret":"nil","comment":["--- Subtract v from this Vector. Self-Modifies.","-- @param v Second Vector.","-- @return nil"],"code":["function vec_methods:sub ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Sub( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:sub","summary":"\nSubtract v from this Vector.","private":false,"classlib":"Vector","description":"\nSubtract v from this Vector. Self-Modifies.","param":{"1":"v","v":"Second Vector."}},"toScreen":{"ret":"nil","comment":["--- Translates the vectors position into 2D user screen coordinates. Self-Modifies.","-- @return nil"],"code":["function vec_methods:toScreen ()","\treturn unwrap( self ):ToScreen()","end",""],"class":"function","name":"vec_methods:toScreen","summary":"\nTranslates the vectors position into 2D user screen coordinates.","private":false,"classlib":"Vector","description":"\nTranslates the vectors position into 2D user screen coordinates. Self-Modifies.","param":[]},"set":{"ret":"nil","comment":["--- Copies the values from the second vector to the first vector. Self-Modifies.","-- @param v Second Vector","-- @return nil"],"code":["function vec_methods:set ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Set( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:set","summary":"\nCopies the values from the second vector to the first vector.","private":false,"classlib":"Vector","description":"\nCopies the values from the second vector to the first vector. Self-Modifies.","param":{"1":"v","v":"Second Vector"}},"isZero":{"ret":"bool True/False","comment":["--- Are all fields zero.","-- @return bool True/False"],"code":["function vec_methods:isZero ()","\treturn unwrap( self ):IsZero()","end",""],"class":"function","name":"vec_methods:isZero","summary":"\nAre all fields zero.","private":false,"classlib":"Vector","description":"\nAre all fields zero.","param":[]},"getNormalized":{"ret":"Vector Normalised","comment":["--- Returns a new vector with the same direction by length of 1.","-- @return Vector Normalised"],"code":["function vec_methods:getNormalized ()","\treturn wrap( unwrap( self ):GetNormalized() )","end",""],"class":"function","name":"vec_methods:getNormalized","summary":"\nReturns a new vector with the same direction by length of 1.","private":false,"classlib":"Vector","description":"\nReturns a new vector with the same direction by length of 1.","param":[]},"withinAABox":{"ret":"bool True/False.","comment":["--- Returns whenever the given vector is in a box created by the 2 other vectors.","-- @param v1 Vector used to define AABox","-- @param v2 Second Vector to define AABox","-- @return bool True/False."],"code":["function vec_methods:withinAABox ( v1, v2 )","\tSF.CheckType( v1, SF.Types[ \"Vector\" ] )","\tSF.CheckType( v2, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):WithinAABox( unwrap( v1 ), unwrap( v2 ) )","end"],"class":"function","name":"vec_methods:withinAABox","summary":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","private":false,"classlib":"Vector","description":"\nReturns whenever the given vector is in a box created by the 2 other vectors.","param":{"1":"v1","2":"v2","v2":"Second Vector to define AABox","v1":"Vector used to define AABox"}},"getLengthSqr":{"ret":"number length squared.","comment":["--- Get the vector's length squared ( Saves computation by skipping the square root ).","-- @return number length squared."],"code":["function vec_methods:getLengthSqr ()","\treturn unwrap( self ):LengthSqr()","end",""],"class":"function","name":"vec_methods:getLengthSqr","summary":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","private":false,"classlib":"Vector","description":"\nGet the vector's length squared ( Saves computation by skipping the square root ).","param":[]},"dot":{"ret":"Number","comment":["--- Dot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","-- @param v Second Vector","-- @return Number"],"code":["function vec_methods:dot ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn unwrap( self ):Dot( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:dot","summary":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths.","private":false,"classlib":"Vector","description":"\nDot product is the cosine of the angle between both vectors multiplied by their lengths. A.B = ||A||||B||cosA.","param":{"1":"v","v":"Second Vector"}},"cross":{"ret":"Vector","comment":["--- Calculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","-- @param v Second Vector","-- @return Vector"],"code":["function vec_methods:cross ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn wrap( unwrap( self ):Cross( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods:cross","summary":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","private":false,"classlib":"Vector","description":"\nCalculates the cross product of the 2 vectors, creates a unique perpendicular vector to both input vectors.","param":{"1":"v","v":"Second Vector"}},"getAngleEx":{"ret":"Angle","comment":["--- Returns the Angle between two vectors.","-- @param v Second Vector","-- @return Angle"],"code":["function vec_methods:getAngleEx ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\treturn SF.WrapObject( unwrap( self ):AngleEx( unwrap( v ) ) )","end",""],"class":"function","name":"vec_methods:getAngleEx","summary":"\nReturns the Angle between two vectors.","private":false,"classlib":"Vector","description":"\nReturns the Angle between two vectors.","param":{"1":"v","v":"Second Vector"}},"rotate":{"ret":"nil.","comment":["--- Rotate the vector by Angle a. Self-Modifies.","-- @param a Angle to rotate by.","-- @return nil."],"code":["function vec_methods:rotate ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\tunwrap( self ):Rotate( SF.UnwrapObject( a ) )","end",""],"class":"function","name":"vec_methods:rotate","summary":"\nRotate the vector by Angle a.","private":false,"classlib":"Vector","description":"\nRotate the vector by Angle a. Self-Modifies.","param":{"1":"a","a":"Angle to rotate by."}},"mul":{"ret":"nil","comment":["--- Scalar Multiplication of the vector. Self-Modifies.","-- @param n Scalar to multiply with.","-- @return nil"],"code":["function vec_methods:mul ( n )","\tSF.CheckType( n, \"number\" )","\tunwrap( self ):Mul( n )","end",""],"class":"function","name":"vec_methods:mul","summary":"\nScalar Multiplication of the vector.","private":false,"classlib":"Vector","description":"\nScalar Multiplication of the vector. Self-Modifies.","param":{"1":"n","n":"Scalar to multiply with."}},"add":{"ret":"nil","comment":["--- Add vector - Modifies self.","-- @param v Vector to add","-- @return nil"],"code":["function vec_methods:add ( v )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tunwrap( self ):Add( unwrap( v ) )","end",""],"class":"function","name":"vec_methods:add","summary":"\nAdd vector - Modifies self.","private":false,"classlib":"Vector","description":"\nAdd vector - Modifies self.","param":{"1":"v","v":"Vector to add"}}}},"Vehicle":{"comment":["--- Vehicle type"],"code":["local vehicle_methods, vehicle_metamethods = SF.Typedef(\"Vehicle\", SF.Entities.Metatable)","","SF.Vehicles.Methods = vehicle_methods","SF.Vehicles.Metatable = vehicle_metamethods",""],"typtbl":"vehicle_methods","fields":[],"name":"Vehicle","summary":"\nVehicle type ","description":"\nVehicle type","class":"class","methods":{"1":"ejectDriver","2":"getDriver","3":"getPassenger","getDriver":{"ret":"Driver of vehicle","comment":["\t--- Returns the driver of the vehicle","\t-- @server","\t-- @return Driver of vehicle"],"code":["\tfunction vehicle_methods:getDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\treturn SF.WrapObject( ent:GetDriver() )","\tend","\t"],"class":"function","summary":"\nReturns the driver of the vehicle ","name":"vehicle_methods:getDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns the driver of the vehicle","param":[]},"ejectDriver":{"comment":["\t--- Ejects the driver of the vehicle","\t-- @server"],"code":["\tfunction vehicle_methods:ejectDriver ()","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\tif not IsValid(ent) then return end","\t\tlocal driver = ent:GetDriver()","\t\tif driver:IsValid() then","\t\t\tdriver:ExitVehicle()","\t\tend","\tend",""],"class":"function","summary":"\nEjects the driver of the vehicle ","name":"vehicle_methods:ejectDriver","classlib":"Vehicle","private":false,"server":true,"description":"\nEjects the driver of the vehicle","param":[]},"getPassenger":{"ret":"amount of ammo","comment":["\t--- Returns a passenger of a vehicle","\t-- @server","\t-- @param passenger The number of the passenger to get","\t-- @return amount of ammo"],"code":["\tfunction vehicle_methods:getPassenger ( n )","\t\tSF.CheckType( self, vehicle_metamethods )","\t\tSF.CheckType( n, \"number\" )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn SF.WrapObject( ent:GetPassenger( n ) )","\tend","","end"],"class":"function","summary":"\nReturns a passenger of a vehicle ","name":"vehicle_methods:getPassenger","classlib":"Vehicle","private":false,"server":true,"description":"\nReturns a passenger of a vehicle","param":{"1":"n","2":"passenger","passenger":"The number of the passenger to get"}}}},"Entity":{"comment":["--- Entity type","-- @shared"],"code":["local ents_methods, ents_metamethods = SF.Typedef( \"Entity\" )","local wrap, unwrap = SF.CreateWrapper( ents_metamethods, true, true, debug.getregistry().Entity )","","local vwrap, vunwrap = SF.WrapObject, SF.UnwrapObject",""],"typtbl":"ents_methods","summary":"\nEntity type ","fields":[],"name":"Entity","server":true,"description":"\nEntity type","client":true,"class":"class","methods":{"1":"addCollisionListener","2":"applyAngForce","3":"applyDamage","4":"applyForceCenter","5":"applyForceOffset","6":"applyTorque","7":"destroy","8":"emitSound","9":"enableDrag","10":"enableGravity","11":"enableMotion","12":"entIndex","13":"getAngleVelocity","14":"getAngles","15":"getClass","16":"getColor","17":"getEyeAngles","18":"getEyePos","19":"getForward","20":"getInertia","21":"getMass","22":"getMassCenter","23":"getMassCenterW","24":"getMaterial","25":"getMaterials","26":"getMatrix","27":"getModel","28":"getOwner","29":"getPos","30":"getRight","31":"getSubMaterial","32":"getUp","33":"getVelocity","34":"isFrozen","35":"isNPC","36":"isPlayer","37":"isValid","38":"isVehicle","39":"isWeapon","40":"isWeldedTo","41":"localToWorld","42":"localToWorldAngles","43":"obbCenter","44":"obbCenterW","45":"obbSize","46":"remove","47":"setAngles","48":"setBodygroup","49":"setColor","50":"setFrozen","51":"setMass","52":"setMaterial","53":"setNoDraw","54":"setParent","55":"setPos","56":"setSkin","57":"setSolid","58":"setSubMaterial","59":"setVelocity","60":"unparent","61":"worldToLocal","62":"worldToLocalAngles","getRight":{"comment":["--- Gets the entities right vector"],"code":["function ents_methods:getRight ()","\treturn SF.WrapObject( unwrap( self ):GetRight() )","end",""],"class":"function","name":"ents_methods:getRight","summary":"\nGets the entities right vector ","private":false,"classlib":"Entity","description":"\nGets the entities right vector","param":[]},"applyTorque":{"comment":["--- Applies torque","-- @param tq The torque vector","-- @param offset Optional offset position"],"code":["function ents_methods:applyTorque ( tq, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( tq, SF.Types[ \"Vector\" ] )","","\tlocal tq = vunwrap( tq )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tlocal torqueamount = tq:Length()","","\tif offset then","\t\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","\t\toffset = vunwrap( offset )","\telse","\t\toffset = phys:GetPos()","\tend","\t-- Convert torque from local to world axis","\ttq = phys:LocalToWorld( tq ) - offset","","\t-- Find two vectors perpendicular to the torque axis","\tlocal off","\tif abs( tq.x ) > torqueamount * 0.1 or abs( tq.z ) > torqueamount * 0.1 then","\t\toff = Vector( -tq.z, 0, tq.x )","\telse","\t\toff = Vector( -tq.y, tq.x, 0 )","\tend","\toff = off:GetNormal() * torqueamount * 0.5","","\tlocal dir = ( tq:Cross( off ) ):GetNormal()","","\tif not check( dir ) or not check( off ) then SF.throw( \"infinite vector\", 2) end","","\tphys:ApplyForceOffset( dir, off )","\tphys:ApplyForceOffset( dir * -1, off * -1 )","end",""],"class":"function","name":"ents_methods:applyTorque","summary":"\nApplies torque ","private":false,"classlib":"Entity","description":"\nApplies torque","param":{"1":"tq","2":"offset","offset":"Optional offset position","tq":"The torque vector"}},"setColor":{"comment":["--- Sets the color of the entity","-- @server","-- @param clr New color","-- @param ply Optional player arguement to set the entity's color only for that player"],"code":["function ents_methods:setColor ( clr, ply )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( clr, SF.Types[ \"Color\" ] )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 1, clr )","\telse","\t\tent:SetColor( clr )","\t\tent:SetRenderMode( clr.a == 255 and RENDERMODE_NORMAL or RENDERMODE_TRANSALPHA )","\tend","","end",""],"class":"function","summary":"\nSets the color of the entity ","name":"ents_methods:setColor","classlib":"Entity","private":false,"server":true,"description":"\nSets the color of the entity","param":{"1":"clr","2":"ply","clr":"New color","ply":"Optional player arguement to set the entity's color only for that player"}},"setSubMaterial":{"comment":["--- Sets an entities' submaterial","-- @server","-- @class function","-- @param index, number, submaterial index.","-- @param material, string, New material name.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setSubMaterial ( index, material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if materialBlacklist[ material:lower() ] then SF.throw( \"This material has been blacklisted\", 2 ) end","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 4, index, material )","\telse","\t\tent:SetSubMaterial( index, material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' submaterial ","name":"ents_methods:setSubMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' submaterial","param":{"1":"index","2":"material","3":"ply","material":", string, New material name.","index":", number, submaterial index.","ply":"Optional player arguement to set material of an entity only for that player"}},"localToWorld":{"ret":"data as world space vector","comment":["--- Converts a vector in entity local space to world space","-- @shared","-- @param data Local space vector","-- @return data as world space vector"],"code":["function ents_methods:localToWorld( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Vector\" ] )","\tlocal ent = unwrap( self )","\t","\treturn SF.WrapObject( ent:LocalToWorld( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorld","server":true,"private":false,"client":true,"description":"\nConverts a vector in entity local space to world space","param":{"1":"data","data":"Local space vector"}},"getAngles":{"ret":"The angle","comment":["--- Returns the angle of the entity","-- @shared","-- @return The angle"],"code":["function ents_methods:getAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:GetAngles() )","end",""],"class":"function","summary":"\nReturns the angle of the entity ","classlib":"Entity","name":"ents_methods:getAngles","server":true,"private":false,"client":true,"description":"\nReturns the angle of the entity","param":[]},"applyForceOffset":{"comment":["--- Applies linear force to the entity with an offset","-- @param vec The force vector","-- @param offset An optional offset position"],"code":["function ents_methods:applyForceOffset ( vec, offset )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tSF.CheckType( offset, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal offset = vunwrap( offset )","","\tif not check( vec ) or not check( offset ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceOffset( vec, offset )","end",""],"class":"function","name":"ents_methods:applyForceOffset","summary":"\nApplies linear force to the entity with an offset ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity with an offset","param":{"1":"vec","2":"offset","vec":"The force vector","offset":"An optional offset position"}},"getSubMaterial":{"ret":"Material","comment":["--- Gets an entities' submaterial","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getSubMaterial ( index )","    local ent = unwrap( self )","    return ent:GetSubMaterial( index ) or \"\"","end",""],"class":"function","summary":"\nGets an entities' submaterial ","classForced":true,"classlib":"Entity","name":"ents_methods:getSubMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' submaterial","param":["index"]},"applyDamage":{"comment":["--- Applies damage to an entity","-- @param amt damage amount","-- @param attacker damage attacker","-- @param inflictor damage inflictor"],"code":["function ents_methods:applyDamage( amt, attacker, inflictor )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( amt, \"number\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyDamage\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif attacker then","\t\tSF.CheckType( attacker, ents_metatable )","\t\tattacker = unwrap( attacker )","\t\tif not isValid( attacker ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","\tif inflictor then","\t\tSF.CheckType( inflictor, ents_metatable )","\t\tinflictor = unwrap( inflictor )","\t\tif not isValid( inflictor ) then SF.throw( \"Entity is not valid\", 2 ) end","\tend","","\tent:TakeDamage( amt, attacker, inflictor )","end","",""],"class":"function","name":"ents_methods:applyDamage","summary":"\nApplies damage to an entity ","private":false,"classlib":"Entity","description":"\nApplies damage to an entity","param":{"1":"amt","2":"attacker","3":"inflictor","inflictor":"damage inflictor","attacker":"damage attacker","amt":"damage amount"}},"applyAngForce":{"comment":["--- Applies angular force to the entity","-- @param ang The force angle"],"code":["function ents_methods:applyAngForce ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\t-- assign vectors","\tlocal up = ent:GetUp()","\tlocal left = ent:GetRight() * -1","\tlocal forward = ent:GetForward()","","\t-- apply pitch force","\tif ang.p ~= 0 then","\t\tlocal pitch = up * ( ang.p * 0.5 )","\t\tphys:ApplyForceOffset( forward, pitch )","\t\tphys:ApplyForceOffset( forward * -1, pitch * -1 )","\tend","","\t-- apply yaw force","\tif ang.y ~= 0 then","\t\tlocal yaw = forward * ( ang.y * 0.5 )","\t\tphys:ApplyForceOffset( left, yaw )","\t\tphys:ApplyForceOffset( left * -1, yaw * -1 )","\tend","","\t-- apply roll force","\tif ang.r ~= 0 then","\t\tlocal roll = left * ( ang.r * 0.5 )","\t\tphys:ApplyForceOffset( up, roll )","\t\tphys:ApplyForceOffset( up * -1, roll * -1 )","\tend","end",""],"class":"function","name":"ents_methods:applyAngForce","summary":"\nApplies angular force to the entity ","private":false,"classlib":"Entity","description":"\nApplies angular force to the entity","param":{"1":"ang","ang":"The force angle"}},"setAngles":{"comment":["--- Sets the entity's angles","-- @param ang New angles"],"code":["function ents_methods:setAngles ( ang )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( ang, SF.Types[ \"Angle\" ] )","\tlocal ang = SF.UnwrapObject( ang )","","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setAngles\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setAng( ent, ang )","end",""],"class":"function","name":"ents_methods:setAngles","summary":"\nSets the entity's angles ","private":false,"classlib":"Entity","description":"\nSets the entity's angles","param":{"1":"ang","ang":"New angles"}},"unparent":{"comment":["--- Unparents the entity from another entity"],"code":["function ents_methods:unparent ()","\tlocal this = unwrap( self )","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.unparent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tthis:SetParent( nil )","end",""],"class":"function","name":"ents_methods:unparent","summary":"\nUnparents the entity from another entity ","private":false,"classlib":"Entity","description":"\nUnparents the entity from another entity","param":[]},"applyForceCenter":{"comment":["--- Applies linear force to the entity","-- @param vec The force vector"],"code":["function ents_methods:applyForceCenter ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","\tlocal vec = vunwrap( vec )","\tif not check( vec ) then SF.throw( \"infinite vector\", 2) end","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.applyForce\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:ApplyForceCenter( vec )","end",""],"class":"function","name":"ents_methods:applyForceCenter","summary":"\nApplies linear force to the entity ","private":false,"classlib":"Entity","description":"\nApplies linear force to the entity","param":{"1":"vec","vec":"The force vector"}},"setSkin":{"comment":["--- Sets the skin of the entity","-- @server","-- @class function","-- @param skinIndex Number, Index of the skin to use.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setSkin ( skinIndex, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( skinIndex, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 6, skinIndex )","\telse","\t\tent:SetSkin( skinIndex )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets the skin of the entity ","name":"ents_methods:setSkin","classlib":"Entity","private":false,"server":true,"description":"\nSets the skin of the entity","param":{"1":"skinIndex","2":"ply","skinIndex":"Number, Index of the skin to use.","ply":"Optional player arguement to set material of an entity only for that player"}},"getMatrix":{"ret":"The matrix","comment":["--- Returns the matrix of the entity","-- @shared","-- @param bone Bone of the entity (def 0)","-- @return The matrix"],"code":["function ents_methods:getMatrix (bone)","\tSF.CheckType( self, ents_metamethods )","\tbone = SF.CheckType( bone, \"number\", 0, 0 )","\t","\tlocal ent = unwrap( self )","\treturn vwrap( ent:GetBoneMatrix(bone) )","end",""],"class":"function","summary":"\nReturns the matrix of the entity ","classlib":"Entity","name":"ents_methods:getMatrix","server":true,"private":false,"client":true,"description":"\nReturns the matrix of the entity","param":{"1":"bone","bone":"Bone of the entity (def 0)"}},"isValid":{"ret":"True if valid, false if not","comment":["--- Checks if an entity is valid.","-- @shared","-- @return True if valid, false if not"],"code":["function ents_methods:isValid ()","\tSF.CheckType( self, ents_metamethods )","\treturn isValid( unwrap( self ) )","end",""],"class":"function","summary":"\nChecks if an entity is valid.","classlib":"Entity","name":"ents_methods:isValid","server":true,"private":false,"client":true,"description":"\nChecks if an entity is valid.","param":[]},"getUp":{"comment":["--- Gets the entities up vector"],"code":["function ents_methods:getUp ()","\treturn SF.WrapObject( unwrap( self ):GetUp() )","end",""],"class":"function","name":"ents_methods:getUp","summary":"\nGets the entities up vector ","private":false,"classlib":"Entity","description":"\nGets the entities up vector","param":[]},"setBodygroup":{"comment":["--- Sets an entities' bodygroup","-- @server","-- @class function","-- @param bodygroup Number, The ID of the bodygroup you're setting.","-- @param value Number, The value you're setting the bodygroup to.","-- @param ply Optional player arguement to set bodygroup of an entity only for that player"],"code":["function ents_methods:setBodygroup ( bodygroup, value, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( bodygroup, \"number\" )","    SF.CheckType( value, \"number\" )","","    local ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, 5, bodygroup, value )","\telse","\t\tent:SetBodyGroup( bodygroup, value )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' bodygroup ","name":"ents_methods:setBodygroup","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' bodygroup","param":{"1":"bodygroup","2":"value","3":"ply","value":"Number, The value you're setting the bodygroup to.","ply":"Optional player arguement to set bodygroup of an entity only for that player","bodygroup":"Number, The ID of the bodygroup you're setting."}},"setNoDraw":{"comment":["--- Sets the whether an entity should be drawn or not","-- @server","-- @param draw Whether to draw the entity or not.","-- @param ply Optional player arguement to set drawing of an entity only for that player"],"code":["function ents_methods:setNoDraw ( draw, ply )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 2, draw and true or false )","\telse","\t\tent:SetNoDraw( draw and true or false )","\tend","end","","local materialBlacklist = {","\t[ \"pp/copy\" ] = true","}",""],"class":"function","summary":"\nSets the whether an entity should be drawn or not ","name":"ents_methods:setNoDraw","classlib":"Entity","private":false,"server":true,"description":"\nSets the whether an entity should be drawn or not","param":{"1":"draw","2":"ply","draw":"Whether to draw the entity or not.","ply":"Optional player arguement to set drawing of an entity only for that player"}},"addCollisionListener":{"comment":["--- Allows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","-- @param func The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"],"code":["function ents_methods:addCollisionListener ( func )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( func, \"function\" )","\tlocal ent = unwrap( self )","\tif ent.SF_CollisionCallback then SF.throw( \"The entity is already listening to collisions!\", 2 ) end","\tent.SF_CollisionCallback = true","","\tlocal instance = SF.instance","\tent:AddCallback(\"PhysicsCollide\", function(ent, data)","\t\tlocal ok, msg, traceback = instance:runFunction( func, setmetatable({}, {","\t\t\t__index=function(t,k)","\t\t\t\treturn SF.WrapObject( data[k] )","\t\t\tend,","\t\t\t__metatable={}","\t\t}))","","\t\tif not ok then","\t\t\tinstance:Error( msg, traceback )","\t\tend","\tend)","end","","util.AddNetworkString( \"sf_setentityrenderproperty\" )","","local renderProperties = {","\t[1] = function( clr ) --Color","\t\tnet.WriteUInt( clr.r, 8 )","\t\tnet.WriteUInt( clr.g, 8 )","\t\tnet.WriteUInt( clr.b, 8 )","\t\tnet.WriteUInt( clr.a, 8 )","\tend,","\t[2] = function( draw ) --Nodraw","\t\tnet.WriteBit( draw )","\tend,","\t[3] = function( material ) --Material","\t\tnet.WriteString( material )","\tend,","\t[4] = function( index, material ) --Submaterial","\t\tnet.WriteUInt( index, 16 )","\t\tnet.WriteString( material )","\tend,","\t[5] = function( bodygroup, value ) --Bodygroup","\t\tnet.WriteUInt( bodygroup, 16 )","\t\tnet.WriteUInt( value, 16 )","\tend,","\t[6] = function( skin ) --Skin","\t\tnet.WriteUInt( skin, 16 )","\tend","}","","local function sendRenderPropertyToClient( ply, ent, func, ... )","\tSF.CheckType( ply, SF.Types[ \"Player\" ] )","\tply = unwrap( ply )","\tif isValid( ply ) and ply:IsPlayer() then","\t\tnet.Start( \"sf_setentityrenderproperty\" )","\t\tnet.WriteEntity( ent )","\t\tnet.WriteUInt( func, 4 )","\t\trenderProperties[ func ]( ... )","\t\tnet.Send( ply )","\tend","end",""],"class":"function","name":"ents_methods:addCollisionListener","summary":"\nAllows detecting collisions on an entity.","private":false,"classlib":"Entity","description":"\nAllows detecting collisions on an entity. You can only do this once for the entity's entire lifespan so use it wisely.","param":{"1":"func","func":"The callback function with argument, table collsiondata, http://wiki.garrysmod.com/page/Structures/CollisionData"}},"remove":{"comment":["--- Removes an entity"],"code":["function ents_methods:remove ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not ent:IsValid() or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Remove()","end",""],"class":"function","name":"ents_methods:remove","summary":"\nRemoves an entity ","private":false,"classlib":"Entity","description":"\nRemoves an entity","param":[]},"getEyeAngles":{"ret":"Angles of the entity's eyes","comment":["--- Gets the entitiy's eye angles","-- @shared","-- @return Angles of the entity's eyes"],"code":["function ents_methods:getEyeAngles ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:EyeAngles() )","end",""],"class":"function","summary":"\nGets the entitiy's eye angles ","classlib":"Entity","name":"ents_methods:getEyeAngles","server":true,"private":false,"client":true,"description":"\nGets the entitiy's eye angles","param":[]},"getAngleVelocity":{"ret":"The angular velocity vector","comment":["--- Returns the angular velocity of the entity","-- @shared","-- @return The angular velocity vector"],"code":["function ents_methods:getAngleVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal phys = getPhysObject( unwrap( self ) )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end\t","\treturn SF.WrapObject( phys:GetAngleVelocity() )","end",""],"class":"function","summary":"\nReturns the angular velocity of the entity ","classlib":"Entity","name":"ents_methods:getAngleVelocity","server":true,"private":false,"client":true,"description":"\nReturns the angular velocity of the entity","param":[]},"getMaterials":{"ret":"Material","comment":["--- Gets an entities' material list","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterials ()","    local ent = unwrap( self )","    return ent:GetMaterials() or {}","end",""],"class":"function","summary":"\nGets an entities' material list ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterials","server":true,"private":false,"client":true,"description":"\nGets an entities' material list","param":[]},"enableMotion":{"comment":["--- Sets the entity movement state","-- @param move Bool should the entity move?"],"code":["function ents_methods:enableMotion ( move )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableMotion\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( move and true or false )","\tphys:Wake()","end","","","local function ent1or2 ( ent, con, num )","\tif not con then return nil end","\tif num then","\t\tcon = con[ num ]","\t\tif not con then return nil end","\tend","\tif con.Ent1 == ent then return con.Ent2 end","\treturn con.Ent1","end",""],"class":"function","name":"ents_methods:enableMotion","summary":"\nSets the entity movement state ","private":false,"classlib":"Entity","description":"\nSets the entity movement state","param":{"1":"move","move":"Bool should the entity move?"}},"getForward":{"comment":["--- Gets the entities forward vector"],"code":["function ents_methods:getForward ()","\treturn SF.WrapObject( unwrap( self ):GetForward() )","end"],"class":"function","name":"ents_methods:getForward","summary":"\nGets the entities forward vector ","private":false,"classlib":"Entity","description":"\nGets the entities forward vector","param":[]},"worldToLocalAngles":{"ret":"data as local space angle","comment":["--- Converts an angle in world space to entity local space","-- @shared","-- @param data World space angle","-- @return data as local space angle"],"code":["function ents_methods:worldToLocalAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Angle\" ] )","\tlocal ent = unwrap( self )","\tlocal data = SF.UnwrapObject( data )","\t","\treturn SF.WrapObject( ent:WorldToLocalAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocalAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in world space to entity local space","param":{"1":"data","data":"World space angle"}},"getClass":{"ret":"The string class name","comment":["--- Returns the class of the entity","-- @shared","-- @return The string class name"],"code":["function ents_methods:getClass ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:GetClass()","end",""],"class":"function","summary":"\nReturns the class of the entity ","classlib":"Entity","name":"ents_methods:getClass","server":true,"private":false,"client":true,"description":"\nReturns the class of the entity","param":[]},"setFrozen":{"comment":["--- Sets the entity frozen state","-- @param freeze Should the entity be frozen?"],"code":["function ents_methods:setFrozen ( freeze )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setFrozen\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableMotion( not ( freeze and true or false ) )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:setFrozen","summary":"\nSets the entity frozen state ","private":false,"classlib":"Entity","description":"\nSets the entity frozen state","param":{"1":"freeze","freeze":"Should the entity be frozen?"}},"obbCenter":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the local position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:OBBCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's outer bounding box","param":[]},"isNPC":{"ret":"True if npc, false if not","comment":["--- Checks if an entity is an npc.","-- @shared","-- @return True if npc, false if not"],"code":["function ents_methods:isNPC ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsNPC()","end",""],"class":"function","summary":"\nChecks if an entity is an npc.","classlib":"Entity","name":"ents_methods:isNPC","server":true,"private":false,"client":true,"description":"\nChecks if an entity is an npc.","param":[]},"isFrozen":{"ret":"True if entity is frozen","comment":["--- Checks the entities frozen state","-- @return True if entity is frozen"],"code":["function ents_methods:isFrozen ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = ent:GetPhysicsObject()","\tif phys:IsMoveable() then return false else return true end","end",""],"class":"function","name":"ents_methods:isFrozen","summary":"\nChecks the entities frozen state ","private":false,"classlib":"Entity","description":"\nChecks the entities frozen state","param":[]},"getModel":{"ret":"Model of the entity","comment":["--- Gets the model of an entity","-- @shared","-- @return Model of the entity"],"code":["function ents_methods:getModel ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:GetModel()","end",""],"class":"function","summary":"\nGets the model of an entity ","classlib":"Entity","name":"ents_methods:getModel","server":true,"private":false,"client":true,"description":"\nGets the model of an entity","param":[]},"isVehicle":{"ret":"True if vehicle, false if not","comment":["--- Checks if an entity is a vehicle.","-- @shared","-- @return True if vehicle, false if not"],"code":["function ents_methods:isVehicle ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsVehicle()","end",""],"class":"function","summary":"\nChecks if an entity is a vehicle.","classlib":"Entity","name":"ents_methods:isVehicle","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a vehicle.","param":[]},"isWeldedTo":{"comment":["--- Gets what the entity is welded to"],"code":["function ents_methods:isWeldedTo ()","\tlocal this = unwrap( self )","\tif not constraint.HasConstraints( this ) then return nil end","","\treturn wrap( ent1or2( this, constraint.FindConstraint( this, \"Weld\" ) ) )","end"],"class":"function","name":"ents_methods:isWeldedTo","summary":"\nGets what the entity is welded to ","private":false,"classlib":"Entity","description":"\nGets what the entity is welded to","param":[]},"setVelocity":{"comment":["--- Sets the entity's linear velocity","-- @param vel New velocity"],"code":["function ents_methods:setVelocity ( vel )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vel, SF.Types[ \"Vector\" ] )","","\tlocal vel = vunwrap( vel )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setVelocity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetVelocity( vel )","end",""],"class":"function","name":"ents_methods:setVelocity","summary":"\nSets the entity's linear velocity ","private":false,"classlib":"Entity","description":"\nSets the entity's linear velocity","param":{"1":"vel","vel":"New velocity"}},"setMaterial":{"comment":["--- Sets an entities' material","-- @server","-- @class function","-- @param material, string, New material name.","-- @param ply Optional player arguement to set material of an entity only for that player"],"code":["function ents_methods:setMaterial ( material, ply )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( material, \"string\" )","    if materialBlacklist[ material:lower() ] then SF.throw( \"This material has been blacklisted\", 2 ) end","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setRenderPropery\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif ply then","\t\tsendRenderPropertyToClient( ply, ent, 3, material )","\telse","\t\tent:SetMaterial( material )","\tend","end",""],"class":"function","classForced":true,"summary":"\nSets an entities' material ","name":"ents_methods:setMaterial","classlib":"Entity","private":false,"server":true,"description":"\nSets an entities' material","param":{"1":"material","2":"ply","ply":"Optional player arguement to set material of an entity only for that player","material":", string, New material name."}},"getMass":{"ret":"The numerical mass","comment":["--- Returns the mass of the entity","-- @shared","-- @return The numerical mass"],"code":["function ents_methods:getMass ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetMass()","end",""],"class":"function","summary":"\nReturns the mass of the entity ","classlib":"Entity","name":"ents_methods:getMass","server":true,"private":false,"client":true,"description":"\nReturns the mass of the entity","param":[]},"destroy":{"comment":["--- Breaks an entity"],"code":["function ents_methods:destroy ()","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) or ent:IsPlayer() then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.remove\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:Fire( \"break\", 1, 0 )","end",""],"class":"function","name":"ents_methods:destroy","summary":"\nBreaks an entity ","private":false,"classlib":"Entity","description":"\nBreaks an entity","param":[]},"setSolid":{"comment":["--- Sets the entity to be Solid or not.","-- For more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","-- @param solid Boolean, Should the entity be solid?"],"code":["function ents_methods:setSolid ( solid )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setSolid\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:SetNotSolid( not solid )","end",""],"class":"function","name":"ents_methods:setSolid","summary":"\nSets the entity to be Solid or not.","private":false,"classlib":"Entity","description":"\nSets the entity to be Solid or not. \nFor more information please refer to GLua function http://wiki.garrysmod.com/page/Entity/SetNotSolid","param":{"1":"solid","solid":"Boolean, Should the entity be solid?"}},"getEyePos":{"ret":["Eye position of the entity","In case of a ragdoll, the position of the other eye"],"comment":["--- Gets the entity's eye position","-- @shared","-- @return Eye position of the entity","-- @return In case of a ragdoll, the position of the other eye"],"code":["function ents_methods:getEyePos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:EyePos() )","end",""],"class":"function","summary":"\nGets the entity's eye position ","classlib":"Entity","name":"ents_methods:getEyePos","server":true,"private":false,"client":true,"description":"\nGets the entity's eye position","param":[]},"getColor":{"ret":"Color","comment":["--- Gets the color of an entity","-- @shared","-- @return Color"],"code":["function ents_methods:getColor ()","\tlocal this = unwrap( self )","\treturn SF.Color.Wrap( this:GetColor() )","end",""],"class":"function","summary":"\nGets the color of an entity ","classlib":"Entity","name":"ents_methods:getColor","server":true,"private":false,"client":true,"description":"\nGets the color of an entity","param":[]},"entIndex":{"ret":"The numerical index of the entity","comment":["--- Returns the EntIndex of the entity","-- @shared","-- @return The numerical index of the entity"],"code":["function ents_methods:entIndex ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn ent:EntIndex()","end",""],"class":"function","summary":"\nReturns the EntIndex of the entity ","classlib":"Entity","name":"ents_methods:entIndex","server":true,"private":false,"client":true,"description":"\nReturns the EntIndex of the entity","param":[]},"obbSize":{"ret":"The outer bounding box size","comment":["--- Returns the x, y, z size of the entity's outer bounding box (local to the entity)","-- @shared","-- @return The outer bounding box size"],"code":["function ents_methods:obbSize ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:OBBMaxs() - ent:OBBMins() )","end",""],"class":"function","summary":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity) ","classlib":"Entity","name":"ents_methods:obbSize","server":true,"private":false,"client":true,"description":"\nReturns the x, y, z size of the entity's outer bounding box (local to the entity)","param":[]},"getInertia":{"ret":"The principle moments of inertia as a vector","comment":["--- Returns the principle moments of inertia of the entity","-- @shared","-- @return The principle moments of inertia as a vector"],"code":["function ents_methods:getInertia ()","\tSF.CheckType( self, ents_metamethods )","\t","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\t","\treturn phys:GetInertia()","end",""],"class":"function","summary":"\nReturns the principle moments of inertia of the entity ","classlib":"Entity","name":"ents_methods:getInertia","server":true,"private":false,"client":true,"description":"\nReturns the principle moments of inertia of the entity","param":[]},"enableGravity":{"comment":["--- Sets entity gravity","-- @param grav Bool should the entity respect gravity?"],"code":["function ents_methods:enableGravity ( grav )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableGravity\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableGravity( grav and true or false )","\tphys:Wake()","end",""],"class":"function","name":"ents_methods:enableGravity","summary":"\nSets entity gravity ","private":false,"classlib":"Entity","description":"\nSets entity gravity","param":{"1":"grav","grav":"Bool should the entity respect gravity?"}},"isPlayer":{"ret":"True if player, false if not","comment":["--- Checks if an entity is a player.","-- @shared","-- @return True if player, false if not"],"code":["function ents_methods:isPlayer ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsPlayer()","end",""],"class":"function","summary":"\nChecks if an entity is a player.","classlib":"Entity","name":"ents_methods:isPlayer","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a player.","param":[]},"enableDrag":{"comment":["--- Sets the entity drag state","-- @param drag Bool should the entity have air resistence?"],"code":["function ents_methods:enableDrag ( drag )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.enableDrag\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:EnableDrag( drag and true or false )","end",""],"class":"function","name":"ents_methods:enableDrag","summary":"\nSets the entity drag state ","private":false,"classlib":"Entity","description":"\nSets the entity drag state","param":{"1":"drag","drag":"Bool should the entity have air resistence?"}},"getMaterial":{"ret":"Material","comment":["--- Gets an entities' material","-- @shared","-- @class function","-- @return Material"],"code":["function ents_methods:getMaterial ()","    local ent = unwrap( self )","    return ent:GetMaterial() or \"\"","end",""],"class":"function","summary":"\nGets an entities' material ","classForced":true,"classlib":"Entity","name":"ents_methods:getMaterial","server":true,"private":false,"client":true,"description":"\nGets an entities' material","param":[]},"setPos":{"comment":["--- Sets the entitiy's position","-- @param vec New position"],"code":["function ents_methods:setPos ( vec )","\tSF.CheckType( self, ents_metatable )","\tSF.CheckType( vec, SF.Types[ \"Vector\" ] )","","\tlocal vec = vunwrap( vec )","\tlocal ent = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setPos\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tSF.setPos( ent, vec )","end",""],"class":"function","name":"ents_methods:setPos","summary":"\nSets the entitiy's position ","private":false,"classlib":"Entity","description":"\nSets the entitiy's position","param":{"1":"vec","vec":"New position"}},"emitSound":{"comment":["--- Plays a sound on the entity","-- @param snd string Sound path","-- @param lvl number soundLevel=75","-- @param pitch pitchPercent=100","-- @param volume volume=1","-- @param channel channel=CHAN_AUTO"],"code":["function ents_methods:emitSound ( snd, lvl, pitch, volume, channel )","\tSF.CheckType( self, ents_metatable )","    SF.CheckType( snd, \"string\" )","","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.emitSound\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tent:EmitSound(snd, lvl, pitch, volume, channel)","end",""],"class":"function","name":"ents_methods:emitSound","summary":"\nPlays a sound on the entity ","private":false,"classlib":"Entity","description":"\nPlays a sound on the entity","param":{"1":"snd","2":"lvl","3":"pitch","4":"volume","5":"channel","pitch":"pitchPercent=100","snd":"string Sound path","lvl":"number soundLevel=75","channel":"channel=CHAN_AUTO","volume":"volume=1"}},"getPos":{"ret":"The position vector","comment":["--- Returns the position of the entity","-- @shared","-- @return The position vector"],"code":["function ents_methods:getPos ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:GetPos() )","end",""],"class":"function","summary":"\nReturns the position of the entity ","classlib":"Entity","name":"ents_methods:getPos","server":true,"private":false,"client":true,"description":"\nReturns the position of the entity","param":[]},"getOwner":{"ret":"Owner","comment":["--- Gets the owner of the entity","-- @return Owner"],"code":["function ents_methods:getOwner ()","\tSF.CheckType( self, ents_metatable )","\tlocal ent = unwrap( self )","\treturn wrap( getOwner( ent ) )","end","","local function check ( v )","\treturn \t-math.huge < v.x and v.x < math.huge and","\t\t\t-math.huge < v.y and v.y < math.huge and","\t\t\t-math.huge < v.z and v.z < math.huge","end","","local function parent_check ( child, parent )","\twhile isValid( parent ) do","\t\tif child == parent then","\t\t\treturn false","\t\tend","\t\tparent = parent:GetParent()","\tend","\treturn true","end",""],"class":"function","name":"ents_methods:getOwner","summary":"\nGets the owner of the entity ","private":false,"classlib":"Entity","description":"\nGets the owner of the entity","param":[]},"isWeapon":{"ret":"True if weapon, false if not","comment":["--- Checks if an entity is a weapon.","-- @shared","-- @return True if weapon, false if not"],"code":["function ents_methods:isWeapon ()","\tSF.CheckType( self, ents_metamethods )","\treturn unwrap( self ):IsWeapon()","end",""],"class":"function","summary":"\nChecks if an entity is a weapon.","classlib":"Entity","name":"ents_methods:isWeapon","server":true,"private":false,"client":true,"description":"\nChecks if an entity is a weapon.","param":[]},"obbCenterW":{"ret":"The position vector of the outer bounding box center","comment":["--- Returns the world position of the entity's outer bounding box","-- @shared","-- @return The position vector of the outer bounding box center"],"code":["function ents_methods:obbCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\treturn SF.WrapObject( ent:LocalToWorld( ent:OBBCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's outer bounding box ","classlib":"Entity","name":"ents_methods:obbCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's outer bounding box","param":[]},"setParent":{"comment":["--- Parents the entity to another entity","-- @param ent Entity to parent to"],"code":["function ents_methods:setParent ( ent )","\tSF.CheckType( self, ents_metatable )","","\tlocal ent = unwrap( ent )","\tlocal this = unwrap( self )","","\tif not SF.Permissions.check( SF.instance.player, this, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.parent\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tif not parent_check( this, ent ) then SF.throw( \"Cannot parent to self\", 2 ) end","","\tthis:SetParent( ent )","end",""],"class":"function","name":"ents_methods:setParent","summary":"\nParents the entity to another entity ","private":false,"classlib":"Entity","description":"\nParents the entity to another entity","param":{"1":"ent","ent":"Entity to parent to"}},"localToWorldAngles":{"ret":"data as world space angle","comment":["--- Converts an angle in entity local space to world space","-- @shared","-- @param data Local space angle","-- @return data as world space angle"],"code":["function ents_methods:localToWorldAngles ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Angle\" ] )","\tlocal ent = unwrap( self )","\tlocal data = SF.UnwrapObject( data )","\t","\treturn SF.WrapObject( ent:LocalToWorldAngles( data ) )","end",""],"class":"function","summary":"\nConverts an angle in entity local space to world space ","classlib":"Entity","name":"ents_methods:localToWorldAngles","server":true,"private":false,"client":true,"description":"\nConverts an angle in entity local space to world space","param":{"1":"data","data":"Local space angle"}},"setMass":{"comment":["--- Sets the entity's mass","-- @param mass number mass"],"code":["function ents_methods:setMass ( mass )","\tlocal ent = unwrap( self )","","\tlocal phys = getPhysObject( ent )","\tif not phys then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","","\tif not SF.Permissions.check( SF.instance.player, ent, \"entities.setMass\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","","\tphys:SetMass( math.Clamp(mass, 1, 50000) )","end",""],"class":"function","name":"ents_methods:setMass","summary":"\nSets the entity's mass ","private":false,"classlib":"Entity","description":"\nSets the entity's mass","param":{"1":"mass","mass":"number mass"}},"getMassCenter":{"ret":"The position vector of the mass center","comment":["--- Returns the local position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenter ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn SF.WrapObject( phys:GetMassCenter() )","end",""],"class":"function","summary":"\nReturns the local position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenter","server":true,"private":false,"client":true,"description":"\nReturns the local position of the entity's mass center","param":[]},"worldToLocal":{"ret":"data as local space vector","comment":["--- Converts a vector in world space to entity local space","-- @shared","-- @param data World space vector","-- @return data as local space vector"],"code":["function ents_methods:worldToLocal ( data )","\tSF.CheckType( self, ents_metamethods )","\tSF.CheckType( data, SF.Types[ \"Vector\" ] )","\tlocal ent = unwrap( self )","\t","\treturn SF.WrapObject( ent:WorldToLocal( vunwrap( data ) ) )","end",""],"class":"function","summary":"\nConverts a vector in world space to entity local space ","classlib":"Entity","name":"ents_methods:worldToLocal","server":true,"private":false,"client":true,"description":"\nConverts a vector in world space to entity local space","param":{"1":"data","data":"World space vector"}},"getVelocity":{"ret":"The velocity vector","comment":["--- Returns the velocity of the entity","-- @shared","-- @return The velocity vector"],"code":["function ents_methods:getVelocity ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tif not isValid( ent ) then SF.throw( \"Entity is not valid\", 2 ) end","\treturn SF.WrapObject( ent:GetVelocity() )","end",""],"class":"function","summary":"\nReturns the velocity of the entity ","classlib":"Entity","name":"ents_methods:getVelocity","server":true,"private":false,"client":true,"description":"\nReturns the velocity of the entity","param":[]},"getMassCenterW":{"ret":"The position vector of the mass center","comment":["--- Returns the world position of the entity's mass center","-- @shared","-- @return The position vector of the mass center"],"code":["function ents_methods:getMassCenterW ()","\tSF.CheckType( self, ents_metamethods )","\tlocal ent = unwrap( self )","\tlocal phys = getPhysObject( ent )","\tif not phys or not phys:IsValid() then SF.throw( \"Entity has no physics object or is not valid\", 2 ) end","\treturn SF.WrapObject( ent:LocalToWorld( phys:GetMassCenter() ) )","end",""],"class":"function","summary":"\nReturns the world position of the entity's mass center ","classlib":"Entity","name":"ents_methods:getMassCenterW","server":true,"private":false,"client":true,"description":"\nReturns the world position of the entity's mass center","param":[]}}},"Angle":{"comment":["--- Angle Type","-- @shared"],"code":["local ang_methods, ang_metamethods = SF.Typedef( \"Angle\" )","local wrap, unwrap = SF.CreateWrapper( ang_metamethods, true, false, debug.getregistry().Angle )","","SF.DefaultEnvironment.Angle = function ( ... )","\treturn wrap( Angle( ... ) )","end","","SF.Angles.Wrap = wrap","SF.Angles.Unwrap = unwrap","SF.Angles.Methods = ang_methods","SF.Angles.Metatable = ang_metamethods",""],"typtbl":"ang_methods","summary":"\nAngle Type ","fields":[],"name":"Angle","server":true,"description":"\nAngle Type","client":true,"class":"class","methods":{"1":"getForward","2":"getRight","3":"getUp","4":"isZero","5":"normalize","6":"rotateAroundAxis","7":"set","8":"setZero","getUp":{"ret":"vector normalised.","comment":["--- Return the Up Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods:getUp ()","\treturn SF.WrapObject( unwrap( self ):Up() )","end",""],"class":"function","name":"ang_methods:getUp","summary":"\nReturn the Up Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Up Vector relative to the angle dir.","param":[]},"getRight":{"ret":"vector normalised.","comment":["--- Return the Right Vector relative to the angle dir.","-- @return vector normalised."],"code":["function ang_methods:getRight ()","\treturn SF.WrapObject( unwrap( self ):Right() )","end",""],"class":"function","name":"ang_methods:getRight","summary":"\nReturn the Right Vector relative to the angle dir.","private":false,"classlib":"Angle","description":"\nReturn the Right Vector relative to the angle dir.","param":[]},"normalize":{"ret":"nil","comment":["--- Normalise angles eg (0,181,1) -> (0,-179,1).","-- @return nil"],"code":["function ang_methods:normalize ()","\tunwrap( self ):Normalize()","end",""],"class":"function","name":"ang_methods:normalize","summary":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","private":false,"classlib":"Angle","description":"\nNormalise angles eg (0,181,1) -> (0,-179,1).","param":[]},"getForward":{"ret":"vector normalised.","comment":["--- Return the Forward Vector ( direction the angle points ).","-- @return vector normalised."],"code":["function ang_methods:getForward ()","\treturn SF.WrapObject( unwrap( self ):Forward() )","end",""],"class":"function","name":"ang_methods:getForward","summary":"\nReturn the Forward Vector ( direction the angle points ).","private":false,"classlib":"Angle","description":"\nReturn the Forward Vector ( direction the angle points ).","param":[]},"isZero":{"ret":"boolean","comment":["--- Returns if p,y,r are all 0.","-- @return boolean"],"code":["function ang_methods:isZero ()","\treturn unwrap( self ):IsZero()","end",""],"class":"function","name":"ang_methods:isZero","summary":"\nReturns if p,y,r are all 0.","private":false,"classlib":"Angle","description":"\nReturns if p,y,r are all 0.","param":[]},"setZero":{"ret":"nil","comment":["--- Sets p,y,r to 0. This is faster than doing it manually.","-- @return nil"],"code":["function ang_methods:setZero ()","\tunwrap( self ):Zero()","end"],"class":"function","name":"ang_methods:setZero","summary":"\nSets p,y,r to 0.","private":false,"classlib":"Angle","description":"\nSets p,y,r to 0. This is faster than doing it manually.","param":[]},"set":{"ret":"nil","comment":["--- Copies p,y,r from second angle to the first.","-- @param a Angle to copy from.","-- @return nil"],"code":["function ang_methods:set ( a )","\tSF.CheckType( a, SF.Types[ \"Angle\" ] )","\tunwrap( self ):Set( unwrap( a ) )","end",""],"class":"function","name":"ang_methods:set","summary":"\nCopies p,y,r from second angle to the first.","private":false,"classlib":"Angle","description":"\nCopies p,y,r from second angle to the first.","param":{"1":"a","a":"Angle to copy from."}},"rotateAroundAxis":{"ret":"nil","comment":["--- Rotates the angle around the specified axis by the specified degrees.","-- @param v Axis","-- @param r Number of degrees.","-- @return nil"],"code":["function ang_methods:rotateAroundAxis ( v, r )","\tSF.CheckType( v, SF.Types[ \"Vector\" ] )","\tSF.CheckType( r, \"number\" )","\tunwrap( self ):RotateAroundAxis( SF.UnwrapObject( v ), r )","end",""],"class":"function","name":"ang_methods:rotateAroundAxis","summary":"\nRotates the angle around the specified axis by the specified degrees.","private":false,"classlib":"Angle","description":"\nRotates the angle around the specified axis by the specified degrees.","param":{"1":"v","2":"r","r":"Number of degrees.","v":"Axis"}}}},"Sound":{"comment":["--- Sound type","-- @shared"],"code":["local sound_methods, sound_metamethods = SF.Typedef( \"Sound\" )","local wrap, unwrap = SF.CreateWrapper( sound_metamethods, true, false, debug.getregistry().CSoundPatch )",""],"typtbl":"sound_methods","summary":"\nSound type ","fields":[],"name":"Sound","server":true,"description":"\nSound type","client":true,"class":"class","methods":{"1":"isPlaying","2":"play","3":"setPitch","4":"setSoundLevel","5":"setVolume","6":"stop","setSoundLevel":{"comment":["--- Sets the sound level in dB.","-- @param level dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."],"code":["function sound_methods:setSoundLevel ( level )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( level, \"number\" )","\tunwrap( self ):SetSoundLevel( math.Clamp( level, 0, 511 ) )","end"],"class":"function","name":"sound_methods:setSoundLevel","summary":"\nSets the sound level in dB.","private":false,"classlib":"Sound","description":"\nSets the sound level in dB.","param":{"1":"level","level":"dB level, see <a href='https://developer.valvesoftware.com/wiki/Soundscripts#SoundLevel'> Vale Dev Wiki</a>, for information on the value to use."}},"stop":{"comment":["--- Stops the sound from being played.","-- @param fade Time in seconds to fade out, if nil or 0 the sound stops instantly."],"code":["function sound_methods:stop ( fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tunwrap( self ):FadeOut( math.max( fade, 0 ) )","\telse","\t\tunwrap( self ):Stop()","\tend","end",""],"class":"function","name":"sound_methods:stop","summary":"\nStops the sound from being played.","private":false,"classlib":"Sound","description":"\nStops the sound from being played.","param":{"1":"fade","fade":"Time in seconds to fade out, if nil or 0 the sound stops instantly."}},"isPlaying":{"comment":["--- Returns whether the sound is being played."],"code":["function sound_methods:isPlaying ()","\treturn unwrap( self ):IsPlaying()\t","end",""],"class":"function","name":"sound_methods:isPlaying","summary":"\nReturns whether the sound is being played.","private":false,"classlib":"Sound","description":"\nReturns whether the sound is being played.","param":[]},"setVolume":{"comment":["--- Sets the volume of the sound.","-- @param vol Volume to set to, between 0 and 1.","-- @param fade Time in seconds to transition to this new volume."],"code":["function sound_methods:setVolume ( vol, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( vol, \"number\" )","","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.abs( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tvol = math.Clamp( vol, 0, 1 )","\tunwrap( self ):ChangeVolume( vol, fade )","end",""],"class":"function","name":"sound_methods:setVolume","summary":"\nSets the volume of the sound.","private":false,"classlib":"Sound","description":"\nSets the volume of the sound.","param":{"1":"vol","2":"fade","vol":"Volume to set to, between 0 and 1.","fade":"Time in seconds to transition to this new volume."}},"play":{"comment":["--- Starts to play the sound."],"code":["function sound_methods:play ()","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( self, sound_metamethods )","\tunwrap( self ):Play()","end",""],"class":"function","name":"sound_methods:play","summary":"\nStarts to play the sound.","private":false,"classlib":"Sound","description":"\nStarts to play the sound.","param":[]},"setPitch":{"comment":["--- Sets the pitch of the sound.","-- @param pitch Pitch to set to, between 0 and 255.","-- @param fade Time in seconds to transition to this new pitch."],"code":["function sound_methods:setPitch ( pitch, fade )","\tif not SF.Permissions.check( SF.instance.player, unwrap( self ), \"sound.modify\" ) then SF.throw( \"Insufficient permissions\", 2 ) end","\tSF.CheckType( pitch, \"number\" )","\t","\tif fade then","\t\tSF.CheckType( fade, \"number\" )","\t\tfade = math.max( fade, 0 )","\telse\t","\t\tfade = 0","\tend","","\tpitch = math.Clamp( pitch, 0, 255 )","\tunwrap( self ):ChangePitch( pitch, fade )","end",""],"class":"function","name":"sound_methods:setPitch","summary":"\nSets the pitch of the sound.","private":false,"classlib":"Sound","description":"\nSets the pitch of the sound.","param":{"1":"pitch","2":"fade","pitch":"Pitch to set to, between 0 and 255.","fade":"Time in seconds to transition to this new pitch."}}}},"Weapon":{"comment":["--- Weapon type"],"code":["local weapon_methods, weapon_metamethods = SF.Typedef(\"Weapon\", SF.Entities.Metatable)","","local vwrap = SF.WrapObject","","SF.Weapons.Methods = weapon_methods","SF.Weapons.Metatable = weapon_metamethods",""],"typtbl":"weapon_methods","fields":[],"name":"Weapon","summary":"\nWeapon type ","description":"\nWeapon type","class":"class","methods":{"1":"clip1","2":"clip2","3":"getActivity","4":"getHoldType","5":"getNextPrimaryFire","6":"getNextSecondaryFire","7":"getPrimaryAmmoType","8":"getPrintName","9":"getSecondaryAmmoType","10":"isCarriedByLocalPlayer","11":"isWeaponVisible","12":"lastShootTime","lastShootTime":{"ret":"Time the weapon was last shot","comment":["--- Returns the time since a weapon was last fired at a float variable","-- @shared","-- @return Time the weapon was last shot"],"code":["function weapon_methods:lastShootTime ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:LastShootTime()","end","","if CLIENT then"],"class":"function","summary":"\nReturns the time since a weapon was last fired at a float variable ","classlib":"Weapon","name":"weapon_methods:lastShootTime","server":true,"private":false,"client":true,"description":"\nReturns the time since a weapon was last fired at a float variable","param":[]},"getNextPrimaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can primary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextPrimaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextPrimaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can primary fire.","classlib":"Weapon","name":"weapon_methods:getNextPrimaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can primary fire.","param":[]},"clip2":{"ret":"amount of ammo","comment":["--- Returns Ammo in secondary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip2 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip2()","end",""],"class":"function","summary":"\nReturns Ammo in secondary clip ","classlib":"Weapon","name":"weapon_methods:clip2","server":true,"private":false,"client":true,"description":"\nReturns Ammo in secondary clip","param":[]},"isCarriedByLocalPlayer":{"ret":"whether or not the weapon is carried by the local player","comment":["\t--- Returns if the weapon is carried by the local player. ","\t-- @client","\t-- @return whether or not the weapon is carried by the local player"],"code":["\tfunction weapon_methods:isCarriedByLocalPlayer ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:IsCarriedByLocalPlayer()","\tend","end"],"class":"function","summary":"\nReturns if the weapon is carried by the local player.","name":"weapon_methods:isCarriedByLocalPlayer","classlib":"Weapon","private":false,"client":true,"description":"\nReturns if the weapon is carried by the local player.","param":[]},"getSecondaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the secondary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getSecondaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetSecondaryAmmoType()","end",""],"class":"function","summary":"\nGets the secondary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getSecondaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the secondary ammo type of the given weapon.","param":[]},"clip1":{"ret":"amount of ammo","comment":["--- Returns Ammo in primary clip","-- @shared","-- @return amount of ammo"],"code":["function weapon_methods:clip1 ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:Clip1()","end",""],"class":"function","summary":"\nReturns Ammo in primary clip ","classlib":"Weapon","name":"weapon_methods:clip1","server":true,"private":false,"client":true,"description":"\nReturns Ammo in primary clip","param":[]},"getActivity":{"ret":"number Current activity","comment":["--- Returns the sequence enumeration number that the weapon is playing. Must be used on a view model. ","-- @shared","-- @return number Current activity"],"code":["function weapon_methods:getActivity ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetActivity()","end",""],"class":"function","summary":"\nReturns the sequence enumeration number that the weapon is playing.","classlib":"Weapon","name":"weapon_methods:getActivity","server":true,"private":false,"client":true,"description":"\nReturns the sequence enumeration number that the weapon is playing. Must be used on a view model.","param":[]},"getPrintName":{"ret":"string Display name of weapon","comment":["\t--- Gets Display name of weapon","\t-- @client","\t-- @return string Display name of weapon"],"code":["\tfunction weapon_methods:getPrintName ()","\t\tSF.CheckType( self, weapon_metamethods )","\t\tlocal ent = SF.Entities.Unwrap( self )","\t\treturn ent:GetPrintName()","\tend","\t"],"class":"function","summary":"\nGets Display name of weapon ","name":"weapon_methods:getPrintName","classlib":"Weapon","private":false,"client":true,"description":"\nGets Display name of weapon","param":[]},"getPrimaryAmmoType":{"ret":"Ammo number type","comment":["--- Gets the primary ammo type of the given weapon. ","-- @shared","-- @return Ammo number type"],"code":["function weapon_methods:getPrimaryAmmoType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetPrimaryAmmoType()","end",""],"class":"function","summary":"\nGets the primary ammo type of the given weapon.","classlib":"Weapon","name":"weapon_methods:getPrimaryAmmoType","server":true,"private":false,"client":true,"description":"\nGets the primary ammo type of the given weapon.","param":[]},"getNextSecondaryFire":{"ret":"The time, relative to CurTime","comment":["--- Gets the next time the weapon can secondary fire.","-- @shared","-- @return The time, relative to CurTime"],"code":["function weapon_methods:getNextSecondaryFire ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetNextSecondaryFire()","end",""],"class":"function","summary":"\nGets the next time the weapon can secondary fire.","classlib":"Weapon","name":"weapon_methods:getNextSecondaryFire","server":true,"private":false,"client":true,"description":"\nGets the next time the weapon can secondary fire.","param":[]},"getHoldType":{"ret":"string Holdtype","comment":["--- Returns the hold type of the weapon. ","-- @shared","-- @return string Holdtype"],"code":["function weapon_methods:getHoldType ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:GetHoldType()","end",""],"class":"function","summary":"\nReturns the hold type of the weapon.","classlib":"Weapon","name":"weapon_methods:getHoldType","server":true,"private":false,"client":true,"description":"\nReturns the hold type of the weapon.","param":[]},"isWeaponVisible":{"ret":"Whether the weapon is visble or not","comment":["--- Returns whether the weapon is visible","-- @shared","-- @return Whether the weapon is visble or not"],"code":["function weapon_methods:isWeaponVisible ()","\tSF.CheckType( self, weapon_metamethods )","\tlocal ent = SF.Entities.Unwrap( self )","\treturn ent:IsWeaponVisible()","end",""],"class":"function","summary":"\nReturns whether the weapon is visible ","classlib":"Weapon","name":"weapon_methods:isWeaponVisible","server":true,"private":false,"client":true,"description":"\nReturns whether the weapon is visible","param":[]}}}},"directives":{"1":"include","2":"includedir","3":"model","4":"name","include":{"description":"\nMark a file to be included in the upload. \nThis is required to use the file in require() and dofile()","code":[""],"class":"directive","classForced":true,"name":"include","summary":"\nMark a file to be included in the upload.","usage":"\n--@include lib/someLibrary.txt \n \nrequire( \"lib/someLibrary.txt\" ) \n-- CODE","comment":["--- Mark a file to be included in the upload.","-- This is required to use the file in require() and dofile()","-- @name include","-- @class directive","-- @param path Path to the file","-- @usage","-- \\--@include lib/someLibrary.txt","-- ","-- require( \"lib/someLibrary.txt\" )","-- -- CODE"],"param":{"1":"path","path":"Path to the file"}},"name":{"description":"\nSet the name of the script. \nThis will become the name of the tab and will show on the overlay of the processor","code":["","--","-- if SERVER then","-- \\\t-- Do important calculations","-- \\\t-- Send net message","-- else","-- \\\t-- Display result of important calculations","-- end",""],"class":"directive","classForced":true,"name":"name","summary":"\nSet the name of the script.","usage":"\n--@name Awesome script \n-- CODE","comment":["--- Set the name of the script.","-- This will become the name of the tab and will show on the overlay of the processor","-- @name name","-- @class directive","-- @param name Name of the script","-- @usage","-- \\--@name Awesome script","-- -- CODE"],"param":{"1":"name","name":"Name of the script"}},"includedir":{"description":"\nMark a directory to be included in the upload. \nThis is optional to include all files in the directory in require() and dofile()","code":[""],"class":"directive","classForced":true,"name":"includedir","summary":"\nMark a directory to be included in the upload.","usage":"\n--@includedir lib \n \nrequire( \"lib/someLibraryInLib.txt\" ) \nrequire( \"lib/someOtherLibraryInLib.txt\" ) \n-- CODE","comment":["--- Mark a directory to be included in the upload.","-- This is optional to include all files in the directory in require() and dofile()","-- @name includedir","-- @class directive","-- @param path Path to the directory","-- @usage","-- \\--@includedir lib","--","-- require( \"lib/someLibraryInLib.txt\" )","-- require( \"lib/someOtherLibraryInLib.txt\" )","-- -- CODE"],"param":{"1":"path","path":"Path to the directory"}},"model":{"description":"\nSet the model of the processor entity. \nThis does not set the model of the screen entity","code":[],"class":"directive","classForced":true,"name":"model","summary":"\nSet the model of the processor entity.","usage":"\n--@model models/props_junk/watermelon01.mdl \n-- CODE","comment":["--- Set the model of the processor entity.","-- This does not set the model of the screen entity","-- @name model","-- @class directive","-- @param model String of the model","-- @usage","-- \\--@model models/props_junk/watermelon01.mdl","-- -- CODE"],"param":{"1":"model","model":"String of the model"}}}}